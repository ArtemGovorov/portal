webpackJsonp([0],[
/* 0 */,
/* 1 */,
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
var globalScope;
if (typeof window === 'undefined') {
    globalScope = global;
}
else {
    globalScope = window;
}
// Need to declare a new variable for global here since TypeScript
// exports the original value of the symbol.
var _global = globalScope;
exports.global = _global;
// ===============
// implementations
// ===============
/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;
/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;
/** Used to detect unsigned integer values. */
var reIsUint = /^\d+$/;
/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;
var argsTag = '[object Arguments]';
var _devMode = true;
/**
 * Disable Angular's development mode, which turns off assertions and other
 * checks within the framework.
 *
 * One important assertion this disables verifies that a change detection pass
 * does not result in additional changes to any bindings (also known as
 * unidirectional data flow).
 */
function enableProdMode() {
    _devMode = false;
}
exports.enableProdMode = enableProdMode;
function assertionsEnabled() {
    return _devMode;
}
exports.assertionsEnabled = assertionsEnabled;
function isPresent(obj) {
    return obj !== undefined && obj !== null;
}
exports.isPresent = isPresent;
function isBlank(obj) {
    return obj === undefined || obj === null;
}
exports.isBlank = isBlank;
function isString(obj) {
    return typeof obj === "string";
}
exports.isString = isString;
function isFunction(obj) {
    return typeof obj === "function";
}
exports.isFunction = isFunction;
function isBoolean(obj) {
    return typeof obj === "boolean";
}
exports.isBoolean = isBoolean;
function isArray(obj) {
    return Array.isArray(obj);
}
exports.isArray = isArray;
function isNumber(obj) {
    return typeof obj === 'number';
}
exports.isNumber = isNumber;
function isDate(obj) {
    return obj instanceof Date && !isNaN(obj.valueOf());
}
exports.isDate = isDate;
function isType(obj) {
    return isFunction(obj);
}
exports.isType = isType;
function isStringMap(obj) {
    return typeof obj === 'object' && obj !== null;
}
exports.isStringMap = isStringMap;
function isPromise(obj) {
    return obj instanceof _global.Promise;
}
exports.isPromise = isPromise;
function isPromiseLike(obj) {
    return Boolean(isPresent(obj) && obj.then);
}
exports.isPromiseLike = isPromiseLike;
function isObservable(obj) {
    return Boolean(isPresent(obj) && obj.subscribe);
}
exports.isObservable = isObservable;
function isPromiseOrObservable(obj) {
    return isPromiseLike(obj) || isObservable(obj);
}
exports.isPromiseOrObservable = isPromiseOrObservable;
function isScope(obj) {
    return isPresent(obj) && obj.$digest && obj.$on;
}
exports.isScope = isScope;
function isSubscription(obj) {
    return isPresent(obj) && obj.unsubscribe;
}
exports.isSubscription = isSubscription;
function isJsObject(o) {
    return o !== null && (typeof o === "function" || typeof o === "object");
}
exports.isJsObject = isJsObject;
function isArguments(value) {
    // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.
    return ('length' in value) && Object.prototype.hasOwnProperty.call(value, 'callee') &&
        (!Object.prototype.propertyIsEnumerable.call(value, 'callee') || Object.prototype.toString.call(value) == argsTag);
}
exports.isArguments = isArguments;
function noop() { }
exports.noop = noop;
function stringify(token) {
    if (typeof token === 'string') {
        return token;
    }
    if (token === undefined || token === null) {
        return '' + token;
    }
    if (token.name) {
        return token.name;
    }
    var res = token.toString();
    var newLineIndex = res.indexOf("\n");
    return (newLineIndex === -1)
        ? res
        : res.substring(0, newLineIndex).replace('\r', '');
}
exports.stringify = stringify;
/**
 * Converts `value` to a string if it's not one. An empty string is returned
 * for `null` or `undefined` values.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
    return value == null ? '' : (value + '');
}
exports.baseToString = baseToString;
/**
 * Converts `value` to property path array if it's not one.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {Array} Returns the property path array.
 */
function toPath(value) {
    if (isArray(value)) {
        return value;
    }
    //return value.split('.');
    var result = [];
    baseToString(value).replace(rePropName, function (match, number, quote, string) {
        var resultValue = quote
            ? string.replace(reEscapeChar, '$1')
            : (number || match);
        result.push(resultValue);
        return resultValue;
    });
    return result;
}
exports.toPath = toPath;
function assign(destination) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    var envAssign = _global.Object['assign'] || _global.angular.extend;
    return envAssign.apply(void 0, [destination].concat(sources));
}
exports.assign = assign;
var ATTRS_BOUNDARIES = /\[|\]/g;
var COMPONENT_SELECTOR = /^\[?[\w|-]*\]?$/;
var SKEWER_CASE = /-(\w)/g;
function resolveDirectiveNameFromSelector(selector) {
    if (!selector.match(COMPONENT_SELECTOR)) {
        throw new Error("Only selectors matching element names or base attributes are supported, got: " + selector);
    }
    return selector
        .trim()
        .replace(ATTRS_BOUNDARIES, '')
        .replace(SKEWER_CASE, function (all, letter) { return letter.toUpperCase(); });
}
exports.resolveDirectiveNameFromSelector = resolveDirectiveNameFromSelector;
function getTypeName(type) {
    var typeName = getFuncName(type);
    return firstToLowerCase(typeName);
}
exports.getTypeName = getTypeName;
/**
 *
 * @param {Function}  func
 * @returns {string}
 * @private
 */
function getFuncName(func) {
    var parsedFnStatement = /function\s*([^\s(]+)/.exec(stringify(func));
    var _a = parsedFnStatement || [], _b = _a[1], name = _b === void 0 ? '' : _b;
    // if Function.name doesn't exist exec will find match otherwise return name property
    return name || stringify(func);
}
exports.getFuncName = getFuncName;
/**
 * controller instance of directive is exposed on jqLiteElement.data()
 * under the name: `$` + Ctor + `Controller`
 * @param name
 * @returns {string}
 */
function controllerKey(name) {
    return '$' + name + 'Controller';
}
exports.controllerKey = controllerKey;
function hasCtorInjectables(Type) {
    return (Array.isArray(Type.$inject) && Type.$inject.length !== 0);
}
exports.hasCtorInjectables = hasCtorInjectables;
function firstToLowerCase(value) {
    return _firstTo(value, String.prototype.toLowerCase);
}
exports.firstToLowerCase = firstToLowerCase;
function firstToUpperCase(value) {
    return _firstTo(value, String.prototype.toUpperCase);
}
exports.firstToUpperCase = firstToUpperCase;
function _firstTo(value, cb) {
    return cb.call(value.charAt(0)) + value.substring(1);
}
function normalizeBlank(obj) {
    return isBlank(obj) ? null : obj;
}
exports.normalizeBlank = normalizeBlank;
function normalizeBool(obj) {
    return isBlank(obj) ? false : obj;
}
exports.normalizeBool = normalizeBool;
function print(obj) {
    console.log(obj);
}
exports.print = print;
/**
 * Angular 2 setValueOnPath
 * supports only `.` path separator
 * @param global
 * @param path
 * @param value
 */
function setValueOnPath(global, path, value) {
    var parts = path.split('.');
    var obj = global;
    while (parts.length > 1) {
        var name = parts.shift();
        if (obj.hasOwnProperty(name) && isPresent(obj[name])) {
            obj = obj[name];
        }
        else {
            obj = obj[name] = {};
        }
    }
    if (obj === undefined || obj === null) {
        obj = {};
    }
    obj[parts.shift()] = value;
}
exports.setValueOnPath = setValueOnPath;
/**
 * Converts `value` to an object if it's not one.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {Object} Returns the object.
 */
function toObject(value) {
    return isJsObject(value)
        ? value
        : Object(value);
}
exports.toObject = toObject;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
    if (length === void 0) { length = MAX_SAFE_INTEGER; }
    value = (isNumber(value) || reIsUint.test(value))
        ? +value
        : -1;
    return value > -1 && value % 1 == 0 && value < length;
}
exports.isIndex = isIndex;
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
    if ((isString(value) && reIsPlainProp.test(value)) || isNumber(value)) {
        return true;
    }
    if (isArray(value)) {
        return false;
    }
    var result = !reIsDeepProp.test(value);
    return result || (object != null && value in toObject(object));
}
exports.isKey = isKey;
//# sourceMappingURL=lang.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(20)))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(__webpack_require__(665));
var util_1 = __webpack_require__(687);
exports.bundle = util_1.bundle;
var directives_1 = __webpack_require__(668);
exports.Directive = directives_1.Directive;
exports.Component = directives_1.Component;
exports.NgModule = directives_1.NgModule;
exports.Attr = directives_1.Attr;
exports.Input = directives_1.Input;
exports.Output = directives_1.Output;
exports.HostBinding = directives_1.HostBinding;
exports.HostListener = directives_1.HostListener;
exports.ViewChild = directives_1.ViewChild;
exports.ViewChildren = directives_1.ViewChildren;
exports.ContentChild = directives_1.ContentChild;
exports.ContentChildren = directives_1.ContentChildren;
var pipes_1 = __webpack_require__(681);
exports.Pipe = pipes_1.Pipe;
__export(__webpack_require__(662));
var lang_1 = __webpack_require__(2);
exports.enableProdMode = lang_1.enableProdMode;
var facade_1 = __webpack_require__(689);
exports.EventEmitter = facade_1.EventEmitter;
//# sourceMappingURL=core.js.map

/***/ }),
/* 4 */,
/* 5 */,
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var lang_1 = __webpack_require__(2);
var INFINITY = 1 / 0;
/**
 * Wraps Javascript Objects
 */
var StringMapWrapper = (function () {
    function StringMapWrapper() {
    }
    StringMapWrapper.create = function () {
        // Note: We are not using Object.create(null) here due to
        // performance!
        // http://jsperf.com/ng2-object-create-null
        return {};
    };
    StringMapWrapper.contains = function (map, key) {
        return map.hasOwnProperty(key);
    };
    /**
     * The base implementation of `getValueFromPath` without support for string paths
     * and default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path of the property to get.
     * @param {string} [pathKey] The key representation of path.
     * @returns {*} Returns the resolved value.
     */
    StringMapWrapper.baseGet = function (object, path, pathKey) {
        if (object == null) {
            return;
        }
        object = lang_1.toObject(object);
        if (pathKey !== undefined && pathKey in object) {
            path = [pathKey];
        }
        var index = 0, length = path.length;
        while (object != null && index < length) {
            object = lang_1.toObject(object)[path[index++]];
        }
        return (index && index == length)
            ? object
            : undefined;
    };
    /**
     * Gets the property value at `path` of `object`. If the resolved value is
     * `undefined` the `defaultValue` is used in its place.
     *
     * @static
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    StringMapWrapper.getValueFromPath = function (object, path, defaultValue) {
        var result = object == null
            ? undefined
            : StringMapWrapper.baseGet(object, lang_1.toPath(path), (path + ''));
        return result === undefined
            ? defaultValue
            : result;
    };
    /**
     * Sets the property value of `path` on `object`. If a portion of `path`
     * does not exist it's created.
     *
     * @static
     * @param {Object} object The object to augment.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, 'x[0].y.z', 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    StringMapWrapper.setValueInPath = function (object, path, value) {
        if (object == null) {
            return object;
        }
        var pathKey = (path + '');
        path = (object[pathKey] != null || lang_1.isKey(path, object))
            ? [pathKey]
            : lang_1.toPath(path);
        var index = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index < length) {
            var key = path[index];
            if (lang_1.isJsObject(nested)) {
                if (index == lastIndex) {
                    nested[key] = value;
                }
                else if (nested[key] == null) {
                    nested[key] = lang_1.isIndex(path[index + 1])
                        ? []
                        : {};
                }
            }
            nested = nested[key];
        }
        return object;
    };
    StringMapWrapper.get = function (map, key) {
        return map.hasOwnProperty(key)
            ? map[key]
            : undefined;
    };
    StringMapWrapper.set = function (map, key, value) { map[key] = value; };
    StringMapWrapper.keys = function (map) { return Object.keys(map); };
    StringMapWrapper.size = function (map) { return StringMapWrapper.keys(map).length; };
    StringMapWrapper.isEmpty = function (map) {
        for (var prop in map) {
            return false;
        }
        return true;
    };
    StringMapWrapper.delete = function (map, key) { delete map[key]; };
    StringMapWrapper.forEach = function (map, callback) {
        for (var prop in map) {
            if (map.hasOwnProperty(prop)) {
                callback(map[prop], prop);
            }
        }
    };
    StringMapWrapper.values = function (map) {
        return Object.keys(map).reduce(function (r, a) {
            r.push(map[a]);
            return r;
        }, []);
    };
    StringMapWrapper.merge = function (m1, m2) {
        var m = {};
        for (var attr in m1) {
            if (m1.hasOwnProperty(attr)) {
                m[attr] = m1[attr];
            }
        }
        for (var attr in m2) {
            if (m2.hasOwnProperty(attr)) {
                m[attr] = m2[attr];
            }
        }
        return m;
    };
    StringMapWrapper.equals = function (m1, m2) {
        var k1 = Object.keys(m1);
        var k2 = Object.keys(m2);
        if (k1.length != k2.length) {
            return false;
        }
        var key;
        for (var i = 0; i < k1.length; i++) {
            key = k1[i];
            if (m1[key] !== m2[key]) {
                return false;
            }
        }
        return true;
    };
    StringMapWrapper.assign = function (target) {
        var sources = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            sources[_i - 1] = arguments[_i];
        }
        if (!lang_1.isPresent(target)) {
            throw new TypeError('Object.assign cannot be called with null or undefined');
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        if (Object.assign) {
            return (_a = Object).assign.apply(_a, [target].concat(sources));
        }
        var from;
        var to = Object(target);
        for (var s = 0; s < sources.length; s++) {
            from = Object(sources[s]);
            for (var key in from) {
                if (hasOwnProperty.call(from, key)) {
                    to[key] = from[key];
                }
            }
        }
        return to;
        var _a;
    };
    return StringMapWrapper;
}());
exports.StringMapWrapper = StringMapWrapper;
var ListWrapper = (function () {
    function ListWrapper() {
    }
    ListWrapper.create = function () { return []; };
    ListWrapper.size = function (array) { return array.length; };
    // JS has no way to express a statically fixed size list, but dart does so we
    // keep both methods.
    ListWrapper.createFixedSize = function (size) { return new Array(size); };
    ListWrapper.createGrowableSize = function (size) { return new Array(size); };
    ListWrapper.clone = function (array) { return array.slice(0); };
    ListWrapper.forEachWithIndex = function (array, fn) {
        for (var i = 0; i < array.length; i++) {
            fn(array[i], i);
        }
    };
    ListWrapper.first = function (array) {
        if (!array)
            return null;
        return array[0];
    };
    ListWrapper.last = function (array) {
        if (!array || array.length == 0)
            return null;
        return array[array.length - 1];
    };
    ListWrapper.indexOf = function (array, value, startIndex) {
        if (startIndex === void 0) { startIndex = 0; }
        return array.indexOf(value, startIndex);
    };
    ListWrapper.contains = function (list, el) { return list.indexOf(el) !== -1; };
    ListWrapper.reversed = function (array) {
        var a = ListWrapper.clone(array);
        return a.reverse();
    };
    ListWrapper.concat = function (a, b) { return a.concat(b); };
    ListWrapper.insert = function (list, index, value) { list.splice(index, 0, value); };
    ListWrapper.removeAt = function (list, index) {
        var res = list[index];
        list.splice(index, 1);
        return res;
    };
    ListWrapper.removeAll = function (list, items) {
        for (var i = 0; i < items.length; ++i) {
            var index = list.indexOf(items[i]);
            list.splice(index, 1);
        }
    };
    ListWrapper.remove = function (list, el) {
        var index = list.indexOf(el);
        if (index > -1) {
            list.splice(index, 1);
            return true;
        }
        return false;
    };
    ListWrapper.clear = function (list) { list.length = 0; };
    ListWrapper.isEmpty = function (list) { return list.length == 0; };
    ListWrapper.fill = function (list, value, start, end) {
        if (start === void 0) { start = 0; }
        if (end === void 0) { end = null; }
        if (!Array.prototype.fill) {
            Array.prototype.fill = function (value) {
                // Steps 1-2.
                if (this == null) {
                    throw new TypeError('this is null or not defined');
                }
                var O = Object(this);
                // Steps 3-5.
                var len = O.length >>> 0;
                // Steps 6-7.
                var start = arguments[1];
                var relativeStart = start >> 0;
                // Step 8.
                var k = relativeStart < 0
                    ? Math.max(len + relativeStart, 0)
                    : Math.min(relativeStart, len);
                // Steps 9-10.
                var end = arguments[2];
                var relativeEnd = end === undefined
                    ? len
                    : end >> 0;
                // Step 11.
                var final = relativeEnd < 0
                    ? Math.max(len + relativeEnd, 0)
                    : Math.min(relativeEnd, len);
                // Step 12.
                while (k < final) {
                    O[k] = value;
                    k++;
                }
                // Step 13.
                return O;
            };
        }
        list.fill(value, start, end === null
            ? list.length
            : end);
    };
    ListWrapper.equals = function (a, b) {
        if (a.length != b.length)
            return false;
        for (var i = 0; i < a.length; ++i) {
            if (a[i] !== b[i])
                return false;
        }
        return true;
    };
    ListWrapper.slice = function (l, from, to) {
        if (from === void 0) { from = 0; }
        if (to === void 0) { to = null; }
        return l.slice(from, to === null
            ? undefined
            : to);
    };
    ListWrapper.splice = function (l, from, length) { return l.splice(from, length); };
    ListWrapper.sort = function (l, compareFn) {
        if (lang_1.isPresent(compareFn)) {
            l.sort(compareFn);
        }
        else {
            l.sort();
        }
    };
    ListWrapper.toString = function (l) { return l.toString(); };
    ListWrapper.toJSON = function (l) { return JSON.stringify(l); };
    ListWrapper.maximum = function (list, predicate) {
        if (list.length == 0) {
            return null;
        }
        var solution = null;
        var maxValue = -Infinity;
        for (var index = 0; index < list.length; index++) {
            var candidate = list[index];
            if (lang_1.isBlank(candidate)) {
                continue;
            }
            var candidateValue = predicate(candidate);
            if (candidateValue > maxValue) {
                solution = candidate;
                maxValue = candidateValue;
            }
        }
        return solution;
    };
    ListWrapper.find = function (arr, predicate, ctx) {
        if (lang_1.isFunction(Array.prototype['find'])) {
            return arr.find(predicate, ctx);
        }
        ctx = ctx || this;
        var length = arr.length;
        var i;
        if (!lang_1.isFunction(predicate)) {
            throw new TypeError(predicate + " is not a function");
        }
        for (i = 0; i < length; i++) {
            if (predicate.call(ctx, arr[i], i, arr)) {
                return arr[i];
            }
        }
        return undefined;
    };
    ListWrapper.findIndex = function (arr, predicate, ctx) {
        if (lang_1.isFunction(Array.prototype['findIndex'])) {
            return arr.findIndex(predicate, ctx);
        }
        if (!lang_1.isFunction(predicate)) {
            throw new TypeError('predicate must be a function');
        }
        var list = Object(arr);
        var len = list.length;
        if (len === 0) {
            return -1;
        }
        for (var i = 0; i < len; i++) {
            if (predicate.call(ctx, list[i], i, list)) {
                return i;
            }
        }
        return -1;
    };
    ListWrapper.isFlattenable = function (value) {
        return lang_1.isArray(value) || lang_1.isArguments(value);
    };
    /**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */
    ListWrapper.arrayPush = function (array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
            array[offset + index] = values[index];
        }
        return array;
    };
    /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    ListWrapper.baseFlatten = function (array, depth, predicate, isStrict, result) {
        if (predicate === void 0) { predicate = ListWrapper.isFlattenable; }
        if (isStrict === void 0) { isStrict = false; }
        if (result === void 0) { result = []; }
        var index = -1;
        var length = array.length;
        while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
                if (depth > 1) {
                    // Recursively flatten arrays (susceptible to call stack limits).
                    ListWrapper.baseFlatten(value, depth - 1, predicate, isStrict, result);
                }
                else {
                    ListWrapper.arrayPush(result, value);
                }
            }
            else if (!isStrict) {
                result[result.length] = value;
            }
        }
        return result;
    };
    /**
     * Flattens `array` a single level deep.
     *
     * @static
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */
    ListWrapper.flatten = function (array) {
        var length = array ? array.length : 0;
        return length ? ListWrapper.baseFlatten(array, 1) : [];
    };
    /**
     * Recursively flattens `array`.
     *
     * @static
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */
    ListWrapper.flattenDeep = function (array) {
        var length = array
            ? array.length
            : 0;
        return length
            ? ListWrapper.baseFlatten(array, INFINITY)
            : [];
    };
    return ListWrapper;
}());
exports.ListWrapper = ListWrapper;
//# sourceMappingURL=collections.js.map

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var lang_1 = __webpack_require__(2);
/**
 * `DependencyMetadata` is used by the framework to extend DI.
 * This is internal to Angular and should not be used directly.
 */
var DependencyMetadata = (function () {
    function DependencyMetadata() {
    }
    Object.defineProperty(DependencyMetadata.prototype, "token", {
        get: function () { return null; },
        enumerable: true,
        configurable: true
    });
    return DependencyMetadata;
}());
exports.DependencyMetadata = DependencyMetadata;
/**
 * A parameter metadata that specifies a dependency.
 *
 * ### Example ([live demo](http://plnkr.co/edit/6uHYJK?p=preview))
 *
 * ```typescript
 * class Engine {}
 *
 * @Injectable()
 * class Car {
 *   engine;
 *   constructor(@Inject("MyEngine") engine:Engine) {
 *     this.engine = engine;
 *   }
 * }
 *
 * var injector = Injector.resolveAndCreate([
 *  provide("MyEngine", {useClass: Engine}),
 *  Car
 * ]);
 *
 * expect(injector.get(Car).engine instanceof Engine).toBe(true);
 * ```
 *
 * When `@Inject()` is not present, {@link Injector} will use the type annotation of the parameter.
 *
 * ### Example
 *
 * ```typescript
 * class Engine {}
 *
 * @Injectable()
 * class Car {
 *   constructor(public engine: Engine) {} //same as constructor(@Inject(Engine) engine:Engine)
 * }
 *
 * var injector = Injector.resolveAndCreate([Engine, Car]);
 * expect(injector.get(Car).engine instanceof Engine).toBe(true);
 * ```
 */
var InjectMetadata = (function () {
    function InjectMetadata(token) {
        this.token = token;
    }
    InjectMetadata.paramDecoratorForNonConstructor = function (annotationInstance, target, propertyKey, paramIndex) {
        var annotateMethod = target[propertyKey];
        annotateMethod.$inject = annotateMethod.$inject || [];
        annotateMethod.$inject[paramIndex] = annotationInstance.token;
    };
    InjectMetadata.prototype.toString = function () { return "@Inject(" + lang_1.stringify(this.token) + ")"; };
    return InjectMetadata;
}());
exports.InjectMetadata = InjectMetadata;
/**
 * A parameter metadata that marks a dependency as optional. {@link Injector} provides `null` if
 * the dependency is not found.
 *
 * ### Example ([live demo](http://plnkr.co/edit/AsryOm?p=preview))
 *
 * ```typescript
 * class Engine {}
 *
 * @Injectable()
 * class Car {
 *   engine;
 *   constructor(@Optional() engine:Engine) {
 *     this.engine = engine;
 *   }
 * }
 *
 * var injector = Injector.resolveAndCreate([Car]);
 * expect(injector.get(Car).engine).toBeNull();
 * ```
 */
var OptionalMetadata = (function () {
    function OptionalMetadata() {
    }
    OptionalMetadata.prototype.toString = function () { return "@Optional()"; };
    return OptionalMetadata;
}());
exports.OptionalMetadata = OptionalMetadata;
/**
 * A marker metadata that marks a class as available to {@link Injector} for creation.
 *
 * ```typescript
 * @Injectable()
 * class UsefulService {}
 *
 * @Injectable()
 * class NeedsService {
 *   constructor(public service:UsefulService) {}
 * }
 *
 * var injector = Injector.resolveAndCreate([NeedsService, UsefulService]);
 * expect(injector.get(NeedsService).service instanceof UsefulService).toBe(true);
 * ```
 * {@link Injector} will throw {@link NoAnnotationError} when trying to instantiate a class that
 * does not have `@Injectable` marker, as shown in the example below.
 *
 * ```typescript
 * class UsefulService {}
 *
 * class NeedsService {
 *   constructor(public service:UsefulService) {}
 * }
 *
 * var injector = Injector.resolveAndCreate([NeedsService, UsefulService]);
 * expect(() => injector.get(NeedsService)).toThrowError();
 * ```
 */
var InjectableMetadata = (function () {
    function InjectableMetadata(_id) {
        this._id = _id;
    }
    Object.defineProperty(InjectableMetadata.prototype, "id", {
        get: function () { return this._id; },
        set: function (newID) { this._id = newID; },
        enumerable: true,
        configurable: true
    });
    return InjectableMetadata;
}());
exports.InjectableMetadata = InjectableMetadata;
/**
 * Specifies that an {@link Injector} should retrieve a dependency only from itself.
 *
 * ### Example ([live demo](http://plnkr.co/edit/NeagAg?p=preview))
 *
 * ```typescript
 * class Dependency {
 * }
 *
 * @Injectable()
 * class NeedsDependency {
 *   dependency;
 *   constructor(@Self() dependency:Dependency) {
 *     this.dependency = dependency;
 *   }
 * }
 *
 * var inj = Injector.resolveAndCreate([Dependency, NeedsDependency]);
 * var nd = inj.get(NeedsDependency);
 *
 * expect(nd.dependency instanceof Dependency).toBe(true);
 *
 * var inj = Injector.resolveAndCreate([Dependency]);
 * var child = inj.resolveAndCreateChild([NeedsDependency]);
 * expect(() => child.get(NeedsDependency)).toThrowError();
 * ```
 */
var SelfMetadata = (function () {
    function SelfMetadata() {
    }
    SelfMetadata.prototype.toString = function () { return "@Self()"; };
    return SelfMetadata;
}());
exports.SelfMetadata = SelfMetadata;
/**
 * Specifies that the dependency resolution should start from the parent injector.
 *
 * ### Example ([live demo](http://plnkr.co/edit/Wchdzb?p=preview))
 *
 * ```typescript
 * class Dependency {
 * }
 *
 * @Injectable()
 * class NeedsDependency {
 *   dependency;
 *   constructor(@SkipSelf() dependency:Dependency) {
 *     this.dependency = dependency;
 *   }
 * }
 *
 * var parent = Injector.resolveAndCreate([Dependency]);
 * var child = parent.resolveAndCreateChild([NeedsDependency]);
 * expect(child.get(NeedsDependency).dependency instanceof Depedency).toBe(true);
 *
 * var inj = Injector.resolveAndCreate([Dependency, NeedsDependency]);
 * expect(() => inj.get(NeedsDependency)).toThrowError();
 * ```
 */
var SkipSelfMetadata = (function () {
    function SkipSelfMetadata() {
    }
    SkipSelfMetadata.prototype.toString = function () { return "@SkipSelf()"; };
    return SkipSelfMetadata;
}());
exports.SkipSelfMetadata = SkipSelfMetadata;
/**
 * Specifies that an injector should retrieve a dependency from any injector until reaching the
 * closest host.
 *
 * In Angular, a component element is automatically declared as a host for all the injectors in
 * its view.
 *
 * ### Example ([live demo](http://plnkr.co/edit/GX79pV?p=preview))
 *
 * In the following example `App` contains `ParentCmp`, which contains `ChildDirective`.
 * So `ParentCmp` is the host of `ChildDirective`.
 *
 * `ChildDirective` depends on two services: `HostService` and `OtherService`.
 * `HostService` is defined at `ParentCmp`, and `OtherService` is defined at `App`.
 *
 *```typescript
 * class OtherService {}
 * class HostService {}
 *
 * @Directive({
 *   selector: 'child-directive'
 * })
 * class ChildDirective {
 *   constructor(@Optional() @Host() os:OtherService, @Optional() @Host() hs:HostService){
 *     console.log("os is null", os);
 *     console.log("hs is NOT null", hs);
 *   }
 * }
 *
 * @Component({
 *   selector: 'parent-cmp',
 *   providers: [HostService],
 *   template: `
 *     Dir: <child-directive></child-directive>
 *   `,
 *   directives: [ChildDirective]
 * })
 * class ParentCmp {
 * }
 *
 * @Component({
 *   selector: 'app',
 *   providers: [OtherService],
 *   template: `
 *     Parent: <parent-cmp></parent-cmp>
 *   `,
 *   directives: [ParentCmp]
 * })
 * class App {
 * }
 *
 * bootstrap(App);
 *```
 */
var HostMetadata = (function () {
    function HostMetadata() {
    }
    HostMetadata.prototype.toString = function () { return "@Host()"; };
    return HostMetadata;
}());
exports.HostMetadata = HostMetadata;
//# sourceMappingURL=metadata.js.map

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metadata_1 = __webpack_require__(7);
/**
 * Directives allow you to attach behavior to elements in the DOM.
 *
 * {@link DirectiveMetadata}s with an embedded view are called {@link ComponentMetadata}s.
 *
 * A directive consists of a single directive annotation and a controller class. When the
 * directive's `selector` matches
 * elements in the DOM, the following steps occur:
 *
 * 1. For each directive, the `ElementInjector` attempts to resolve the directive's constructor
 * arguments.
 * 2. Angular instantiates directives for each matched element using `ElementInjector` in a
 * depth-first order,
 *    as declared in the HTML.
 *
 * ## Understanding How Injection Works
 *
 * There are three stages of injection resolution.
 * - *Pre-existing Injectors*:
 *   - The terminal {@link Injector} cannot resolve dependencies. It either throws an error or, if
 * the dependency was
 *     specified as `@Optional`, returns `null`.
 *   - The platform injector resolves browser singleton resources, such as: cookies, title,
 * location, and others.
 * - *Component Injectors*: Each component instance has its own {@link Injector}, and they follow
 * the same parent-child hierarchy
 *     as the component instances in the DOM.
 * - *Element Injectors*: Each component instance has a Shadow DOM. Within the Shadow DOM each
 * element has an `ElementInjector`
 *     which follow the same parent-child hierarchy as the DOM elements themselves.
 *
 * When a template is instantiated, it also must instantiate the corresponding directives in a
 * depth-first order. The
 * current `ElementInjector` resolves the constructor dependencies for each directive.
 *
 * Angular then resolves dependencies as follows, according to the order in which they appear in the
 * {@link ViewMetadata}:
 *
 * 1. Dependencies on the current element
 * 2. Dependencies on element injectors and their parents until it encounters a Shadow DOM boundary
 * 3. Dependencies on component injectors and their parents until it encounters the root component
 * 4. Dependencies on pre-existing injectors
 *
 *
 * The `ElementInjector` can inject other directives, element-specific special objects, or it can
 * delegate to the parent
 * injector.
 *
 * To inject other directives, declare the constructor parameter as:
 * - `directive:DirectiveType`: a directive on the current element only
 * - `@Host() directive:DirectiveType`: any directive that matches the type between the current
 * element and the
 *    Shadow DOM root.
 * - `@Query(DirectiveType) query:QueryList<DirectiveType>`: A live collection of direct child
 * directives.
 * - `@QueryDescendants(DirectiveType) query:QueryList<DirectiveType>`: A live collection of any
 * child directives.
 *
 * To inject element-specific special objects, declare the constructor parameter as:
 * - `element: ElementRef` to obtain a reference to logical element in the view.
 * - `viewContainer: ViewContainerRef` to control child template instantiation, for
 * {@link DirectiveMetadata} directives only
 * - `bindingPropagation: BindingPropagation` to control change detection in a more granular way.
 *
 * ### Example
 *
 * The following example demonstrates how dependency injection resolves constructor arguments in
 * practice.
 *
 *
 * Assume this HTML template:
 *
 * ```
 * <div dependency="1">
 *   <div dependency="2">
 *     <div dependency="3" my-directive>
 *       <div dependency="4">
 *         <div dependency="5"></div>
 *       </div>
 *       <div dependency="6"></div>
 *     </div>
 *   </div>
 * </div>
 * ```
 *
 * With the following `dependency` decorator and `SomeService` injectable class.
 *
 * ```
 * @Injectable()
 * class SomeService {
 * }
 *
 * @Directive({
 *   selector: '[dependency]',
 *   inputs: [
 *     'id: dependency'
 *   ]
 * })
 * class Dependency {
 *   id:string;
 * }
 * ```
 *
 * Let's step through the different ways in which `MyDirective` could be declared...
 *
 *
 * ### No injection
 *
 * Here the constructor is declared with no arguments, therefore nothing is injected into
 * `MyDirective`.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor() {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with no dependencies.
 *
 *
 * ### Component-level injection
 *
 * Directives can inject any injectable instance from the closest component injector or any of its
 * parents.
 *
 * Here, the constructor declares a parameter, `someService`, and injects the `SomeService` type
 * from the parent
 * component's injector.
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(someService: SomeService) {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with a dependency on `SomeService`.
 *
 *
 * ### Injecting a directive from the current element
 *
 * Directives can inject other directives declared on the current element.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(dependency: Dependency) {
 *     expect(dependency.id).toEqual(3);
 *   }
 * }
 * ```
 * This directive would be instantiated with `Dependency` declared at the same element, in this case
 * `dependency="3"`.
 *
 * ### Injecting a directive from any ancestor elements
 *
 * Directives can inject other directives declared on any ancestor element (in the current Shadow
 * DOM), i.e. on the current element, the
 * parent element, or its parents.
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(@Host() dependency: Dependency) {
 *     expect(dependency.id).toEqual(2);
 *   }
 * }
 * ```
 *
 * `@Host` checks the current element, the parent, as well as its parents recursively. If
 * `dependency="2"` didn't
 * exist on the direct parent, this injection would
 * have returned
 * `dependency="1"`.
 *
 *
 * ### Injecting a live collection of direct child directives
 *
 *
 * A directive can also query for other child directives. Since parent directives are instantiated
 * before child directives, a directive can't simply inject the list of child directives. Instead,
 * the directive injects a {@link QueryList}, which updates its contents as children are added,
 * removed, or moved by a directive that uses a {@link ViewContainerRef} such as a `ngFor`, an
 * `ngIf`, or an `ngSwitch`.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(@Query(Dependency) dependencies:QueryList<Dependency>) {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with a {@link QueryList} which contains `Dependency` 4 and
 * `Dependency` 6. Here, `Dependency` 5 would not be included, because it is not a direct child.
 *
 * ### Injecting a live collection of descendant directives
 *
 * By passing the descendant flag to `@Query` above, we can include the children of the child
 * elements.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(@Query(Dependency, {descendants: true}) dependencies:QueryList<Dependency>) {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with a Query which would contain `Dependency` 4, 5 and 6.
 *
 * ### Optional injection
 *
 * The normal behavior of directives is to return an error when a specified dependency cannot be
 * resolved. If you
 * would like to inject `null` on unresolved dependency instead, you can annotate that dependency
 * with `@Optional()`.
 * This explicitly permits the author of a template to treat some of the surrounding directives as
 * optional.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(@Optional() dependency:Dependency) {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with a `Dependency` directive found on the current element.
 * If none can be
 * found, the injector supplies `null` instead of throwing an error.
 *
 * ### Example
 *
 * Here we use a decorator directive to simply define basic tool-tip behavior.
 *
 * ```
 * @Directive({
 *   selector: '[tooltip]',
 *   inputs: [
 *     'text: tooltip'
 *   ],
 *   host: {
 *     '(mouseenter)': 'onMouseEnter()',
 *     '(mouseleave)': 'onMouseLeave()'
 *   }
 * })
 * class Tooltip{
 *   text:string;
 *   overlay:Overlay; // NOT YET IMPLEMENTED
 *   overlayManager:OverlayManager; // NOT YET IMPLEMENTED
 *
 *   constructor(overlayManager:OverlayManager) {
 *     this.overlay = overlay;
 *   }
 *
 *   onMouseEnter() {
 *     // exact signature to be determined
 *     this.overlay = this.overlayManager.open(text, ...);
 *   }
 *
 *   onMouseLeave() {
 *     this.overlay.close();
 *     this.overlay = null;
 *   }
 * }
 * ```
 * In our HTML template, we can then add this behavior to a `<div>` or any other element with the
 * `tooltip` selector,
 * like so:
 *
 * ```
 * <div tooltip="some text here"></div>
 * ```
 *
 * Directives can also control the instantiation, destruction, and positioning of inline template
 * elements:
 *
 * A directive uses a {@link ViewContainerRef} to instantiate, insert, move, and destroy views at
 * runtime.
 * The {@link ViewContainerRef} is created as a result of `<template>` element, and represents a
 * location in the current view
 * where these actions are performed.
 *
 * Views are always created as children of the current {@link ViewMetadata}, and as siblings of the
 * `<template>` element. Thus a
 * directive in a child view cannot inject the directive that created it.
 *
 * Since directives that create views via ViewContainers are common in Angular, and using the full
 * `<template>` element syntax is wordy, Angular
 * also supports a shorthand notation: `<li *foo="bar">` and `<li template="foo: bar">` are
 * equivalent.
 *
 * Thus,
 *
 * ```
 * <ul>
 *   <li *foo="bar" title="text"></li>
 * </ul>
 * ```
 *
 * Expands in use to:
 *
 * ```
 * <ul>
 *   <template [foo]="bar">
 *     <li title="text"></li>
 *   </template>
 * </ul>
 * ```
 *
 * Notice that although the shorthand places `*foo="bar"` within the `<li>` element, the binding for
 * the directive
 * controller is correctly instantiated on the `<template>` element rather than the `<li>` element.
 *
 * ## Lifecycle hooks
 *
 * When the directive class implements some {@link angular2/lifecycle_hooks} the callbacks are
 * called by the change detection at defined points in time during the life of the directive.
 *
 * ### Example
 *
 * Let's suppose we want to implement the `unless` behavior, to conditionally include a template.
 *
 * Here is a simple directive that triggers on an `unless` selector:
 *
 * ```
 * @Directive({
 *   selector: '[unless]',
 *   inputs: ['unless']
 * })
 * export class Unless {
 *   viewContainer: ViewContainerRef;
 *   templateRef: TemplateRef;
 *   prevCondition: boolean;
 *
 *   constructor(viewContainer: ViewContainerRef, templateRef: TemplateRef) {
 *     this.viewContainer = viewContainer;
 *     this.templateRef = templateRef;
 *     this.prevCondition = null;
 *   }
 *
 *   set unless(newCondition) {
 *     if (newCondition && (isBlank(this.prevCondition) || !this.prevCondition)) {
 *       this.prevCondition = true;
 *       this.viewContainer.clear();
 *     } else if (!newCondition && (isBlank(this.prevCondition) || this.prevCondition)) {
 *       this.prevCondition = false;
 *       this.viewContainer.create(this.templateRef);
 *     }
 *   }
 * }
 * ```
 *
 * We can then use this `unless` selector in a template:
 * ```
 * <ul>
 *   <li *unless="expr"></li>
 * </ul>
 * ```
 *
 * Once the directive instantiates the child view, the shorthand notation for the template expands
 * and the result is:
 *
 * ```
 * <ul>
 *   <template [unless]="exp">
 *     <li></li>
 *   </template>
 *   <li></li>
 * </ul>
 * ```
 *
 * Note also that although the `<li></li>` template still exists inside the `<template></template>`,
 * the instantiated
 * view occurs on the second `<li></li>` which is a sibling to the `<template>` element.
 */
var DirectiveMetadata = (function (_super) {
    __extends(DirectiveMetadata, _super);
    function DirectiveMetadata(_a) {
        var _b = _a === void 0 ? {} : _a, selector = _b.selector, inputs = _b.inputs, attrs = _b.attrs, outputs = _b.outputs, host = _b.host, providers = _b.providers, exportAs = _b.exportAs, queries = _b.queries, legacy = _b.legacy;
        var _this = _super.call(this) || this;
        _this.selector = selector;
        _this._inputs = inputs;
        _this._attrs = attrs;
        _this._outputs = outputs;
        _this.host = host;
        _this.exportAs = exportAs;
        _this.queries = queries;
        _this._providers = providers;
        _this.legacy = legacy;
        return _this;
    }
    Object.defineProperty(DirectiveMetadata.prototype, "inputs", {
        /**
         * Enumerates the set of data-bound input properties for a directive
         *
         * Angular automatically updates input properties during change detection.
         *
         * The `inputs` property defines a set of `directiveProperty` to `bindingProperty`
         * configuration:
         *
         * - `directiveProperty` specifies the component property where the value is written.
         * - `bindingProperty` specifies the DOM property where the value is read from.
         *
         * When `bindingProperty` is not provided, it is assumed to be equal to `directiveProperty`.
         *
         * ### Example ([live demo](http://plnkr.co/edit/ivhfXY?p=preview))
         *
         * The following example creates a component with two data-bound properties.
         *
         * ```typescript
         * @Component({
         *   selector: 'bank-account',
         *   inputs: ['bankName', 'id: account-id'],
         *   template: `
         *     Bank Name: {{bankName}}
         *     Account Id: {{id}}
         *   `
         * })
         * class BankAccount {
         *   bankName: string;
         *   id: string;
         *
         *   // this property is not bound, and won't be automatically updated by Angular
         *   normalizedBankName: string;
         * }
         *
         * @Component({
         *   selector: 'app',
         *   template: `
         *     <bank-account bank-name="RBC" account-id="4747"></bank-account>
         *   `,
         *   directives: [BankAccount]
         * })
         * class App {}
         *
         * bootstrap(App);
         * ```
         *
         */
        get: function () {
            return this._inputs;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectiveMetadata.prototype, "attrs", {
        /**
         * Enumerates the set of attribute-bound input properties for a directive
         *
         * Angular automatically updates input properties during change detection.
         *
         * The `attrs` property defines a set of `directiveProperty` to `bindingProperty`
         * configuration:
         *
         * - `directiveProperty` specifies the component property where the value is written.
         * - `bindingProperty` specifies the DOM property where the value is read from.
         *
         * When `bindingProperty` is not provided, it is assumed to be equal to `directiveProperty`.
         *
         * #### Behind the scenes:
         * This is just Angular 1 `@` binding on `bindToController` object.
         *
         * So this `attrs: ['bankName', 'id: account-id']`
         * is equal to: `bindToController{bankName:'@',id:'@accountId'}`
         *
         *
         * The following example creates a component with two attribute-bound properties.
         *
         * ```typescript
         * @Component({
         *   selector: 'bank-account',
         *   attrs: ['bankName', 'id: accountId'],
         *   template: `
         *     Bank Name: {{ctrl.bankName}}
         *     Account Id: {{ctrl.id}}
         *   `
         * })
         * class BankAccount {
         *   bankName: string;
         *   id: string;
         *
         *   // this property is not bound, and won't be automatically updated by Angular
         *   normalizedBankName: string;
         * }
         *
         * @Component({
         *   selector: 'app',
         *   template: `
         *     <bank-account bank-name="RBC" account-id="4747"></bank-account>
         *   `
         * })
         * class App {}
         *
         * ```
         *
         * Will output:
         * ```html
         * <bank-account bank-name="RBC" account-id="4747">
         *    Bank Name: RBC
         *    Account Id: 4747
         * </bank-account>
         * ```
         *
         */
        get: function () {
            return this._attrs;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectiveMetadata.prototype, "outputs", {
        /**
         * Enumerates the set of event-bound output properties.
         *
         * When an output property emits an event, an event handler attached to that event
         * the template is invoked.
         *
         * The `outputs` property defines a set of `directiveProperty` to `bindingProperty`
         * configuration:
         *
         * - `directiveProperty` specifies the component property that emits events.
         * - `bindingProperty` specifies the DOM property the event handler is attached to.
         *
         * ### Example ([live demo](http://plnkr.co/edit/d5CNq7?p=preview))
         *
         * ```typescript
         * @Directive({
         *   selector: 'interval-dir',
         *   outputs: ['everySecond', 'five5Secs: everyFiveSeconds']
         * })
         * class IntervalDir {
         *   everySecond = new EventEmitter();
         *   five5Secs = new EventEmitter();
         *
         *   constructor() {
         *     setInterval(() => this.everySecond.emit("event"), 1000);
         *     setInterval(() => this.five5Secs.emit("event"), 5000);
         *   }
         * }
         *
         * @Component({
         *   selector: 'app',
         *   template: `
         *     <interval-dir (every-second)="everySecond()" (every-five-seconds)="everyFiveSeconds()">
         *     </interval-dir>
         *   `,
         *   directives: [IntervalDir]
         * })
         * class App {
         *   everySecond() { console.log('second'); }
         *   everyFiveSeconds() { console.log('five seconds'); }
         * }
         * bootstrap(App);
         * ```
         *
         */
        get: function () {
            return this._outputs;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectiveMetadata.prototype, "providers", {
        /**
         * Defines the set of injectable objects that are visible to a Directive and its light DOM
         * children.
         *
         * ## Simple Example
         *
         * Here is an example of a class that can be injected:
         *
         * ```
         * class Greeter {
         *    greet(name:string) {
         *      return 'Hello ' + name + '!';
         *    }
         * }
         *
         * @Directive({
         *   selector: 'greet',
         *   bindings: [
         *     Greeter
         *   ]
         * })
         * class HelloWorld {
         *   greeter:Greeter;
         *
         *   constructor(greeter:Greeter) {
         *     this.greeter = greeter;
         *   }
         * }
         * ```
         */
        get: function () {
            return this._providers;
        },
        enumerable: true,
        configurable: true
    });
    return DirectiveMetadata;
}(metadata_1.InjectableMetadata));
exports.DirectiveMetadata = DirectiveMetadata;
/**
 * Declare reusable UI building blocks for an application.
 *
 * Each Angular component requires a single `@Component` annotation. The
 * `@Component`
 * annotation specifies when a component is instantiated, and which properties and hostListeners it
 * binds to.
 *
 * When a component is instantiated, Angular
 * - creates a shadow DOM for the component.
 * - loads the selected template into the shadow DOM.
 * - creates all the injectable objects configured with `providers` and `viewProviders`.
 *
 * All template expressions and statements are then evaluated against the component instance.
 *
 * ## Lifecycle hooks
 *
 * When the component class implements some {@link angular2/lifecycle_hooks} the callbacks are
 * called by the change detection at defined points in time during the life of the component.
 *
 * ### Example
 *
 * {@example core/ts/metadata/metadata.ts region='component'}
 */
var ComponentMetadata = (function (_super) {
    __extends(ComponentMetadata, _super);
    function ComponentMetadata(_a) {
        var _b = _a === void 0 ? {} : _a, selector = _b.selector, inputs = _b.inputs, attrs = _b.attrs, outputs = _b.outputs, host = _b.host, exportAs = _b.exportAs, moduleId = _b.moduleId, providers = _b.providers, viewProviders = _b.viewProviders, _c = _b.changeDetection, changeDetection = _c === void 0 ? 1 /* Default */ : _c, queries = _b.queries, templateUrl = _b.templateUrl, template = _b.template, styleUrls = _b.styleUrls, styles = _b.styles, legacy = _b.legacy;
        var _this = _super.call(this, {
            selector: selector,
            inputs: inputs,
            attrs: attrs,
            outputs: outputs,
            host: host,
            exportAs: exportAs,
            providers: providers,
            queries: queries,
            legacy: legacy
        }) || this;
        _this.changeDetection = changeDetection;
        _this._viewProviders = viewProviders;
        _this.templateUrl = templateUrl;
        _this.template = template;
        _this.styleUrls = styleUrls;
        _this.styles = styles;
        _this.moduleId = moduleId;
        return _this;
    }
    Object.defineProperty(ComponentMetadata.prototype, "viewProviders", {
        /**
         * Defines the set of injectable objects that are visible to its view DOM children.
         *
         * ## Simple Example
         *
         * Here is an example of a class that can be injected:
         *
         * ```
         * class Greeter {
         *    greet(name:string) {
         *      return 'Hello ' + name + '!';
         *    }
         * }
         *
         * @Directive({
         *   selector: 'needs-greeter'
         * })
         * class NeedsGreeter {
         *   greeter:Greeter;
         *
         *   constructor(greeter:Greeter) {
         *     this.greeter = greeter;
         *   }
         * }
         *
         * @Component({
         *   selector: 'greet',
         *   viewProviders: [
         *     Greeter
         *   ],
         *   template: `<needs-greeter></needs-greeter>`,
         *   directives: [NeedsGreeter]
         * })
         * class HelloWorld {
         * }
         *
         * ```
         */
        get: function () {
            return this._viewProviders;
        },
        enumerable: true,
        configurable: true
    });
    return ComponentMetadata;
}(DirectiveMetadata));
exports.ComponentMetadata = ComponentMetadata;
/**
 * Declares a data-bound input property.
 *
 * Angular automatically updates data-bound properties during change detection.
 *
 * `InputMetadata` takes an optional parameter that specifies the name
 * used when instantiating a component in the template. When not provided,
 * the name of the decorated property is used.
 *
 * ### Example
 *
 * The following example creates a component with two input properties.
 *
 * ```typescript
 * @Component({
 *   selector: 'bank-account',
 *   template: `
 *     Bank Name: {{bankName}}
 *     Account Id: {{id}}
 *   `
 * })
 * class BankAccount {
 *   @Input() bankName: string;
 *   @Input('account-id') id: string;
 *
 *   // this property is not bound, and won't be automatically updated by Angular
 *   normalizedBankName: string;
 * }
 *
 * @Component({
 *   selector: 'app',
 *   template: `
 *     <bank-account bank-name="RBC" account-id="4747"></bank-account>
 *   `,
 *   directives: [BankAccount]
 * })
 * class App {}
 *
 * bootstrap(App);
 * ```
 */
var InputMetadata = (function () {
    /**
     *
     * @param {string?} bindingPropertyName Name used when instantiating a component in the template.
     */
    function InputMetadata(bindingPropertyName) {
        this.bindingPropertyName = bindingPropertyName;
    }
    return InputMetadata;
}());
exports.InputMetadata = InputMetadata;
/**
 * Declares a data-bound attribute property.
 *
 * Angular automatically updates data-bound properties during change detection.
 *
 * `AttrMetadata` takes an optional parameter that specifies the name
 * used when instantiating a component in the template. When not provided,
 * the name of the decorated property is used.
 *
 *
 * #### Behind the scenes:
 * This is just Angular 1 `@` binding on `bindToController` object.
 *
 * So this `attrs: ['bankName', 'id: account-id']`
 * is equal to: `bindToController{bankName:'@',id:'@accountId'}`
 *
 * ### Example
 *
 * The following example creates a component with two attribute-bound properties.
 *
 * ```typescript
 * @Component({
 *   selector: 'bank-account',
 *   template: `
 *     Bank Name: {{ctrl.bankName}}
 *     Account Id: {{ctrl.id}}
 *   `
 * })
 * class BankAccount {
 *    @Attr() bankName: string;
 *    @Attr('accountId') id: string;
 *
 *   // this property is not bound, and won't be automatically updated by Angular
 *   normalizedBankName: string;
 * }
 *
 * @Component({
 *   selector: 'app',
 *   template: `
 *     <bank-account bank-name="RBC" account-id="4747"></bank-account>
 *   `
 * })
 * class App {}
 * ```
 *
 * Will output:
 * ```html
 * <bank-account bank-name="RBC" account-id="4747">
 *    Bank Name: RBC
 *    Account Id: 4747
 * </bank-account>
 * ```
 *
 */
var AttrMetadata = (function () {
    /**
     *
     * @param {string?} bindingPropertyName Name used when instantiating a component in the template.
     */
    function AttrMetadata(bindingPropertyName) {
        this.bindingPropertyName = bindingPropertyName;
    }
    return AttrMetadata;
}());
exports.AttrMetadata = AttrMetadata;
/**
 * Declares an event-bound output property.
 *
 * When an output property emits an event, an event handler attached to that event
 * the template is invoked.
 *
 * `OutputMetadata` takes an optional parameter that specifies the name
 * used when instantiating a component in the template. When not provided,
 * the name of the decorated property is used.
 *
 * ### Example
 *
 * ```typescript
 * @Directive({
 *   selector: 'interval-dir',
 * })
 * class IntervalDir {
 *   @Output() everySecond = new EventEmitter();
 *   @Output('everyFiveSeconds') five5Secs = new EventEmitter();
 *
 *   constructor() {
 *     setInterval(() => this.everySecond.emit("event"), 1000);
 *     setInterval(() => this.five5Secs.emit("event"), 5000);
 *   }
 * }
 *
 * @Component({
 *   selector: 'app',
 *   template: `
 *     <interval-dir (every-second)="everySecond()" (every-five-seconds)="everyFiveSeconds()">
 *     </interval-dir>
 *   `,
 *   directives: [IntervalDir]
 * })
 * class App {
 *   everySecond() { console.log('second'); }
 *   everyFiveSeconds() { console.log('five seconds'); }
 * }
 * bootstrap(App);
 * ```
 */
var OutputMetadata = (function () {
    /**
     *
     * @param {string?} bindingPropertyName Name used when instantiating a component in the template.
     */
    function OutputMetadata(bindingPropertyName) {
        this.bindingPropertyName = bindingPropertyName;
    }
    return OutputMetadata;
}());
exports.OutputMetadata = OutputMetadata;
/**
 * Declares a host property binding.
 *
 * Angular automatically checks host property bindings during change detection.
 * If a binding changes, it will update the host element of the directive.
 *
 * `HostBindingMetadata` takes an optional parameter that specifies the property
 * name of the host element that will be updated. When not provided,
 * the class property name is used.
 *
 * ### Example
 *
 * The following example creates a directive that sets the `valid` and `invalid` classes
 * on the DOM element that has ngModel directive on it.
 *
 * ```typescript
 * @Directive({selector: '[ngModel]'})
 * class NgModelStatus {
 *   constructor(public control:NgModel) {}
 *   @HostBinding('[class.valid]') get valid { return this.control.valid; }
 *   @HostBinding('[class.invalid]') get invalid { return this.control.invalid; }
 * }
 *
 * @Component({
 *   selector: 'app',
 *   template: `<input [(ngModel)]="prop">`,
 *   directives: [FORM_DIRECTIVES, NgModelStatus]
 * })
 * class App {
 *   prop;
 * }
 *
 * bootstrap(App);
 * ```
 */
var HostBindingMetadata = (function () {
    function HostBindingMetadata(hostPropertyName) {
        this.hostPropertyName = hostPropertyName;
    }
    return HostBindingMetadata;
}());
exports.HostBindingMetadata = HostBindingMetadata;
/**
 * Declares a host listener.
 *
 * Angular will invoke the decorated method when the host element emits the specified event.
 *
 * If the decorated method returns `false`, then `preventDefault` is applied on the DOM
 * event.
 *
 * ### Example
 *
 * The following example declares a directive that attaches a click listener to the button and
 * counts clicks.
 *
 * ```typescript
 * @Directive({selector: 'button[counting]'})
 * class CountClicks {
 *   numberOfClicks = 0;
 *
 *   @HostListener('click', ['$event.target'])
 *   onClick(btn) {
 *     console.log("button", btn, "number of clicks:", this.numberOfClicks++);
 *   }
 * }
 *
 * @Component({
 *   selector: 'app',
 *   template: `<button counting>Increment</button>`,
 *   directives: [CountClicks]
 * })
 * class App {}
 *
 * bootstrap(App);
 * ```
 */
var HostListenerMetadata = (function () {
    function HostListenerMetadata(eventName, args) {
        this.eventName = eventName;
        this.args = args;
    }
    return HostListenerMetadata;
}());
exports.HostListenerMetadata = HostListenerMetadata;
/**
 * Declares an Angular Module.
 */
var NgModuleMetadata = (function (_super) {
    __extends(NgModuleMetadata, _super);
    function NgModuleMetadata(options) {
        if (options === void 0) { options = {}; }
        var _this = 
        // We cannot use destructuring of the constructor argument because `exports` is a
        // protected symbol in CommonJS and closure tries to aggressively optimize it away.
        _super.call(this) || this;
        _this._providers = options.providers;
        _this.declarations = options.declarations;
        _this.imports = options.imports;
        return _this;
    }
    Object.defineProperty(NgModuleMetadata.prototype, "providers", {
        get: function () { return this._providers; },
        enumerable: true,
        configurable: true
    });
    return NgModuleMetadata;
}(metadata_1.InjectableMetadata));
exports.NgModuleMetadata = NgModuleMetadata;
//# sourceMappingURL=metadata_directives.js.map

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var reflector_1 = __webpack_require__(685);
var reflection_capabilities_1 = __webpack_require__(684);
/**
 * The {@link Reflector} used internally in Angular to access metadata
 * about symbols.
 */
exports.reflector = new reflector_1.Reflector(new reflection_capabilities_1.ReflectionCapabilities());
//# sourceMappingURL=reflection.js.map

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//{CODE:CGU01}
// di.core.global.utility
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    window.$di.utility.util = {
        isArray: isArray,
        isNonEmptyArray: isNonEmptyArray,
        isBoolean: isBoolean,
        isNull: isNull,
        isNullOrUndefined: isNullOrUndefined,
        isNumber: isNumber,
        isDecimalNumber: isDecimalNumber,
        isString: isString,
        isNonEmptyString: isNonEmptyString,
        isSymbol: isSymbol,
        isUndefined: isUndefined,
        isRegExp: isRegExp,
        isObject: isObject,
        isEmptyObject: isEmptyObject,
        isRealObject: isRealObject,
        isDate: isDate,
        isError: isError,
        isFunction: isFunction,
        isPrimitive: isPrimitive,
        isDefined: isDefined,
        extend: extend,
        isAnyObjectPropertyDefined: isAnyObjectPropertyDefined,
        toSnakeCase: toSnakeCase,
        hasValue: hasValue
    };

    return window.$di.utility.util;

    function isArray(arg) {
        return !isNullOrUndefined(arg) && Array.isArray(arg);
    }

    function isNonEmptyArray(arg) {
        return isArray(arg) && arg.length > 0;
    }

    function isBoolean(arg) {
        return !isNullOrUndefined(arg) && typeof arg === 'boolean';
    }

    function isNull(arg) {
        return arg === null;
    }

    function isNullOrUndefined(arg) {
        return isNull(arg) || isUndefined(arg);
    }

    function isNumber(arg) {
        return !isNullOrUndefined(arg) && typeof arg === 'number';
    }

    function isDecimalNumber(arg) {
        return isNumber(arg) && Math.floor(arg) != arg;
    }

    function isString(arg) {
        return !isNullOrUndefined(arg) && typeof arg === 'string';
    }

    function isNonEmptyString(arg) {
        return isString(arg) && arg !== '';
    }

    function isSymbol(arg) {
        return !isNullOrUndefined(arg) && (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'symbol';
    }

    function isUndefined(arg) {
        return arg === void 0;
    }

    function isRegExp(arg) {
        return isObject(arg) && objectToString(arg) === '[object RegExp]';
    }

    function isObject(arg) {
        return !isNullOrUndefined(arg) && (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object';
    }

    function isEmptyObject(arg) {
        if (!isObject(arg)) {
            return false; //false result implies arg is non empty object, not that it is not an object
        }

        var name;

        for (name in arg) {
            return false;
        }

        return true;
    }

    function isRealObject(arg) {
        return !isNullOrUndefined(arg) && isObject(arg) && !isEmptyObject(arg);
    }

    function isDate(arg) {
        return isObject(arg) && objectToString(arg) === '[object Date]';
    }

    function isError(arg) {
        return isObject(arg) && (objectToString(arg) === '[object Error]' || arg instanceof Error);
    }

    function isFunction(arg) {
        return !isNullOrUndefined(arg) && typeof arg === 'function';
    }

    function isPrimitive(arg) {
        return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'symbol' || // ES6 symbol
        typeof arg === 'undefined';
    }

    function objectToString(o) {
        return Object.prototype.toString.call(o);
    }

    function isDefined() {
        for (var argI = 0; argI < arguments.length; ++argI) {
            if (isUndefined(arguments[argI])) {
                return false;
            }
        }

        return true;
    }

    /**
     * Copies properties from source to destination object
     * If any properties are an array, the array is emptied and filled with the items from source
     * to preserve any references to the array property
     * @param dest
     * @param source
     */
    function extend(dest, source) {
        if (!isObject(source)) {
            return;
        }

        for (var attr in source) {
            if (source.hasOwnProperty(attr)) {
                if (isArray(source[attr])) {
                    if (isArray(dest[attr]) === false) {
                        dest[attr] = [];
                    }
                    dest[attr].fill(source[attr]);
                } else {
                    dest[attr] = source[attr];
                }
            }
        }
    }

    function isAnyObjectPropertyDefined(arg, ignoredProperties) {
        if (!isObject(arg)) {
            return false;
        }

        if (!isNonEmptyArray(ignoredProperties)) {
            ignoredProperties = [];
        }

        for (var property in arg) {
            if (arg.hasOwnProperty(property) && !isNullOrUndefined(arg[property]) && arg[property] !== '' && !contains(ignoredProperties, property)) {
                return true;
            }
        }

        return false;

        function contains(arrhaystack, needle) {
            return arrhaystack.indexOf(needle) > -1;
        }
    }

    function toSnakeCase(name, separator) {
        separator = separator || '_';
        return name.replace(/[A-Z]/g, function (letter, pos) {
            return (pos ? separator : '') + letter.toLowerCase();
        });
    }

    function hasValue() {
        for (var argI = 0; argI < arguments.length; ++argI) {
            if (isNullOrUndefined(arguments[argI])) {
                return false;
            }
        }

        return true;
    }
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var lang_1 = __webpack_require__(2);
var reflection_1 = __webpack_require__(9);
var pipe_provider_1 = __webpack_require__(683);
var directive_provider_1 = __webpack_require__(674);
var collections_1 = __webpack_require__(6);
var forward_ref_1 = __webpack_require__(13);
var exceptions_1 = __webpack_require__(60);
var provider_util_1 = __webpack_require__(14);
var provider_util_2 = __webpack_require__(14);
var provider_util_3 = __webpack_require__(14);
var Provider = (function () {
    function Provider(token, _a) {
        var useClass = _a.useClass, useValue = _a.useValue, useExisting = _a.useExisting, useFactory = _a.useFactory, deps = _a.deps, multi = _a.multi;
        this.token = token;
        this.useClass = useClass;
        this.useValue = useValue;
        this.useExisting = useExisting;
        this.useFactory = useFactory;
        this.dependencies = deps;
        this._multi = multi;
    }
    Object.defineProperty(Provider.prototype, "multi", {
        /**
         * Creates multiple providers matching the same token (a multi-provider).
         *
         * Multi-providers are used for creating pluggable service, where the system comes
         * with some default providers, and the user can register additional providers.
         * The combination of the default providers and the additional providers will be
         * used to drive the behavior of the system.
         *
         * ### Example
         *
         * ```typescript
         * var injector = Injector.resolveAndCreate([
         *   new Provider("Strings", { useValue: "String1", multi: true}),
         *   new Provider("Strings", { useValue: "String2", multi: true})
         * ]);
         *
         * expect(injector.get("Strings")).toEqual(["String1", "String2"]);
         * ```
         *
         * Multi-providers and regular providers cannot be mixed. The following
         * will throw an exception:
         *
         * ```typescript
         * var injector = Injector.resolveAndCreate([
         *   new Provider("Strings", { useValue: "String1", multi: true }),
         *   new Provider("Strings", { useValue: "String2"})
         * ]);
         * ```
         */
        get: function () { return lang_1.normalizeBool(this._multi); },
        enumerable: true,
        configurable: true
    });
    return Provider;
}());
exports.Provider = Provider;
var ProviderBuilder = (function () {
    function ProviderBuilder() {
    }
    ProviderBuilder.createFromType = function (type, _a) {
        var useClass = _a.useClass, useValue = _a.useValue, useFactory = _a.useFactory, deps = _a.deps;
        // ...provide('myFactory',{useFactory: () => () => { return new Foo(); } })
        if (lang_1.isPresent(useFactory)) {
            var factoryToken = getInjectableName(type);
            var injectableDeps = lang_1.isArray(deps) ? deps.map(getInjectableName) : [];
            useFactory.$inject = injectableDeps;
            return [
                factoryToken,
                useFactory
            ];
        }
        // ...provide(opaqueTokenInst,{useValue: {foo:12312} })
        // ...provide('myValue',{useValue: {foo:12312} })
        if (lang_1.isPresent(useValue)) {
            var valueToken = getInjectableName(type);
            return [
                valueToken,
                useValue
            ];
        }
        var injectableType = lang_1.isString(type) || provider_util_1.isOpaqueToken(type)
            ? forward_ref_1.resolveForwardRef(useClass)
            : forward_ref_1.resolveForwardRef(type);
        var overrideName = lang_1.isString(type) || provider_util_1.isOpaqueToken(type)
            ? getInjectableName(type)
            : '';
        if (!lang_1.isType(injectableType)) {
            throw new Error("\n      Provider registration: \"" + lang_1.stringify(injectableType) + "\":\n      =======================================================\n      token " + lang_1.stringify(injectableType) + " must be type of Type, You cannot provide none class\n      ");
        }
        /**
         *
         * @type {any[]}
         */
        var annotations = reflection_1.reflector.annotations(injectableType);
        var rootAnnotation = annotations[0];
        // No Annotation === it's config function !!!
        // NOTE: we are not checking anymore if user annotated the class or not,
        // we cannot do that anymore at the costs for nic config functions registration
        if (collections_1.ListWrapper.isEmpty(annotations)) {
            return [injectableType];
        }
        if (collections_1.ListWrapper.size(annotations) > 1) {
            var hasComponentAnnotation = annotations.some(function (meta) { return provider_util_2.isComponent(meta); });
            var hasNotAllowedSecondAnnotation = annotations.some(function (meta) {
                return provider_util_1.isDirectiveLike(meta) || provider_util_1.isService(meta) || provider_util_1.isPipe(meta);
            });
            if (!hasComponentAnnotation || (hasNotAllowedSecondAnnotation && hasComponentAnnotation)) {
                throw Error("\n        Provider registration: \"" + lang_1.stringify(injectableType) + "\":\n        =======================================================\n        - you cannot use more than 1 class decorator,\n        - you've used " + annotations.map(function (meta) { return lang_1.stringify(meta.constructor); }) + "\n        Multiple class decorators are allowed only for component class: [ @Component, @StateConfig? ]\n        ");
            }
        }
        injectableType.$inject = _dependenciesFor(injectableType);
        if (provider_util_1.isPipe(rootAnnotation)) {
            return pipe_provider_1.pipeProvider.createFromType(injectableType);
        }
        if (provider_util_1.isDirectiveLike(rootAnnotation)) {
            return directive_provider_1.directiveProvider.createFromType(injectableType);
        }
        if (provider_util_1.isService(rootAnnotation)) {
            return [
                overrideName || rootAnnotation.id,
                injectableType
            ];
        }
    };
    return ProviderBuilder;
}());
/**
 * should extract the string token from provided Type and add $inject angular 1 annotation to constructor if @Inject
 * was used
 * @returns {[string,Type]}
 * @deprecated
 */
function provide(type, _a) {
    var _b = _a === void 0 ? {} : _a, useClass = _b.useClass, useValue = _b.useValue, useFactory = _b.useFactory, deps = _b.deps;
    return ProviderBuilder.createFromType(type, { useClass: useClass, useValue: useValue, useFactory: useFactory, deps: deps });
}
exports.provide = provide;
/**
 * creates $inject array Angular 1 DI annotation strings for provided Type
 * @param typeOrFunc
 * @returns {any}
 * @private
 * @internal
 */
function _dependenciesFor(typeOrFunc) {
    var params = reflection_1.reflector.parameters(typeOrFunc);
    if (lang_1.isBlank(params))
        return [];
    if (params.some(function (param) { return lang_1.isBlank(param) || collections_1.ListWrapper.isEmpty(param); })) {
        throw new Error(exceptions_1.getErrorMsg(typeOrFunc, "you cannot have holes in constructor DI injection"));
    }
    return params
        .map(function (p) { return _extractToken(p); });
}
exports._dependenciesFor = _dependenciesFor;
/**
 * should extract service/values/directives/pipes token from constructor @Inject() paramMetadata
 * @param metadata
 * @private
 * @internal
 */
function _extractToken(metadata) {
    // this is token obtained via design:paramtypes via Reflect.metadata
    var paramMetadata = metadata.filter(lang_1.isType)[0];
    // this is token obtained from @Inject() usage  for DI
    var injectMetadata = metadata.filter(provider_util_3.isInjectMetadata)[0];
    if (lang_1.isBlank(injectMetadata) && lang_1.isBlank(paramMetadata)) {
        return;
    }
    var _a = (injectMetadata || {}).token, token = _a === void 0 ? undefined : _a;
    var injectable = forward_ref_1.resolveForwardRef(token) || paramMetadata;
    return getInjectableName(injectable);
}
exports._extractToken = _extractToken;
/**
 *  A utility function that can be used to get the angular 1 injectable's name. Needed for some cases, since
 *  injectable names are auto-created.
 *
 *  Works for string/OpaqueToken/Type
 *  Note: Type must be decorated otherwise it throws
 *
 *  @example
 *  ```typescript
 *  import { Injectable, getInjectableName } from 'ng-metadata/core';
 *  // this is given some random name like 'myService48' when it's created with `module.service`
 *
 *  @Injectable
 *  class MyService {}
 *
 *  console.log(getInjectableName(MyService)); // 'myService48'
 *  ```
 *
 * @param {ProviderType}  injectable
 * @returns {string}
 */
function getInjectableName(injectable) {
    // @Inject('foo') foo
    if (lang_1.isString(injectable)) {
        return injectable;
    }
    // const fooToken = new OpaqueToken('foo')
    // @Inject(fooToken) foo
    if (provider_util_1.isOpaqueToken(injectable)) {
        return injectable.desc;
    }
    // @Injectable()
    // class SomeService(){}
    //
    // @Inject(SomeService) someSvc
    // someSvc: SomeService
    if (lang_1.isType(injectable)) {
        // only the first class annotations is injectable
        var annotation = reflection_1.reflector.annotations(injectable)[0];
        if (lang_1.isBlank(annotation)) {
            throw new Error("\n        cannot get injectable name token from none decorated class " + lang_1.getFuncName(injectable) + "\n        Only decorated classes by one of [ @Injectable,@Directive,@Component,@Pipe ], can be injected by reference\n      ");
        }
        if (provider_util_1.isPipe(annotation)) {
            return annotation.name;
        }
        if (provider_util_1.isDirectiveLike(annotation)) {
            return lang_1.resolveDirectiveNameFromSelector(annotation.selector);
        }
        if (provider_util_1.isService(annotation)) {
            return annotation.id;
        }
    }
}
exports.getInjectableName = getInjectableName;
/**
 *
 * @param metadata
 * @returns {boolean}
 * @private
 * @internal
 * @deprecated
 *
 * @TODO: delete this
 */
function _areAllDirectiveInjectionsAtTail(metadata) {
    return metadata.every(function (paramMetadata, idx, arr) {
        var isCurrentDirectiveInjection = paramMetadata.length > 1;
        var hasPrev = idx > 0;
        var hasNext = idx < arr.length - 1;
        if (hasPrev) {
            var prevInjection = arr[idx - 1];
            var isPrevDirectiveInjection = prevInjection.length > 1;
            if (isPrevDirectiveInjection && !isCurrentDirectiveInjection) {
                return false;
            }
        }
        if (hasNext) {
            var nextInjection = arr[idx + 1];
            var isNextDirectiveInjection = nextInjection.length > 1;
            if (!isNextDirectiveInjection && isNextDirectiveInjection) {
                return false;
            }
        }
        return true;
    });
}
exports._areAllDirectiveInjectionsAtTail = _areAllDirectiveInjectionsAtTail;
//# sourceMappingURL=provider.js.map

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CGE02}
// di.core.global.exception
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(10)], __WEBPACK_AMD_DEFINE_RESULT__ = function (util) {
    'use strict';

    throwIfNullOrUndefined('CGE0202E', util, 'util');

    /** Guard object with methods for validating values and throwing di exceptions with source */
    window.$di.exception.guard = {
        getNewError: getNewError,
        throwNew: throwNew,
        throwIf: throwIf,
        throwIfNull: throwIfNull,
        throwIfUndefined: throwIfUndefined,
        throwIfNullOrUndefined: throwIfNullOrUndefined,
        throwIfNotAnObject: throwIfNotAnObject,
        throwIfNotANumber: throwIfNotANumber,
        throwIfZero: throwIfZero,
        throwIfNegative: throwIfNegative,
        throwIfZeroOrNegative: throwIfZeroOrNegative,
        throwIfDecimal: throwIfDecimal,
        throwIfNotAString: throwIfNotAString,
        throwIfEmptyString: throwIfEmptyString,
        throwIfInvalidId: throwIfInvalidId,
        throwIfNotAFunction: throwIfNotAFunction,
        throwIfNotArray: throwIfNotArray,
        throwIfEmptyArray: throwIfEmptyArray,
        reThrow: reThrow
    };

    return window.$di.exception.guard;

    /**
     * Generate a new di exception
     * @param source
     * @param message
     * @returns
     */
    function getNewError(source, message) {
        var err = new Error(message);

        err.source = source;

        return err;
    }

    /**
     * Throw a new exception
     * @param {string} source Exception source
     * @param {string} message Exception message
     * @returns
     */
    function throwNew(source, message) {
        var err = getNewError(source, message);

        throw err;
    }

    /**
     * Throw an exception if condition is true
     * @param {string} source Exception source
     * @param {bool} condition Whether or not to throw the exception
     * @param {string} message Exception message
     */
    function throwIf(source, condition, message) {
        if (condition) {
            throwNew(source, message);
        }
    }

    /**
     * Throw an exception if the given value is [null]
     * @param {string} source Exception source
     * @param value Value to check
     * @param {string} valueName Name of the argument or property being checked
     */
    function throwIfNull(source, value, valueName) {
        throwIf(source, util.isNull(value), valueName + " is null");
    }

    /**
     * Throw an exception if the given value is [undefined]
     * @param {string} source Exception source
     * @param value Value to check
     * @param {string} valueName Name of the argument or property being checked
     */
    function throwIfUndefined(source, value, valueName) {
        throwIf(source, util.isUndefined(value), valueName + " is undefined");
    }

    /**
     * Throw an exception if the given value is [null] or [undefined]
     * @param {string} source Exception source
     * @param value Value to check
     * @param {string} valueName Name of the argument or property being checked
     */
    function throwIfNullOrUndefined(source, value, valueName) {
        throwIfNull(source, value, valueName);
        throwIfUndefined(source, value, valueName);
    }

    /**
     * Throw an exception if the given value is not an object
     * @param {string} source Exception source
     * @param value Value to check
     * @param {string} valueName Name of the argument or property being checked
     */
    function throwIfNotAnObject(source, value, valueName) {
        throwIfNullOrUndefined(source, value, valueName);
        throwIf(source, !util.isObject(value), valueName + " is not an object");
    }

    /**
     * Throw an exception if the given value is not a numeric data type
     * or is [null]/[undefined]
     * @param {string} source Exception source
     * @param value Value to check
     * @param {string} valueName Name of the argument or property being checked
     */
    function throwIfNotANumber(source, value, valueName) {
        throwIfNullOrUndefined(source, value, valueName);
        throwIf(source, !util.isNumber(value), valueName + " is not a number");
    }

    /**
     * Throw an exception if the given value is not a numeric data type
     * or is zero
     * @param {string} source Exception source
     * @param value Value to check
     * @param {string} valueName Name of the argument or property being checked
     */
    function throwIfZero(source, value, valueName) {
        throwIfNotANumber(source, value, valueName);
        throwIf(source, value === 0, valueName + " is zero");
    }

    /**
     * Throw an exception if the given value is not a numeric data type
     * or is negative
     * @param {string} source Exception source
     * @param value Value to check
     * @param {string} valueName Name of the argument or property being checked
     */
    function throwIfNegative(source, value, valueName) {
        throwIfNotANumber(source, value, valueName);
        throwIf(source, value < 0, valueName + " is negative");
    }

    /**
     * Throw an exception if the given value is not a numeric data type
     * or is zero or is negative
     * @param {string} source Exception source
     * @param value Value to check
     * @param {string} valueName Name of the argument or property being checked
     */
    function throwIfZeroOrNegative(source, value, valueName) {
        throwIfZero(source, value, valueName);
        throwIfNegative(source, value, valueName);
    }

    /**
     * Throw an exception if the given value is not a numeric data type
     * or is decimal
     * @param {string} source Exception source
     * @param value Value to check
     * @param {string} valueName Name of the argument or property being checked
     */
    function throwIfDecimal(source, value, valueName) {
        throwIfNotANumber(source, value, valueName);
        throwIf(source, util.isDecimalNumber(value), valueName + " is decimal");
    }

    /**
     * Throw an exception if the given value is not a string
     * @param {string} source Exception source
     * @param value Value to check
     * @param {string} valueName Name of the argument or property being checked
     */
    function throwIfNotAString(source, value, valueName) {
        throwIfNullOrUndefined(source, value, valueName);
        throwIf(source, !util.isString(value), valueName + " is not a string");
    }

    /**
     * Throw an exception if the given value is an empty string
     * @param {string} source Exception source
     * @param value Value to check
     * @param {string} valueName Name of the argument or property being checked
     */
    function throwIfEmptyString(source, value, valueName) {
        throwIfNotAString(source, value, valueName);
        throwIf(source, value == '', valueName + " is an empty string");
    }

    /**
     * Throw an exception if the given value is not a positive integer data type
     * @param {string} source Exception source
     * @param value Value to check
     * @param {string} valueName Name of the argument or property being checked
     */
    function throwIfInvalidId(source, value, valueName) {
        try {
            throwIfDecimal(source, value, valueName);
            throwIfZeroOrNegative(source, value, valueName);
        } catch (e) {
            reThrow(source, e, valueName + " is not a valid ID");
        }
    }

    /**
     * Throw an exception if the given value is not a function
     * or is [null]/[undefined]
     * @param {string} source Exception source
     * @param value Value to check
     * @param {string} valueName Name of the argument or property being checked
     */
    function throwIfNotAFunction(source, value, valueName) {
        throwIfNullOrUndefined(source, value, valueName);
        throwIf(source, !util.isFunction(value), valueName + " is not a function");
    }

    /**
     * Throw an exception if the given value is not an array
     * or is [null]/[undefined]
     * @param {string} source Exception source
     * @param value Value to check
     * @param {string} valueName Name of the argument or property being checked
     */
    function throwIfNotArray(source, value, valueName) {
        throwIfNullOrUndefined(source, value, valueName);
        throwIf(source, !util.isArray(value), valueName + " is not an array");
    }

    /**
     * Throw an exception if the given value is an empty array
     * or is [null]/[undefined]
     * @param {string} source Exception source
     * @param value Value to check
     * @param {string} valueName Name of the argument or property being checked
     */
    function throwIfEmptyArray(source, value, valueName) {
        throwIfNotArray(source, value, valueName);
        throwIf(source, value.length == 0, valueName + " is an empty array");
    }

    /**
     * Throw a new exception containing the given exception as the innerException
     * @param {string} source Exception source
     * @param {Error} ex
     * @param {string} message Exception message
     */
    function reThrow(source, ex, message) {
        var err = getNewError(source, message);

        err.innerException = ex;

        throw err;
    }
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var lang_1 = __webpack_require__(2);
/**
 * Allows to refer to references which are not yet defined.
 *
 * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of
 * DI is declared,
 * but not yet defined. It is also used when the `token` which we use when creating a query is not
 * yet defined.
 *
 * ### Example
 * {@example core/di/ts/forward_ref/forward_ref.ts region='forward_ref'}
 */
function forwardRef(forwardRefFn) {
    forwardRefFn.__forward_ref__ = forwardRef;
    forwardRefFn.toString = function () { return lang_1.stringify(this()); };
    return forwardRefFn;
}
exports.forwardRef = forwardRef;
/**
 * Lazily retrieves the reference value from a forwardRef.
 *
 * Acts as the identity function when given a non-forward-ref value.
 *
 * ### Example ([live demo](http://plnkr.co/edit/GU72mJrk1fiodChcmiDR?p=preview))
 *
 * ```typescript
 * var ref = forwardRef(() => "refValue");
 * expect(resolveForwardRef(ref)).toEqual("refValue");
 * expect(resolveForwardRef("regularValue")).toEqual("regularValue");
 * ```
 *
 * See: {@link forwardRef}
 */
function resolveForwardRef(type) {
    if (_isForwardRef(type)) {
        return type();
    }
    else {
        return type;
    }
    function _isForwardRef(type) {
        return lang_1.isFunction(type) && type.hasOwnProperty('__forward_ref__') && type.__forward_ref__ === forwardRef;
    }
}
exports.resolveForwardRef = resolveForwardRef;
//# sourceMappingURL=forward_ref.js.map

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var lang_1 = __webpack_require__(2);
var metadata_directives_1 = __webpack_require__(8);
var metadata_1 = __webpack_require__(29);
var provider_1 = __webpack_require__(11);
var opaque_token_1 = __webpack_require__(57);
var metadata_2 = __webpack_require__(7);
function isProviderLiteral(obj) {
    return obj && typeof obj == 'object' && obj.provide;
}
exports.isProviderLiteral = isProviderLiteral;
function createProvider(obj) {
    return new provider_1.Provider(obj.provide, obj);
}
exports.createProvider = createProvider;
function isOpaqueToken(obj) {
    return obj instanceof opaque_token_1.OpaqueToken;
}
exports.isOpaqueToken = isOpaqueToken;
function isDirectiveLike(annotation) {
    return lang_1.isString(annotation.selector) && annotation instanceof metadata_directives_1.DirectiveMetadata;
}
exports.isDirectiveLike = isDirectiveLike;
function isDirective(annotation) {
    return isDirectiveLike(annotation) && !_hasTemplate(annotation);
}
exports.isDirective = isDirective;
function isComponent(annotation) {
    return lang_1.isString(annotation.selector) && _hasTemplate(annotation) && annotation instanceof metadata_directives_1.ComponentMetadata;
}
exports.isComponent = isComponent;
function _hasTemplate(annotation) {
    return lang_1.isPresent(annotation.template || annotation.templateUrl);
}
function isService(annotation) {
    return annotation instanceof metadata_2.InjectableMetadata;
}
exports.isService = isService;
function isPipe(annotation) {
    return lang_1.isString(annotation.name) && annotation instanceof metadata_1.PipeMetadata;
}
exports.isPipe = isPipe;
function isInjectMetadata(injectMeta) {
    return injectMeta instanceof metadata_2.InjectMetadata;
}
exports.isInjectMetadata = isInjectMetadata;
function isNgModule(annotation) {
    return annotation instanceof metadata_directives_1.NgModuleMetadata;
}
exports.isNgModule = isNgModule;
//# sourceMappingURL=provider_util.js.map

/***/ }),
/* 15 */,
/* 16 */,
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var ng = __webpack_require__(1);
var core_1 = __webpack_require__(3);
var ResourceListConfigurationServiceBase = (function () {
    function ResourceListConfigurationServiceBase() {
        this._tableOptions = {
            enableSelect: true,
            multiSelect: false,
            enablePaging: true,
            fixedHeight: true,
            maxItemsToShow: 500,
            paginationPageSize: 5,
            paginationPageNumber: 1,
            maxButtonsShown: 3,
            columns: [],
            actionColumns: []
        };
    }
    ResourceListConfigurationServiceBase.prototype.tableOptions = function () {
        return ng.copy(this._tableOptions);
    };
    ResourceListConfigurationServiceBase = __decorate([
        core_1.Injectable(),
        __metadata("design:paramtypes", [])
    ], ResourceListConfigurationServiceBase);
    return ResourceListConfigurationServiceBase;
}());
exports.ResourceListConfigurationServiceBase = ResourceListConfigurationServiceBase;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = __webpack_require__(2);
var forward_ref_1 = __webpack_require__(13);
var metadata_1 = __webpack_require__(7);
/**
 * Declares an injectable parameter to be a live list of directives or variable
 * bindings from the content children of a directive.
 *
 * ### Example ([live demo](http://plnkr.co/edit/lY9m8HLy7z06vDoUaSN2?p=preview))
 *
 * Assume that `<tabs>` component would like to get a list its children `<pane>`
 * components as shown in this example:
 *
 * ```html
 * <tabs>
 *   <pane title="Overview">...</pane>
 *   <pane *ngFor="#o of objects" [title]="o.title">{{o.text}}</pane>
 * </tabs>
 * ```
 *
 * The preferred solution is to query for `Pane` directives using this decorator.
 *
 * ```javascript
 * @Component({
 *   selector: 'pane',
 *   inputs: ['title']
 * })
 * class Pane {
 *   title:string;
 * }
 *
 * @Component({
 *  selector: 'tabs',
 *  template: `
 *    <ul>
 *      <li *ngFor="#pane of panes">{{pane.title}}</li>
 *    </ul>
 *    <content></content>
 *  `
 * })
 * class Tabs {
 *   panes: QueryList<Pane>;
 *   constructor(@Query(Pane) panes:QueryList<Pane>) {
  *    this.panes = panes;
  *  }
 * }
 * ```
 *
 * A query can look for variable bindings by passing in a string with desired binding symbol.
 *
 * ### Example ([live demo](http://plnkr.co/edit/sT2j25cH1dURAyBRCKx1?p=preview))
 * ```html
 * <seeker>
 *   <div #findme>...</div>
 * </seeker>
 *
 * @Component({ selector: 'seeker' })
 * class Seeker {
 *   constructor(@Query('findme') elList: QueryList<ElementRef>) {...}
 * }
 * ```
 *
 * In this case the object that is injected depend on the type of the variable
 * binding. It can be an ElementRef, a directive or a component.
 *
 * Passing in a comma separated list of variable bindings will query for all of them.
 *
 * ```html
 * <seeker>
 *   <div #find-me>...</div>
 *   <div #find-me-too>...</div>
 * </seeker>
 *
 *  @Component({
 *   selector: 'seeker'
 * })
 * class Seeker {
 *   constructor(@Query('findMe, findMeToo') elList: QueryList<ElementRef>) {...}
 * }
 * ```
 *
 * Configure whether query looks for direct children or all descendants
 * of the querying element, by using the `descendants` parameter.
 * It is set to `false` by default.
 *
 * ### Example ([live demo](http://plnkr.co/edit/wtGeB977bv7qvA5FTYl9?p=preview))
 * ```html
 * <container #first>
 *   <item>a</item>
 *   <item>b</item>
 *   <container #second>
 *     <item>c</item>
 *   </container>
 * </container>
 * ```
 *
 * When querying for items, the first container will see only `a` and `b` by default,
 * but with `Query(TextDirective, {descendants: true})` it will see `c` too.
 *
 * The queried directives are kept in a depth-first pre-order with respect to their
 * positions in the DOM.
 *
 * Query does not look deep into any subcomponent views.
 *
 * Query is updated as part of the change-detection cycle. Since change detection
 * happens after construction of a directive, QueryList will always be empty when observed in the
 * constructor.
 *
 * The injected object is an unmodifiable live list.
 * See {@link QueryList} for more details.
 */
var QueryMetadata = (function (_super) {
    __extends(QueryMetadata, _super);
    function QueryMetadata(_selector, _a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.descendants, descendants = _c === void 0 ? false : _c, _d = _b.first, first = _d === void 0 ? false : _d;
        var _this = _super.call(this) || this;
        _this._selector = _selector;
        _this.descendants = descendants;
        _this.first = first;
        return _this;
    }
    Object.defineProperty(QueryMetadata.prototype, "isViewQuery", {
        /**
         * always `false` to differentiate it with {@link ViewQueryMetadata}.
         */
        get: function () { return false; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QueryMetadata.prototype, "selector", {
        /**
         * what this is querying for.
         */
        get: function () { return forward_ref_1.resolveForwardRef(this._selector); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QueryMetadata.prototype, "isVarBindingQuery", {
        /**
         * whether this is querying for a variable binding or a directive.
         */
        get: function () { return lang_1.isString(this.selector); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QueryMetadata.prototype, "varBindings", {
        /**
         * returns a list of variable bindings this is querying for.
         * Only applicable if this is a variable bindings query.
         */
        get: function () {
            return this.isVarBindingQuery
                ? this.selector.split(',')
                : [];
        },
        enumerable: true,
        configurable: true
    });
    QueryMetadata.prototype.toString = function () { return "@Query(" + lang_1.stringify(this.selector) + ")"; };
    return QueryMetadata;
}(metadata_1.DependencyMetadata));
exports.QueryMetadata = QueryMetadata;
/**
 * Configures a content query.
 *
 * Content queries are set before the `ngAfterContentInit` callback is called.
 *
 * ### Example
 *
 * ```
 * @Directive({
 *   selector: 'someDir'
 * })
 * class SomeDir {
 *   @ContentChildren(ChildDirective) contentChildren: QueryList<ChildDirective>;
 *
 *   ngAfterContentInit() {
 *     // contentChildren is set
 *   }
 * }
 * ```
 */
var ContentChildrenMetadata = (function (_super) {
    __extends(ContentChildrenMetadata, _super);
    function ContentChildrenMetadata(_selector, _a) {
        var _b = (_a === void 0 ? {} : _a).descendants, descendants = _b === void 0 ? false : _b;
        return _super.call(this, _selector, { descendants: descendants }) || this;
    }
    return ContentChildrenMetadata;
}(QueryMetadata));
exports.ContentChildrenMetadata = ContentChildrenMetadata;
/**
 * Configures a content query.
 *
 * Content queries are set before the `ngAfterContentInit` callback is called.
 *
 * ### Example
 *
 * ```
 * @Directive({
 *   selector: 'someDir'
 * })
 * class SomeDir {
 *   @ContentChild(ChildDirective) contentChild;
 *
 *   ngAfterContentInit() {
 *     // contentChild is set
 *   }
 * }
 * ```
 */
var ContentChildMetadata = (function (_super) {
    __extends(ContentChildMetadata, _super);
    function ContentChildMetadata(_selector) {
        return _super.call(this, _selector, { descendants: true, first: true }) || this;
    }
    return ContentChildMetadata;
}(QueryMetadata));
exports.ContentChildMetadata = ContentChildMetadata;
/**
 * Similar to {@link QueryMetadata}, but querying the component view, instead of
 * the content children.
 *
 * ### Example ([live demo](http://plnkr.co/edit/eNsFHDf7YjyM6IzKxM1j?p=preview))
 *
 * ```javascript
 * @Component({...})
 * @View({
 *   template: `
 *     <item> a </item>
 *     <item> b </item>
 *     <item> c </item>
 *   `
 * })
 * class MyComponent {
 *   shown: boolean;
 *
 *   constructor(private @Query(Item) items:QueryList<Item>) {
 *     items.onChange(() => console.log(items.length));
 *   }
 * }
 * ```
 *
 * Supports the same querying parameters as {@link QueryMetadata}, except
 * `descendants`. This always queries the whole view.
 *
 * As `shown` is flipped between true and false, items will contain zero of one
 * items.
 *
 * Specifies that a {@link QueryList} should be injected.
 *
 * The injected object is an iterable and observable live list.
 * See {@link QueryList} for more details.
 */
var ViewQueryMetadata = (function (_super) {
    __extends(ViewQueryMetadata, _super);
    function ViewQueryMetadata(_selector, _a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.descendants, descendants = _c === void 0 ? false : _c, _d = _b.first, first = _d === void 0 ? false : _d;
        return _super.call(this, _selector, { descendants: descendants, first: first }) || this;
    }
    Object.defineProperty(ViewQueryMetadata.prototype, "isViewQuery", {
        /**
         * always `true` to differentiate it with {@link QueryMetadata}.
         */
        get: function () { return true; },
        enumerable: true,
        configurable: true
    });
    ViewQueryMetadata.prototype.toString = function () { return "@ViewQuery(" + lang_1.stringify(this.selector) + ")"; };
    return ViewQueryMetadata;
}(QueryMetadata));
exports.ViewQueryMetadata = ViewQueryMetadata;
/**
 * Configures a view query.
 *
 * View queries are set before the `ngAfterViewInit` callback is called.
 *
 * ### Example
 *
 * ```
 * @Component({
 *   selector: 'someDir',
 *   templateUrl: 'someTemplate',
 *   directives: [ItemDirective]
 * })
 * class SomeDir {
 *   @ViewChildren(ItemDirective) viewChildren: QueryList<ItemDirective>;
 *
 *   ngAfterViewInit() {
 *     // viewChildren is set
 *   }
 * }
 * ```
 */
var ViewChildrenMetadata = (function (_super) {
    __extends(ViewChildrenMetadata, _super);
    function ViewChildrenMetadata(_selector) {
        return _super.call(this, _selector, { descendants: true }) || this;
    }
    return ViewChildrenMetadata;
}(ViewQueryMetadata));
exports.ViewChildrenMetadata = ViewChildrenMetadata;
/**
 * Configures a view query.
 *
 * View queries are set before the `ngAfterViewInit` callback is called.
 *
 * ### Example
 *
 * ```
 * @Component({
 *   selector: 'someDir',
 *   templateUrl: 'someTemplate',
 *   directives: [ItemDirective]
 * })
 * class SomeDir {
 *   @ViewChild(ItemDirective) viewChild:ItemDirective;
 *
 *   ngAfterViewInit() {
 *     // viewChild is set
 *   }
 * }
 * ```
 */
var ViewChildMetadata = (function (_super) {
    __extends(ViewChildMetadata, _super);
    function ViewChildMetadata(_selector) {
        return _super.call(this, _selector, { descendants: true, first: true }) || this;
    }
    return ViewChildMetadata;
}(ViewQueryMetadata));
exports.ViewChildMetadata = ViewChildMetadata;
//# sourceMappingURL=metadata_di.js.map

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var lang_1 = __webpack_require__(2);
var reflection_1 = __webpack_require__(9);
var metadata_1 = __webpack_require__(7);
var key_1 = __webpack_require__(666);
function makeDecorator(AnnotationCls, chainFn) {
    if (chainFn === void 0) { chainFn = null; }
    function DecoratorFactory(objOrType) {
        var annotationInstance = new AnnotationCls(objOrType);
        if (this instanceof AnnotationCls) {
            return annotationInstance;
        }
        else {
            //var chainAnnotation = isFunction( this ) && this.annotations instanceof Array
            //  ? this.annotations
            //  : [];
            //chainAnnotation.push(annotationInstance);
            if (chainFn) {
                chainFn(TypeDecorator);
            }
            return TypeDecorator;
        }
        function TypeDecorator(cls) {
            /**
             * here we are creating generated name for Services
             * so we can acquire the key for AngularJS DI
             * and we have unique names after mangling our JS
             */
            if (annotationInstance instanceof metadata_1.InjectableMetadata) {
                // set id if it was explicitly provided by user @Injectable('mySvc') otherwise generate
                annotationInstance.id = annotationInstance.id || key_1.globalKeyRegistry.get(cls);
            }
            var annotations = reflection_1.reflector.ownAnnotations(cls);
            annotations = annotations || [];
            annotations.push(annotationInstance);
            reflection_1.reflector.registerAnnotations(annotations, cls);
            return cls;
        }
    }
    DecoratorFactory.prototype = Object.create(AnnotationCls.prototype);
    return DecoratorFactory;
}
exports.makeDecorator = makeDecorator;
function makeParamDecorator(annotationCls, overrideParamDecorator) {
    if (overrideParamDecorator === void 0) { overrideParamDecorator = null; }
    function ParamDecoratorFactory() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        // create new annotation instance with annotation decorator on proto
        var annotationInstance = Object.create(annotationCls.prototype);
        annotationCls.apply(annotationInstance, args);
        if (this instanceof annotationCls) {
            return annotationInstance;
        }
        else {
            //(ParamDecorator as any).annotation = annotationInstance;
            return ParamDecorator;
        }
        /**
         * paramDecorators are 2 dimensional arrays
         * @param cls
         * @param unusedKey
         * @param index
         * @returns {any}
         * @constructor
         */
        function ParamDecorator(cls, unusedKey, index) {
            // this is special behaviour for non constructor param Injection
            if (lang_1.isFunction(overrideParamDecorator) && lang_1.isPresent(unusedKey)) {
                return overrideParamDecorator(annotationInstance, cls, unusedKey, index);
            }
            var parameters = reflection_1.reflector.rawParameters(cls);
            parameters = parameters || [];
            // there might be gaps if some in between parameters do not have annotations.
            // we pad with nulls.
            while (parameters.length <= index) {
                parameters.push(null);
            }
            parameters[index] = parameters[index] || [];
            var annotationsForParam = parameters[index];
            annotationsForParam.push(annotationInstance);
            reflection_1.reflector.registerParameters(parameters, cls);
            return cls;
        }
    }
    ParamDecoratorFactory.prototype = Object.create(annotationCls.prototype);
    return ParamDecoratorFactory;
}
exports.makeParamDecorator = makeParamDecorator;
function makePropDecorator(decoratorCls) {
    function PropDecoratorFactory() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var decoratorInstance = Object.create(decoratorCls.prototype);
        decoratorCls.apply(decoratorInstance, args);
        // check if this decorator was already invoked
        // - if it was return it again, just with newly applied arguments
        // - this is possible thanks to PropDecoratorFactory.prototype = Object.create(decoratorCls.prototype);
        if (this instanceof decoratorCls) {
            return decoratorInstance;
        }
        else {
            return function PropDecorator(target, name) {
                var meta = reflection_1.reflector.ownPropMetadata(target.constructor);
                meta = meta || {};
                meta[name] = meta[name] || [];
                meta[name].unshift(decoratorInstance);
                reflection_1.reflector.registerPropMetadata(meta, target.constructor);
            };
        }
    }
    // caching
    PropDecoratorFactory.prototype = Object.create(decoratorCls.prototype);
    return PropDecoratorFactory;
}
exports.makePropDecorator = makePropDecorator;
//# sourceMappingURL=decorators.js.map

/***/ }),
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {
Object.defineProperty(exports, "__esModule", { value: true });
var ModalControllerBase = (function () {
    function ModalControllerBase($element, promptWindow, options, close) {
        this.$element = $element;
        this.promptWindow = promptWindow;
        this.options = options;
        this.close = close;
        this.onDataChanged = this.onDataChanged.bind(this);
        this.closeWindow = this.closeWindow.bind(this);
        this.model = _.clone(this.options.dataModel);
        this.original = _.clone(this.options.dataModel);
        this.changed = false;
        this.defaultCancelPromptOptions = {
            title: 'EINVOICING.COMPONENTS.NAVIGATION.ABANDON_CHANGES_WARNING.TITLE',
            message: 'EINVOICING.COMPONENTS.NAVIGATION.ABANDON_CHANGES_WARNING.MESSAGE',
            okBtnText: 'CORE.PROMPT.YES',
            cancelBtnText: 'CORE.PROMPT.NO'
        };
    }
    ModalControllerBase.prototype.onDataChanged = function () {
        this.changed = true;
        if (this.options.onDataChanged) {
            this.options.onDataChanged(this.model);
        }
    };
    ModalControllerBase.prototype.onSave = function () {
        this.$element.modal('hide');
        this.close({
            state: 'saved',
            object: this.model
        }, 500);
    };
    ModalControllerBase.prototype.onDelete = function () {
        this.$element.modal('hide');
        this.close({
            state: 'deleted',
            object: this.model
        }, 500);
    };
    ModalControllerBase.prototype.onPrompt = function (action) {
        if (this.options.onPrompt && this.options.onPrompt[action]) {
            this.options.onPrompt[action]();
        }
    };
    ModalControllerBase.prototype.onCancel = function () {
        if (this.options.promptOnCancel && this.changed) {
            this.promptCancel(this.closeWindow);
        }
        else {
            this.closeWindow();
        }
    };
    ModalControllerBase.prototype.closeWindow = function () {
        this.$element.modal('hide');
        this.close({
            state: 'cancelled',
            object: this.original
        }, 500);
    };
    ModalControllerBase.prototype.promptCancel = function (onConfirmed) {
        var options = {
            title: this.options.cancelPromptTitle,
            message: this.options.cancelPromptMessage,
            okBtnText: this.options.cancelPromptOkBtnText,
            cancelBtnText: this.options.cancelPromptCancelBtnText,
            callback: function (result) {
                if (result) {
                    onConfirmed();
                }
            }
        };
        _.defaults(options, this.defaultCancelPromptOptions);
        this.promptWindow.confirm(options);
    };
    return ModalControllerBase;
}());
exports.ModalControllerBase = ModalControllerBase;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(3);
var resource_list_configuration_base_service_1 = __webpack_require__(17);
var ResourceHandlerServiceBase = (function () {
    function ResourceHandlerServiceBase(resourceListConfigurationService) {
        this.resourceListConfigurationService = resourceListConfigurationService;
    }
    ResourceHandlerServiceBase.prototype.init = function (partyId, forPartyId, sortBy) {
        if (sortBy === void 0) { sortBy = 1; }
        var tableOptionsPromise = this.resourceListConfigurationService.getTableOptions();
        var sortOptionsPromise = this.resourceListConfigurationService.getSortOptions();
        var resourcesPromise = this.getResourceBook(partyId, forPartyId, sortBy);
        return [resourcesPromise, tableOptionsPromise, sortOptionsPromise];
    };
    ResourceHandlerServiceBase = __decorate([
        core_1.Injectable(),
        __metadata("design:paramtypes", [resource_list_configuration_base_service_1.ResourceListConfigurationServiceBase])
    ], ResourceHandlerServiceBase);
    return ResourceHandlerServiceBase;
}());
exports.ResourceHandlerServiceBase = ResourceHandlerServiceBase;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(angularLocalStorage) {__webpack_require__(661);
module.exports = 'LocalStorageModule';


/*** EXPORTS FROM exports-loader ***/
module.exports = angularLocalStorage;

/*** EXPORTS FROM exports-loader ***/
module.exports = window.angular;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(25)))

/***/ }),
/* 26 */,
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var metadata_directives_1 = __webpack_require__(8);
/**
 * use #isDirective instead
 * @deprecated
 */
function isAttrDirective(metadata) {
    return metadata instanceof metadata_directives_1.DirectiveMetadata && !(metadata instanceof metadata_directives_1.ComponentMetadata);
}
exports.isAttrDirective = isAttrDirective;
/**
 * use #isComponent instead
 * @deprecated
 */
function isComponentDirective(metadata) {
    return metadata instanceof metadata_directives_1.ComponentMetadata;
}
exports.isComponentDirective = isComponentDirective;
/**
 *
 * @param scope
 * @param element
 * @param ctrl
 * @param implementsNgOnDestroy
 * @param watchersToDispose
 * @param observersToDispose
 * @private
 */
function _setupDestroyHandler(scope, element, ctrl, implementsNgOnDestroy, watchersToDispose, observersToDispose) {
    if (watchersToDispose === void 0) { watchersToDispose = []; }
    if (observersToDispose === void 0) { observersToDispose = []; }
    scope.$on('$destroy', function () {
        if (implementsNgOnDestroy) {
            ctrl.ngOnDestroy();
        }
        watchersToDispose.forEach(function (_watcherDispose) { return _watcherDispose(); });
        observersToDispose.forEach(function (_observerDispose) { return _observerDispose(); });
    });
}
exports._setupDestroyHandler = _setupDestroyHandler;
//# sourceMappingURL=directives_utils.js.map

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LifecycleHooks;
(function (LifecycleHooks) {
    LifecycleHooks[LifecycleHooks["OnInit"] = 0] = "OnInit";
    LifecycleHooks[LifecycleHooks["OnDestroy"] = 1] = "OnDestroy";
    LifecycleHooks[LifecycleHooks["DoCheck"] = 2] = "DoCheck";
    LifecycleHooks[LifecycleHooks["OnChanges"] = 3] = "OnChanges";
    LifecycleHooks[LifecycleHooks["AfterContentInit"] = 4] = "AfterContentInit";
    LifecycleHooks[LifecycleHooks["AfterContentChecked"] = 5] = "AfterContentChecked";
    LifecycleHooks[LifecycleHooks["AfterViewInit"] = 6] = "AfterViewInit";
    LifecycleHooks[LifecycleHooks["AfterViewChecked"] = 7] = "AfterViewChecked";
    LifecycleHooks[LifecycleHooks["_OnChildrenChanged"] = 8] = "_OnChildrenChanged";
})(LifecycleHooks = exports.LifecycleHooks || (exports.LifecycleHooks = {}));
/**
 * @internal
 */
exports.LIFECYCLE_HOOKS_VALUES = [
    LifecycleHooks.OnInit,
    LifecycleHooks.OnDestroy,
    LifecycleHooks.DoCheck,
    LifecycleHooks.OnChanges,
    LifecycleHooks.AfterContentInit,
    LifecycleHooks.AfterContentChecked,
    LifecycleHooks.AfterViewInit,
    LifecycleHooks.AfterViewChecked,
    LifecycleHooks._OnChildrenChanged
];
var ChildrenChangeHook;
(function (ChildrenChangeHook) {
    ChildrenChangeHook[ChildrenChangeHook["FromView"] = 0] = "FromView";
    ChildrenChangeHook[ChildrenChangeHook["FromContent"] = 1] = "FromContent";
})(ChildrenChangeHook = exports.ChildrenChangeHook || (exports.ChildrenChangeHook = {}));
//# sourceMappingURL=directive_lifecycle_interfaces.js.map

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = __webpack_require__(2);
var metadata_1 = __webpack_require__(7);
/**
 * Declare reusable pipe function.
 *
 * A "pure" pipe is only re-evaluated when either the input or any of the arguments change.
 *
 * When not specified, pipes default to being pure.
 *
 * ### Example
 *
 * {@example core/ts/metadata/metadata.ts region='pipe'}
 */
var PipeMetadata = (function (_super) {
    __extends(PipeMetadata, _super);
    function PipeMetadata(_a) {
        var name = _a.name, pure = _a.pure;
        var _this = _super.call(this) || this;
        _this.name = name;
        _this._pure = pure;
        return _this;
    }
    Object.defineProperty(PipeMetadata.prototype, "pure", {
        get: function () { return lang_1.isPresent(this._pure) ? this._pure : true; },
        enumerable: true,
        configurable: true
    });
    return PipeMetadata;
}(metadata_1.InjectableMetadata));
exports.PipeMetadata = PipeMetadata;
//# sourceMappingURL=metadata.js.map

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isArray_1 = __webpack_require__(696);
var isObject_1 = __webpack_require__(697);
var isFunction_1 = __webpack_require__(66);
var tryCatch_1 = __webpack_require__(699);
var errorObject_1 = __webpack_require__(65);
var UnsubscriptionError_1 = __webpack_require__(695);
/**
 * Represents a disposable resource, such as the execution of an Observable. A
 * Subscription has one important method, `unsubscribe`, that takes no argument
 * and just disposes the resource held by the subscription.
 *
 * Additionally, subscriptions may be grouped together through the `add()`
 * method, which will attach a child Subscription to the current Subscription.
 * When a Subscription is unsubscribed, all its children (and its grandchildren)
 * will be unsubscribed as well.
 *
 * @class Subscription
 */
var Subscription = (function () {
    /**
     * @param {function(): void} [unsubscribe] A function describing how to
     * perform the disposal of resources when the `unsubscribe` method is called.
     */
    function Subscription(unsubscribe) {
        /**
         * A flag to indicate whether this Subscription has already been unsubscribed.
         * @type {boolean}
         */
        this.closed = false;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    /**
     * Disposes the resources held by the subscription. May, for instance, cancel
     * an ongoing Observable execution or cancel any other type of work that
     * started when the Subscription was created.
     * @return {void}
     */
    Subscription.prototype.unsubscribe = function () {
        var hasErrors = false;
        var errors;
        if (this.closed) {
            return;
        }
        this.closed = true;
        var _a = this, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this._subscriptions = null;
        if (isFunction_1.isFunction(_unsubscribe)) {
            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
            if (trial === errorObject_1.errorObject) {
                hasErrors = true;
                (errors = errors || []).push(errorObject_1.errorObject.e);
            }
        }
        if (isArray_1.isArray(_subscriptions)) {
            var index = -1;
            var len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
                    if (trial === errorObject_1.errorObject) {
                        hasErrors = true;
                        errors = errors || [];
                        var err = errorObject_1.errorObject.e;
                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                            errors = errors.concat(err.errors);
                        }
                        else {
                            errors.push(err);
                        }
                    }
                }
            }
        }
        if (hasErrors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
    };
    /**
     * Adds a tear down to be called during the unsubscribe() of this
     * Subscription.
     *
     * If the tear down being added is a subscription that is already
     * unsubscribed, is the same reference `add` is being called on, or is
     * `Subscription.EMPTY`, it will not be added.
     *
     * If this subscription is already in an `closed` state, the passed
     * tear down logic will be executed immediately.
     *
     * @param {TeardownLogic} teardown The additional logic to execute on
     * teardown.
     * @return {Subscription} Returns the Subscription used or created to be
     * added to the inner subscriptions list. This Subscription can be used with
     * `remove()` to remove the passed teardown logic from the inner subscriptions
     * list.
     */
    Subscription.prototype.add = function (teardown) {
        if (!teardown || (teardown === Subscription.EMPTY)) {
            return Subscription.EMPTY;
        }
        if (teardown === this) {
            return this;
        }
        var sub = teardown;
        switch (typeof teardown) {
            case 'function':
                sub = new Subscription(teardown);
            case 'object':
                if (sub.closed || typeof sub.unsubscribe !== 'function') {
                    break;
                }
                else if (this.closed) {
                    sub.unsubscribe();
                }
                else {
                    (this._subscriptions || (this._subscriptions = [])).push(sub);
                }
                break;
            default:
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
        return sub;
    };
    /**
     * Removes a Subscription from the internal list of subscriptions that will
     * unsubscribe during the unsubscribe process of this Subscription.
     * @param {Subscription} subscription The subscription to remove.
     * @return {void}
     */
    Subscription.prototype.remove = function (subscription) {
        // HACK: This might be redundant because of the logic in `add()`
        if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {
            return;
        }
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
exports.Subscription = Subscription;
//# sourceMappingURL=Subscription.js.map

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(32);
var Symbol = root_1.root.Symbol;
exports.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
    Symbol.for('rxSubscriber') : '@@rxSubscriber';
//# sourceMappingURL=rxSubscriber.js.map

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
/**
 * window: browser in DOM main thread
 * self: browser in WebWorker
 * global: Node.js/other
 */
exports.root = (typeof window == 'object' && window.window === window && window
    || typeof self == 'object' && self.self === self && self
    || typeof global == 'object' && global.global === global && global);
if (!exports.root) {
    throw new Error('RxJS could not find any global context (window, self, global)');
}
//# sourceMappingURL=root.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(20)))

/***/ }),
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(3);
var modal_base_controller_1 = __webpack_require__(23);
var AddPartyComponentController = (function (_super) {
    __extends(AddPartyComponentController, _super);
    function AddPartyComponentController($element, promptWindow, options, close) {
        var _this = _super.call(this, $element, promptWindow, options, close) || this;
        _this.partyId = options.partyId;
        _this.saveButtonText = options.saveButtonText;
        _this.title = options.modalTitle;
        return _this;
    }
    AddPartyComponentController.prototype.tradingPartyIdChanged = function (tradingPartyId) {
        this.model = tradingPartyId;
    };
    AddPartyComponentController = __decorate([
        core_1.Injectable(),
        __param(0, core_1.Inject('$element')),
        __param(1, core_1.Inject('promptWindow')),
        __param(2, core_1.Inject('options')),
        __param(3, core_1.Inject('close')),
        __metadata("design:paramtypes", [Object, Object, Object, Object])
    ], AddPartyComponentController);
    return AddPartyComponentController;
}(modal_base_controller_1.ModalControllerBase));
exports.AddPartyComponentController = AddPartyComponentController;
AddPartyComponentController.prototype.constructor.$inject = ['$element', 'promptWindow', 'options', 'close'];


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(82));
__export(__webpack_require__(83));


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(92));
__export(__webpack_require__(93));


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var resource_list_configuration_base_service_1 = __webpack_require__(17);
var core_1 = __webpack_require__(3);
var PartyCodeConfigurationService = (function (_super) {
    __extends(PartyCodeConfigurationService, _super);
    function PartyCodeConfigurationService() {
        var _this = _super.call(this) || this;
        _this._sortOptions = [];
        _this._columns = [];
        _this._actionColumns = [];
        return _this;
    }
    PartyCodeConfigurationService.prototype.getSortOptions = function () {
        return Promise.resolve(this._sortOptions);
    };
    PartyCodeConfigurationService.prototype.getTableOptions = function () {
        var tableOptions = _super.prototype.tableOptions.call(this);
        tableOptions.columns = this._columns;
        tableOptions.actionColumns = this._actionColumns;
        return Promise.resolve(tableOptions);
    };
    PartyCodeConfigurationService = __decorate([
        core_1.Injectable(),
        __metadata("design:paramtypes", [])
    ], PartyCodeConfigurationService);
    return PartyCodeConfigurationService;
}(resource_list_configuration_base_service_1.ResourceListConfigurationServiceBase));
exports.PartyCodeConfigurationService = PartyCodeConfigurationService;


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(3);
var resource_handler_base_service_1 = __webpack_require__(24);
var party_code_configuration_service_1 = __webpack_require__(49);
var PartyCodeHandlerService = (function (_super) {
    __extends(PartyCodeHandlerService, _super);
    function PartyCodeHandlerService(partyProxy, partyCodeConfigurationService) {
        var _this = _super.call(this, partyCodeConfigurationService) || this;
        _this.partyProxy = partyProxy;
        _this.partyCodeConfigurationService = partyCodeConfigurationService;
        _this.type = "partyCode";
        return _this;
    }
    PartyCodeHandlerService.prototype.getResourceBook = function (partyId, forPartyId, sortBy) {
        return this.partyProxy.getPartyCodesForParty(partyId);
    };
    PartyCodeHandlerService.prototype.updateResource = function (resouce, resourceId) {
        return this.partyProxy.updatePartyCode(resouce);
    };
    PartyCodeHandlerService.prototype.addNewResource = function (resource, forPartyId) {
        var partyId = resource.partyId;
        return this.partyProxy.addNewPartyCode(partyId, resource);
    };
    PartyCodeHandlerService.prototype.removeResource = function (resource, resourceId) {
    };
    PartyCodeHandlerService = __decorate([
        core_1.Injectable(),
        __param(0, core_1.Inject('partyProxy')),
        __param(1, core_1.Inject('partyCodeConfigurationService')),
        __metadata("design:paramtypes", [Object, party_code_configuration_service_1.PartyCodeConfigurationService])
    ], PartyCodeHandlerService);
    return PartyCodeHandlerService;
}(resource_handler_base_service_1.ResourceHandlerServiceBase));
exports.PartyCodeHandlerService = PartyCodeHandlerService;
PartyCodeHandlerService.prototype.constructor.$inject = ['partyProxy', 'partyCodeConfigurationService'];


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//{CODE:CGU09}
// di.core.global.utility.placeholders.arguments
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(12)], __WEBPACK_AMD_DEFINE_RESULT__ = function (guard) {
    'use strict';

    window.$di.utility.placeholders.arguments.map = map;

    return window.$di.utility.placeholders.arguments.map;

    /**
     * Maps arguments to pre-defined placeholders.
     * @param targets
     * @param args
     */
    function map(targets, args) {
        guard.throwIfNullOrUndefined("CGU0901E", targets, "targets");
        guard.throwIfNullOrUndefined("CGU0902E", args, "args");

        var mapped = {};
        var unmapped = [];

        // try to map named arguments first
        for (var i = 0; i < args.length; i++) {
            try {
                var obj = eval('(' + args[i] + ')');
                if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === _typeof({})) {
                    for (var arg in obj) {
                        mapped[arg] = obj[arg];
                    }
                } else if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === _typeof('')) {
                    mapped[arg] = obj;
                } else {
                    throw obj;
                }
            } catch (error) {
                unmapped.unshift(args[i]);
            }
        }

        // map any unmapped arguments in the order that they are found in
        for (i = 0; i < targets.length; i++) {
            if (mapped[targets[i]] === undefined) {
                var popped = unmapped.pop();
                // assigns the key as the value if it's still undefined
                if (popped === undefined) {
                    var s = targets[i];
                    s = s.replace(/\./g, '_');
                    mapped[s] = targets[i];
                } else {
                    mapped[targets[i]] = popped;
                }
            }
        }

        return mapped;
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CGU05}
// di.core.global.utility
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(12)], __WEBPACK_AMD_DEFINE_RESULT__ = function (guard) {
    'use strict';

    var _pattern = /<%=([\s.a-zA-Z0-9]+)%>/g;

    window.$di.utility.placeholders.extract = extract;

    return window.$di.utility.placeholders.extract;

    /**
     * Extracts a collection of placeholders in the format of <%= xxx %> from the target string
     * @param placeholderString
     */
    function extract(placeholderString) {
        guard.throwIfNotAString("CGU0501E", placeholderString, "placeholderString");
        var matches = _pattern.exec(placeholderString);
        var ms = [];

        while (matches != null) {
            for (var i = 1; i < matches.length; i++) {
                ms.push(matches[i].trim());
            }

            matches = _pattern.exec(placeholderString);
        }

        return ms;
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(angularUiRouter) {/**
 * State-based routing for AngularJS
 * @version v0.4.2
 * @link http://angular-ui.github.com/
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */

/* commonjs package manager support (eg componentjs) */
if (typeof module !== "undefined" && typeof exports !== "undefined" && module.exports === exports){
  module.exports = 'ui.router';
}

(function (window, angular, undefined) {
/*jshint globalstrict:true*/
/*global angular:false*/
'use strict';

var isDefined = angular.isDefined,
    isFunction = angular.isFunction,
    isString = angular.isString,
    isObject = angular.isObject,
    isArray = angular.isArray,
    forEach = angular.forEach,
    extend = angular.extend,
    copy = angular.copy,
    toJson = angular.toJson;

function inherit(parent, extra) {
  return extend(new (extend(function() {}, { prototype: parent }))(), extra);
}

function merge(dst) {
  forEach(arguments, function(obj) {
    if (obj !== dst) {
      forEach(obj, function(value, key) {
        if (!dst.hasOwnProperty(key)) dst[key] = value;
      });
    }
  });
  return dst;
}

/**
 * Finds the common ancestor path between two states.
 *
 * @param {Object} first The first state.
 * @param {Object} second The second state.
 * @return {Array} Returns an array of state names in descending order, not including the root.
 */
function ancestors(first, second) {
  var path = [];

  for (var n in first.path) {
    if (first.path[n] !== second.path[n]) break;
    path.push(first.path[n]);
  }
  return path;
}

/**
 * IE8-safe wrapper for `Object.keys()`.
 *
 * @param {Object} object A JavaScript object.
 * @return {Array} Returns the keys of the object as an array.
 */
function objectKeys(object) {
  if (Object.keys) {
    return Object.keys(object);
  }
  var result = [];

  forEach(object, function(val, key) {
    result.push(key);
  });
  return result;
}

/**
 * IE8-safe wrapper for `Array.prototype.indexOf()`.
 *
 * @param {Array} array A JavaScript array.
 * @param {*} value A value to search the array for.
 * @return {Number} Returns the array index value of `value`, or `-1` if not present.
 */
function indexOf(array, value) {
  if (Array.prototype.indexOf) {
    return array.indexOf(value, Number(arguments[2]) || 0);
  }
  var len = array.length >>> 0, from = Number(arguments[2]) || 0;
  from = (from < 0) ? Math.ceil(from) : Math.floor(from);

  if (from < 0) from += len;

  for (; from < len; from++) {
    if (from in array && array[from] === value) return from;
  }
  return -1;
}

/**
 * Merges a set of parameters with all parameters inherited between the common parents of the
 * current state and a given destination state.
 *
 * @param {Object} currentParams The value of the current state parameters ($stateParams).
 * @param {Object} newParams The set of parameters which will be composited with inherited params.
 * @param {Object} $current Internal definition of object representing the current state.
 * @param {Object} $to Internal definition of object representing state to transition to.
 */
function inheritParams(currentParams, newParams, $current, $to) {
  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];

  for (var i in parents) {
    if (!parents[i] || !parents[i].params) continue;
    parentParams = objectKeys(parents[i].params);
    if (!parentParams.length) continue;

    for (var j in parentParams) {
      if (indexOf(inheritList, parentParams[j]) >= 0) continue;
      inheritList.push(parentParams[j]);
      inherited[parentParams[j]] = currentParams[parentParams[j]];
    }
  }
  return extend({}, inherited, newParams);
}

/**
 * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.
 *
 * @param {Object} a The first object.
 * @param {Object} b The second object.
 * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,
 *                     it defaults to the list of keys in `a`.
 * @return {Boolean} Returns `true` if the keys match, otherwise `false`.
 */
function equalForKeys(a, b, keys) {
  if (!keys) {
    keys = [];
    for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility
  }

  for (var i=0; i<keys.length; i++) {
    var k = keys[i];
    if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized
  }
  return true;
}

/**
 * Returns the subset of an object, based on a list of keys.
 *
 * @param {Array} keys
 * @param {Object} values
 * @return {Boolean} Returns a subset of `values`.
 */
function filterByKeys(keys, values) {
  var filtered = {};

  forEach(keys, function (name) {
    filtered[name] = values[name];
  });
  return filtered;
}

// like _.indexBy
// when you know that your index values will be unique, or you want last-one-in to win
function indexBy(array, propName) {
  var result = {};
  forEach(array, function(item) {
    result[item[propName]] = item;
  });
  return result;
}

// extracted from underscore.js
// Return a copy of the object only containing the whitelisted properties.
function pick(obj) {
  var copy = {};
  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
  forEach(keys, function(key) {
    if (key in obj) copy[key] = obj[key];
  });
  return copy;
}

// extracted from underscore.js
// Return a copy of the object omitting the blacklisted properties.
function omit(obj) {
  var copy = {};
  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
  for (var key in obj) {
    if (indexOf(keys, key) == -1) copy[key] = obj[key];
  }
  return copy;
}

function pluck(collection, key) {
  var result = isArray(collection) ? [] : {};

  forEach(collection, function(val, i) {
    result[i] = isFunction(key) ? key(val) : val[key];
  });
  return result;
}

function filter(collection, callback) {
  var array = isArray(collection);
  var result = array ? [] : {};
  forEach(collection, function(val, i) {
    if (callback(val, i)) {
      result[array ? result.length : i] = val;
    }
  });
  return result;
}

function map(collection, callback) {
  var result = isArray(collection) ? [] : {};

  forEach(collection, function(val, i) {
    result[i] = callback(val, i);
  });
  return result;
}

// issue #2676 #2889
function silenceUncaughtInPromise (promise) {
  return promise.then(undefined, function() {}) && promise;
}

/**
 * @ngdoc overview
 * @name ui.router.util
 *
 * @description
 * # ui.router.util sub-module
 *
 * This module is a dependency of other sub-modules. Do not include this module as a dependency
 * in your angular app (use {@link ui.router} module instead).
 *
 */
angular.module('ui.router.util', ['ng']);

/**
 * @ngdoc overview
 * @name ui.router.router
 * 
 * @requires ui.router.util
 *
 * @description
 * # ui.router.router sub-module
 *
 * This module is a dependency of other sub-modules. Do not include this module as a dependency
 * in your angular app (use {@link ui.router} module instead).
 */
angular.module('ui.router.router', ['ui.router.util']);

/**
 * @ngdoc overview
 * @name ui.router.state
 * 
 * @requires ui.router.router
 * @requires ui.router.util
 *
 * @description
 * # ui.router.state sub-module
 *
 * This module is a dependency of the main ui.router module. Do not include this module as a dependency
 * in your angular app (use {@link ui.router} module instead).
 * 
 */
angular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);

/**
 * @ngdoc overview
 * @name ui.router
 *
 * @requires ui.router.state
 *
 * @description
 * # ui.router
 * 
 * ## The main module for ui.router 
 * There are several sub-modules included with the ui.router module, however only this module is needed
 * as a dependency within your angular app. The other modules are for organization purposes. 
 *
 * The modules are:
 * * ui.router - the main "umbrella" module
 * * ui.router.router - 
 * 
 * *You'll need to include **only** this module as the dependency within your angular app.*
 * 
 * <pre>
 * <!doctype html>
 * <html ng-app="myApp">
 * <head>
 *   <script src="js/angular.js"></script>
 *   <!-- Include the ui-router script -->
 *   <script src="js/angular-ui-router.min.js"></script>
 *   <script>
 *     // ...and add 'ui.router' as a dependency
 *     var myApp = angular.module('myApp', ['ui.router']);
 *   </script>
 * </head>
 * <body>
 * </body>
 * </html>
 * </pre>
 */
angular.module('ui.router', ['ui.router.state']);

angular.module('ui.router.compat', ['ui.router']);

/**
 * @ngdoc object
 * @name ui.router.util.$resolve
 *
 * @requires $q
 * @requires $injector
 *
 * @description
 * Manages resolution of (acyclic) graphs of promises.
 */
$Resolve.$inject = ['$q', '$injector'];
function $Resolve(  $q,    $injector) {
  
  var VISIT_IN_PROGRESS = 1,
      VISIT_DONE = 2,
      NOTHING = {},
      NO_DEPENDENCIES = [],
      NO_LOCALS = NOTHING,
      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });
  

  /**
   * @ngdoc function
   * @name ui.router.util.$resolve#study
   * @methodOf ui.router.util.$resolve
   *
   * @description
   * Studies a set of invocables that are likely to be used multiple times.
   * <pre>
   * $resolve.study(invocables)(locals, parent, self)
   * </pre>
   * is equivalent to
   * <pre>
   * $resolve.resolve(invocables, locals, parent, self)
   * </pre>
   * but the former is more efficient (in fact `resolve` just calls `study` 
   * internally).
   *
   * @param {object} invocables Invocable objects
   * @return {function} a function to pass in locals, parent and self
   */
  this.study = function (invocables) {
    if (!isObject(invocables)) throw new Error("'invocables' must be an object");
    var invocableKeys = objectKeys(invocables || {});
    
    // Perform a topological sort of invocables to build an ordered plan
    var plan = [], cycle = [], visited = {};
    function visit(value, key) {
      if (visited[key] === VISIT_DONE) return;
      
      cycle.push(key);
      if (visited[key] === VISIT_IN_PROGRESS) {
        cycle.splice(0, indexOf(cycle, key));
        throw new Error("Cyclic dependency: " + cycle.join(" -> "));
      }
      visited[key] = VISIT_IN_PROGRESS;
      
      if (isString(value)) {
        plan.push(key, [ function() { return $injector.get(value); }], NO_DEPENDENCIES);
      } else {
        var params = $injector.annotate(value);
        forEach(params, function (param) {
          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);
        });
        plan.push(key, value, params);
      }
      
      cycle.pop();
      visited[key] = VISIT_DONE;
    }
    forEach(invocables, visit);
    invocables = cycle = visited = null; // plan is all that's required
    
    function isResolve(value) {
      return isObject(value) && value.then && value.$$promises;
    }
    
    return function (locals, parent, self) {
      if (isResolve(locals) && self === undefined) {
        self = parent; parent = locals; locals = null;
      }
      if (!locals) locals = NO_LOCALS;
      else if (!isObject(locals)) {
        throw new Error("'locals' must be an object");
      }       
      if (!parent) parent = NO_PARENT;
      else if (!isResolve(parent)) {
        throw new Error("'parent' must be a promise returned by $resolve.resolve()");
      }
      
      // To complete the overall resolution, we have to wait for the parent
      // promise and for the promise for each invokable in our plan.
      var resolution = $q.defer(),
          result = silenceUncaughtInPromise(resolution.promise),
          promises = result.$$promises = {},
          values = extend({}, locals),
          wait = 1 + plan.length/3,
          merged = false;

      silenceUncaughtInPromise(result);
          
      function done() {
        // Merge parent values we haven't got yet and publish our own $$values
        if (!--wait) {
          if (!merged) merge(values, parent.$$values); 
          result.$$values = values;
          result.$$promises = result.$$promises || true; // keep for isResolve()
          delete result.$$inheritedValues;
          resolution.resolve(values);
        }
      }
      
      function fail(reason) {
        result.$$failure = reason;
        resolution.reject(reason);
      }

      // Short-circuit if parent has already failed
      if (isDefined(parent.$$failure)) {
        fail(parent.$$failure);
        return result;
      }
      
      if (parent.$$inheritedValues) {
        merge(values, omit(parent.$$inheritedValues, invocableKeys));
      }

      // Merge parent values if the parent has already resolved, or merge
      // parent promises and wait if the parent resolve is still in progress.
      extend(promises, parent.$$promises);
      if (parent.$$values) {
        merged = merge(values, omit(parent.$$values, invocableKeys));
        result.$$inheritedValues = omit(parent.$$values, invocableKeys);
        done();
      } else {
        if (parent.$$inheritedValues) {
          result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);
        }        
        parent.then(done, fail);
      }
      
      // Process each invocable in the plan, but ignore any where a local of the same name exists.
      for (var i=0, ii=plan.length; i<ii; i+=3) {
        if (locals.hasOwnProperty(plan[i])) done();
        else invoke(plan[i], plan[i+1], plan[i+2]);
      }
      
      function invoke(key, invocable, params) {
        // Create a deferred for this invocation. Failures will propagate to the resolution as well.
        var invocation = $q.defer(), waitParams = 0;
        function onfailure(reason) {
          invocation.reject(reason);
          fail(reason);
        }
        // Wait for any parameter that we have a promise for (either from parent or from this
        // resolve; in that case study() will have made sure it's ordered before us in the plan).
        forEach(params, function (dep) {
          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {
            waitParams++;
            promises[dep].then(function (result) {
              values[dep] = result;
              if (!(--waitParams)) proceed();
            }, onfailure);
          }
        });
        if (!waitParams) proceed();
        function proceed() {
          if (isDefined(result.$$failure)) return;
          try {
            invocation.resolve($injector.invoke(invocable, self, values));
            invocation.promise.then(function (result) {
              values[key] = result;
              done();
            }, onfailure);
          } catch (e) {
            onfailure(e);
          }
        }
        // Publish promise synchronously; invocations further down in the plan may depend on it.
        promises[key] = silenceUncaughtInPromise(invocation.promise);
      }
      
      return result;
    };
  };
  
  /**
   * @ngdoc function
   * @name ui.router.util.$resolve#resolve
   * @methodOf ui.router.util.$resolve
   *
   * @description
   * Resolves a set of invocables. An invocable is a function to be invoked via 
   * `$injector.invoke()`, and can have an arbitrary number of dependencies. 
   * An invocable can either return a value directly,
   * or a `$q` promise. If a promise is returned it will be resolved and the 
   * resulting value will be used instead. Dependencies of invocables are resolved 
   * (in this order of precedence)
   *
   * - from the specified `locals`
   * - from another invocable that is part of this `$resolve` call
   * - from an invocable that is inherited from a `parent` call to `$resolve` 
   *   (or recursively
   * - from any ancestor `$resolve` of that parent).
   *
   * The return value of `$resolve` is a promise for an object that contains 
   * (in this order of precedence)
   *
   * - any `locals` (if specified)
   * - the resolved return values of all injectables
   * - any values inherited from a `parent` call to `$resolve` (if specified)
   *
   * The promise will resolve after the `parent` promise (if any) and all promises 
   * returned by injectables have been resolved. If any invocable 
   * (or `$injector.invoke`) throws an exception, or if a promise returned by an 
   * invocable is rejected, the `$resolve` promise is immediately rejected with the 
   * same error. A rejection of a `parent` promise (if specified) will likewise be 
   * propagated immediately. Once the `$resolve` promise has been rejected, no 
   * further invocables will be called.
   * 
   * Cyclic dependencies between invocables are not permitted and will cause `$resolve`
   * to throw an error. As a special case, an injectable can depend on a parameter 
   * with the same name as the injectable, which will be fulfilled from the `parent` 
   * injectable of the same name. This allows inherited values to be decorated. 
   * Note that in this case any other injectable in the same `$resolve` with the same
   * dependency would see the decorated value, not the inherited value.
   *
   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an 
   * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) 
   * exception.
   *
   * Invocables are invoked eagerly as soon as all dependencies are available. 
   * This is true even for dependencies inherited from a `parent` call to `$resolve`.
   *
   * As a special case, an invocable can be a string, in which case it is taken to 
   * be a service name to be passed to `$injector.get()`. This is supported primarily 
   * for backwards-compatibility with the `resolve` property of `$routeProvider` 
   * routes.
   *
   * @param {object} invocables functions to invoke or 
   * `$injector` services to fetch.
   * @param {object} locals  values to make available to the injectables
   * @param {object} parent  a promise returned by another call to `$resolve`.
   * @param {object} self  the `this` for the invoked methods
   * @return {object} Promise for an object that contains the resolved return value
   * of all invocables, as well as any inherited and local values.
   */
  this.resolve = function (invocables, locals, parent, self) {
    return this.study(invocables)(locals, parent, self);
  };
}

angular.module('ui.router.util').service('$resolve', $Resolve);



/**
 * @ngdoc object
 * @name ui.router.util.$templateFactoryProvider
 *
 * @description
 * Provider for $templateFactory. Manages which template-loading mechanism to
 * use, and will default to the most recent one ($templateRequest on Angular
 * versions starting from 1.3, $http otherwise).
 */
function TemplateFactoryProvider() {
  var shouldUnsafelyUseHttp = angular.version.minor < 3;

  /**
   * @ngdoc function
   * @name ui.router.util.$templateFactoryProvider#shouldUnsafelyUseHttp
   * @methodOf ui.router.util.$templateFactoryProvider
   *
   * @description
   * Forces $templateFactory to use $http instead of $templateRequest. This
   * might cause XSS, as $http doesn't enforce the regular security checks for
   * templates that have been introduced in Angular 1.3. Note that setting this
   * to false on Angular older than 1.3.x will crash, as the $templateRequest
   * service (and the security checks) are not implemented on these versions.
   *
   * See the $sce documentation, section
   * <a href="https://docs.angularjs.org/api/ng/service/$sce#impact-on-loading-templates">
   * Impact on loading templates</a> for more details about this mechanism.
   *
   * @param {boolean} value
   */
  this.shouldUnsafelyUseHttp = function(value) {
    shouldUnsafelyUseHttp = !!value;
  };

  /**
   * @ngdoc object
   * @name ui.router.util.$templateFactory
   *
   * @requires $http
   * @requires $templateCache
   * @requires $injector
   *
   * @description
   * Service. Manages loading of templates.
   */
  this.$get = ['$http', '$templateCache', '$injector', function($http, $templateCache, $injector){
    return new TemplateFactory($http, $templateCache, $injector, shouldUnsafelyUseHttp);}];
}


/**
 * @ngdoc object
 * @name ui.router.util.$templateFactory
 *
 * @requires $http
 * @requires $templateCache
 * @requires $injector
 *
 * @description
 * Service. Manages loading of templates.
 */
function TemplateFactory($http, $templateCache, $injector, shouldUnsafelyUseHttp) {

  /**
   * @ngdoc function
   * @name ui.router.util.$templateFactory#fromConfig
   * @methodOf ui.router.util.$templateFactory
   *
   * @description
   * Creates a template from a configuration object. 
   *
   * @param {object} config Configuration object for which to load a template. 
   * The following properties are search in the specified order, and the first one 
   * that is defined is used to create the template:
   *
   * @param {string|object} config.template html string template or function to 
   * load via {@link ui.router.util.$templateFactory#fromString fromString}.
   * @param {string|object} config.templateUrl url to load or a function returning 
   * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.
   * @param {Function} config.templateProvider function to invoke via 
   * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.
   * @param {object} params  Parameters to pass to the template function.
   * @param {object} locals Locals to pass to `invoke` if the template is loaded 
   * via a `templateProvider`. Defaults to `{ params: params }`.
   *
   * @return {string|object}  The template html as a string, or a promise for 
   * that string,or `null` if no template is configured.
   */
  this.fromConfig = function (config, params, locals) {
    return (
      isDefined(config.template) ? this.fromString(config.template, params) :
      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :
      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :
      null
    );
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$templateFactory#fromString
   * @methodOf ui.router.util.$templateFactory
   *
   * @description
   * Creates a template from a string or a function returning a string.
   *
   * @param {string|object} template html template as a string or function that 
   * returns an html template as a string.
   * @param {object} params Parameters to pass to the template function.
   *
   * @return {string|object} The template html as a string, or a promise for that 
   * string.
   */
  this.fromString = function (template, params) {
    return isFunction(template) ? template(params) : template;
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$templateFactory#fromUrl
   * @methodOf ui.router.util.$templateFactory
   * 
   * @description
   * Loads a template from the a URL via `$http` and `$templateCache`.
   *
   * @param {string|Function} url url of the template to load, or a function 
   * that returns a url.
   * @param {Object} params Parameters to pass to the url function.
   * @return {string|Promise.<string>} The template html as a string, or a promise 
   * for that string.
   */
  this.fromUrl = function (url, params) {
    if (isFunction(url)) url = url(params);
    if (url == null) return null;
    else {
      if(!shouldUnsafelyUseHttp) {
        return $injector.get('$templateRequest')(url);
      } else {
        return $http
          .get(url, { cache: $templateCache, headers: { Accept: 'text/html' }})
          .then(function(response) { return response.data; });
      }
    }
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$templateFactory#fromProvider
   * @methodOf ui.router.util.$templateFactory
   *
   * @description
   * Creates a template by invoking an injectable provider function.
   *
   * @param {Function} provider Function to invoke via `$injector.invoke`
   * @param {Object} params Parameters for the template.
   * @param {Object} locals Locals to pass to `invoke`. Defaults to 
   * `{ params: params }`.
   * @return {string|Promise.<string>} The template html as a string, or a promise 
   * for that string.
   */
  this.fromProvider = function (provider, params, locals) {
    return $injector.invoke(provider, null, locals || { params: params });
  };
}

angular.module('ui.router.util').provider('$templateFactory', TemplateFactoryProvider);

var $$UMFP; // reference to $UrlMatcherFactoryProvider

/**
 * @ngdoc object
 * @name ui.router.util.type:UrlMatcher
 *
 * @description
 * Matches URLs against patterns and extracts named parameters from the path or the search
 * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list
 * of search parameters. Multiple search parameter names are separated by '&'. Search parameters
 * do not influence whether or not a URL is matched, but their values are passed through into
 * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.
 *
 * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace
 * syntax, which optionally allows a regular expression for the parameter to be specified:
 *
 * * `':'` name - colon placeholder
 * * `'*'` name - catch-all placeholder
 * * `'{' name '}'` - curly placeholder
 * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the
 *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.
 *
 * Parameter names may contain only word characters (latin letters, digits, and underscore) and
 * must be unique within the pattern (across both path and search parameters). For colon
 * placeholders or curly placeholders without an explicit regexp, a path parameter matches any
 * number of characters other than '/'. For catch-all placeholders the path parameter matches
 * any number of characters.
 *
 * Examples:
 *
 * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for
 *   trailing slashes, and patterns have to match the entire path, not just a prefix.
 * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or
 *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.
 * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.
 * * `'/user/{id:[^/]*}'` - Same as the previous example.
 * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id
 *   parameter consists of 1 to 8 hex digits.
 * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the
 *   path into the parameter 'path'.
 * * `'/files/*path'` - ditto.
 * * `'/calendar/{start:date}'` - Matches "/calendar/2014-11-12" (because the pattern defined
 *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start
 *
 * @param {string} pattern  The pattern to compile into a matcher.
 * @param {Object} config  A configuration object hash:
 * @param {Object=} parentMatcher Used to concatenate the pattern/config onto
 *   an existing UrlMatcher
 *
 * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.
 * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.
 *
 * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any
 *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns
 *   non-null) will start with this prefix.
 *
 * @property {string} source  The pattern that was passed into the constructor
 *
 * @property {string} sourcePath  The path portion of the source property
 *
 * @property {string} sourceSearch  The search portion of the source property
 *
 * @property {string} regex  The constructed regex that will be used to match against the url when
 *   it is time to determine which url will match.
 *
 * @returns {Object}  New `UrlMatcher` object
 */
function UrlMatcher(pattern, config, parentMatcher) {
  config = extend({ params: {} }, isObject(config) ? config : {});

  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:
  //   '*' name
  //   ':' name
  //   '{' name '}'
  //   '{' name ':' regexp '}'
  // The regular expression is somewhat complicated due to the need to allow curly braces
  // inside the regular expression. The placeholder regexp breaks down as follows:
  //    ([:*])([\w\[\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)
  //    \{([\w\[\]]+)(?:\:\s*( ... ))?\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case
  //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either
  //    [^{}\\]+                       - anything other than curly braces or backslash
  //    \\.                            - a backslash escape
  //    \{(?:[^{}\\]+|\\.)*\}          - a matched set of curly braces containing other atoms
  var placeholder       = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
      searchPlaceholder = /([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
      compiled = '^', last = 0, m,
      segments = this.segments = [],
      parentParams = parentMatcher ? parentMatcher.params : {},
      params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),
      paramNames = [];

  function addParameter(id, type, config, location) {
    paramNames.push(id);
    if (parentParams[id]) return parentParams[id];
    if (!/^\w+([-.]+\w+)*(?:\[\])?$/.test(id)) throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
    if (params[id]) throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
    params[id] = new $$UMFP.Param(id, type, config, location);
    return params[id];
  }

  function quoteRegExp(string, pattern, squash, optional) {
    var surroundPattern = ['',''], result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
    if (!pattern) return result;
    switch(squash) {
      case false: surroundPattern = ['(', ')' + (optional ? "?" : "")]; break;
      case true:
        result = result.replace(/\/$/, '');
        surroundPattern = ['(?:\/(', ')|\/)?'];
      break;
      default:    surroundPattern = ['(' + squash + "|", ')?']; break;
    }
    return result + surroundPattern[0] + pattern + surroundPattern[1];
  }

  this.source = pattern;

  // Split into static segments separated by path parameter placeholders.
  // The number of segments is always 1 more than the number of parameters.
  function matchDetails(m, isSearch) {
    var id, regexp, segment, type, cfg, arrayMode;
    id          = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null
    cfg         = config.params[id];
    segment     = pattern.substring(last, m.index);
    regexp      = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);

    if (regexp) {
      type      = $$UMFP.type(regexp) || inherit($$UMFP.type("string"), { pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined) });
    }

    return {
      id: id, regexp: regexp, segment: segment, type: type, cfg: cfg
    };
  }

  var p, param, segment;
  while ((m = placeholder.exec(pattern))) {
    p = matchDetails(m, false);
    if (p.segment.indexOf('?') >= 0) break; // we're into the search part

    param = addParameter(p.id, p.type, p.cfg, "path");
    compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);
    segments.push(p.segment);
    last = placeholder.lastIndex;
  }
  segment = pattern.substring(last);

  // Find any search parameter names and remove them from the last segment
  var i = segment.indexOf('?');

  if (i >= 0) {
    var search = this.sourceSearch = segment.substring(i);
    segment = segment.substring(0, i);
    this.sourcePath = pattern.substring(0, last + i);

    if (search.length > 0) {
      last = 0;
      while ((m = searchPlaceholder.exec(search))) {
        p = matchDetails(m, true);
        param = addParameter(p.id, p.type, p.cfg, "search");
        last = placeholder.lastIndex;
        // check if ?&
      }
    }
  } else {
    this.sourcePath = pattern;
    this.sourceSearch = '';
  }

  compiled += quoteRegExp(segment) + (config.strict === false ? '\/?' : '') + '$';
  segments.push(segment);

  this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);
  this.prefix = segments[0];
  this.$$paramNames = paramNames;
}

/**
 * @ngdoc function
 * @name ui.router.util.type:UrlMatcher#concat
 * @methodOf ui.router.util.type:UrlMatcher
 *
 * @description
 * Returns a new matcher for a pattern constructed by appending the path part and adding the
 * search parameters of the specified pattern to this pattern. The current pattern is not
 * modified. This can be understood as creating a pattern for URLs that are relative to (or
 * suffixes of) the current pattern.
 *
 * @example
 * The following two matchers are equivalent:
 * <pre>
 * new UrlMatcher('/user/{id}?q').concat('/details?date');
 * new UrlMatcher('/user/{id}/details?q&date');
 * </pre>
 *
 * @param {string} pattern  The pattern to append.
 * @param {Object} config  An object hash of the configuration for the matcher.
 * @returns {UrlMatcher}  A matcher for the concatenated pattern.
 */
UrlMatcher.prototype.concat = function (pattern, config) {
  // Because order of search parameters is irrelevant, we can add our own search
  // parameters to the end of the new pattern. Parse the new pattern by itself
  // and then join the bits together, but it's much easier to do this on a string level.
  var defaultConfig = {
    caseInsensitive: $$UMFP.caseInsensitive(),
    strict: $$UMFP.strictMode(),
    squash: $$UMFP.defaultSquashPolicy()
  };
  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);
};

UrlMatcher.prototype.toString = function () {
  return this.source;
};

/**
 * @ngdoc function
 * @name ui.router.util.type:UrlMatcher#exec
 * @methodOf ui.router.util.type:UrlMatcher
 *
 * @description
 * Tests the specified path against this matcher, and returns an object containing the captured
 * parameter values, or null if the path does not match. The returned object contains the values
 * of any search parameters that are mentioned in the pattern, but their value may be null if
 * they are not present in `searchParams`. This means that search parameters are always treated
 * as optional.
 *
 * @example
 * <pre>
 * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {
 *   x: '1', q: 'hello'
 * });
 * // returns { id: 'bob', q: 'hello', r: null }
 * </pre>
 *
 * @param {string} path  The URL path to match, e.g. `$location.path()`.
 * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.
 * @returns {Object}  The captured parameter values.
 */
UrlMatcher.prototype.exec = function (path, searchParams) {
  var m = this.regexp.exec(path);
  if (!m) return null;
  searchParams = searchParams || {};

  var paramNames = this.parameters(), nTotal = paramNames.length,
    nPath = this.segments.length - 1,
    values = {}, i, j, cfg, paramName;

  if (nPath !== m.length - 1) throw new Error("Unbalanced capture group in route '" + this.source + "'");

  function decodePathArray(string) {
    function reverseString(str) { return str.split("").reverse().join(""); }
    function unquoteDashes(str) { return str.replace(/\\-/g, "-"); }

    var split = reverseString(string).split(/-(?!\\)/);
    var allReversed = map(split, reverseString);
    return map(allReversed, unquoteDashes).reverse();
  }

  var param, paramVal;
  for (i = 0; i < nPath; i++) {
    paramName = paramNames[i];
    param = this.params[paramName];
    paramVal = m[i+1];
    // if the param value matches a pre-replace pair, replace the value before decoding.
    for (j = 0; j < param.replace.length; j++) {
      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;
    }
    if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);
    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);
    values[paramName] = param.value(paramVal);
  }
  for (/**/; i < nTotal; i++) {
    paramName = paramNames[i];
    values[paramName] = this.params[paramName].value(searchParams[paramName]);
    param = this.params[paramName];
    paramVal = searchParams[paramName];
    for (j = 0; j < param.replace.length; j++) {
      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;
    }
    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);
    values[paramName] = param.value(paramVal);
  }

  return values;
};

/**
 * @ngdoc function
 * @name ui.router.util.type:UrlMatcher#parameters
 * @methodOf ui.router.util.type:UrlMatcher
 *
 * @description
 * Returns the names of all path and search parameters of this pattern in an unspecified order.
 *
 * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the
 *    pattern has no parameters, an empty array is returned.
 */
UrlMatcher.prototype.parameters = function (param) {
  if (!isDefined(param)) return this.$$paramNames;
  return this.params[param] || null;
};

/**
 * @ngdoc function
 * @name ui.router.util.type:UrlMatcher#validates
 * @methodOf ui.router.util.type:UrlMatcher
 *
 * @description
 * Checks an object hash of parameters to validate their correctness according to the parameter
 * types of this `UrlMatcher`.
 *
 * @param {Object} params The object hash of parameters to validate.
 * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.
 */
UrlMatcher.prototype.validates = function (params) {
  return this.params.$$validates(params);
};

/**
 * @ngdoc function
 * @name ui.router.util.type:UrlMatcher#format
 * @methodOf ui.router.util.type:UrlMatcher
 *
 * @description
 * Creates a URL that matches this pattern by substituting the specified values
 * for the path and search parameters. Null values for path parameters are
 * treated as empty strings.
 *
 * @example
 * <pre>
 * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });
 * // returns '/user/bob?q=yes'
 * </pre>
 *
 * @param {Object} values  the values to substitute for the parameters in this pattern.
 * @returns {string}  the formatted URL (path and optionally search part).
 */
UrlMatcher.prototype.format = function (values) {
  values = values || {};
  var segments = this.segments, params = this.parameters(), paramset = this.params;
  if (!this.validates(values)) return null;

  var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];

  function encodeDashes(str) { // Replace dashes with encoded "\-"
    return encodeURIComponent(str).replace(/-/g, function(c) { return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase(); });
  }

  for (i = 0; i < nTotal; i++) {
    var isPathParam = i < nPath;
    var name = params[i], param = paramset[name], value = param.value(values[name]);
    var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);
    var squash = isDefaultValue ? param.squash : false;
    var encoded = param.type.encode(value);

    if (isPathParam) {
      var nextSegment = segments[i + 1];
      var isFinalPathParam = i + 1 === nPath;

      if (squash === false) {
        if (encoded != null) {
          if (isArray(encoded)) {
            result += map(encoded, encodeDashes).join("-");
          } else {
            result += encodeURIComponent(encoded);
          }
        }
        result += nextSegment;
      } else if (squash === true) {
        var capture = result.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
        result += nextSegment.match(capture)[1];
      } else if (isString(squash)) {
        result += squash + nextSegment;
      }

      if (isFinalPathParam && param.squash === true && result.slice(-1) === '/') result = result.slice(0, -1);
    } else {
      if (encoded == null || (isDefaultValue && squash !== false)) continue;
      if (!isArray(encoded)) encoded = [ encoded ];
      if (encoded.length === 0) continue;
      encoded = map(encoded, encodeURIComponent).join('&' + name + '=');
      result += (search ? '&' : '?') + (name + '=' + encoded);
      search = true;
    }
  }

  return result;
};

/**
 * @ngdoc object
 * @name ui.router.util.type:Type
 *
 * @description
 * Implements an interface to define custom parameter types that can be decoded from and encoded to
 * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}
 * objects when matching or formatting URLs, or comparing or validating parameter values.
 *
 * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more
 * information on registering custom types.
 *
 * @param {Object} config  A configuration object which contains the custom type definition.  The object's
 *        properties will override the default methods and/or pattern in `Type`'s public interface.
 * @example
 * <pre>
 * {
 *   decode: function(val) { return parseInt(val, 10); },
 *   encode: function(val) { return val && val.toString(); },
 *   equals: function(a, b) { return this.is(a) && a === b; },
 *   is: function(val) { return angular.isNumber(val) isFinite(val) && val % 1 === 0; },
 *   pattern: /\d+/
 * }
 * </pre>
 *
 * @property {RegExp} pattern The regular expression pattern used to match values of this type when
 *           coming from a substring of a URL.
 *
 * @returns {Object}  Returns a new `Type` object.
 */
function Type(config) {
  extend(this, config);
}

/**
 * @ngdoc function
 * @name ui.router.util.type:Type#is
 * @methodOf ui.router.util.type:Type
 *
 * @description
 * Detects whether a value is of a particular type. Accepts a native (decoded) value
 * and determines whether it matches the current `Type` object.
 *
 * @param {*} val  The value to check.
 * @param {string} key  Optional. If the type check is happening in the context of a specific
 *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the
 *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.
 * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.
 */
Type.prototype.is = function(val, key) {
  return true;
};

/**
 * @ngdoc function
 * @name ui.router.util.type:Type#encode
 * @methodOf ui.router.util.type:Type
 *
 * @description
 * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the
 * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it
 * only needs to be a representation of `val` that has been coerced to a string.
 *
 * @param {*} val  The value to encode.
 * @param {string} key  The name of the parameter in which `val` is stored. Can be used for
 *        meta-programming of `Type` objects.
 * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.
 */
Type.prototype.encode = function(val, key) {
  return val;
};

/**
 * @ngdoc function
 * @name ui.router.util.type:Type#decode
 * @methodOf ui.router.util.type:Type
 *
 * @description
 * Converts a parameter value (from URL string or transition param) to a custom/native value.
 *
 * @param {string} val  The URL parameter value to decode.
 * @param {string} key  The name of the parameter in which `val` is stored. Can be used for
 *        meta-programming of `Type` objects.
 * @returns {*}  Returns a custom representation of the URL parameter value.
 */
Type.prototype.decode = function(val, key) {
  return val;
};

/**
 * @ngdoc function
 * @name ui.router.util.type:Type#equals
 * @methodOf ui.router.util.type:Type
 *
 * @description
 * Determines whether two decoded values are equivalent.
 *
 * @param {*} a  A value to compare against.
 * @param {*} b  A value to compare against.
 * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.
 */
Type.prototype.equals = function(a, b) {
  return a == b;
};

Type.prototype.$subPattern = function() {
  var sub = this.pattern.toString();
  return sub.substr(1, sub.length - 2);
};

Type.prototype.pattern = /.*/;

Type.prototype.toString = function() { return "{Type:" + this.name + "}"; };

/** Given an encoded string, or a decoded object, returns a decoded object */
Type.prototype.$normalize = function(val) {
  return this.is(val) ? val : this.decode(val);
};

/*
 * Wraps an existing custom Type as an array of Type, depending on 'mode'.
 * e.g.:
 * - urlmatcher pattern "/path?{queryParam[]:int}"
 * - url: "/path?queryParam=1&queryParam=2
 * - $stateParams.queryParam will be [1, 2]
 * if `mode` is "auto", then
 * - url: "/path?queryParam=1 will create $stateParams.queryParam: 1
 * - url: "/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]
 */
Type.prototype.$asArray = function(mode, isSearch) {
  if (!mode) return this;
  if (mode === "auto" && !isSearch) throw new Error("'auto' array mode is for query parameters only");

  function ArrayType(type, mode) {
    function bindTo(type, callbackName) {
      return function() {
        return type[callbackName].apply(type, arguments);
      };
    }

    // Wrap non-array value as array
    function arrayWrap(val) { return isArray(val) ? val : (isDefined(val) ? [ val ] : []); }
    // Unwrap array value for "auto" mode. Return undefined for empty array.
    function arrayUnwrap(val) {
      switch(val.length) {
        case 0: return undefined;
        case 1: return mode === "auto" ? val[0] : val;
        default: return val;
      }
    }
    function falsey(val) { return !val; }

    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array
    function arrayHandler(callback, allTruthyMode) {
      return function handleArray(val) {
        if (isArray(val) && val.length === 0) return val;
        val = arrayWrap(val);
        var result = map(val, callback);
        if (allTruthyMode === true)
          return filter(result, falsey).length === 0;
        return arrayUnwrap(result);
      };
    }

    // Wraps type (.equals) functions to operate on each value of an array
    function arrayEqualsHandler(callback) {
      return function handleArray(val1, val2) {
        var left = arrayWrap(val1), right = arrayWrap(val2);
        if (left.length !== right.length) return false;
        for (var i = 0; i < left.length; i++) {
          if (!callback(left[i], right[i])) return false;
        }
        return true;
      };
    }

    this.encode = arrayHandler(bindTo(type, 'encode'));
    this.decode = arrayHandler(bindTo(type, 'decode'));
    this.is     = arrayHandler(bindTo(type, 'is'), true);
    this.equals = arrayEqualsHandler(bindTo(type, 'equals'));
    this.pattern = type.pattern;
    this.$normalize = arrayHandler(bindTo(type, '$normalize'));
    this.name = type.name;
    this.$arrayMode = mode;
  }

  return new ArrayType(this, mode);
};



/**
 * @ngdoc object
 * @name ui.router.util.$urlMatcherFactory
 *
 * @description
 * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory
 * is also available to providers under the name `$urlMatcherFactoryProvider`.
 */
function $UrlMatcherFactory() {
  $$UMFP = this;

  var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;

  // Use tildes to pre-encode slashes.
  // If the slashes are simply URLEncoded, the browser can choose to pre-decode them,
  // and bidirectional encoding/decoding fails.
  // Tilde was chosen because it's not a RFC 3986 section 2.2 Reserved Character
  function valToString(val) { return val != null ? val.toString().replace(/(~|\/)/g, function (m) { return {'~':'~~', '/':'~2F'}[m]; }) : val; }
  function valFromString(val) { return val != null ? val.toString().replace(/(~~|~2F)/g, function (m) { return {'~~':'~', '~2F':'/'}[m]; }) : val; }

  var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {
    "string": {
      encode: valToString,
      decode: valFromString,
      // TODO: in 1.0, make string .is() return false if value is undefined/null by default.
      // In 0.2.x, string params are optional by default for backwards compat
      is: function(val) { return val == null || !isDefined(val) || typeof val === "string"; },
      pattern: /[^/]*/
    },
    "int": {
      encode: valToString,
      decode: function(val) { return parseInt(val, 10); },
      is: function(val) { return val !== undefined && val !== null && this.decode(val.toString()) === val; },
      pattern: /\d+/
    },
    "bool": {
      encode: function(val) { return val ? 1 : 0; },
      decode: function(val) { return parseInt(val, 10) !== 0; },
      is: function(val) { return val === true || val === false; },
      pattern: /0|1/
    },
    "date": {
      encode: function (val) {
        if (!this.is(val))
          return undefined;
        return [ val.getFullYear(),
          ('0' + (val.getMonth() + 1)).slice(-2),
          ('0' + val.getDate()).slice(-2)
        ].join("-");
      },
      decode: function (val) {
        if (this.is(val)) return val;
        var match = this.capture.exec(val);
        return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
      },
      is: function(val) { return val instanceof Date && !isNaN(val.valueOf()); },
      equals: function (a, b) { return this.is(a) && this.is(b) && a.toISOString() === b.toISOString(); },
      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
      capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
    },
    "json": {
      encode: angular.toJson,
      decode: angular.fromJson,
      is: angular.isObject,
      equals: angular.equals,
      pattern: /[^/]*/
    },
    "any": { // does not encode/decode
      encode: angular.identity,
      decode: angular.identity,
      equals: angular.equals,
      pattern: /.*/
    }
  };

  function getDefaultConfig() {
    return {
      strict: isStrictMode,
      caseInsensitive: isCaseInsensitive
    };
  }

  function isInjectable(value) {
    return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));
  }

  /**
   * [Internal] Get the default value of a parameter, which may be an injectable function.
   */
  $UrlMatcherFactory.$$getDefaultValue = function(config) {
    if (!isInjectable(config.value)) return config.value;
    if (!injector) throw new Error("Injectable functions cannot be called at configuration time");
    return injector.invoke(config.value);
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$urlMatcherFactory#caseInsensitive
   * @methodOf ui.router.util.$urlMatcherFactory
   *
   * @description
   * Defines whether URL matching should be case sensitive (the default behavior), or not.
   *
   * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;
   * @returns {boolean} the current value of caseInsensitive
   */
  this.caseInsensitive = function(value) {
    if (isDefined(value))
      isCaseInsensitive = value;
    return isCaseInsensitive;
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$urlMatcherFactory#strictMode
   * @methodOf ui.router.util.$urlMatcherFactory
   *
   * @description
   * Defines whether URLs should match trailing slashes, or not (the default behavior).
   *
   * @param {boolean=} value `false` to match trailing slashes in URLs, otherwise `true`.
   * @returns {boolean} the current value of strictMode
   */
  this.strictMode = function(value) {
    if (isDefined(value))
      isStrictMode = value;
    return isStrictMode;
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$urlMatcherFactory#defaultSquashPolicy
   * @methodOf ui.router.util.$urlMatcherFactory
   *
   * @description
   * Sets the default behavior when generating or matching URLs with default parameter values.
   *
   * @param {string} value A string that defines the default parameter URL squashing behavior.
   *    `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL
   *    `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the
   *             parameter is surrounded by slashes, squash (remove) one slash from the URL
   *    any other string, e.g. "~": When generating an href with a default parameter value, squash (remove)
   *             the parameter value from the URL and replace it with this string.
   */
  this.defaultSquashPolicy = function(value) {
    if (!isDefined(value)) return defaultSquashPolicy;
    if (value !== true && value !== false && !isString(value))
      throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
    defaultSquashPolicy = value;
    return value;
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$urlMatcherFactory#compile
   * @methodOf ui.router.util.$urlMatcherFactory
   *
   * @description
   * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.
   *
   * @param {string} pattern  The URL pattern.
   * @param {Object} config  The config object hash.
   * @returns {UrlMatcher}  The UrlMatcher.
   */
  this.compile = function (pattern, config) {
    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$urlMatcherFactory#isMatcher
   * @methodOf ui.router.util.$urlMatcherFactory
   *
   * @description
   * Returns true if the specified object is a `UrlMatcher`, or false otherwise.
   *
   * @param {Object} object  The object to perform the type check against.
   * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by
   *          implementing all the same methods.
   */
  this.isMatcher = function (o) {
    if (!isObject(o)) return false;
    var result = true;

    forEach(UrlMatcher.prototype, function(val, name) {
      if (isFunction(val)) {
        result = result && (isDefined(o[name]) && isFunction(o[name]));
      }
    });
    return result;
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$urlMatcherFactory#type
   * @methodOf ui.router.util.$urlMatcherFactory
   *
   * @description
   * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to
   * generate URLs with typed parameters.
   *
   * @param {string} name  The type name.
   * @param {Object|Function} definition   The type definition. See
   *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.
   * @param {Object|Function} definitionFn (optional) A function that is injected before the app
   *        runtime starts.  The result of this function is merged into the existing `definition`.
   *        See {@link ui.router.util.type:Type `Type`} for information on the values accepted.
   *
   * @returns {Object}  Returns `$urlMatcherFactoryProvider`.
   *
   * @example
   * This is a simple example of a custom type that encodes and decodes items from an
   * array, using the array index as the URL-encoded value:
   *
   * <pre>
   * var list = ['John', 'Paul', 'George', 'Ringo'];
   *
   * $urlMatcherFactoryProvider.type('listItem', {
   *   encode: function(item) {
   *     // Represent the list item in the URL using its corresponding index
   *     return list.indexOf(item);
   *   },
   *   decode: function(item) {
   *     // Look up the list item by index
   *     return list[parseInt(item, 10)];
   *   },
   *   is: function(item) {
   *     // Ensure the item is valid by checking to see that it appears
   *     // in the list
   *     return list.indexOf(item) > -1;
   *   }
   * });
   *
   * $stateProvider.state('list', {
   *   url: "/list/{item:listItem}",
   *   controller: function($scope, $stateParams) {
   *     console.log($stateParams.item);
   *   }
   * });
   *
   * // ...
   *
   * // Changes URL to '/list/3', logs "Ringo" to the console
   * $state.go('list', { item: "Ringo" });
   * </pre>
   *
   * This is a more complex example of a type that relies on dependency injection to
   * interact with services, and uses the parameter name from the URL to infer how to
   * handle encoding and decoding parameter values:
   *
   * <pre>
   * // Defines a custom type that gets a value from a service,
   * // where each service gets different types of values from
   * // a backend API:
   * $urlMatcherFactoryProvider.type('dbObject', {}, function(Users, Posts) {
   *
   *   // Matches up services to URL parameter names
   *   var services = {
   *     user: Users,
   *     post: Posts
   *   };
   *
   *   return {
   *     encode: function(object) {
   *       // Represent the object in the URL using its unique ID
   *       return object.id;
   *     },
   *     decode: function(value, key) {
   *       // Look up the object by ID, using the parameter
   *       // name (key) to call the correct service
   *       return services[key].findById(value);
   *     },
   *     is: function(object, key) {
   *       // Check that object is a valid dbObject
   *       return angular.isObject(object) && object.id && services[key];
   *     }
   *     equals: function(a, b) {
   *       // Check the equality of decoded objects by comparing
   *       // their unique IDs
   *       return a.id === b.id;
   *     }
   *   };
   * });
   *
   * // In a config() block, you can then attach URLs with
   * // type-annotated parameters:
   * $stateProvider.state('users', {
   *   url: "/users",
   *   // ...
   * }).state('users.item', {
   *   url: "/{user:dbObject}",
   *   controller: function($scope, $stateParams) {
   *     // $stateParams.user will now be an object returned from
   *     // the Users service
   *   },
   *   // ...
   * });
   * </pre>
   */
  this.type = function (name, definition, definitionFn) {
    if (!isDefined(definition)) return $types[name];
    if ($types.hasOwnProperty(name)) throw new Error("A type named '" + name + "' has already been defined.");

    $types[name] = new Type(extend({ name: name }, definition));
    if (definitionFn) {
      typeQueue.push({ name: name, def: definitionFn });
      if (!enqueue) flushTypeQueue();
    }
    return this;
  };

  // `flushTypeQueue()` waits until `$urlMatcherFactory` is injected before invoking the queued `definitionFn`s
  function flushTypeQueue() {
    while(typeQueue.length) {
      var type = typeQueue.shift();
      if (type.pattern) throw new Error("You cannot override a type's .pattern at runtime.");
      angular.extend($types[type.name], injector.invoke(type.def));
    }
  }

  // Register default types. Store them in the prototype of $types.
  forEach(defaultTypes, function(type, name) { $types[name] = new Type(extend({name: name}, type)); });
  $types = inherit($types, {});

  /* No need to document $get, since it returns this */
  this.$get = ['$injector', function ($injector) {
    injector = $injector;
    enqueue = false;
    flushTypeQueue();

    forEach(defaultTypes, function(type, name) {
      if (!$types[name]) $types[name] = new Type(type);
    });
    return this;
  }];

  this.Param = function Param(id, type, config, location) {
    var self = this;
    config = unwrapShorthand(config);
    type = getType(config, type, location);
    var arrayMode = getArrayMode();
    type = arrayMode ? type.$asArray(arrayMode, location === "search") : type;
    if (type.name === "string" && !arrayMode && location === "path" && config.value === undefined)
      config.value = ""; // for 0.2.x; in 0.3.0+ do not automatically default to ""
    var isOptional = config.value !== undefined;
    var squash = getSquashPolicy(config, isOptional);
    var replace = getReplace(config, arrayMode, isOptional, squash);

    function unwrapShorthand(config) {
      var keys = isObject(config) ? objectKeys(config) : [];
      var isShorthand = indexOf(keys, "value") === -1 && indexOf(keys, "type") === -1 &&
                        indexOf(keys, "squash") === -1 && indexOf(keys, "array") === -1;
      if (isShorthand) config = { value: config };
      config.$$fn = isInjectable(config.value) ? config.value : function () { return config.value; };
      return config;
    }

    function getType(config, urlType, location) {
      if (config.type && urlType) throw new Error("Param '"+id+"' has two type configurations.");
      if (urlType) return urlType;
      if (!config.type) return (location === "config" ? $types.any : $types.string);

      if (angular.isString(config.type))
        return $types[config.type];
      if (config.type instanceof Type)
        return config.type;
      return new Type(config.type);
    }

    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.
    function getArrayMode() {
      var arrayDefaults = { array: (location === "search" ? "auto" : false) };
      var arrayParamNomenclature = id.match(/\[\]$/) ? { array: true } : {};
      return extend(arrayDefaults, arrayParamNomenclature, config).array;
    }

    /**
     * returns false, true, or the squash value to indicate the "default parameter url squash policy".
     */
    function getSquashPolicy(config, isOptional) {
      var squash = config.squash;
      if (!isOptional || squash === false) return false;
      if (!isDefined(squash) || squash == null) return defaultSquashPolicy;
      if (squash === true || isString(squash)) return squash;
      throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
    }

    function getReplace(config, arrayMode, isOptional, squash) {
      var replace, configuredKeys, defaultPolicy = [
        { from: "",   to: (isOptional || arrayMode ? undefined : "") },
        { from: null, to: (isOptional || arrayMode ? undefined : "") }
      ];
      replace = isArray(config.replace) ? config.replace : [];
      if (isString(squash))
        replace.push({ from: squash, to: undefined });
      configuredKeys = map(replace, function(item) { return item.from; } );
      return filter(defaultPolicy, function(item) { return indexOf(configuredKeys, item.from) === -1; }).concat(replace);
    }

    /**
     * [Internal] Get the default value of a parameter, which may be an injectable function.
     */
    function $$getDefaultValue() {
      if (!injector) throw new Error("Injectable functions cannot be called at configuration time");
      var defaultValue = injector.invoke(config.$$fn);
      if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))
        throw new Error("Default value (" + defaultValue + ") for parameter '" + self.id + "' is not an instance of Type (" + self.type.name + ")");
      return defaultValue;
    }

    /**
     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the
     * default value, which may be the result of an injectable function.
     */
    function $value(value) {
      function hasReplaceVal(val) { return function(obj) { return obj.from === val; }; }
      function $replace(value) {
        var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) { return obj.to; });
        return replacement.length ? replacement[0] : value;
      }
      value = $replace(value);
      return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);
    }

    function toString() { return "{Param:" + id + " " + type + " squash: '" + squash + "' optional: " + isOptional + "}"; }

    extend(this, {
      id: id,
      type: type,
      location: location,
      array: arrayMode,
      squash: squash,
      replace: replace,
      isOptional: isOptional,
      value: $value,
      dynamic: undefined,
      config: config,
      toString: toString
    });
  };

  function ParamSet(params) {
    extend(this, params || {});
  }

  ParamSet.prototype = {
    $$new: function() {
      return inherit(this, extend(new ParamSet(), { $$parent: this}));
    },
    $$keys: function () {
      var keys = [], chain = [], parent = this,
        ignore = objectKeys(ParamSet.prototype);
      while (parent) { chain.push(parent); parent = parent.$$parent; }
      chain.reverse();
      forEach(chain, function(paramset) {
        forEach(objectKeys(paramset), function(key) {
            if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);
        });
      });
      return keys;
    },
    $$values: function(paramValues) {
      var values = {}, self = this;
      forEach(self.$$keys(), function(key) {
        values[key] = self[key].value(paramValues && paramValues[key]);
      });
      return values;
    },
    $$equals: function(paramValues1, paramValues2) {
      var equal = true, self = this;
      forEach(self.$$keys(), function(key) {
        var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];
        if (!self[key].type.equals(left, right)) equal = false;
      });
      return equal;
    },
    $$validates: function $$validate(paramValues) {
      var keys = this.$$keys(), i, param, rawVal, normalized, encoded;
      for (i = 0; i < keys.length; i++) {
        param = this[keys[i]];
        rawVal = paramValues[keys[i]];
        if ((rawVal === undefined || rawVal === null) && param.isOptional)
          break; // There was no parameter value, but the param is optional
        normalized = param.type.$normalize(rawVal);
        if (!param.type.is(normalized))
          return false; // The value was not of the correct Type, and could not be decoded to the correct Type
        encoded = param.type.encode(normalized);
        if (angular.isString(encoded) && !param.type.pattern.exec(encoded))
          return false; // The value was of the correct type, but when encoded, did not match the Type's regexp
      }
      return true;
    },
    $$parent: undefined
  };

  this.ParamSet = ParamSet;
}

// Register as a provider so it's available to other providers
angular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);
angular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) { }]);

/**
 * @ngdoc object
 * @name ui.router.router.$urlRouterProvider
 *
 * @requires ui.router.util.$urlMatcherFactoryProvider
 * @requires $locationProvider
 *
 * @description
 * `$urlRouterProvider` has the responsibility of watching `$location`. 
 * When `$location` changes it runs through a list of rules one by one until a 
 * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify 
 * a url in a state configuration. All urls are compiled into a UrlMatcher object.
 *
 * There are several methods on `$urlRouterProvider` that make it useful to use directly
 * in your module config.
 */
$UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];
function $UrlRouterProvider(   $locationProvider,   $urlMatcherFactory) {
  var rules = [], otherwise = null, interceptDeferred = false, listener;

  // Returns a string that is a prefix of all strings matching the RegExp
  function regExpPrefix(re) {
    var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
    return (prefix != null) ? prefix[1].replace(/\\(.)/g, "$1") : '';
  }

  // Interpolates matched values into a String.replace()-style pattern
  function interpolate(pattern, match) {
    return pattern.replace(/\$(\$|\d{1,2})/, function (m, what) {
      return match[what === '$' ? 0 : Number(what)];
    });
  }

  /**
   * @ngdoc function
   * @name ui.router.router.$urlRouterProvider#rule
   * @methodOf ui.router.router.$urlRouterProvider
   *
   * @description
   * Defines rules that are used by `$urlRouterProvider` to find matches for
   * specific URLs.
   *
   * @example
   * <pre>
   * var app = angular.module('app', ['ui.router.router']);
   *
   * app.config(function ($urlRouterProvider) {
   *   // Here's an example of how you might allow case insensitive urls
   *   $urlRouterProvider.rule(function ($injector, $location) {
   *     var path = $location.path(),
   *         normalized = path.toLowerCase();
   *
   *     if (path !== normalized) {
   *       return normalized;
   *     }
   *   });
   * });
   * </pre>
   *
   * @param {function} rule Handler function that takes `$injector` and `$location`
   * services as arguments. You can use them to return a valid path as a string.
   *
   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance
   */
  this.rule = function (rule) {
    if (!isFunction(rule)) throw new Error("'rule' must be a function");
    rules.push(rule);
    return this;
  };

  /**
   * @ngdoc object
   * @name ui.router.router.$urlRouterProvider#otherwise
   * @methodOf ui.router.router.$urlRouterProvider
   *
   * @description
   * Defines a path that is used when an invalid route is requested.
   *
   * @example
   * <pre>
   * var app = angular.module('app', ['ui.router.router']);
   *
   * app.config(function ($urlRouterProvider) {
   *   // if the path doesn't match any of the urls you configured
   *   // otherwise will take care of routing the user to the
   *   // specified url
   *   $urlRouterProvider.otherwise('/index');
   *
   *   // Example of using function rule as param
   *   $urlRouterProvider.otherwise(function ($injector, $location) {
   *     return '/a/valid/url';
   *   });
   * });
   * </pre>
   *
   * @param {string|function} rule The url path you want to redirect to or a function 
   * rule that returns the url path. The function version is passed two params: 
   * `$injector` and `$location` services, and must return a url string.
   *
   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance
   */
  this.otherwise = function (rule) {
    if (isString(rule)) {
      var redirect = rule;
      rule = function () { return redirect; };
    }
    else if (!isFunction(rule)) throw new Error("'rule' must be a function");
    otherwise = rule;
    return this;
  };


  function handleIfMatch($injector, handler, match) {
    if (!match) return false;
    var result = $injector.invoke(handler, handler, { $match: match });
    return isDefined(result) ? result : true;
  }

  /**
   * @ngdoc function
   * @name ui.router.router.$urlRouterProvider#when
   * @methodOf ui.router.router.$urlRouterProvider
   *
   * @description
   * Registers a handler for a given url matching. 
   * 
   * If the handler is a string, it is
   * treated as a redirect, and is interpolated according to the syntax of match
   * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).
   *
   * If the handler is a function, it is injectable. It gets invoked if `$location`
   * matches. You have the option of inject the match object as `$match`.
   *
   * The handler can return
   *
   * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`
   *   will continue trying to find another one that matches.
   * - **string** which is treated as a redirect and passed to `$location.url()`
   * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.
   *
   * @example
   * <pre>
   * var app = angular.module('app', ['ui.router.router']);
   *
   * app.config(function ($urlRouterProvider) {
   *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {
   *     if ($state.$current.navigable !== state ||
   *         !equalForKeys($match, $stateParams) {
   *      $state.transitionTo(state, $match, false);
   *     }
   *   });
   * });
   * </pre>
   *
   * @param {string|object} what The incoming path that you want to redirect.
   * @param {string|function} handler The path you want to redirect your user to.
   */
  this.when = function (what, handler) {
    var redirect, handlerIsString = isString(handler);
    if (isString(what)) what = $urlMatcherFactory.compile(what);

    if (!handlerIsString && !isFunction(handler) && !isArray(handler))
      throw new Error("invalid 'handler' in when()");

    var strategies = {
      matcher: function (what, handler) {
        if (handlerIsString) {
          redirect = $urlMatcherFactory.compile(handler);
          handler = ['$match', function ($match) { return redirect.format($match); }];
        }
        return extend(function ($injector, $location) {
          return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
        }, {
          prefix: isString(what.prefix) ? what.prefix : ''
        });
      },
      regex: function (what, handler) {
        if (what.global || what.sticky) throw new Error("when() RegExp must not be global or sticky");

        if (handlerIsString) {
          redirect = handler;
          handler = ['$match', function ($match) { return interpolate(redirect, $match); }];
        }
        return extend(function ($injector, $location) {
          return handleIfMatch($injector, handler, what.exec($location.path()));
        }, {
          prefix: regExpPrefix(what)
        });
      }
    };

    var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };

    for (var n in check) {
      if (check[n]) return this.rule(strategies[n](what, handler));
    }

    throw new Error("invalid 'what' in when()");
  };

  /**
   * @ngdoc function
   * @name ui.router.router.$urlRouterProvider#deferIntercept
   * @methodOf ui.router.router.$urlRouterProvider
   *
   * @description
   * Disables (or enables) deferring location change interception.
   *
   * If you wish to customize the behavior of syncing the URL (for example, if you wish to
   * defer a transition but maintain the current URL), call this method at configuration time.
   * Then, at run time, call `$urlRouter.listen()` after you have configured your own
   * `$locationChangeSuccess` event handler.
   *
   * @example
   * <pre>
   * var app = angular.module('app', ['ui.router.router']);
   *
   * app.config(function ($urlRouterProvider) {
   *
   *   // Prevent $urlRouter from automatically intercepting URL changes;
   *   // this allows you to configure custom behavior in between
   *   // location changes and route synchronization:
   *   $urlRouterProvider.deferIntercept();
   *
   * }).run(function ($rootScope, $urlRouter, UserService) {
   *
   *   $rootScope.$on('$locationChangeSuccess', function(e) {
   *     // UserService is an example service for managing user state
   *     if (UserService.isLoggedIn()) return;
   *
   *     // Prevent $urlRouter's default handler from firing
   *     e.preventDefault();
   *
   *     UserService.handleLogin().then(function() {
   *       // Once the user has logged in, sync the current URL
   *       // to the router:
   *       $urlRouter.sync();
   *     });
   *   });
   *
   *   // Configures $urlRouter's listener *after* your custom listener
   *   $urlRouter.listen();
   * });
   * </pre>
   *
   * @param {boolean} defer Indicates whether to defer location change interception. Passing
            no parameter is equivalent to `true`.
   */
  this.deferIntercept = function (defer) {
    if (defer === undefined) defer = true;
    interceptDeferred = defer;
  };

  /**
   * @ngdoc object
   * @name ui.router.router.$urlRouter
   *
   * @requires $location
   * @requires $rootScope
   * @requires $injector
   * @requires $browser
   *
   * @description
   *
   */
  this.$get = $get;
  $get.$inject = ['$location', '$rootScope', '$injector', '$browser', '$sniffer'];
  function $get(   $location,   $rootScope,   $injector,   $browser,   $sniffer) {

    var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;

    function appendBasePath(url, isHtml5, absolute) {
      if (baseHref === '/') return url;
      if (isHtml5) return baseHref.slice(0, -1) + url;
      if (absolute) return baseHref.slice(1) + url;
      return url;
    }

    // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree
    function update(evt) {
      if (evt && evt.defaultPrevented) return;
      var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;
      lastPushedUrl = undefined;
      // TODO: Re-implement this in 1.0 for https://github.com/angular-ui/ui-router/issues/1573
      //if (ignoreUpdate) return true;

      function check(rule) {
        var handled = rule($injector, $location);

        if (!handled) return false;
        if (isString(handled)) $location.replace().url(handled);
        return true;
      }
      var n = rules.length, i;

      for (i = 0; i < n; i++) {
        if (check(rules[i])) return;
      }
      // always check otherwise last to allow dynamic updates to the set of rules
      if (otherwise) check(otherwise);
    }

    function listen() {
      listener = listener || $rootScope.$on('$locationChangeSuccess', update);
      return listener;
    }

    if (!interceptDeferred) listen();

    return {
      /**
       * @ngdoc function
       * @name ui.router.router.$urlRouter#sync
       * @methodOf ui.router.router.$urlRouter
       *
       * @description
       * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.
       * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,
       * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed
       * with the transition by calling `$urlRouter.sync()`.
       *
       * @example
       * <pre>
       * angular.module('app', ['ui.router'])
       *   .run(function($rootScope, $urlRouter) {
       *     $rootScope.$on('$locationChangeSuccess', function(evt) {
       *       // Halt state change from even starting
       *       evt.preventDefault();
       *       // Perform custom logic
       *       var meetsRequirement = ...
       *       // Continue with the update and state transition if logic allows
       *       if (meetsRequirement) $urlRouter.sync();
       *     });
       * });
       * </pre>
       */
      sync: function() {
        update();
      },

      listen: function() {
        return listen();
      },

      update: function(read) {
        if (read) {
          location = $location.url();
          return;
        }
        if ($location.url() === location) return;

        $location.url(location);
        $location.replace();
      },

      push: function(urlMatcher, params, options) {
         var url = urlMatcher.format(params || {});

        // Handle the special hash param, if needed
        if (url !== null && params && params['#']) {
            url += '#' + params['#'];
        }

        $location.url(url);
        lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;
        if (options && options.replace) $location.replace();
      },

      /**
       * @ngdoc function
       * @name ui.router.router.$urlRouter#href
       * @methodOf ui.router.router.$urlRouter
       *
       * @description
       * A URL generation method that returns the compiled URL for a given
       * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.
       *
       * @example
       * <pre>
       * $bob = $urlRouter.href(new UrlMatcher("/about/:person"), {
       *   person: "bob"
       * });
       * // $bob == "/about/bob";
       * </pre>
       *
       * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.
       * @param {object=} params An object of parameter values to fill the matcher's required parameters.
       * @param {object=} options Options object. The options are:
       *
       * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. "http://www.example.com/fullurl".
       *
       * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`
       */
      href: function(urlMatcher, params, options) {
        if (!urlMatcher.validates(params)) return null;

        var isHtml5 = $locationProvider.html5Mode();
        if (angular.isObject(isHtml5)) {
          isHtml5 = isHtml5.enabled;
        }

        isHtml5 = isHtml5 && $sniffer.history;
        
        var url = urlMatcher.format(params);
        options = options || {};

        if (!isHtml5 && url !== null) {
          url = "#" + $locationProvider.hashPrefix() + url;
        }

        // Handle special hash param, if needed
        if (url !== null && params && params['#']) {
          url += '#' + params['#'];
        }

        url = appendBasePath(url, isHtml5, options.absolute);

        if (!options.absolute || !url) {
          return url;
        }

        var slash = (!isHtml5 && url ? '/' : ''), port = $location.port();
        port = (port === 80 || port === 443 ? '' : ':' + port);

        return [$location.protocol(), '://', $location.host(), port, slash, url].join('');
      }
    };
  }
}

angular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);

/**
 * @ngdoc object
 * @name ui.router.state.$stateProvider
 *
 * @requires ui.router.router.$urlRouterProvider
 * @requires ui.router.util.$urlMatcherFactoryProvider
 *
 * @description
 * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely
 * on state.
 *
 * A state corresponds to a "place" in the application in terms of the overall UI and
 * navigation. A state describes (via the controller / template / view properties) what
 * the UI looks like and does at that place.
 *
 * States often have things in common, and the primary way of factoring out these
 * commonalities in this model is via the state hierarchy, i.e. parent/child states aka
 * nested states.
 *
 * The `$stateProvider` provides interfaces to declare these states for your app.
 */
$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];
function $StateProvider(   $urlRouterProvider,   $urlMatcherFactory) {

  var root, states = {}, $state, queue = {}, abstractKey = 'abstract';

  // Builds state properties from definition passed to registerState()
  var stateBuilder = {

    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.
    // state.children = [];
    // if (parent) parent.children.push(state);
    parent: function(state) {
      if (isDefined(state.parent) && state.parent) return findState(state.parent);
      // regex matches any valid composite state name
      // would match "contact.list" but not "contacts"
      var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
      return compositeName ? findState(compositeName[1]) : root;
    },

    // inherit 'data' from parent and override by own values (if any)
    data: function(state) {
      if (state.parent && state.parent.data) {
        state.data = state.self.data = inherit(state.parent.data, state.data);
      }
      return state.data;
    },

    // Build a URLMatcher if necessary, either via a relative or absolute URL
    url: function(state) {
      var url = state.url, config = { params: state.params || {} };

      if (isString(url)) {
        if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);
        return (state.parent.navigable || root).url.concat(url, config);
      }

      if (!url || $urlMatcherFactory.isMatcher(url)) return url;
      throw new Error("Invalid url '" + url + "' in state '" + state + "'");
    },

    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)
    navigable: function(state) {
      return state.url ? state : (state.parent ? state.parent.navigable : null);
    },

    // Own parameters for this state. state.url.params is already built at this point. Create and add non-url params
    ownParams: function(state) {
      var params = state.url && state.url.params || new $$UMFP.ParamSet();
      forEach(state.params || {}, function(config, id) {
        if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, "config");
      });
      return params;
    },

    // Derive parameters for this state and ensure they're a super-set of parent's parameters
    params: function(state) {
      var ownParams = pick(state.ownParams, state.ownParams.$$keys());
      return state.parent && state.parent.params ? extend(state.parent.params.$$new(), ownParams) : new $$UMFP.ParamSet();
    },

    // If there is no explicit multi-view configuration, make one up so we don't have
    // to handle both cases in the view directive later. Note that having an explicit
    // 'views' property will mean the default unnamed view properties are ignored. This
    // is also a good time to resolve view names to absolute names, so everything is a
    // straight lookup at link time.
    views: function(state) {
      var views = {};

      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {
        if (name.indexOf('@') < 0) name += '@' + state.parent.name;
        view.resolveAs = view.resolveAs || state.resolveAs || '$resolve';
        views[name] = view;
      });
      return views;
    },

    // Keep a full path from the root down to this state as this is needed for state activation.
    path: function(state) {
      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path
    },

    // Speed up $state.contains() as it's used a lot
    includes: function(state) {
      var includes = state.parent ? extend({}, state.parent.includes) : {};
      includes[state.name] = true;
      return includes;
    },

    $delegates: {}
  };

  function isRelative(stateName) {
    return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
  }

  function findState(stateOrName, base) {
    if (!stateOrName) return undefined;

    var isStr = isString(stateOrName),
        name  = isStr ? stateOrName : stateOrName.name,
        path  = isRelative(name);

    if (path) {
      if (!base) throw new Error("No reference point given for path '"  + name + "'");
      base = findState(base);
      
      var rel = name.split("."), i = 0, pathLength = rel.length, current = base;

      for (; i < pathLength; i++) {
        if (rel[i] === "" && i === 0) {
          current = base;
          continue;
        }
        if (rel[i] === "^") {
          if (!current.parent) throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
          current = current.parent;
          continue;
        }
        break;
      }
      rel = rel.slice(i).join(".");
      name = current.name + (current.name && rel ? "." : "") + rel;
    }
    var state = states[name];

    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {
      return state;
    }
    return undefined;
  }

  function queueState(parentName, state) {
    if (!queue[parentName]) {
      queue[parentName] = [];
    }
    queue[parentName].push(state);
  }

  function flushQueuedChildren(parentName) {
    var queued = queue[parentName] || [];
    while(queued.length) {
      registerState(queued.shift());
    }
  }

  function registerState(state) {
    // Wrap a new object around the state so we can store our private details easily.
    state = inherit(state, {
      self: state,
      resolve: state.resolve || {},
      toString: function() { return this.name; }
    });

    var name = state.name;
    if (!isString(name) || name.indexOf('@') >= 0) throw new Error("State must have a valid name");
    if (states.hasOwnProperty(name)) throw new Error("State '" + name + "' is already defined");

    // Get parent name
    var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))
        : (isString(state.parent)) ? state.parent
        : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name
        : '';

    // If parent is not registered yet, add state to queue and register later
    if (parentName && !states[parentName]) {
      return queueState(parentName, state.self);
    }

    for (var key in stateBuilder) {
      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);
    }
    states[name] = state;

    // Register the state in the global state list and with $urlRouter if necessary.
    if (!state[abstractKey] && state.url) {
      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {
        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {
          $state.transitionTo(state, $match, { inherit: true, location: false });
        }
      }]);
    }

    // Register any queued children
    flushQueuedChildren(name);

    return state;
  }

  // Checks text to see if it looks like a glob.
  function isGlob (text) {
    return text.indexOf('*') > -1;
  }

  // Returns true if glob matches current $state name.
  function doesStateMatchGlob (glob) {
    var globSegments = glob.split('.'),
        segments = $state.$current.name.split('.');

    //match single stars
    for (var i = 0, l = globSegments.length; i < l; i++) {
      if (globSegments[i] === '*') {
        segments[i] = '*';
      }
    }

    //match greedy starts
    if (globSegments[0] === '**') {
       segments = segments.slice(indexOf(segments, globSegments[1]));
       segments.unshift('**');
    }
    //match greedy ends
    if (globSegments[globSegments.length - 1] === '**') {
       segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);
       segments.push('**');
    }

    if (globSegments.length != segments.length) {
      return false;
    }

    return segments.join('') === globSegments.join('');
  }


  // Implicit root state that is always active
  root = registerState({
    name: '',
    url: '^',
    views: null,
    'abstract': true
  });
  root.navigable = null;


  /**
   * @ngdoc function
   * @name ui.router.state.$stateProvider#decorator
   * @methodOf ui.router.state.$stateProvider
   *
   * @description
   * Allows you to extend (carefully) or override (at your own peril) the 
   * `stateBuilder` object used internally by `$stateProvider`. This can be used 
   * to add custom functionality to ui-router, for example inferring templateUrl 
   * based on the state name.
   *
   * When passing only a name, it returns the current (original or decorated) builder
   * function that matches `name`.
   *
   * The builder functions that can be decorated are listed below. Though not all
   * necessarily have a good use case for decoration, that is up to you to decide.
   *
   * In addition, users can attach custom decorators, which will generate new 
   * properties within the state's internal definition. There is currently no clear 
   * use-case for this beyond accessing internal states (i.e. $state.$current), 
   * however, expect this to become increasingly relevant as we introduce additional 
   * meta-programming features.
   *
   * **Warning**: Decorators should not be interdependent because the order of 
   * execution of the builder functions in non-deterministic. Builder functions 
   * should only be dependent on the state definition object and super function.
   *
   *
   * Existing builder functions and current return values:
   *
   * - **parent** `{object}` - returns the parent state object.
   * - **data** `{object}` - returns state data, including any inherited data that is not
   *   overridden by own values (if any).
   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}
   *   or `null`.
   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is 
   *   navigable).
   * - **params** `{object}` - returns an array of state params that are ensured to 
   *   be a super-set of parent's params.
   * - **views** `{object}` - returns a views object where each key is an absolute view 
   *   name (i.e. "viewName@stateName") and each value is the config object 
   *   (template, controller) for the view. Even when you don't use the views object 
   *   explicitly on a state config, one is still created for you internally.
   *   So by decorating this builder function you have access to decorating template 
   *   and controller properties.
   * - **ownParams** `{object}` - returns an array of params that belong to the state, 
   *   not including any params defined by ancestor states.
   * - **path** `{string}` - returns the full path from the root down to this state. 
   *   Needed for state activation.
   * - **includes** `{object}` - returns an object that includes every state that 
   *   would pass a `$state.includes()` test.
   *
   * @example
   * <pre>
   * // Override the internal 'views' builder with a function that takes the state
   * // definition, and a reference to the internal function being overridden:
   * $stateProvider.decorator('views', function (state, parent) {
   *   var result = {},
   *       views = parent(state);
   *
   *   angular.forEach(views, function (config, name) {
   *     var autoName = (state.name + '.' + name).replace('.', '/');
   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';
   *     result[name] = config;
   *   });
   *   return result;
   * });
   *
   * $stateProvider.state('home', {
   *   views: {
   *     'contact.list': { controller: 'ListController' },
   *     'contact.item': { controller: 'ItemController' }
   *   }
   * });
   *
   * // ...
   *
   * $state.go('home');
   * // Auto-populates list and item views with /partials/home/contact/list.html,
   * // and /partials/home/contact/item.html, respectively.
   * </pre>
   *
   * @param {string} name The name of the builder function to decorate. 
   * @param {object} func A function that is responsible for decorating the original 
   * builder function. The function receives two parameters:
   *
   *   - `{object}` - state - The state config object.
   *   - `{object}` - super - The original builder function.
   *
   * @return {object} $stateProvider - $stateProvider instance
   */
  this.decorator = decorator;
  function decorator(name, func) {
    /*jshint validthis: true */
    if (isString(name) && !isDefined(func)) {
      return stateBuilder[name];
    }
    if (!isFunction(func) || !isString(name)) {
      return this;
    }
    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {
      stateBuilder.$delegates[name] = stateBuilder[name];
    }
    stateBuilder[name] = func;
    return this;
  }

  /**
   * @ngdoc function
   * @name ui.router.state.$stateProvider#state
   * @methodOf ui.router.state.$stateProvider
   *
   * @description
   * Registers a state configuration under a given state name. The stateConfig object
   * has the following acceptable properties.
   *
   * @param {string} name A unique state name, e.g. "home", "about", "contacts".
   * To create a parent/child state use a dot, e.g. "about.sales", "home.newest".
   * @param {object} stateConfig State configuration object.
   * @param {string|function=} stateConfig.template
   * <a id='template'></a>
   *   html template as a string or a function that returns
   *   an html template as a string which should be used by the uiView directives. This property 
   *   takes precedence over templateUrl.
   *   
   *   If `template` is a function, it will be called with the following parameters:
   *
   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by
   *     applying the current state
   *
   * <pre>template:
   *   "<h1>inline template definition</h1>" +
   *   "<div ui-view></div>"</pre>
   * <pre>template: function(params) {
   *       return "<h1>generated template</h1>"; }</pre>
   * </div>
   *
   * @param {string|function=} stateConfig.templateUrl
   * <a id='templateUrl'></a>
   *
   *   path or function that returns a path to an html
   *   template that should be used by uiView.
   *   
   *   If `templateUrl` is a function, it will be called with the following parameters:
   *
   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by 
   *     applying the current state
   *
   * <pre>templateUrl: "home.html"</pre>
   * <pre>templateUrl: function(params) {
   *     return myTemplates[params.pageId]; }</pre>
   *
   * @param {function=} stateConfig.templateProvider
   * <a id='templateProvider'></a>
   *    Provider function that returns HTML content string.
   * <pre> templateProvider:
   *       function(MyTemplateService, params) {
   *         return MyTemplateService.getTemplate(params.pageId);
   *       }</pre>
   *
   * @param {string|function=} stateConfig.controller
   * <a id='controller'></a>
   *
   *  Controller fn that should be associated with newly
   *   related scope or the name of a registered controller if passed as a string.
   *   Optionally, the ControllerAs may be declared here.
   * <pre>controller: "MyRegisteredController"</pre>
   * <pre>controller:
   *     "MyRegisteredController as fooCtrl"}</pre>
   * <pre>controller: function($scope, MyService) {
   *     $scope.data = MyService.getData(); }</pre>
   *
   * @param {function=} stateConfig.controllerProvider
   * <a id='controllerProvider'></a>
   *
   * Injectable provider function that returns the actual controller or string.
   * <pre>controllerProvider:
   *   function(MyResolveData) {
   *     if (MyResolveData.foo)
   *       return "FooCtrl"
   *     else if (MyResolveData.bar)
   *       return "BarCtrl";
   *     else return function($scope) {
   *       $scope.baz = "Qux";
   *     }
   *   }</pre>
   *
   * @param {string=} stateConfig.controllerAs
   * <a id='controllerAs'></a>
   * 
   * A controller alias name. If present the controller will be
   *   published to scope under the controllerAs name.
   * <pre>controllerAs: "myCtrl"</pre>
   *
   * @param {string|object=} stateConfig.parent
   * <a id='parent'></a>
   * Optionally specifies the parent state of this state.
   *
   * <pre>parent: 'parentState'</pre>
   * <pre>parent: parentState // JS variable</pre>
   *
   * @param {object=} stateConfig.resolve
   * <a id='resolve'></a>
   *
   * An optional map&lt;string, function&gt; of dependencies which
   *   should be injected into the controller. If any of these dependencies are promises, 
   *   the router will wait for them all to be resolved before the controller is instantiated.
   *   If all the promises are resolved successfully, the $stateChangeSuccess event is fired
   *   and the values of the resolved promises are injected into any controllers that reference them.
   *   If any  of the promises are rejected the $stateChangeError event is fired.
   *
   *   The map object is:
   *   
   *   - key - {string}: name of dependency to be injected into controller
   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, 
   *     it is injected and return value it treated as dependency. If result is a promise, it is 
   *     resolved before its value is injected into controller.
   *
   * <pre>resolve: {
   *     myResolve1:
   *       function($http, $stateParams) {
   *         return $http.get("/api/foos/"+stateParams.fooID);
   *       }
   *     }</pre>
   *
   * @param {string=} stateConfig.url
   * <a id='url'></a>
   *
   *   A url fragment with optional parameters. When a state is navigated or
   *   transitioned to, the `$stateParams` service will be populated with any 
   *   parameters that were passed.
   *
   *   (See {@link ui.router.util.type:UrlMatcher UrlMatcher} `UrlMatcher`} for
   *   more details on acceptable patterns )
   *
   * examples:
   * <pre>url: "/home"
   * url: "/users/:userid"
   * url: "/books/{bookid:[a-zA-Z_-]}"
   * url: "/books/{categoryid:int}"
   * url: "/books/{publishername:string}/{categoryid:int}"
   * url: "/messages?before&after"
   * url: "/messages?{before:date}&{after:date}"
   * url: "/messages/:mailboxid?{before:date}&{after:date}"
   * </pre>
   *
   * @param {object=} stateConfig.views
   * <a id='views'></a>
   * an optional map&lt;string, object&gt; which defined multiple views, or targets views
   * manually/explicitly.
   *
   * Examples:
   *
   * Targets three named `ui-view`s in the parent state's template
   * <pre>views: {
   *     header: {
   *       controller: "headerCtrl",
   *       templateUrl: "header.html"
   *     }, body: {
   *       controller: "bodyCtrl",
   *       templateUrl: "body.html"
   *     }, footer: {
   *       controller: "footCtrl",
   *       templateUrl: "footer.html"
   *     }
   *   }</pre>
   *
   * Targets named `ui-view="header"` from grandparent state 'top''s template, and named `ui-view="body" from parent state's template.
   * <pre>views: {
   *     'header@top': {
   *       controller: "msgHeaderCtrl",
   *       templateUrl: "msgHeader.html"
   *     }, 'body': {
   *       controller: "messagesCtrl",
   *       templateUrl: "messages.html"
   *     }
   *   }</pre>
   *
   * @param {boolean=} [stateConfig.abstract=false]
   * <a id='abstract'></a>
   * An abstract state will never be directly activated,
   *   but can provide inherited properties to its common children states.
   * <pre>abstract: true</pre>
   *
   * @param {function=} stateConfig.onEnter
   * <a id='onEnter'></a>
   *
   * Callback function for when a state is entered. Good way
   *   to trigger an action or dispatch an event, such as opening a dialog.
   * If minifying your scripts, make sure to explicitly annotate this function,
   * because it won't be automatically annotated by your build tools.
   *
   * <pre>onEnter: function(MyService, $stateParams) {
   *     MyService.foo($stateParams.myParam);
   * }</pre>
   *
   * @param {function=} stateConfig.onExit
   * <a id='onExit'></a>
   *
   * Callback function for when a state is exited. Good way to
   *   trigger an action or dispatch an event, such as opening a dialog.
   * If minifying your scripts, make sure to explicitly annotate this function,
   * because it won't be automatically annotated by your build tools.
   *
   * <pre>onExit: function(MyService, $stateParams) {
   *     MyService.cleanup($stateParams.myParam);
   * }</pre>
   *
   * @param {boolean=} [stateConfig.reloadOnSearch=true]
   * <a id='reloadOnSearch'></a>
   *
   * If `false`, will not retrigger the same state
   *   just because a search/query parameter has changed (via $location.search() or $location.hash()). 
   *   Useful for when you'd like to modify $location.search() without triggering a reload.
   * <pre>reloadOnSearch: false</pre>
   *
   * @param {object=} stateConfig.data
   * <a id='data'></a>
   *
   * Arbitrary data object, useful for custom configuration.  The parent state's `data` is
   *   prototypally inherited.  In other words, adding a data property to a state adds it to
   *   the entire subtree via prototypal inheritance.
   *
   * <pre>data: {
   *     requiredRole: 'foo'
   * } </pre>
   *
   * @param {object=} stateConfig.params
   * <a id='params'></a>
   *
   * A map which optionally configures parameters declared in the `url`, or
   *   defines additional non-url parameters.  For each parameter being
   *   configured, add a configuration object keyed to the name of the parameter.
   *
   *   Each parameter configuration object may contain the following properties:
   *
   *   - ** value ** - {object|function=}: specifies the default value for this
   *     parameter.  This implicitly sets this parameter as optional.
   *
   *     When UI-Router routes to a state and no value is
   *     specified for this parameter in the URL or transition, the
   *     default value will be used instead.  If `value` is a function,
   *     it will be injected and invoked, and the return value used.
   *
   *     *Note*: `undefined` is treated as "no default value" while `null`
   *     is treated as "the default value is `null`".
   *
   *     *Shorthand*: If you only need to configure the default value of the
   *     parameter, you may use a shorthand syntax.   In the **`params`**
   *     map, instead mapping the param name to a full parameter configuration
   *     object, simply set map it to the default parameter value, e.g.:
   *
   * <pre>// define a parameter's default value
   * params: {
   *     param1: { value: "defaultValue" }
   * }
   * // shorthand default values
   * params: {
   *     param1: "defaultValue",
   *     param2: "param2Default"
   * }</pre>
   *
   *   - ** array ** - {boolean=}: *(default: false)* If true, the param value will be
   *     treated as an array of values.  If you specified a Type, the value will be
   *     treated as an array of the specified Type.  Note: query parameter values
   *     default to a special `"auto"` mode.
   *
   *     For query parameters in `"auto"` mode, if multiple  values for a single parameter
   *     are present in the URL (e.g.: `/foo?bar=1&bar=2&bar=3`) then the values
   *     are mapped to an array (e.g.: `{ foo: [ '1', '2', '3' ] }`).  However, if
   *     only one value is present (e.g.: `/foo?bar=1`) then the value is treated as single
   *     value (e.g.: `{ foo: '1' }`).
   *
   * <pre>params: {
   *     param1: { array: true }
   * }</pre>
   *
   *   - ** squash ** - {bool|string=}: `squash` configures how a default parameter value is represented in the URL when
   *     the current parameter value is the same as the default value. If `squash` is not set, it uses the
   *     configured default squash policy.
   *     (See {@link ui.router.util.$urlMatcherFactory#methods_defaultSquashPolicy `defaultSquashPolicy()`})
   *
   *   There are three squash settings:
   *
   *     - false: The parameter's default value is not squashed.  It is encoded and included in the URL
   *     - true: The parameter's default value is omitted from the URL.  If the parameter is preceeded and followed
   *       by slashes in the state's `url` declaration, then one of those slashes are omitted.
   *       This can allow for cleaner looking URLs.
   *     - `"<arbitrary string>"`: The parameter's default value is replaced with an arbitrary placeholder of  your choice.
   *
   * <pre>params: {
   *     param1: {
   *       value: "defaultId",
   *       squash: true
   * } }
   * // squash "defaultValue" to "~"
   * params: {
   *     param1: {
   *       value: "defaultValue",
   *       squash: "~"
   * } }
   * </pre>
   *
   *
   * @example
   * <pre>
   * // Some state name examples
   *
   * // stateName can be a single top-level name (must be unique).
   * $stateProvider.state("home", {});
   *
   * // Or it can be a nested state name. This state is a child of the
   * // above "home" state.
   * $stateProvider.state("home.newest", {});
   *
   * // Nest states as deeply as needed.
   * $stateProvider.state("home.newest.abc.xyz.inception", {});
   *
   * // state() returns $stateProvider, so you can chain state declarations.
   * $stateProvider
   *   .state("home", {})
   *   .state("about", {})
   *   .state("contacts", {});
   * </pre>
   *
   */
  this.state = state;
  function state(name, definition) {
    /*jshint validthis: true */
    if (isObject(name)) definition = name;
    else definition.name = name;
    registerState(definition);
    return this;
  }

  /**
   * @ngdoc object
   * @name ui.router.state.$state
   *
   * @requires $rootScope
   * @requires $q
   * @requires ui.router.state.$view
   * @requires $injector
   * @requires ui.router.util.$resolve
   * @requires ui.router.state.$stateParams
   * @requires ui.router.router.$urlRouter
   *
   * @property {object} params A param object, e.g. {sectionId: section.id)}, that 
   * you'd like to test against the current active state.
   * @property {object} current A reference to the state's config object. However 
   * you passed it in. Useful for accessing custom data.
   * @property {object} transition Currently pending transition. A promise that'll 
   * resolve or reject.
   *
   * @description
   * `$state` service is responsible for representing states as well as transitioning
   * between them. It also provides interfaces to ask for current state or even states
   * you're coming from.
   */
  this.$get = $get;
  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];
  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $urlRouter,   $location,   $urlMatcherFactory) {

    var TransitionSupersededError = new Error('transition superseded');

    var TransitionSuperseded = silenceUncaughtInPromise($q.reject(TransitionSupersededError));
    var TransitionPrevented = silenceUncaughtInPromise($q.reject(new Error('transition prevented')));
    var TransitionAborted = silenceUncaughtInPromise($q.reject(new Error('transition aborted')));
    var TransitionFailed = silenceUncaughtInPromise($q.reject(new Error('transition failed')));

    // Handles the case where a state which is the target of a transition is not found, and the user
    // can optionally retry or defer the transition
    function handleRedirect(redirect, state, params, options) {
      /**
       * @ngdoc event
       * @name ui.router.state.$state#$stateNotFound
       * @eventOf ui.router.state.$state
       * @eventType broadcast on root scope
       * @description
       * Fired when a requested state **cannot be found** using the provided state name during transition.
       * The event is broadcast allowing any handlers a single chance to deal with the error (usually by
       * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,
       * you can see its three properties in the example. You can use `event.preventDefault()` to abort the
       * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.
       *
       * @param {Object} event Event object.
       * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.
       * @param {State} fromState Current state object.
       * @param {Object} fromParams Current state params.
       *
       * @example
       *
       * <pre>
       * // somewhere, assume lazy.state has not been defined
       * $state.go("lazy.state", {a:1, b:2}, {inherit:false});
       *
       * // somewhere else
       * $scope.$on('$stateNotFound',
       * function(event, unfoundState, fromState, fromParams){
       *     console.log(unfoundState.to); // "lazy.state"
       *     console.log(unfoundState.toParams); // {a:1, b:2}
       *     console.log(unfoundState.options); // {inherit:false} + default options
       * })
       * </pre>
       */
      var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);

      if (evt.defaultPrevented) {
        $urlRouter.update();
        return TransitionAborted;
      }

      if (!evt.retry) {
        return null;
      }

      // Allow the handler to return a promise to defer state lookup retry
      if (options.$retry) {
        $urlRouter.update();
        return TransitionFailed;
      }
      var retryTransition = $state.transition = $q.when(evt.retry);

      retryTransition.then(function() {
        if (retryTransition !== $state.transition) {
          $rootScope.$broadcast('$stateChangeCancel', redirect.to, redirect.toParams, state, params);
          return TransitionSuperseded;
        }
        redirect.options.$retry = true;
        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);
      }, function() {
        return TransitionAborted;
      });
      $urlRouter.update();

      return retryTransition;
    }

    root.locals = { resolve: null, globals: { $stateParams: {} } };

    $state = {
      params: {},
      current: root.self,
      $current: root,
      transition: null
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#reload
     * @methodOf ui.router.state.$state
     *
     * @description
     * A method that force reloads the current state. All resolves are re-resolved,
     * controllers reinstantiated, and events re-fired.
     *
     * @example
     * <pre>
     * var app angular.module('app', ['ui.router']);
     *
     * app.controller('ctrl', function ($scope, $state) {
     *   $scope.reload = function(){
     *     $state.reload();
     *   }
     * });
     * </pre>
     *
     * `reload()` is just an alias for:
     * <pre>
     * $state.transitionTo($state.current, $stateParams, { 
     *   reload: true, inherit: false, notify: true
     * });
     * </pre>
     *
     * @param {string=|object=} state - A state name or a state object, which is the root of the resolves to be re-resolved.
     * @example
     * <pre>
     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item' 
     * //and current state is 'contacts.detail.item'
     * var app angular.module('app', ['ui.router']);
     *
     * app.controller('ctrl', function ($scope, $state) {
     *   $scope.reload = function(){
     *     //will reload 'contact.detail' and 'contact.detail.item' states
     *     $state.reload('contact.detail');
     *   }
     * });
     * </pre>
     *
     * `reload()` is just an alias for:
     * <pre>
     * $state.transitionTo($state.current, $stateParams, { 
     *   reload: true, inherit: false, notify: true
     * });
     * </pre>

     * @returns {promise} A promise representing the state of the new transition. See
     * {@link ui.router.state.$state#methods_go $state.go}.
     */
    $state.reload = function reload(state) {
      return $state.transitionTo($state.current, $stateParams, { reload: state || true, inherit: false, notify: true});
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#go
     * @methodOf ui.router.state.$state
     *
     * @description
     * Convenience method for transitioning to a new state. `$state.go` calls 
     * `$state.transitionTo` internally but automatically sets options to 
     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. 
     * This allows you to easily use an absolute or relative to path and specify 
     * only the parameters you'd like to update (while letting unspecified parameters 
     * inherit from the currently active ancestor states).
     *
     * @example
     * <pre>
     * var app = angular.module('app', ['ui.router']);
     *
     * app.controller('ctrl', function ($scope, $state) {
     *   $scope.changeState = function () {
     *     $state.go('contact.detail');
     *   };
     * });
     * </pre>
     * <img src='../ngdoc_assets/StateGoExamples.png'/>
     *
     * @param {string} to Absolute state name or relative state path. Some examples:
     *
     * - `$state.go('contact.detail')` - will go to the `contact.detail` state
     * - `$state.go('^')` - will go to a parent state
     * - `$state.go('^.sibling')` - will go to a sibling state
     * - `$state.go('.child.grandchild')` - will go to grandchild state
     *
     * @param {object=} params A map of the parameters that will be sent to the state, 
     * will populate $stateParams. Any parameters that are not specified will be inherited from currently 
     * defined parameters. Only parameters specified in the state definition can be overridden, new 
     * parameters will be ignored. This allows, for example, going to a sibling state that shares parameters
     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.
     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child
     * will get you all current parameters, etc.
     * @param {object=} options Options object. The options are:
     *
     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`
     *    will not. If string, must be `"replace"`, which will update url and also replace last history record.
     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.
     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), 
     *    defines which state to be relative from.
     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.
     * - **`reload`** (v0.2.5) - {boolean=false|string|object}, If `true` will force transition even if no state or params
     *    have changed.  It will reload the resolves and views of the current state and parent states.
     *    If `reload` is a string (or state object), the state object is fetched (by name, or object reference); and \
     *    the transition reloads the resolves and views for that matched state, and all its children states.
     *
     * @returns {promise} A promise representing the state of the new transition.
     *
     * Possible success values:
     *
     * - $state.current
     *
     * <br/>Possible rejection values:
     *
     * - 'transition superseded' - when a newer transition has been started after this one
     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener
     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or
     *   when a `$stateNotFound` `event.retry` promise errors.
     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.
     * - *resolve error* - when an error has occurred with a `resolve`
     *
     */
    $state.go = function go(to, params, options) {
      return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#transitionTo
     * @methodOf ui.router.state.$state
     *
     * @description
     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}
     * uses `transitionTo` internally. `$state.go` is recommended in most situations.
     *
     * @example
     * <pre>
     * var app = angular.module('app', ['ui.router']);
     *
     * app.controller('ctrl', function ($scope, $state) {
     *   $scope.changeState = function () {
     *     $state.transitionTo('contact.detail');
     *   };
     * });
     * </pre>
     *
     * @param {string} to State name.
     * @param {object=} toParams A map of the parameters that will be sent to the state,
     * will populate $stateParams.
     * @param {object=} options Options object. The options are:
     *
     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`
     *    will not. If string, must be `"replace"`, which will update url and also replace last history record.
     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.
     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), 
     *    defines which state to be relative from.
     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.
     * - **`reload`** (v0.2.5) - {boolean=false|string=|object=}, If `true` will force transition even if the state or params 
     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd
     *    use this when you want to force a reload when *everything* is the same, including search params.
     *    if String, then will reload the state with the name given in reload, and any children.
     *    if Object, then a stateObj is expected, will reload the state found in stateObj, and any children.
     *
     * @returns {promise} A promise representing the state of the new transition. See
     * {@link ui.router.state.$state#methods_go $state.go}.
     */
    $state.transitionTo = function transitionTo(to, toParams, options) {
      toParams = toParams || {};
      options = extend({
        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false
      }, options || {});

      var from = $state.$current, fromParams = $state.params, fromPath = from.path;
      var evt, toState = findState(to, options.relative);

      // Store the hash param for later (since it will be stripped out by various methods)
      var hash = toParams['#'];

      if (!isDefined(toState)) {
        var redirect = { to: to, toParams: toParams, options: options };
        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);

        if (redirectResult) {
          return redirectResult;
        }

        // Always retry once if the $stateNotFound was not prevented
        // (handles either redirect changed or state lazy-definition)
        to = redirect.to;
        toParams = redirect.toParams;
        options = redirect.options;
        toState = findState(to, options.relative);

        if (!isDefined(toState)) {
          if (!options.relative) throw new Error("No such state '" + to + "'");
          throw new Error("Could not resolve '" + to + "' from state '" + options.relative + "'");
        }
      }
      if (toState[abstractKey]) throw new Error("Cannot transition to abstract state '" + to + "'");
      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);
      if (!toState.params.$$validates(toParams)) return TransitionFailed;

      toParams = toState.params.$$values(toParams);
      to = toState;

      var toPath = to.path;

      // Starting from the root of the path, keep all levels that haven't changed
      var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];

      if (!options.reload) {
        while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {
          locals = toLocals[keep] = state.locals;
          keep++;
          state = toPath[keep];
        }
      } else if (isString(options.reload) || isObject(options.reload)) {
        if (isObject(options.reload) && !options.reload.name) {
          throw new Error('Invalid reload state object');
        }
        
        var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);
        if (options.reload && !reloadState) {
          throw new Error("No such reload state '" + (isString(options.reload) ? options.reload : options.reload.name) + "'");
        }

        while (state && state === fromPath[keep] && state !== reloadState) {
          locals = toLocals[keep] = state.locals;
          keep++;
          state = toPath[keep];
        }
      }

      // If we're going to the same state and all locals are kept, we've got nothing to do.
      // But clear 'transition', as we still want to cancel any other pending transitions.
      // TODO: We may not want to bump 'transition' if we're called from a location change
      // that we've initiated ourselves, because we might accidentally abort a legitimate
      // transition initiated from code?
      if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {
        if (hash) toParams['#'] = hash;
        $state.params = toParams;
        copy($state.params, $stateParams);
        copy(filterByKeys(to.params.$$keys(), $stateParams), to.locals.globals.$stateParams);
        if (options.location && to.navigable && to.navigable.url) {
          $urlRouter.push(to.navigable.url, toParams, {
            $$avoidResync: true, replace: options.location === 'replace'
          });
          $urlRouter.update(true);
        }
        $state.transition = null;
        return $q.when($state.current);
      }

      // Filter parameters before we pass them to event handlers etc.
      toParams = filterByKeys(to.params.$$keys(), toParams || {});
      
      // Re-add the saved hash before we start returning things or broadcasting $stateChangeStart
      if (hash) toParams['#'] = hash;
      
      // Broadcast start event and cancel the transition if requested
      if (options.notify) {
        /**
         * @ngdoc event
         * @name ui.router.state.$state#$stateChangeStart
         * @eventOf ui.router.state.$state
         * @eventType broadcast on root scope
         * @description
         * Fired when the state transition **begins**. You can use `event.preventDefault()`
         * to prevent the transition from happening and then the transition promise will be
         * rejected with a `'transition prevented'` value.
         *
         * @param {Object} event Event object.
         * @param {State} toState The state being transitioned to.
         * @param {Object} toParams The params supplied to the `toState`.
         * @param {State} fromState The current state, pre-transition.
         * @param {Object} fromParams The params supplied to the `fromState`.
         *
         * @example
         *
         * <pre>
         * $rootScope.$on('$stateChangeStart',
         * function(event, toState, toParams, fromState, fromParams){
         *     event.preventDefault();
         *     // transitionTo() promise will be rejected with
         *     // a 'transition prevented' error
         * })
         * </pre>
         */
        if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams, options).defaultPrevented) {
          $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);
          //Don't update and resync url if there's been a new transition started. see issue #2238, #600
          if ($state.transition == null) $urlRouter.update();
          return TransitionPrevented;
        }
      }

      // Resolve locals for the remaining states, but don't update any global state just
      // yet -- if anything fails to resolve the current state needs to remain untouched.
      // We also set up an inheritance chain for the locals here. This allows the view directive
      // to quickly look up the correct definition for each view in the current state. Even
      // though we create the locals object itself outside resolveState(), it is initially
      // empty and gets filled asynchronously. We need to keep track of the promise for the
      // (fully resolved) current locals, and pass this down the chain.
      var resolved = $q.when(locals);

      for (var l = keep; l < toPath.length; l++, state = toPath[l]) {
        locals = toLocals[l] = inherit(locals);
        resolved = resolveState(state, toParams, state === to, resolved, locals, options);
      }

      // Once everything is resolved, we are ready to perform the actual transition
      // and return a promise for the new state. We also keep track of what the
      // current promise is, so that we can detect overlapping transitions and
      // keep only the outcome of the last transition.
      var transition = $state.transition = resolved.then(function () {
        var l, entering, exiting;

        if ($state.transition !== transition) {
          $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);
          return TransitionSuperseded;
        }

        // Exit 'from' states not kept
        for (l = fromPath.length - 1; l >= keep; l--) {
          exiting = fromPath[l];
          if (exiting.self.onExit) {
            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);
          }
          exiting.locals = null;
        }

        // Enter 'to' states not kept
        for (l = keep; l < toPath.length; l++) {
          entering = toPath[l];
          entering.locals = toLocals[l];
          if (entering.self.onEnter) {
            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
          }
        }

        // Run it again, to catch any transitions in callbacks
        if ($state.transition !== transition) {
          $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);
          return TransitionSuperseded;
        }

        // Update globals in $state
        $state.$current = to;
        $state.current = to.self;
        $state.params = toParams;
        copy($state.params, $stateParams);
        $state.transition = null;

        if (options.location && to.navigable) {
          $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {
            $$avoidResync: true, replace: options.location === 'replace'
          });
        }

        if (options.notify) {
        /**
         * @ngdoc event
         * @name ui.router.state.$state#$stateChangeSuccess
         * @eventOf ui.router.state.$state
         * @eventType broadcast on root scope
         * @description
         * Fired once the state transition is **complete**.
         *
         * @param {Object} event Event object.
         * @param {State} toState The state being transitioned to.
         * @param {Object} toParams The params supplied to the `toState`.
         * @param {State} fromState The current state, pre-transition.
         * @param {Object} fromParams The params supplied to the `fromState`.
         */
          $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);
        }
        $urlRouter.update(true);

        return $state.current;
      }).then(null, function (error) {
        // propagate TransitionSuperseded error without emitting $stateChangeCancel
        // as it was already emitted in the success handler above
        if (error === TransitionSupersededError) return TransitionSuperseded;

        if ($state.transition !== transition) {
          $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);
          return TransitionSuperseded;
        }

        $state.transition = null;
        /**
         * @ngdoc event
         * @name ui.router.state.$state#$stateChangeError
         * @eventOf ui.router.state.$state
         * @eventType broadcast on root scope
         * @description
         * Fired when an **error occurs** during transition. It's important to note that if you
         * have any errors in your resolve functions (javascript errors, non-existent services, etc)
         * they will not throw traditionally. You must listen for this $stateChangeError event to
         * catch **ALL** errors.
         *
         * @param {Object} event Event object.
         * @param {State} toState The state being transitioned to.
         * @param {Object} toParams The params supplied to the `toState`.
         * @param {State} fromState The current state, pre-transition.
         * @param {Object} fromParams The params supplied to the `fromState`.
         * @param {Error} error The resolve error object.
         */
        evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);

        if (!evt.defaultPrevented) {
          $urlRouter.update();
        }

        return $q.reject(error);
      });

      silenceUncaughtInPromise(transition);
      return transition;
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#is
     * @methodOf ui.router.state.$state
     *
     * @description
     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},
     * but only checks for the full state name. If params is supplied then it will be
     * tested for strict equality against the current active params object, so all params
     * must match with none missing and no extras.
     *
     * @example
     * <pre>
     * $state.$current.name = 'contacts.details.item';
     *
     * // absolute name
     * $state.is('contact.details.item'); // returns true
     * $state.is(contactDetailItemStateObject); // returns true
     *
     * // relative name (. and ^), typically from a template
     * // E.g. from the 'contacts.details' template
     * <div ng-class="{highlighted: $state.is('.item')}">Item</div>
     * </pre>
     *
     * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.
     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like
     * to test against the current active state.
     * @param {object=} options An options object.  The options are:
     *
     * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will
     * test relative to `options.relative` state (or name).
     *
     * @returns {boolean} Returns true if it is the state.
     */
    $state.is = function is(stateOrName, params, options) {
      options = extend({ relative: $state.$current }, options || {});
      var state = findState(stateOrName, options.relative);

      if (!isDefined(state)) { return undefined; }
      if ($state.$current !== state) { return false; }

      return !params || objectKeys(params).reduce(function(acc, key) {
        var paramDef = state.params[key];
        return acc && !paramDef || paramDef.type.equals($stateParams[key], params[key]);
      }, true);
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#includes
     * @methodOf ui.router.state.$state
     *
     * @description
     * A method to determine if the current active state is equal to or is the child of the
     * state stateName. If any params are passed then they will be tested for a match as well.
     * Not all the parameters need to be passed, just the ones you'd like to test for equality.
     *
     * @example
     * Partial and relative names
     * <pre>
     * $state.$current.name = 'contacts.details.item';
     *
     * // Using partial names
     * $state.includes("contacts"); // returns true
     * $state.includes("contacts.details"); // returns true
     * $state.includes("contacts.details.item"); // returns true
     * $state.includes("contacts.list"); // returns false
     * $state.includes("about"); // returns false
     *
     * // Using relative names (. and ^), typically from a template
     * // E.g. from the 'contacts.details' template
     * <div ng-class="{highlighted: $state.includes('.item')}">Item</div>
     * </pre>
     *
     * Basic globbing patterns
     * <pre>
     * $state.$current.name = 'contacts.details.item.url';
     *
     * $state.includes("*.details.*.*"); // returns true
     * $state.includes("*.details.**"); // returns true
     * $state.includes("**.item.**"); // returns true
     * $state.includes("*.details.item.url"); // returns true
     * $state.includes("*.details.*.url"); // returns true
     * $state.includes("*.details.*"); // returns false
     * $state.includes("item.**"); // returns false
     * </pre>
     *
     * @param {string} stateOrName A partial name, relative name, or glob pattern
     * to be searched for within the current state name.
     * @param {object=} params A param object, e.g. `{sectionId: section.id}`,
     * that you'd like to test against the current active state.
     * @param {object=} options An options object.  The options are:
     *
     * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,
     * .includes will test relative to `options.relative` state (or name).
     *
     * @returns {boolean} Returns true if it does include the state
     */
    $state.includes = function includes(stateOrName, params, options) {
      options = extend({ relative: $state.$current }, options || {});
      if (isString(stateOrName) && isGlob(stateOrName)) {
        if (!doesStateMatchGlob(stateOrName)) {
          return false;
        }
        stateOrName = $state.$current.name;
      }

      var state = findState(stateOrName, options.relative);
      if (!isDefined(state)) { return undefined; }
      if (!isDefined($state.$current.includes[state.name])) { return false; }
      if (!params) { return true; }

      var keys = objectKeys(params);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i], paramDef = state.params[key];
        if (paramDef && !paramDef.type.equals($stateParams[key], params[key])) {
          return false;
        }
      }

      return objectKeys(params).reduce(function(acc, key) {
        var paramDef = state.params[key];
        return acc && !paramDef || paramDef.type.equals($stateParams[key], params[key]);
      }, true);
    };


    /**
     * @ngdoc function
     * @name ui.router.state.$state#href
     * @methodOf ui.router.state.$state
     *
     * @description
     * A url generation method that returns the compiled url for the given state populated with the given params.
     *
     * @example
     * <pre>
     * expect($state.href("about.person", { person: "bob" })).toEqual("/about/bob");
     * </pre>
     *
     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.
     * @param {object=} params An object of parameter values to fill the state's required parameters.
     * @param {object=} options Options object. The options are:
     *
     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the
     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka
     *    ancestor with a valid url).
     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.
     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), 
     *    defines which state to be relative from.
     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. "http://www.example.com/fullurl".
     * 
     * @returns {string} compiled state url
     */
    $state.href = function href(stateOrName, params, options) {
      options = extend({
        lossy:    true,
        inherit:  true,
        absolute: false,
        relative: $state.$current
      }, options || {});

      var state = findState(stateOrName, options.relative);

      if (!isDefined(state)) return null;
      if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);
      
      var nav = (state && options.lossy) ? state.navigable : state;

      if (!nav || nav.url === undefined || nav.url === null) {
        return null;
      }
      return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {
        absolute: options.absolute
      });
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#get
     * @methodOf ui.router.state.$state
     *
     * @description
     * Returns the state configuration object for any specific state or all states.
     *
     * @param {string|object=} stateOrName (absolute or relative) If provided, will only get the config for
     * the requested state. If not provided, returns an array of ALL state configs.
     * @param {string|object=} context When stateOrName is a relative state reference, the state will be retrieved relative to context.
     * @returns {Object|Array} State configuration object or array of all objects.
     */
    $state.get = function (stateOrName, context) {
      if (arguments.length === 0) return map(objectKeys(states), function(name) { return states[name].self; });
      var state = findState(stateOrName, context || $state.$current);
      return (state && state.self) ? state.self : null;
    };

    function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {
      // Make a restricted $stateParams with only the parameters that apply to this state if
      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,
      // we also need $stateParams to be available for any $injector calls we make during the
      // dependency resolution process.
      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);
      var locals = { $stateParams: $stateParams };

      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.
      // We're also including $stateParams in this; that way the parameters are restricted
      // to the set that should be visible to the state, and are independent of when we update
      // the global $state and $stateParams values.
      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
      var promises = [dst.resolve.then(function (globals) {
        dst.globals = globals;
      })];
      if (inherited) promises.push(inherited);

      function resolveViews() {
        var viewsPromises = [];

        // Resolve template and dependencies for all views.
        forEach(state.views, function (view, name) {
          var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});
          injectables.$template = [ function () {
            return $view.load(name, { view: view, locals: dst.globals, params: $stateParams, notify: options.notify }) || '';
          }];

          viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {
            // References to the controller (only instantiated at link time)
            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
              var injectLocals = angular.extend({}, injectables, dst.globals);
              result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);
            } else {
              result.$$controller = view.controller;
            }
            // Provide access to the state itself for internal use
            result.$$state = state;
            result.$$controllerAs = view.controllerAs;
            result.$$resolveAs = view.resolveAs;
            dst[name] = result;
          }));
        });

        return $q.all(viewsPromises).then(function(){
          return dst.globals;
        });
      }

      // Wait for all the promises and then return the activation object
      return $q.all(promises).then(resolveViews).then(function (values) {
        return dst;
      });
    }

    return $state;
  }

  function shouldSkipReload(to, toParams, from, fromParams, locals, options) {
    // Return true if there are no differences in non-search (path/object) params, false if there are differences
    function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {
      // Identify whether all the parameters that differ between `fromParams` and `toParams` were search params.
      function notSearchParam(key) {
        return fromAndToState.params[key].location != "search";
      }
      var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);
      var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));
      var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);
      return nonQueryParamSet.$$equals(fromParams, toParams);
    }

    // If reload was not explicitly requested
    // and we're transitioning to the same state we're already in
    // and    the locals didn't change
    //     or they changed in a way that doesn't merit reloading
    //        (reloadOnParams:false, or reloadOnSearch.false and only search params changed)
    // Then return true.
    if (!options.reload && to === from &&
      (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {
      return true;
    }
  }
}

angular.module('ui.router.state')
  .factory('$stateParams', function () { return {}; })
  .constant("$state.runtime", { autoinject: true })
  .provider('$state', $StateProvider)
  // Inject $state to initialize when entering runtime. #2574
  .run(['$injector', function ($injector) {
    // Allow tests (stateSpec.js) to turn this off by defining this constant
    if ($injector.get("$state.runtime").autoinject) {
      $injector.get('$state');
    }
  }]);


$ViewProvider.$inject = [];
function $ViewProvider() {

  this.$get = $get;
  /**
   * @ngdoc object
   * @name ui.router.state.$view
   *
   * @requires ui.router.util.$templateFactory
   * @requires $rootScope
   *
   * @description
   *
   */
  $get.$inject = ['$rootScope', '$templateFactory'];
  function $get(   $rootScope,   $templateFactory) {
    return {
      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })
      /**
       * @ngdoc function
       * @name ui.router.state.$view#load
       * @methodOf ui.router.state.$view
       *
       * @description
       *
       * @param {string} name name
       * @param {object} options option object.
       */
      load: function load(name, options) {
        var result, defaults = {
          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}
        };
        options = extend(defaults, options);

        if (options.view) {
          result = $templateFactory.fromConfig(options.view, options.params, options.locals);
        }
        return result;
      }
    };
  }
}

angular.module('ui.router.state').provider('$view', $ViewProvider);

/**
 * @ngdoc object
 * @name ui.router.state.$uiViewScrollProvider
 *
 * @description
 * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.
 */
function $ViewScrollProvider() {

  var useAnchorScroll = false;

  /**
   * @ngdoc function
   * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll
   * @methodOf ui.router.state.$uiViewScrollProvider
   *
   * @description
   * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for
   * scrolling based on the url anchor.
   */
  this.useAnchorScroll = function () {
    useAnchorScroll = true;
  };

  /**
   * @ngdoc object
   * @name ui.router.state.$uiViewScroll
   *
   * @requires $anchorScroll
   * @requires $timeout
   *
   * @description
   * When called with a jqLite element, it scrolls the element into view (after a
   * `$timeout` so the DOM has time to refresh).
   *
   * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,
   * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.
   */
  this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {
    if (useAnchorScroll) {
      return $anchorScroll;
    }

    return function ($element) {
      return $timeout(function () {
        $element[0].scrollIntoView();
      }, 0, false);
    };
  }];
}

angular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);

/**
 * @ngdoc directive
 * @name ui.router.state.directive:ui-view
 *
 * @requires ui.router.state.$state
 * @requires $compile
 * @requires $controller
 * @requires $injector
 * @requires ui.router.state.$uiViewScroll
 * @requires $document
 *
 * @restrict ECA
 *
 * @description
 * The ui-view directive tells $state where to place your templates.
 *
 * @param {string=} name A view name. The name should be unique amongst the other views in the
 * same state. You can have views of the same name that live in different states.
 *
 * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window
 * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll
 * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you
 * scroll ui-view elements into view when they are populated during a state activation.
 *
 * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)
 * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*
 *
 * @param {string=} onload Expression to evaluate whenever the view updates.
 *
 * @example
 * A view can be unnamed or named.
 * <pre>
 * <!-- Unnamed -->
 * <div ui-view></div>
 *
 * <!-- Named -->
 * <div ui-view="viewName"></div>
 * </pre>
 *
 * You can only have one unnamed view within any template (or root html). If you are only using a
 * single view and it is unnamed then you can populate it like so:
 * <pre>
 * <div ui-view></div>
 * $stateProvider.state("home", {
 *   template: "<h1>HELLO!</h1>"
 * })
 * </pre>
 *
 * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#methods_state `views`}
 * config property, by name, in this case an empty name:
 * <pre>
 * $stateProvider.state("home", {
 *   views: {
 *     "": {
 *       template: "<h1>HELLO!</h1>"
 *     }
 *   }    
 * })
 * </pre>
 *
 * But typically you'll only use the views property if you name your view or have more than one view
 * in the same template. There's not really a compelling reason to name a view if its the only one,
 * but you could if you wanted, like so:
 * <pre>
 * <div ui-view="main"></div>
 * </pre>
 * <pre>
 * $stateProvider.state("home", {
 *   views: {
 *     "main": {
 *       template: "<h1>HELLO!</h1>"
 *     }
 *   }    
 * })
 * </pre>
 *
 * Really though, you'll use views to set up multiple views:
 * <pre>
 * <div ui-view></div>
 * <div ui-view="chart"></div>
 * <div ui-view="data"></div>
 * </pre>
 *
 * <pre>
 * $stateProvider.state("home", {
 *   views: {
 *     "": {
 *       template: "<h1>HELLO!</h1>"
 *     },
 *     "chart": {
 *       template: "<chart_thing/>"
 *     },
 *     "data": {
 *       template: "<data_thing/>"
 *     }
 *   }    
 * })
 * </pre>
 *
 * Examples for `autoscroll`:
 *
 * <pre>
 * <!-- If autoscroll present with no expression,
 *      then scroll ui-view into view -->
 * <ui-view autoscroll/>
 *
 * <!-- If autoscroll present with valid expression,
 *      then scroll ui-view into view if expression evaluates to true -->
 * <ui-view autoscroll='true'/>
 * <ui-view autoscroll='false'/>
 * <ui-view autoscroll='scopeVariable'/>
 * </pre>
 *
 * Resolve data:
 *
 * The resolved data from the state's `resolve` block is placed on the scope as `$resolve` (this
 * can be customized using [[ViewDeclaration.resolveAs]]).  This can be then accessed from the template.
 *
 * Note that when `controllerAs` is being used, `$resolve` is set on the controller instance *after* the
 * controller is instantiated.  The `$onInit()` hook can be used to perform initialization code which
 * depends on `$resolve` data.
 *
 * Example usage of $resolve in a view template
 * <pre>
 * $stateProvider.state('home', {
 *   template: '<my-component user="$resolve.user"></my-component>',
 *   resolve: {
 *     user: function(UserService) { return UserService.fetchUser(); }
 *   }
 * });
 * </pre>
 */
$ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate', '$q'];
function $ViewDirective(   $state,   $injector,   $uiViewScroll,   $interpolate,   $q) {

  function getService() {
    return ($injector.has) ? function(service) {
      return $injector.has(service) ? $injector.get(service) : null;
    } : function(service) {
      try {
        return $injector.get(service);
      } catch (e) {
        return null;
      }
    };
  }

  var service = getService(),
      $animator = service('$animator'),
      $animate = service('$animate');

  // Returns a set of DOM manipulation functions based on which Angular version
  // it should use
  function getRenderer(attrs, scope) {
    var statics = function() {
      return {
        enter: function (element, target, cb) { target.after(element); cb(); },
        leave: function (element, cb) { element.remove(); cb(); }
      };
    };

    if ($animate) {
      return {
        enter: function(element, target, cb) {
          if (angular.version.minor > 2) {
            $animate.enter(element, null, target).then(cb);
          } else {
            $animate.enter(element, null, target, cb);
          }
        },
        leave: function(element, cb) {
          if (angular.version.minor > 2) {
            $animate.leave(element).then(cb);
          } else {
            $animate.leave(element, cb);
          }
        }
      };
    }

    if ($animator) {
      var animate = $animator && $animator(scope, attrs);

      return {
        enter: function(element, target, cb) {animate.enter(element, null, target); cb(); },
        leave: function(element, cb) { animate.leave(element); cb(); }
      };
    }

    return statics();
  }

  var directive = {
    restrict: 'ECA',
    terminal: true,
    priority: 400,
    transclude: 'element',
    compile: function (tElement, tAttrs, $transclude) {
      return function (scope, $element, attrs) {
        var previousEl, currentEl, currentScope, latestLocals,
            onloadExp     = attrs.onload || '',
            autoScrollExp = attrs.autoscroll,
            renderer      = getRenderer(attrs, scope),
            inherited     = $element.inheritedData('$uiView');

        scope.$on('$stateChangeSuccess', function() {
          updateView(false);
        });

        updateView(true);

        function cleanupLastView() {
          if (previousEl) {
            previousEl.remove();
            previousEl = null;
          }

          if (currentScope) {
            currentScope.$destroy();
            currentScope = null;
          }

          if (currentEl) {
            var $uiViewData = currentEl.data('$uiViewAnim');
            renderer.leave(currentEl, function() {
              $uiViewData.$$animLeave.resolve();
              previousEl = null;
            });

            previousEl = currentEl;
            currentEl = null;
          }
        }

        function updateView(firstTime) {
          var newScope,
              name            = getUiViewName(scope, attrs, $element, $interpolate),
              previousLocals  = name && $state.$current && $state.$current.locals[name];

          if (!firstTime && previousLocals === latestLocals) return; // nothing to do
          newScope = scope.$new();
          latestLocals = $state.$current.locals[name];

          /**
           * @ngdoc event
           * @name ui.router.state.directive:ui-view#$viewContentLoading
           * @eventOf ui.router.state.directive:ui-view
           * @eventType emits on ui-view directive scope
           * @description
           *
           * Fired once the view **begins loading**, *before* the DOM is rendered.
           *
           * @param {Object} event Event object.
           * @param {string} viewName Name of the view.
           */
          newScope.$emit('$viewContentLoading', name);

          var clone = $transclude(newScope, function(clone) {
            var animEnter = $q.defer(), animLeave = $q.defer();
            var viewAnimData = {
              $animEnter: animEnter.promise,
              $animLeave: animLeave.promise,
              $$animLeave: animLeave
            };

            clone.data('$uiViewAnim', viewAnimData);
            renderer.enter(clone, $element, function onUiViewEnter() {
              animEnter.resolve();
              if(currentScope) {
                currentScope.$emit('$viewContentAnimationEnded');
              }

              if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {
                $uiViewScroll(clone);
              }
            });
            cleanupLastView();
          });

          currentEl = clone;
          currentScope = newScope;
          /**
           * @ngdoc event
           * @name ui.router.state.directive:ui-view#$viewContentLoaded
           * @eventOf ui.router.state.directive:ui-view
           * @eventType emits on ui-view directive scope
           * @description
           * Fired once the view is **loaded**, *after* the DOM is rendered.
           *
           * @param {Object} event Event object.
           * @param {string} viewName Name of the view.
           */
          currentScope.$emit('$viewContentLoaded', name);
          currentScope.$eval(onloadExp);
        }
      };
    }
  };

  return directive;
}

$ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];
function $ViewDirectiveFill (  $compile,   $controller,   $state,   $interpolate) {
  return {
    restrict: 'ECA',
    priority: -400,
    compile: function (tElement) {
      var initial = tElement.html();
      if (tElement.empty) {
        tElement.empty();
      } else {
        // ng 1.0.0 doesn't have empty(), which cleans up data and handlers
        tElement[0].innerHTML = null;
      }

      return function (scope, $element, attrs) {
        var current = $state.$current,
            name = getUiViewName(scope, attrs, $element, $interpolate),
            locals  = current && current.locals[name];

        if (! locals) {
          $element.html(initial);
          $compile($element.contents())(scope);
          return;
        }

        $element.data('$uiView', { name: name, state: locals.$$state });
        $element.html(locals.$template ? locals.$template : initial);

        var resolveData = angular.extend({}, locals);
        scope[locals.$$resolveAs] = resolveData;

        var link = $compile($element.contents());

        if (locals.$$controller) {
          locals.$scope = scope;
          locals.$element = $element;
          var controller = $controller(locals.$$controller, locals);
          if (locals.$$controllerAs) {
            scope[locals.$$controllerAs] = controller;
            scope[locals.$$controllerAs][locals.$$resolveAs] = resolveData;
          }
          if (isFunction(controller.$onInit)) controller.$onInit();
          $element.data('$ngControllerController', controller);
          $element.children().data('$ngControllerController', controller);
        }

        link(scope);
      };
    }
  };
}

/**
 * Shared ui-view code for both directives:
 * Given scope, element, and its attributes, return the view's name
 */
function getUiViewName(scope, attrs, element, $interpolate) {
  var name = $interpolate(attrs.uiView || attrs.name || '')(scope);
  var uiViewCreatedBy = element.inheritedData('$uiView');
  return name.indexOf('@') >= 0 ?  name :  (name + '@' + (uiViewCreatedBy ? uiViewCreatedBy.state.name : ''));
}

angular.module('ui.router.state').directive('uiView', $ViewDirective);
angular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);

function parseStateRef(ref, current) {
  var preparsed = ref.match(/^\s*({[^}]*})\s*$/), parsed;
  if (preparsed) ref = current + '(' + preparsed[1] + ')';
  parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/);
  if (!parsed || parsed.length !== 4) throw new Error("Invalid state ref '" + ref + "'");
  return { state: parsed[1], paramExpr: parsed[3] || null };
}

function stateContext(el) {
  var stateData = el.parent().inheritedData('$uiView');

  if (stateData && stateData.state && stateData.state.name) {
    return stateData.state;
  }
}

function getTypeInfo(el) {
  // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.
  var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';
  var isForm = el[0].nodeName === "FORM";

  return {
    attr: isForm ? "action" : (isSvg ? 'xlink:href' : 'href'),
    isAnchor: el.prop("tagName").toUpperCase() === "A",
    clickable: !isForm
  };
}

function clickHook(el, $state, $timeout, type, current) {
  return function(e) {
    var button = e.which || e.button, target = current();

    if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {
      // HACK: This is to allow ng-clicks to be processed before the transition is initiated:
      var transition = $timeout(function() {
        $state.go(target.state, target.params, target.options);
      });
      e.preventDefault();

      // if the state has no URL, ignore one preventDefault from the <a> directive.
      var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1: 0;

      e.preventDefault = function() {
        if (ignorePreventDefaultCount-- <= 0) $timeout.cancel(transition);
      };
    }
  };
}

function defaultOpts(el, $state) {
  return { relative: stateContext(el) || $state.$current, inherit: true };
}

/**
 * @ngdoc directive
 * @name ui.router.state.directive:ui-sref
 *
 * @requires ui.router.state.$state
 * @requires $timeout
 *
 * @restrict A
 *
 * @description
 * A directive that binds a link (`<a>` tag) to a state. If the state has an associated
 * URL, the directive will automatically generate & update the `href` attribute via
 * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking
 * the link will trigger a state transition with optional parameters.
 *
 * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be
 * handled natively by the browser.
 *
 * You can also use relative state paths within ui-sref, just like the relative
 * paths passed to `$state.go()`. You just need to be aware that the path is relative
 * to the state that the link lives in, in other words the state that loaded the
 * template containing the link.
 *
 * You can specify options to pass to {@link ui.router.state.$state#methods_go $state.go()}
 * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,
 * and `reload`.
 *
 * @example
 * Here's an example of how you'd use ui-sref and how it would compile. If you have the
 * following template:
 * <pre>
 * <a ui-sref="home">Home</a> | <a ui-sref="about">About</a> | <a ui-sref="{page: 2}">Next page</a>
 *
 * <ul>
 *     <li ng-repeat="contact in contacts">
 *         <a ui-sref="contacts.detail({ id: contact.id })">{{ contact.name }}</a>
 *     </li>
 * </ul>
 * </pre>
 *
 * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):
 * <pre>
 * <a href="#/home" ui-sref="home">Home</a> | <a href="#/about" ui-sref="about">About</a> | <a href="#/contacts?page=2" ui-sref="{page: 2}">Next page</a>
 *
 * <ul>
 *     <li ng-repeat="contact in contacts">
 *         <a href="#/contacts/1" ui-sref="contacts.detail({ id: contact.id })">Joe</a>
 *     </li>
 *     <li ng-repeat="contact in contacts">
 *         <a href="#/contacts/2" ui-sref="contacts.detail({ id: contact.id })">Alice</a>
 *     </li>
 *     <li ng-repeat="contact in contacts">
 *         <a href="#/contacts/3" ui-sref="contacts.detail({ id: contact.id })">Bob</a>
 *     </li>
 * </ul>
 *
 * <a ui-sref="home" ui-sref-opts="{reload: true}">Home</a>
 * </pre>
 *
 * @param {string} ui-sref 'stateName' can be any valid absolute or relative state
 * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#methods_go $state.go()}
 */
$StateRefDirective.$inject = ['$state', '$timeout'];
function $StateRefDirective($state, $timeout) {
  return {
    restrict: 'A',
    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
    link: function(scope, element, attrs, uiSrefActive) {
      var ref    = parseStateRef(attrs.uiSref, $state.current.name);
      var def    = { state: ref.state, href: null, params: null };
      var type   = getTypeInfo(element);
      var active = uiSrefActive[1] || uiSrefActive[0];
      var unlinkInfoFn = null;
      var hookFn;

      def.options = extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});

      var update = function(val) {
        if (val) def.params = angular.copy(val);
        def.href = $state.href(ref.state, def.params, def.options);

        if (unlinkInfoFn) unlinkInfoFn();
        if (active) unlinkInfoFn = active.$$addStateInfo(ref.state, def.params);
        if (def.href !== null) attrs.$set(type.attr, def.href);
      };

      if (ref.paramExpr) {
        scope.$watch(ref.paramExpr, function(val) { if (val !== def.params) update(val); }, true);
        def.params = angular.copy(scope.$eval(ref.paramExpr));
      }
      update();

      if (!type.clickable) return;
      hookFn = clickHook(element, $state, $timeout, type, function() { return def; });
      element[element.on ? 'on' : 'bind']("click", hookFn);
      scope.$on('$destroy', function() {
        element[element.off ? 'off' : 'unbind']("click", hookFn);
      });
    }
  };
}

/**
 * @ngdoc directive
 * @name ui.router.state.directive:ui-state
 *
 * @requires ui.router.state.uiSref
 *
 * @restrict A
 *
 * @description
 * Much like ui-sref, but will accept named $scope properties to evaluate for a state definition,
 * params and override options.
 *
 * @param {string} ui-state 'stateName' can be any valid absolute or relative state
 * @param {Object} ui-state-params params to pass to {@link ui.router.state.$state#methods_href $state.href()}
 * @param {Object} ui-state-opts options to pass to {@link ui.router.state.$state#methods_go $state.go()}
 */
$StateRefDynamicDirective.$inject = ['$state', '$timeout'];
function $StateRefDynamicDirective($state, $timeout) {
  return {
    restrict: 'A',
    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
    link: function(scope, element, attrs, uiSrefActive) {
      var type   = getTypeInfo(element);
      var active = uiSrefActive[1] || uiSrefActive[0];
      var group  = [attrs.uiState, attrs.uiStateParams || null, attrs.uiStateOpts || null];
      var watch  = '[' + group.map(function(val) { return val || 'null'; }).join(', ') + ']';
      var def    = { state: null, params: null, options: null, href: null };
      var unlinkInfoFn = null;
      var hookFn;

      function runStateRefLink (group) {
        def.state = group[0]; def.params = group[1]; def.options = group[2];
        def.href = $state.href(def.state, def.params, def.options);

        if (unlinkInfoFn) unlinkInfoFn();
        if (active) unlinkInfoFn = active.$$addStateInfo(def.state, def.params);
        if (def.href) attrs.$set(type.attr, def.href);
      }

      scope.$watch(watch, runStateRefLink, true);
      runStateRefLink(scope.$eval(watch));

      if (!type.clickable) return;
      hookFn = clickHook(element, $state, $timeout, type, function() { return def; });
      element[element.on ? 'on' : 'bind']("click", hookFn);
      scope.$on('$destroy', function() {
        element[element.off ? 'off' : 'unbind']("click", hookFn);
      });
    }
  };
}


/**
 * @ngdoc directive
 * @name ui.router.state.directive:ui-sref-active
 *
 * @requires ui.router.state.$state
 * @requires ui.router.state.$stateParams
 * @requires $interpolate
 *
 * @restrict A
 *
 * @description
 * A directive working alongside ui-sref to add classes to an element when the
 * related ui-sref directive's state is active, and removing them when it is inactive.
 * The primary use-case is to simplify the special appearance of navigation menus
 * relying on `ui-sref`, by having the "active" state's menu button appear different,
 * distinguishing it from the inactive menu items.
 *
 * ui-sref-active can live on the same element as ui-sref or on a parent element. The first
 * ui-sref-active found at the same level or above the ui-sref will be used.
 *
 * Will activate when the ui-sref's target state or any child state is active. If you
 * need to activate only when the ui-sref target state is active and *not* any of
 * it's children, then you will use
 * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}
 *
 * @example
 * Given the following template:
 * <pre>
 * <ul>
 *   <li ui-sref-active="active" class="item">
 *     <a href ui-sref="app.user({user: 'bilbobaggins'})">@bilbobaggins</a>
 *   </li>
 * </ul>
 * </pre>
 *
 *
 * When the app state is "app.user" (or any children states), and contains the state parameter "user" with value "bilbobaggins",
 * the resulting HTML will appear as (note the 'active' class):
 * <pre>
 * <ul>
 *   <li ui-sref-active="active" class="item active">
 *     <a ui-sref="app.user({user: 'bilbobaggins'})" href="/users/bilbobaggins">@bilbobaggins</a>
 *   </li>
 * </ul>
 * </pre>
 *
 * The class name is interpolated **once** during the directives link time (any further changes to the
 * interpolated value are ignored).
 *
 * Multiple classes may be specified in a space-separated format:
 * <pre>
 * <ul>
 *   <li ui-sref-active='class1 class2 class3'>
 *     <a ui-sref="app.user">link</a>
 *   </li>
 * </ul>
 * </pre>
 *
 * It is also possible to pass ui-sref-active an expression that evaluates
 * to an object hash, whose keys represent active class names and whose
 * values represent the respective state names/globs.
 * ui-sref-active will match if the current active state **includes** any of
 * the specified state names/globs, even the abstract ones.
 *
 * @Example
 * Given the following template, with "admin" being an abstract state:
 * <pre>
 * <div ui-sref-active="{'active': 'admin.*'}">
 *   <a ui-sref-active="active" ui-sref="admin.roles">Roles</a>
 * </div>
 * </pre>
 *
 * When the current state is "admin.roles" the "active" class will be applied
 * to both the <div> and <a> elements. It is important to note that the state
 * names/globs passed to ui-sref-active shadow the state provided by ui-sref.
 */

/**
 * @ngdoc directive
 * @name ui.router.state.directive:ui-sref-active-eq
 *
 * @requires ui.router.state.$state
 * @requires ui.router.state.$stateParams
 * @requires $interpolate
 *
 * @restrict A
 *
 * @description
 * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will only activate
 * when the exact target state used in the `ui-sref` is active; no child states.
 *
 */
$StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];
function $StateRefActiveDirective($state, $stateParams, $interpolate) {
  return  {
    restrict: "A",
    controller: ['$scope', '$element', '$attrs', '$timeout', function ($scope, $element, $attrs, $timeout) {
      var states = [], activeClasses = {}, activeEqClass, uiSrefActive;

      // There probably isn't much point in $observing this
      // uiSrefActive and uiSrefActiveEq share the same directive object with some
      // slight difference in logic routing
      activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);

      try {
        uiSrefActive = $scope.$eval($attrs.uiSrefActive);
      } catch (e) {
        // Do nothing. uiSrefActive is not a valid expression.
        // Fall back to using $interpolate below
      }
      uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);
      if (isObject(uiSrefActive)) {
        forEach(uiSrefActive, function(stateOrName, activeClass) {
          if (isString(stateOrName)) {
            var ref = parseStateRef(stateOrName, $state.current.name);
            addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);
          }
        });
      }

      // Allow uiSref to communicate with uiSrefActive[Equals]
      this.$$addStateInfo = function (newState, newParams) {
        // we already got an explicit state provided by ui-sref-active, so we
        // shadow the one that comes from ui-sref
        if (isObject(uiSrefActive) && states.length > 0) {
          return;
        }
        var deregister = addState(newState, newParams, uiSrefActive);
        update();
        return deregister;
      };

      $scope.$on('$stateChangeSuccess', update);

      function addState(stateName, stateParams, activeClass) {
        var state = $state.get(stateName, stateContext($element));
        var stateHash = createStateHash(stateName, stateParams);

        var stateInfo = {
          state: state || { name: stateName },
          params: stateParams,
          hash: stateHash
        };

        states.push(stateInfo);
        activeClasses[stateHash] = activeClass;

        return function removeState() {
          var idx = states.indexOf(stateInfo);
          if (idx !== -1) states.splice(idx, 1);
        };
      }

      /**
       * @param {string} state
       * @param {Object|string} [params]
       * @return {string}
       */
      function createStateHash(state, params) {
        if (!isString(state)) {
          throw new Error('state should be a string');
        }
        if (isObject(params)) {
          return state + toJson(params);
        }
        params = $scope.$eval(params);
        if (isObject(params)) {
          return state + toJson(params);
        }
        return state;
      }

      // Update route state
      function update() {
        for (var i = 0; i < states.length; i++) {
          if (anyMatch(states[i].state, states[i].params)) {
            addClass($element, activeClasses[states[i].hash]);
          } else {
            removeClass($element, activeClasses[states[i].hash]);
          }

          if (exactMatch(states[i].state, states[i].params)) {
            addClass($element, activeEqClass);
          } else {
            removeClass($element, activeEqClass);
          }
        }
      }

      function addClass(el, className) { $timeout(function () { el.addClass(className); }); }
      function removeClass(el, className) { el.removeClass(className); }
      function anyMatch(state, params) { return $state.includes(state.name, params); }
      function exactMatch(state, params) { return $state.is(state.name, params); }

      update();
    }]
  };
}

angular.module('ui.router.state')
  .directive('uiSref', $StateRefDirective)
  .directive('uiSrefActive', $StateRefActiveDirective)
  .directive('uiSrefActiveEq', $StateRefActiveDirective)
  .directive('uiState', $StateRefDynamicDirective);

/**
 * @ngdoc filter
 * @name ui.router.state.filter:isState
 *
 * @requires ui.router.state.$state
 *
 * @description
 * Translates to {@link ui.router.state.$state#methods_is $state.is("stateName")}.
 */
$IsStateFilter.$inject = ['$state'];
function $IsStateFilter($state) {
  var isFilter = function (state, params) {
    return $state.is(state, params);
  };
  isFilter.$stateful = true;
  return isFilter;
}

/**
 * @ngdoc filter
 * @name ui.router.state.filter:includedByState
 *
 * @requires ui.router.state.$state
 *
 * @description
 * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.
 */
$IncludedByStateFilter.$inject = ['$state'];
function $IncludedByStateFilter($state) {
  var includesFilter = function (state, params, options) {
    return $state.includes(state, params, options);
  };
  includesFilter.$stateful = true;
  return  includesFilter;
}

angular.module('ui.router.state')
  .filter('isState', $IsStateFilter)
  .filter('includedByState', $IncludedByStateFilter);
})(window, window.angular);

/*** EXPORTS FROM exports-loader ***/
module.exports = angularUiRouter;

/*** EXPORTS FROM exports-loader ***/
module.exports = window.angular;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(53)))

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var lang_1 = __webpack_require__(2);
var UninitializedValue = (function () {
    function UninitializedValue() {
    }
    return UninitializedValue;
}());
exports.UninitializedValue = UninitializedValue;
var uninitialized = new UninitializedValue();
/**
 * Represents a basic change from a previous to a new value.
 */
var SimpleChange = (function () {
    function SimpleChange(previousValue, currentValue) {
        this.previousValue = previousValue;
        this.currentValue = currentValue;
    }
    /**
     * Check whether the new value is the first value assigned.
     */
    SimpleChange.prototype.isFirstChange = function () { return this.previousValue === uninitialized; };
    return SimpleChange;
}());
exports.SimpleChange = SimpleChange;
var ChangeDetectionUtil = (function () {
    function ChangeDetectionUtil() {
    }
    ChangeDetectionUtil.simpleChange = function (previousValue, currentValue) {
        return new SimpleChange(previousValue, currentValue);
    };
    ChangeDetectionUtil.isOnPushChangeDetectionStrategy = function (changeDetectionStrategy) {
        return lang_1.isPresent(changeDetectionStrategy) && changeDetectionStrategy === 0 /* OnPush */;
    };
    return ChangeDetectionUtil;
}());
ChangeDetectionUtil.uninitialized = uninitialized;
exports.ChangeDetectionUtil = ChangeDetectionUtil;
//# sourceMappingURL=change_detection_util.js.map

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var decorators_1 = __webpack_require__(56);
var ChangeDetectorRef = ChangeDetectorRef_1 = (function () {
    function ChangeDetectorRef($scope) {
        this.$scope = $scope;
    }
    ChangeDetectorRef.create = function ($scope) {
        return new ChangeDetectorRef_1($scope);
    };
    /**
     * Marks all {@link ChangeDetectionStrategy#OnPush} ancestors as to be checked.
     *
     * <!-- TODO: Add a link to a chapter on OnPush components -->
     *
     * ### Example ([live demo](http://plnkr.co/edit/GC512b?p=preview))
     *
     * ```typescript
     * @Component({
     *   selector: 'cmp',
     *   changeDetection: ChangeDetectionStrategy.OnPush,
     *   template: `Number of ticks: {{numberOfTicks}}`
     * })
     * class Cmp {
     *   numberOfTicks = 0;
     *
     *   constructor(ref: ChangeDetectorRef) {
     *     setInterval(() => {
     *       this.numberOfTicks ++
     *       // the following is required, otherwise the view will not be updated
     *       this.ref.markForCheck();
     *     }, 1000);
     *   }
     * }
     *
     * @Component({
     *   selector: 'app',
     *   changeDetection: ChangeDetectionStrategy.OnPush,
     *   template: `
     *     <cmp><cmp>
     *   `,
     *   directives: [Cmp]
     * })
     * class App {
     * }
     *
     * bootstrap(App);
     * ```
     */
    ChangeDetectorRef.prototype.markForCheck = function () { this.$scope.$applyAsync(); };
    /**
     * Detaches the change detector from the change detector tree.
     *
     * The detached change detector will not be checked until it is reattached.
     *
     * This can also be used in combination with {@link ChangeDetectorRef#detectChanges} to implement
     * local change
     * detection checks.
     *
     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
     * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
     *
     * ### Example
     *
     * The following example defines a component with a large list of readonly data.
     * Imagine the data changes constantly, many times per second. For performance reasons,
     * we want to check and update the list every five seconds. We can do that by detaching
     * the component's change detector and doing a local check every five seconds.
     *
     * ```typescript
     * class DataProvider {
     *   // in a real application the returned data will be different every time
     *   get data() {
     *     return [1,2,3,4,5];
     *   }
     * }
     *
     * @Component({
     *   selector: 'giant-list',
     *   template: `
     *     <li *ngFor="let d of dataProvider.data">Data {{d}}</lig>
     *   `,
     *   directives: [NgFor]
     * })
     * class GiantList {
     *   constructor(private ref: ChangeDetectorRef, private dataProvider:DataProvider) {
     *     ref.detach();
     *     setInterval(() => {
     *       this.ref.detectChanges();
     *     }, 5000);
     *   }
     * }
     *
     * @Component({
     *   selector: 'app',
     *   providers: [DataProvider],
     *   template: `
     *     <giant-list><giant-list>
     *   `,
     *   directives: [GiantList]
     * })
     * class App {
     * }
     *
     * bootstrap(App);
     * ```
     */
    ChangeDetectorRef.prototype.detach = function () { disconnectScope(this.$scope); };
    /**
     * Checks the change detector and its children.
     *
     * This can also be used in combination with {@link ChangeDetectorRef#detach} to implement local
     * change detection
     * checks.
     *
     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
     * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
     *
     * ### Example
     *
     * The following example defines a component with a large list of readonly data.
     * Imagine, the data changes constantly, many times per second. For performance reasons,
     * we want to check and update the list every five seconds.
     *
     * We can do that by detaching the component's change detector and doing a local change detection
     * check
     * every five seconds.
     *
     * See {@link ChangeDetectorRef#detach} for more information.
     */
    ChangeDetectorRef.prototype.detectChanges = function () { this.$scope.$digest(); };
    /**
     * Checks the change detector and its children, and throws if any changes are detected.
     *
     * This is used in development mode to verify that running change detection doesn't introduce
     * other changes.
     */
    ChangeDetectorRef.prototype.checkNoChanges = function () { };
    /**
     * Reattach the change detector to the change detector tree.
     *
     * This also marks OnPush ancestors as to be checked. This reattached change detector will be
     * checked during the next change detection run.
     *
     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
     *
     * ### Example ([live demo](http://plnkr.co/edit/aUhZha?p=preview))
     *
     * The following example creates a component displaying `live` data. The component will detach
     * its change detector from the main change detector tree when the component's live property
     * is set to false.
     *
     * ```typescript
     * class DataProvider {
     *   data = 1;
     *
     *   constructor() {
     *     setInterval(() => {
     *       this.data = this.data * 2;
     *     }, 500);
     *   }
     * }
     *
     * @Component({
     *   selector: 'live-data',
     *   inputs: ['live'],
     *   template: `Data: {{dataProvider.data}}`
     * })
     * class LiveData {
     *   constructor(private ref: ChangeDetectorRef, private dataProvider:DataProvider) {}
     *
     *   set live(value) {
     *     if (value)
     *       this.ref.reattach();
     *     else
     *       this.ref.detach();
     *   }
     * }
     *
     * @Component({
     *   selector: 'app',
     *   providers: [DataProvider],
     *   template: `
     *     Live Update: <input type="checkbox" [(ngModel)]="live">
     *     <live-data [live]="live"><live-data>
     *   `,
     *   directives: [LiveData, FORM_DIRECTIVES]
     * })
     * class App {
     *   live = true;
     * }
     *
     * bootstrap(App);
     * ```
     */
    ChangeDetectorRef.prototype.reattach = function () { reconnectScope(this.$scope); };
    return ChangeDetectorRef;
}());
ChangeDetectorRef = ChangeDetectorRef_1 = __decorate([
    decorators_1.Injectable('changeDetectorRef'),
    __metadata("design:paramtypes", [Object])
], ChangeDetectorRef);
exports.ChangeDetectorRef = ChangeDetectorRef;
// Stop watchers and events from firing on a scope without destroying it,
// by disconnecting it from its parent and its siblings' linked lists.
function disconnectScope(scope) {
    if (!scope)
        return;
    // we can't destroy the root scope or a scope that has been already destroyed
    if (scope.$root === scope)
        return;
    if (scope.$$destroyed)
        return;
    var parent = scope.$parent;
    scope.$$disconnected = true;
    // See Scope.$destroy
    if (parent.$$childHead === scope)
        parent.$$childHead = scope.$$nextSibling;
    if (parent.$$childTail === scope)
        parent.$$childTail = scope.$$prevSibling;
    if (scope.$$prevSibling)
        scope.$$prevSibling.$$nextSibling = scope.$$nextSibling;
    if (scope.$$nextSibling)
        scope.$$nextSibling.$$prevSibling = scope.$$prevSibling;
    scope.$$nextSibling = scope.$$prevSibling = null;
}
// Undo the effects of disconnectScope above.
function reconnectScope(scope) {
    if (!scope)
        return;
    // we can't disconnect the root node or scope already disconnected
    if (scope.$root === scope)
        return;
    if (!scope.$$disconnected)
        return;
    var child = scope;
    var parent = child.$parent;
    child.$$disconnected = false;
    // See Scope.$new for this logic...
    child.$$prevSibling = parent.$$childTail;
    if (parent.$$childHead) {
        parent.$$childTail.$$nextSibling = child;
        parent.$$childTail = child;
    }
    else {
        parent.$$childHead = parent.$$childTail = child;
    }
}
var ChangeDetectorRef_1;
//# sourceMappingURL=change_detector_ref.js.map

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var metadata_1 = __webpack_require__(7);
var decorators_1 = __webpack_require__(19);
/**
 * Factory for creating {@link InjectMetadata}.
 */
exports.Inject = decorators_1.makeParamDecorator(metadata_1.InjectMetadata, metadata_1.InjectMetadata.paramDecoratorForNonConstructor);
/**
 * Factory for creating {@link OptionalMetadata}.
 */
exports.Optional = decorators_1.makeParamDecorator(metadata_1.OptionalMetadata);
/**
 * Factory for creating {@link InjectableMetadata}.
 */
exports.Injectable = decorators_1.makeDecorator(metadata_1.InjectableMetadata);
/**
 * Factory for creating {@link SelfMetadata}.
 */
exports.Self = decorators_1.makeParamDecorator(metadata_1.SelfMetadata);
/**
 * Factory for creating {@link HostMetadata}.
 */
exports.Host = decorators_1.makeParamDecorator(metadata_1.HostMetadata);
/**
 * Factory for creating {@link SkipSelfMetadata}.
 */
exports.SkipSelf = decorators_1.makeParamDecorator(metadata_1.SkipSelfMetadata);
//# sourceMappingURL=decorators.js.map

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Creates a token that can be used in a DI Provider.
 *
 * ### Example ([live demo](http://plnkr.co/edit/Ys9ezXpj2Mnoy3Uc8KBp?p=preview))
 *
 * ```typescript
 * var t = new OpaqueToken("value");
 *
 * var injector = Injector.resolveAndCreate([
 *   provide(t, {useValue: "providedValue"})
 * ]);
 *
 * expect(injector.get(t)).toEqual("providedValue");
 * ```
 *
 * Using an `OpaqueToken` is preferable to using strings as tokens because of possible collisions
 * caused by multiple providers using the same string as two different tokens.
 *
 * Using an `OpaqueToken` is preferable to using an `Object` as tokens because it provides better
 * error messages.
 */
var OpaqueToken = (function () {
    function OpaqueToken(_desc) {
        this._desc = _desc;
    }
    Object.defineProperty(OpaqueToken.prototype, "desc", {
        get: function () { return this._desc; },
        enumerable: true,
        configurable: true
    });
    OpaqueToken.prototype.toString = function () { return "Token " + this._desc; };
    return OpaqueToken;
}());
exports.OpaqueToken = OpaqueToken;
//# sourceMappingURL=opaque_token.js.map

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.INPUT_MODE_REGEX = /^(<|=|@)?(\??)(\w*)$/;
exports.BINDING_MODE = Object.freeze({
    oneWay: '<',
    twoWay: '=',
    output: '&',
    attr: '@',
    optional: '?'
});
//# sourceMappingURL=constants.js.map

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = __webpack_require__(2);
var Subject_1 = __webpack_require__(691);
/**
 * Use by directives and components to emit custom Events.
 *
 * ### Examples
 *
 * In the following example, `ZippyComponent` alternatively emits `open` and `close` events when its
 * title gets clicked:
 *
 * ```
 * @Component({
 *   selector: 'zippy',
 *   template: `
 *   <div class="zippy">
 *     <div ng-click="$ctrl.toggle()">Toggle</div>
 *     <div ng-hide="!$ctrl.visible">
 *       <ng-transclude></ng-transclude>
 *     </div>
 *  </div>`
 * })
 * export class ZippyComponent {
 *   visible: boolean = true;
 *
 *   @Output() open = new EventEmitter<boolean>();
 *   @Output() close = new EventEmitter<boolean>();
 *
 *   toggle() {
 *     this.visible = !this.visible;
 *     if (this.visible) {
 *       this.open.emit( this.visible );
 *     } else {
 *       this.close.emit( this.visible );
 *     }
 *   }
 * }
 * ```
 *
 * Use Rx.Observable but provides an adapter to make it work as specified here:
 * https://github.com/jhusain/observable-spec
 *
 * Once a reference implementation of the spec is available, switch to it.
 */
var EventEmitter = (function (_super) {
    __extends(EventEmitter, _super);
    /**
     * Creates an instance of [EventEmitter], which depending on [isAsync],
     * delivers events synchronously or asynchronously.
     */
    function EventEmitter(isAsync) {
        if (isAsync === void 0) { isAsync = false; }
        var _this = _super.call(this) || this;
        /** @internal */
        _this._ngExpressionBindingCb = lang_1.noop;
        _this.__isAsync = isAsync;
        return _this;
    }
    /** @internal */
    EventEmitter.prototype.wrapNgExpBindingToEmitter = function (cb) {
        //used in reassignBindingsAndCreteEventEmitters to attach the original @Output binding to the instance new EventEmitter
        this._ngExpressionBindingCb = cb;
        // this could create memory leaks because the subscription would be never terminated
        // super.subscribe((newValue)=>this._ngExpressionBindingCb({$event:newValue}));
    };
    EventEmitter.prototype.emit = function (value) {
        var payload = { $event: value };
        // push just the value
        _super.prototype.next.call(this, value);
        // our & binding needs to be called via { $event: value } because Angular 1 locals
        this._ngExpressionBindingCb(payload);
    };
    EventEmitter.prototype.subscribe = function (generatorOrNext, error, complete) {
        var schedulerFn /** TODO #9100 */;
        var errorFn = function (err) { return null; };
        var completeFn = function () { return null; };
        if (generatorOrNext && typeof generatorOrNext === 'object') {
            schedulerFn = this.__isAsync
                ? function (value /** TODO #9100 */) { setTimeout(function () { return generatorOrNext.next(value); }); }
                : function (value /** TODO #9100 */) { generatorOrNext.next(value); };
            if (generatorOrNext.error) {
                errorFn = this.__isAsync
                    ? function (err) { setTimeout(function () { return generatorOrNext.error(err); }); }
                    : function (err) { generatorOrNext.error(err); };
            }
            if (generatorOrNext.complete) {
                completeFn = this.__isAsync
                    ? function () { setTimeout(function () { return generatorOrNext.complete(); }); }
                    : function () { generatorOrNext.complete(); };
            }
        }
        else {
            schedulerFn = this.__isAsync
                ? function (value /** TODO #9100 */) { setTimeout(function () { return generatorOrNext(value); }); }
                : function (value /** TODO #9100 */) { generatorOrNext(value); };
            if (error) {
                errorFn = this.__isAsync ? function (err) { setTimeout(function () { return error(err); }); } : function (err) { error(err); };
            }
            if (complete) {
                completeFn = this.__isAsync ? function () { setTimeout(function () { return complete(); }); } : function () { complete(); };
            }
        }
        return _super.prototype.subscribe.call(this, schedulerFn, errorFn, completeFn);
    };
    return EventEmitter;
}(Subject_1.Subject));
exports.EventEmitter = EventEmitter;
//# sourceMappingURL=async.js.map

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = __webpack_require__(2);
var BaseException = (function (_super) {
    __extends(BaseException, _super);
    function BaseException(message) {
        if (message === void 0) { message = "--"; }
        var _this = _super.call(this, message) || this;
        _this.message = message;
        _this.stack = new Error(message).stack;
        return _this;
    }
    BaseException.prototype.toString = function () { return this.message; };
    return BaseException;
}(Error));
exports.BaseException = BaseException;
function getErrorMsg(typeOrFunc, msg) {
    return "\n      " + lang_1.getFuncName(typeOrFunc) + ":\n      ===========================\n      " + msg + "\n    ";
}
exports.getErrorMsg = getErrorMsg;
//# sourceMappingURL=exceptions.js.map

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var lang_1 = __webpack_require__(2);
var _kebabCase = _caseTransformerFactory('-');
var _snakeCase = _caseTransformerFactory('_');
var StringWrapper = (function () {
    function StringWrapper() {
    }
    StringWrapper.fromCharCode = function (code) { return String.fromCharCode(code); };
    StringWrapper.charCodeAt = function (s, index) { return s.charCodeAt(index); };
    StringWrapper.split = function (s, regExp) { return s.split(regExp); };
    StringWrapper.equals = function (s, s2) { return s === s2; };
    StringWrapper.stripLeft = function (s, charVal) {
        if (s && s.length) {
            var pos = 0;
            for (var i = 0; i < s.length; i++) {
                if (s[i] != charVal)
                    break;
                pos++;
            }
            s = s.substring(pos);
        }
        return s;
    };
    StringWrapper.stripRight = function (s, charVal) {
        if (s && s.length) {
            var pos = s.length;
            for (var i = s.length - 1; i >= 0; i--) {
                if (s[i] != charVal)
                    break;
                pos--;
            }
            s = s.substring(0, pos);
        }
        return s;
    };
    StringWrapper.replace = function (s, from, replace) {
        return s.replace(from, replace);
    };
    StringWrapper.replaceAll = function (s, from, replace) {
        return s.replace(from, replace);
    };
    StringWrapper.slice = function (s, from, to) {
        if (from === void 0) { from = 0; }
        if (to === void 0) { to = null; }
        return s.slice(from, to === null
            ? undefined
            : to);
    };
    StringWrapper.replaceAllMapped = function (s, from, cb) {
        return s.replace(from, function () {
            var matches = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                matches[_i] = arguments[_i];
            }
            // Remove offset & string from the result array
            matches.splice(-2, 2);
            // The callback receives match, p1, ..., pn
            return cb(matches);
        });
    };
    StringWrapper.compare = function (a, b) {
        if (a < b) {
            return -1;
        }
        else if (a > b) {
            return 1;
        }
        else {
            return 0;
        }
    };
    StringWrapper.includes = function (str, searchString, position) {
        if (position === void 0) { position = 0; }
        if (String.prototype.includes) {
            return str.includes(searchString, position);
        }
        return str.indexOf(searchString, position) === position;
    };
    StringWrapper.startsWith = function (str, searchString, position) {
        if (position === void 0) { position = 0; }
        if (String.prototype.startsWith) {
            return str.startsWith(searchString, position);
        }
        return str.indexOf(searchString, position) === position;
    };
    StringWrapper.endsWith = function (str, searchString, position) {
        if (String.prototype.endsWith) {
            return str.endsWith(searchString, position);
        }
        var subjectString = str.toString();
        if (!lang_1.isNumber(position) || !isFinite(position)
            || Math.floor(position) !== position || position > subjectString.length) {
            position = subjectString.length;
        }
        position -= searchString.length;
        var lastIndex = subjectString.indexOf(searchString, position);
        return lastIndex !== -1 && lastIndex === position;
    };
    StringWrapper.kebabCase = function (name) {
        return _kebabCase(name);
    };
    StringWrapper.snakeCase = function (name) {
        return _snakeCase(name);
    };
    return StringWrapper;
}());
exports.StringWrapper = StringWrapper;
function _caseTransformerFactory(separator) {
    var SNAKE_CASE_REGEXP = /[A-Z]/g;
    return _caseTransform;
    function _caseTransform(name) {
        return name.replace(SNAKE_CASE_REGEXP, function (match, offset) {
            return (offset
                ? separator
                : '') + match.toLowerCase();
        });
    }
}
//# sourceMappingURL=primitives.js.map

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @whatItDoes Represents a type that a Component or other object is instances of.
 *
 * @description
 *
 * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by
 * the `MyCustomComponent` constructor function.
 *
 * @stable
 */
exports.Type = Function;
//# sourceMappingURL=type.js.map

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.empty = {
    closed: true,
    next: function (value) { },
    error: function (err) { throw err; },
    complete: function () { }
};
//# sourceMappingURL=Observer.js.map

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isFunction_1 = __webpack_require__(66);
var Subscription_1 = __webpack_require__(30);
var Observer_1 = __webpack_require__(63);
var rxSubscriber_1 = __webpack_require__(31);
/**
 * Implements the {@link Observer} interface and extends the
 * {@link Subscription} class. While the {@link Observer} is the public API for
 * consuming the values of an {@link Observable}, all Observers get converted to
 * a Subscriber, in order to provide Subscription-like capabilities such as
 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
 * implementing operators, but it is rarely used as a public API.
 *
 * @class Subscriber<T>
 */
var Subscriber = (function (_super) {
    __extends(Subscriber, _super);
    /**
     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
     * defined Observer or a `next` callback function.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     */
    function Subscriber(destinationOrNext, error, complete) {
        _super.call(this);
        this.syncErrorValue = null;
        this.syncErrorThrown = false;
        this.syncErrorThrowable = false;
        this.isStopped = false;
        switch (arguments.length) {
            case 0:
                this.destination = Observer_1.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    this.destination = Observer_1.empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        this.destination = destinationOrNext;
                        this.destination.add(this);
                    }
                    else {
                        this.syncErrorThrowable = true;
                        this.destination = new SafeSubscriber(this, destinationOrNext);
                    }
                    break;
                }
            default:
                this.syncErrorThrowable = true;
                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
                break;
        }
    }
    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () { return this; };
    /**
     * A static factory for a Subscriber, given a (potentially partial) definition
     * of an Observer.
     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
     * Observer represented by the given arguments.
     */
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    /**
     * The {@link Observer} callback to receive notifications of type `next` from
     * the Observable, with a value. The Observable may call this method 0 or more
     * times.
     * @param {T} [value] The `next` value.
     * @return {void}
     */
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    /**
     * The {@link Observer} callback to receive notifications of type `error` from
     * the Observable, with an attached {@link Error}. Notifies the Observer that
     * the Observable has experienced an error condition.
     * @param {any} [err] The `error` exception.
     * @return {void}
     */
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    /**
     * The {@link Observer} callback to receive a valueless notification of type
     * `complete` from the Observable. Notifies the Observer that the Observable
     * has finished sending push-based notifications.
     * @return {void}
     */
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    return Subscriber;
}(Subscription_1.Subscription));
exports.Subscriber = Subscriber;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SafeSubscriber = (function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parent, observerOrNext, error, complete) {
        _super.call(this);
        this._parent = _parent;
        var next;
        var context = this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            context = observerOrNext;
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (isFunction_1.isFunction(context.unsubscribe)) {
                this.add(context.unsubscribe.bind(context));
            }
            context.unsubscribe = this.unsubscribe.bind(this);
        }
        this._context = context;
        this._next = next;
        this._error = error;
        this._complete = complete;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parent = this._parent;
            if (!_parent.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parent, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parent = this._parent;
            if (this._error) {
                if (!_parent.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parent, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parent.syncErrorThrowable) {
                this.unsubscribe();
                throw err;
            }
            else {
                _parent.syncErrorValue = err;
                _parent.syncErrorThrown = true;
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
            var _parent = this._parent;
            if (this._complete) {
                if (!_parent.syncErrorThrowable) {
                    this.__tryOrUnsub(this._complete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parent, this._complete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            throw err;
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            parent.syncErrorValue = err;
            parent.syncErrorThrown = true;
            return true;
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parent = this._parent;
        this._context = null;
        this._parent = null;
        _parent.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));
//# sourceMappingURL=Subscriber.js.map

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// typeof any so that it we don't have to cast when comparing a result to the error object
exports.errorObject = { e: {} };
//# sourceMappingURL=errorObject.js.map

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function isFunction(x) {
    return typeof x === 'function';
}
exports.isFunction = isFunction;
//# sourceMappingURL=isFunction.js.map

/***/ }),
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */,
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CGL06}
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(103)], __WEBPACK_AMD_DEFINE_RESULT__ = function () {}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP02}
// di.einvoicing.ui.portal
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1),
// Application Angular components
__webpack_require__(297), __webpack_require__(298), __webpack_require__(299), __webpack_require__(612), __webpack_require__(304), __webpack_require__(652), __webpack_require__(301), __webpack_require__(102),
// External Angular components
__webpack_require__(655), __webpack_require__(53), __webpack_require__(26), __webpack_require__(37), __webpack_require__(25), __webpack_require__(39), __webpack_require__(657), __webpack_require__(41), __webpack_require__(38), __webpack_require__(36), __webpack_require__(35)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ng, configLoader, runLoader, statesLoader, componentsLoader, portalLoader, welcomeLoader, impersonateLoader, diCoreAngularLoader) {
	'use strict';

	var module = ng.module('di.einvoicing.ui.portal', ['ngAnimate', 'ui.router', 'pascalprecht.translate', 'LocalStorageModule', 'valdr', 'ngSanitize', 'ngFileUpload', 'ngIdle', 'angularModalService', 'angular-clipboard']);

	configLoader(module);
	runLoader(module);
	componentsLoader(module);
	portalLoader(module);
	welcomeLoader(module);
	impersonateLoader(module);
	statesLoader(module);

	diCoreAngularLoader(module);

	return module;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15)(module)))

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * detect-dom-ready
 * http://github.amexpub.com/modules
 *
 * Copyright (c) 2013 Amex Pub. All rights reserved.
 */



module.exports = function(callback){
    // if ( this.readyBound ) {return;}
    // this.readyBound = true;

    if(document.addEventListener){
        document.addEventListener( "DOMContentLoaded", function(){
            //remove listener
            callback();
            return;
        }, false );
    }
    else if(document.attachEvent){
        document.attachEvent("onreadystatechange", function(){
            if ( document.readyState === "complete" ) {
                //remove listener
                callback();
                return;
            }
        });

        if ( document.documentElement.doScroll && window === window.top ){
            try{
                // If IE is used, use the trick by Diego Perini
                // http://javascript.nwbox.com/IEContentLoaded/
                document.documentElement.doScroll("left");

            }
            catch( error ) {
                callback();
                return;
            }
            // and execute any waiting functions
            callback();
            return;
        }
    }
};

/***/ }),
/* 74 */,
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(3);
var add_party_component_controller_1 = __webpack_require__(46);
var AddPartyComponent = (function (_super) {
    __extends(AddPartyComponent, _super);
    function AddPartyComponent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AddPartyComponent = __decorate([
        core_1.Component({
            selector: 'diAddParty',
            templateUrl: 'src/app/portal/parties/add-party.component.html'
        })
    ], AddPartyComponent);
    return AddPartyComponent;
}(add_party_component_controller_1.AddPartyComponentController));
exports.AddPartyComponent = AddPartyComponent;


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var _loader_1 = __webpack_require__(77);
var _loader_2 = __webpack_require__(81);
function load(module) {
    _loader_1.load(module);
    _loader_2.load(module);
}
exports.load = load;


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(3);
var index_1 = __webpack_require__(80);
function load(module) {
    module.service('contactListConfigurationService', index_1.ContactListConfigurationService);
    module.directive.apply(module, core_1.provide(index_1.ContactListComponent));
}
exports.load = load;


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(3);
var resource_list_configuration_base_service_1 = __webpack_require__(17);
var ContactListConfigurationService = (function (_super) {
    __extends(ContactListConfigurationService, _super);
    function ContactListConfigurationService() {
        var _this = _super.call(this) || this;
        _this._sortOptions = [
            {
                value: 7,
                key: "contactTypeAsc",
                label: "EINVOICING.PORTAL.PARTIES.CONTACTS.LIST.TABLE.SORT_OPTIONS.CONTACT_TYPE_ASC"
            },
            {
                value: 8,
                key: "contactTypeDesc",
                label: "EINVOICING.PORTAL.PARTIES.CONTACTS.LIST.TABLE.SORT_OPTIONS.CONTACT_TYPE_DESC"
            },
            {
                value: 3,
                key: "contactNameAsc",
                label: "EINVOICING.PORTAL.PARTIES.CONTACTS.LIST.TABLE.SORT_OPTIONS.CONTACT_NAME_ASC"
            },
            {
                value: 4,
                key: "contactNameDesc",
                label: "EINVOICING.PORTAL.PARTIES.CONTACTS.LIST.TABLE.SORT_OPTIONS.CONTACT_NAME_DESC"
            },
            {
                value: 1,
                key: "contactEmailAsc",
                label: "EINVOICING.PORTAL.PARTIES.CONTACTS.LIST.TABLE.SORT_OPTIONS.CONTACT_EMAIL_ASC"
            },
            {
                value: 2,
                key: "contactEmailDesc",
                label: "EINVOICING.PORTAL.PARTIES.CONTACTS.LIST.TABLE.SORT_OPTIONS.CONTACT_EMAIL_DESC"
            },
            {
                value: 5,
                key: "contactTelephoneAsc",
                label: "EINVOICING.PORTAL.PARTIES.CONTACTS.LIST.TABLE.SORT_OPTIONS.CONTACT_TELEPHONE_ASC"
            },
            {
                value: 6,
                key: "contactTelephoneDesc",
                label: "EINVOICING.PORTAL.PARTIES.CONTACTS.LIST.TABLE.SORT_OPTIONS.CONTACT_TELEPHONE_DESC"
            },
            {
                value: 9,
                key: "contactClassificationAsc",
                label: "EINVOICING.PORTAL.PARTIES.CONTACTS.LIST.TABLE.SORT_OPTIONS.CONTACT_CLASSIFICATION_ASC"
            },
            {
                value: 10,
                key: "contactClassificationDesc",
                label: "EINVOICING.PORTAL.PARTIES.CONTACTS.LIST.TABLE.SORT_OPTIONS.CONTACT_CLASSIFICATION_DESC"
            }
        ];
        _this._columns = [
            {
                field: 'type',
                nameLanguageKey: 'EINVOICING.PORTAL.PARTIES.CONTACTS.LIST.TABLE.CONTACT_TYPE',
                template: '<span>{{binding.type}}</span>'
            },
            {
                field: 'name',
                nameLanguageKey: 'EINVOICING.PORTAL.PARTIES.CONTACTS.LIST.TABLE.CONTACT_NAME',
                template: '<span>{{binding.resource.name}}</span>'
            },
            {
                field: 'email',
                nameLanguageKey: 'EINVOICING.PORTAL.PARTIES.CONTACTS.LIST.TABLE.CONTACT_EMAIL',
                template: '<span>{{binding.resource.email}}</span>'
            },
            {
                field: 'telephoneNumber',
                nameLanguageKey: 'EINVOICING.PORTAL.PARTIES.CONTACTS.LIST.TABLE.CONTACT_TELEPHONE_NUMBER',
                template: '<span>{{binding.resource.telephoneNumber}}</span>'
            },
            {
                field: 'classification',
                nameLanguageKey: 'EINVOICING.PORTAL.PARTIES.CONTACTS.LIST.TABLE.CONTACT_CLASSIFICATION',
                template: '<span>{{binding.classification}}</span>'
            }
        ];
        _this._actionColumns = [{
                field: 'actionButtons',
                template: '<di-button ng-if="controller.readonly || !binding.isEditable" image="view" image-colour="button" action="controller.viewContact(binding)"></di-button>\
                       <di-button ng-if="!controller.readonly && binding.isEditable" image="edit" image-colour="button" action="controller.viewContact(binding)"></di-button>',
                cellClass: 'cell-right'
            }];
        return _this;
    }
    ContactListConfigurationService.prototype.getSortOptions = function () {
        return Promise.resolve(this._sortOptions);
    };
    ContactListConfigurationService.prototype.getTableOptions = function () {
        var tableOptions = _super.prototype.tableOptions.call(this);
        tableOptions.columns = this._columns;
        tableOptions.actionColumns = this._actionColumns;
        return Promise.resolve(tableOptions);
    };
    ContactListConfigurationService = __decorate([
        core_1.Injectable(),
        __metadata("design:paramtypes", [])
    ], ContactListConfigurationService);
    return ContactListConfigurationService;
}(resource_list_configuration_base_service_1.ResourceListConfigurationServiceBase));
exports.ContactListConfigurationService = ContactListConfigurationService;


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var util = $di.utility.util;
var core_1 = __webpack_require__(3);
var ContactListComponent = (function () {
    function ContactListComponent(modalWindow, translator, stateParams) {
        this.modalWindow = modalWindow;
        this.translator = translator;
        this.stateParams = stateParams;
        this.onSortByChanged = new core_1.EventEmitter();
        this.addNew = new core_1.EventEmitter();
        this.update = new core_1.EventEmitter();
        this.remove = new core_1.EventEmitter();
        this.reloadData = new core_1.EventEmitter();
        this.viewContact = this.viewContact.bind(this);
        this.sortByChanged = this.sortByChanged.bind(this);
    }
    ContactListComponent.prototype.ngOnChanges = function (changes) {
        var _this = this;
        if (changes.boundToObject && changes.boundToObject.currentValue) {
            this.translator.whenReady().then(function () {
                _this.parties = changes.boundToObject.currentValue.parties;
                _this.contacts = _.map(changes.boundToObject.currentValue.items, function (item) {
                    var contact = _.extend({}, item);
                    contact.classification = _this.getClasification(contact.isGlobal);
                    contact.type = _this.getType(contact.party);
                    return contact;
                });
            });
        }
        if (changes.sortOptions && changes.sortOptions.currentValue) {
            if (this.stateParams.contactSortOption) {
                this.sortBy = _.find(changes.sortOptions.currentValue, function (sortBy) {
                    return sortBy.value === _this.stateParams.contactSortOption;
                });
            }
        }
    };
    ContactListComponent.prototype.getDefaultSortOption = function () {
        return _.find(this.sortOptions, function (option) {
            return option.key === 'contactEmailAsc';
        });
    };
    ContactListComponent.prototype.getClasification = function (isGlobal) {
        if (isGlobal) {
            return this.translator.instantTranslate('EINVOICING.PORTAL.PARTIES.CONTACTS.LIST.TABLE.PUBLIC');
        }
        else {
            return this.translator.instantTranslate('EINVOICING.PORTAL.PARTIES.CONTACTS.LIST.TABLE.PRIVATE');
        }
    };
    ContactListComponent.prototype.getType = function (party) {
        if (party.isAccountingCustomer) {
            return this.translator.instantTranslate('EINVOICING.PORTAL.PARTIES.CONTACTS.LIST.TABLE.FINANCIAL');
        }
        else {
            return this.translator.instantTranslate('EINVOICING.PORTAL.PARTIES.CONTACTS.LIST.TABLE.ORGANISATION');
        }
    };
    ContactListComponent.prototype.sortByChanged = function (value) {
        if (this.sortBy && this.sortBy.value === value) {
            return;
        }
        this.tableOptions.paginationPageNumber = 1;
        this.onSortByChanged.emit(value);
    };
    ContactListComponent.prototype.viewContact = function (obj) {
        var model = _.extend({}, obj);
        var typeOptions = [];
        if (model.party.isAccountingCustomer) {
            model.party.name = 'Financial';
            typeOptions.push(model.party);
        }
        else {
            model.party.name = 'Organisation';
            typeOptions.push(model.party);
        }
        model.allowedTypes = typeOptions;
        var options = {
            dataModel: model,
            controller: "ResourceController",
            templateUrl: 'src/app/portal/parties/contacts/contact.component.html',
            onDataChanged: this.contactChanged,
            title: obj.isEditable ? 'Edit contact' : 'View contact',
            promptOnCancel: true
        };
        this.showPopup(options);
    };
    ContactListComponent.prototype.addContact = function () {
        this.selectedContact = {
            isUpdatable: true
        };
        var typeOptions = [];
        var financialAdded = false;
        _.each(this.parties, function (item) {
            if (item.isAccountingCustomer) {
                if (financialAdded === false) {
                    item.name = 'Financial';
                    typeOptions.push(item);
                    financialAdded = true;
                }
            }
            else {
                item.name = 'Organisation';
                typeOptions.push(item);
            }
        });
        this.selectedContact.partyId = typeOptions[0].id;
        var options = {
            dataModel: {
                isNew: true,
                isEditable: true,
                resource: this.selectedContact,
                party: typeOptions[0],
                allowedTypes: typeOptions
            },
            controller: "ResourceController",
            templateUrl: 'src/app/portal/parties/contacts/contact.component.html',
            onDataChanged: this.contactChanged,
            title: 'Add contact',
            promptOnCancel: true
        };
        this.showPopup(options);
    };
    ContactListComponent.prototype.contactChanged = function () {
        this.changed = true;
    };
    ContactListComponent.prototype.showPopup = function (options) {
        var _this = this;
        this.modalWindow.show(options, function (result) {
            _this.contactSaved(result);
        }, function () {
            if (_this.changed && _this.reloadData) {
                _this.reloadData.emit(null);
            }
        }, function (result) {
            _this.contactDeleted(result);
        });
    };
    ContactListComponent.prototype.contactSaved = function (contact) {
        var resource = contact.resource;
        var existing = _.find(this.contacts, function (item) {
            return item.resource.id === resource.id;
        });
        if (util.isUndefined(existing) === false) {
            if (this.update) {
                this.update.emit(resource);
            }
        }
        else {
            if (this.addNew) {
                this.addNew.emit(resource);
            }
        }
    };
    ContactListComponent.prototype.contactDeleted = function (contact) {
        var resource = contact.resource;
        if (this.remove) {
            this.remove.emit(resource);
        }
    };
    __decorate([
        core_1.Input(),
        __metadata("design:type", Object)
    ], ContactListComponent.prototype, "boundToObject", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", Object)
    ], ContactListComponent.prototype, "tableOptions", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", Object)
    ], ContactListComponent.prototype, "sortOptions", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", Object)
    ], ContactListComponent.prototype, "readonly", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", Object)
    ], ContactListComponent.prototype, "selectedSortItem", void 0);
    __decorate([
        core_1.Output(),
        __metadata("design:type", Object)
    ], ContactListComponent.prototype, "onSortByChanged", void 0);
    __decorate([
        core_1.Output(),
        __metadata("design:type", Object)
    ], ContactListComponent.prototype, "addNew", void 0);
    __decorate([
        core_1.Output(),
        __metadata("design:type", Object)
    ], ContactListComponent.prototype, "update", void 0);
    __decorate([
        core_1.Output(),
        __metadata("design:type", Object)
    ], ContactListComponent.prototype, "remove", void 0);
    __decorate([
        core_1.Output(),
        __metadata("design:type", Object)
    ], ContactListComponent.prototype, "reloadData", void 0);
    ContactListComponent = __decorate([
        core_1.Component({
            selector: 'diContactList',
            templateUrl: 'src/app/portal/parties/contacts/list/contact-list.component.html'
        }),
        __param(0, core_1.Inject('modalWindow')),
        __param(1, core_1.Inject('translator')),
        __param(2, core_1.Inject('$stateParams')),
        __metadata("design:paramtypes", [Object, Object, Object])
    ], ContactListComponent);
    return ContactListComponent;
}());
exports.ContactListComponent = ContactListComponent;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(78));
__export(__webpack_require__(79));


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = __webpack_require__(47);
function load(module) {
    module.service('contactHandlerService', index_1.ContactHandlerService);
    module.service('contactProxy', index_1.ContactProxy);
}
exports.load = load;


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(3);
var resource_handler_base_service_1 = __webpack_require__(24);
var ContactHandlerService = (function (_super) {
    __extends(ContactHandlerService, _super);
    function ContactHandlerService(contactProxy, contactListConfigurationService) {
        var _this = _super.call(this, contactListConfigurationService) || this;
        _this.contactProxy = contactProxy;
        _this.contactListConfigurationService = contactListConfigurationService;
        _this.type = "contact";
        return _this;
    }
    ContactHandlerService.prototype.getResourceBook = function (partyId, forPartyId, sortBy) {
        if (sortBy === void 0) { sortBy = 1; }
        return this.contactProxy.getContactBook(partyId, forPartyId, (sortBy || {}) || sortBy);
    };
    ContactHandlerService.prototype.addNewResource = function (resource, forPartyId) {
        if (forPartyId === void 0) { forPartyId = null; }
        return this.contactProxy.addContactBookEntry(resource, forPartyId);
    };
    ContactHandlerService.prototype.updateResource = function (resource, resourceId) {
        return this.contactProxy.updateContactBookEntry(resource, resourceId);
    };
    ContactHandlerService.prototype.removeResource = function (resource, resourceId) {
        return this.contactProxy.removeContactBookEntry(resource, resourceId);
    };
    ContactHandlerService = __decorate([
        core_1.Injectable(),
        __param(0, core_1.Inject('contactProxy')),
        __param(1, core_1.Inject('contactListConfigurationService')),
        __metadata("design:paramtypes", [Object, Object])
    ], ContactHandlerService);
    return ContactHandlerService;
}(resource_handler_base_service_1.ResourceHandlerServiceBase));
exports.ContactHandlerService = ContactHandlerService;
ContactHandlerService.prototype.constructor.$inject = ['contactProxy', 'contactListConfigurationService'];


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(3);
var ContactProxy = (function () {
    function ContactProxy(http, $q, urlHelper) {
        this.http = http;
        this.$q = $q;
        this.urlHelper = urlHelper;
    }
    ContactProxy.prototype.getContactBook = function (partyId, contactBookOwnerId, sortOption) {
        var _this = this;
        var requestProperties = {
            partyId: partyId,
            contactBookOwnerId: contactBookOwnerId,
            sortOption: sortOption
        };
        var requestUrl = this.urlHelper.setParameters('Contact/GetContactBook', requestProperties);
        var httpPromise = this.http.get(requestUrl);
        var newPromise = httpPromise.then(function (data) {
            return data;
        }, function (error) {
            error.failureReason = 'EINVOICING.PORTAL.PARTIES.CONTACTS.ERRORS.RECEIVE_ERROR';
            return _this.$q.reject(error);
        });
        return newPromise;
    };
    ContactProxy.prototype.addContactBookEntry = function (contact, contactBookOwnerId) {
        var _this = this;
        var requestProperties = {
            partyId: contact.partyId,
            contactBookOwnerId: contactBookOwnerId
        };
        var requestUrl = this.urlHelper.setParameters('Contact/AddContactBookEntry', requestProperties);
        var httpPromise = this.http.post(requestUrl, contact)
            .then(function (data) {
            return data;
        }, function (error) {
            error.failureReason = 'EINVOICING.PORTAL.PARTIES.CONTACTS.ERRORS.SAVE_ERROR';
            return _this.$q.reject(error);
        });
        return httpPromise;
    };
    ContactProxy.prototype.updateContactBookEntry = function (contact, resourceId) {
        var _this = this;
        var requestProperties = {
            contactId: resourceId
        };
        var requestUrl = this.urlHelper.setParameters('Contact/UpdateContactBookEntry', requestProperties);
        var httpPromise = this.http.post(requestUrl, contact)
            .then(function (data) {
            return data;
        }, function (error) {
            error.failureReason = 'EINVOICING.PORTAL.PARTIES.CONTACTS.ERRORS.UPDATE_ERROR';
            return _this.$q.reject(error);
        });
        return httpPromise;
    };
    ContactProxy.prototype.removeContactBookEntry = function (contact, resourceId) {
        var _this = this;
        var requestProperties = {
            contactId: resourceId
        };
        var requestUrl = this.urlHelper.setParameters('Contact/RemoveContactBookEntry', requestProperties);
        var httpPromise = this.http.post(requestUrl, contact)
            .then(function (data) {
            return data;
        }, function (error) {
            error.failureReason = 'EINVOICING.PORTAL.PARTIES.CONTACTS.ERRORS.REMOVE_ERROR';
            return _this.$q.reject(error);
        });
        return httpPromise;
    };
    ContactProxy = __decorate([
        core_1.Injectable(),
        __param(0, core_1.Inject('webApiHttp')),
        __param(1, core_1.Inject('$q')),
        __param(2, core_1.Inject('urlHelper')),
        __metadata("design:paramtypes", [Object, Object, Object])
    ], ContactProxy);
    return ContactProxy;
}());
exports.ContactProxy = ContactProxy;
ContactProxy.prototype.constructor.$inject = ['webApiHttp', '$q', 'urlHelper'];


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var party_component_1 = __webpack_require__(98);
var add_party_component_1 = __webpack_require__(75);
var core_1 = __webpack_require__(3);
function load(module) {
    module.directive.apply(module, core_1.provide(add_party_component_1.AddPartyComponent));
    module.directive.apply(module, core_1.provide(party_component_1.PartyComponent));
}
exports.load = load;


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var _loader_1 = __webpack_require__(91);
var _loader_2 = __webpack_require__(86);
function load(module) {
    _loader_1.load(module);
    _loader_2.load(module);
}
exports.load = load;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = __webpack_require__(87);
var core_1 = __webpack_require__(3);
function load(module) {
    module.directive.apply(module, core_1.provide(index_1.LocationListComponent));
    module.service('locationListConfigurationService', index_1.LocationListConfigurationService);
}
exports.load = load;


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(88));
__export(__webpack_require__(89));


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var resource_list_configuration_base_service_1 = __webpack_require__(17);
var core_1 = __webpack_require__(3);
var LocationListConfigurationService = (function (_super) {
    __extends(LocationListConfigurationService, _super);
    function LocationListConfigurationService() {
        var _this = _super.call(this) || this;
        _this._sortOptions = [
            {
                value: 1,
                key: "locationTypeAsc",
                label: "EINVOICING.PORTAL.PARTIES.LOCATIONS.LIST.TABLE.SORT_OPTIONS.LOCATION_TYPE_ASC"
            },
            {
                value: 2,
                key: "locationTypeDesc",
                label: "EINVOICING.PORTAL.PARTIES.LOCATIONS.LIST.TABLE.SORT_OPTIONS.LOCATION_TYPE_DESC"
            },
            {
                value: 3,
                key: "addressNameAsc",
                label: "EINVOICING.PORTAL.PARTIES.LOCATIONS.LIST.TABLE.SORT_OPTIONS.ADDRESS_NAME_ASC"
            },
            {
                value: 4,
                key: "addressNameDesc",
                label: "EINVOICING.PORTAL.PARTIES.LOCATIONS.LIST.TABLE.SORT_OPTIONS.ADDRESS_NAME_DESC"
            },
            {
                value: 5,
                key: "addressAsc",
                label: "EINVOICING.PORTAL.PARTIES.LOCATIONS.LIST.TABLE.SORT_OPTIONS.ADDRESS_ASC"
            },
            {
                value: 6,
                key: "addressDesc",
                label: "EINVOICING.PORTAL.PARTIES.LOCATIONS.LIST.TABLE.SORT_OPTIONS.ADDRESS_DESC"
            },
            {
                value: 7,
                key: "addressIdentifierAsc",
                label: "EINVOICING.PORTAL.PARTIES.LOCATIONS.LIST.TABLE.SORT_OPTIONS.ADDRESS_IDENTIFIER_ASC"
            },
            {
                value: 8,
                key: "addressIdentifierDesc",
                label: "EINVOICING.PORTAL.PARTIES.LOCATIONS.LIST.TABLE.SORT_OPTIONS.ADDRESS_IDENTIFIER_DESC"
            },
            {
                value: 9,
                key: "classificationAsc",
                label: "EINVOICING.PORTAL.PARTIES.LOCATIONS.LIST.TABLE.SORT_OPTIONS.CLASSIFICATION_ASC"
            },
            {
                value: 10,
                key: "classificationDesc",
                label: "EINVOICING.PORTAL.PARTIES.LOCATIONS.LIST.TABLE.SORT_OPTIONS.CLASSIFICATION_DESC"
            }
        ];
        _this._columns = [
            {
                field: 'locationType',
                nameLanguageKey: 'EINVOICING.PORTAL.PARTIES.LOCATIONS.LIST.TABLE.LOCATION_TYPE',
                template: '<span>{{binding.resource.locationTypeTranslated}}</span>'
            },
            {
                field: 'name',
                nameLanguageKey: 'EINVOICING.PORTAL.PARTIES.LOCATIONS.LIST.TABLE.ADDRESS_NAME',
                template: '<span>{{binding.resource.name}}</span>'
            },
            {
                field: 'address',
                nameLanguageKey: 'EINVOICING.PORTAL.PARTIES.LOCATIONS.LIST.TABLE.FORMATTED_ADDRESS',
                template: '<span>{{binding.resource.formatted}}</span>'
            },
            {
                field: 'identifier',
                nameLanguageKey: 'EINVOICING.PORTAL.PARTIES.LOCATIONS.LIST.TABLE.ADDRESS_IDENTIFIER',
                template: '<span>{{binding.resource.identifier.displayValue}}</span>'
            },
            {
                field: 'classification',
                nameLanguageKey: 'EINVOICING.PORTAL.PARTIES.LOCATIONS.LIST.TABLE.CLASSIFICATION',
                template: '<span>{{binding.classification}}</span>'
            }
        ];
        _this._actionColumns = [{
                field: 'actionButtons',
                template: '<di-button ng-if="controller.readonly || !binding.isEditable" image="view" image-colour="button" action="controller.viewLocation(binding)"></di-button>\
                       <di-button ng-if="!controller.readonly && binding.isEditable" image="edit" image-colour="button" action="controller.viewLocation(binding)"></di-button>',
                cellClass: 'cell-right'
            }];
        return _this;
    }
    LocationListConfigurationService.prototype.getSortOptions = function () {
        return Promise.resolve(this._sortOptions);
    };
    LocationListConfigurationService.prototype.getTableOptions = function () {
        var tableOptions = _super.prototype.tableOptions.call(this);
        tableOptions.columns = this._columns;
        tableOptions.actionColumns = this._actionColumns;
        return Promise.resolve(tableOptions);
    };
    LocationListConfigurationService = __decorate([
        core_1.Injectable(),
        __metadata("design:paramtypes", [])
    ], LocationListConfigurationService);
    return LocationListConfigurationService;
}(resource_list_configuration_base_service_1.ResourceListConfigurationServiceBase));
exports.LocationListConfigurationService = LocationListConfigurationService;


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var util = $di.utility.util;
var location_component_controller_1 = __webpack_require__(90);
var core_1 = __webpack_require__(3);
var LocationListComponent = (function () {
    function LocationListComponent(CLIENT_ENUMS, enumTranslator, modalWindow, staticLookupProxy, translator, stateParams, identifierFactory, partyProxy) {
        this.CLIENT_ENUMS = CLIENT_ENUMS;
        this.enumTranslator = enumTranslator;
        this.modalWindow = modalWindow;
        this.staticLookupProxy = staticLookupProxy;
        this.translator = translator;
        this.stateParams = stateParams;
        this.identifierFactory = identifierFactory;
        this.partyProxy = partyProxy;
        this.onSortByChanged = new core_1.EventEmitter();
        this.addNew = new core_1.EventEmitter();
        this.update = new core_1.EventEmitter();
        this.remove = new core_1.EventEmitter();
        this.addPartyCode = new core_1.EventEmitter();
        this.updatePartyCode = new core_1.EventEmitter();
        this.deletePartyCode = new core_1.EventEmitter();
        this.reloadData = new core_1.EventEmitter();
        this.countries = [];
        this.deliveryLocationIdentifiers = [];
        this.viewLocation = this.viewLocation.bind(this);
        this.sortByChanged = this.sortByChanged.bind(this);
    }
    LocationListComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.staticLookupProxy.get('Country').then(function (data) { _this.countries.fill(data); });
        this.partyProxy.getEnabledSchemes().then(function (schemes) {
            _this.defaultOptions = _this.identifierFactory.getDefaultOptions(schemes[_this.CLIENT_ENUMS.partyCodeType.default], 'deliveryLocationIdentifiers', 'deliveryLocationIdentifier', _this.setNewItem);
        });
    };
    LocationListComponent.prototype.ngOnChanges = function (changes) {
        var _this = this;
        if (changes.boundToObject && changes.boundToObject.currentValue) {
            this.translator.whenReady().then(function () {
                _this.parties = changes.boundToObject.currentValue.parties;
                _this.locations = _.map(changes.boundToObject.currentValue.items, function (item) {
                    var location = _.extend({}, item);
                    location.classification = _this.getClasification(location.isGlobal);
                    if (item && item.resource && item.resource.locationType) {
                        location.resource.locationTypeTranslated = _this.enumTranslator.instantTranslate(_this.CLIENT_ENUMS.locationType, item.resource.locationType);
                    }
                    if (item.resource.locationType === _this.CLIENT_ENUMS.locationType.Accounting && location.isEditable) {
                        location.isAddressUpdateableOnly = true;
                    }
                    else {
                        location.isAddressUpdateableOnly = false;
                    }
                    location.resource.identifier = _this.identifierFactory.create(item.resource
                        .locationIdentifierScheme, item.resource.locationIdentifierSchemeId, item.resource.locationIdentifier);
                    return location;
                });
                _this.setAvailableAddressTypeOptionsToAdd();
            });
        }
        if (changes.sortOptions && changes.sortOptions.currentValue) {
            if (this.stateParams.locationSortOption) {
                this.sortBy = _.find(changes.sortOptions.currentValue, function (sortBy) {
                    return sortBy.value === _this.stateParams.locationSortOption;
                });
            }
        }
    };
    LocationListComponent.prototype.getClasification = function (isGlobal) {
        if (isGlobal) {
            return this.translator.instantTranslate('EINVOICING.PORTAL.PARTIES.LOCATIONS.LIST.TABLE.PUBLIC');
        }
        else {
            return this.translator.instantTranslate('EINVOICING.PORTAL.PARTIES.LOCATIONS.LIST.TABLE.PRIVATE');
        }
    };
    LocationListComponent.prototype.sortByChanged = function (value) {
        if (this.sortBy && this.sortBy.value === value) {
            return;
        }
        this.tableOptions.paginationPageNumber = 1;
        this.onSortByChanged.emit(value);
    };
    LocationListComponent.prototype.countryChanged = function (country) {
        this.selectedLocation.country = country;
        this.selectedLocation.countryId = country.id;
    };
    LocationListComponent.prototype.viewLocation = function (obj) {
        obj.party.partyId = obj.party.id;
        obj.party.name = obj.resource.locationTypeTranslated;
        obj.party.locationType = obj.resource.locationType;
        obj.resource.party = obj.party;
        var identifiers = this.defaultOptions;
        obj.identifiers = _.clone(identifiers);
        var exists = _.find(obj.identifiers, function (item) {
            return item.identifier === obj.resource.identifier.identifier;
        });
        if (util.isNullOrUndefined(exists)) {
            obj.identifiers.push(obj.resource.identifier);
        }
        obj.partyCodes = this.setObjectIdentifiers(this.partyCodes.items);
        var options = {
            controller: location_component_controller_1.LocationComponentController,
            templateUrl: 'src/app/portal/parties/locations/location.component.html',
            model: obj,
            addPartyCode: this.addPartyCode,
            updatePartyCode: this.updatePartyCode,
            deletePartyCode: this.deletePartyCode,
            onDataChanged: this.locationChanged,
            onCountryChanged: this.countryChanged,
            title: this.translator.instantTranslate('EINVOICING.PORTAL.PARTIES.LOCATIONS.LIST.' + (obj.isEditable ? 'EDIT' : 'VIEW')),
            save: this.translator.instantTranslate('EINVOICING.PORTAL.PARTIES.LOCATIONS.LIST.SAVE'),
            cancel: this.translator.instantTranslate('EINVOICING.PORTAL.PARTIES.LOCATIONS.LIST.CANCEL'),
            remove: this.translator.instantTranslate('EINVOICING.PORTAL.PARTIES.LOCATIONS.LIST.REMOVE')
        };
        this.showPopup(options);
    };
    LocationListComponent.prototype.setObjectIdentifiers = function (items) {
        var partyCodes = {};
        partyCodes.defaultIdentifiers = this.setIdentifiers(items, this.CLIENT_ENUMS.partyCodeType.default);
        partyCodes.endpointIdentifiers = this.setIdentifiers(items, this.CLIENT_ENUMS.partyCodeType.endpoint);
        partyCodes.taxIdentifiers = this.setIdentifiers(items, this.CLIENT_ENUMS.partyCodeType.taxReference);
        return partyCodes;
    };
    LocationListComponent.prototype.setIdentifiers = function (items, identifierType) {
        return _.chain(items)
            .filter(function (item) {
            return item.code.partyCodeType === identifierType;
        })
            .map(function (item) {
            return {
                id: item.code.id,
                code: item.code.codeValue,
                relatedParty: item.code.relatedPartyId,
                scheme: item.code.scheme,
                schemeId: item.code.schemeId,
                type: item.code.partyCodeType
            };
        })
            .value();
    };
    LocationListComponent.prototype.setAvailableAddressTypeOptionsToAdd = function () {
        var _this = this;
        this.typeOptions = [];
        var isGlobal = this.selfManagement;
        var businessLocation = _.find(this.locations, function (location) { return location.isGlobal === isGlobal && location.resource.locationType === _this.CLIENT_ENUMS.locationType.Business; });
        var businessAdded = util.isDefined(businessLocation);
        var accountingLocation = _.find(this.locations, function (location) { return location.isGlobal === isGlobal && location.resource.locationType === _this.CLIENT_ENUMS.locationType.Accounting; });
        var accountingAdded = util.isDefined(accountingLocation);
        var index = 1;
        var addTypeOption = function (party, locationType) {
            var partyClone = _.clone(party);
            partyClone.partyId = party.id;
            partyClone.id = index++;
            partyClone.name = _this.enumTranslator.instantTranslate(_this.CLIENT_ENUMS.locationType, locationType);
            partyClone.locationType = locationType;
            _this.typeOptions.push(partyClone);
        };
        _.each(this.parties, function (party) {
            if (party.isAccountingCustomer) {
                if (accountingAdded === false) {
                    addTypeOption(party, _this.CLIENT_ENUMS.locationType.Accounting);
                    accountingAdded = true;
                }
            }
            else {
                if (party.isBuyer) {
                    addTypeOption(party, _this.CLIENT_ENUMS.locationType.Delivery);
                }
                if (businessAdded === false) {
                    addTypeOption(party, _this.CLIENT_ENUMS.locationType.Business);
                    businessAdded = true;
                }
            }
        });
        this.canAddNewAddress = this.typeOptions.length > 0;
    };
    LocationListComponent.prototype.addLocation = function () {
        if (this.typeOptions.length > 0) {
            this.selectedLocation = {
                country: '',
                countryCode: '',
                countryId: 0,
                isUpdatable: true
            };
            this.selectedLocation.locationTypeTranslated = this.typeOptions[0].name;
            this.selectedLocation.locationType = this.typeOptions[0].locationType;
            this.selectedLocation.party = this.typeOptions[0];
            var defaultOptions = this.defaultOptions;
            var identifiers = defaultOptions;
            var options = {
                controller: location_component_controller_1.LocationComponentController,
                templateUrl: 'src/app/portal/parties/locations/location.component.html',
                model: {
                    isNew: true,
                    isEditable: true,
                    resource: this.selectedLocation,
                    allowedTypes: this.typeOptions,
                    identifiers: identifiers,
                    party: this.typeOptions[0],
                    partyCodes: this.setObjectIdentifiers(this.partyCodes.items)
                },
                onDataChanged: this.locationChanged,
                onCountryChanged: this.countryChanged,
                title: this.translator.instantTranslate('EINVOICING.PORTAL.PARTIES.LOCATIONS.LIST.LOCATION.ADD'),
                save: this.translator.instantTranslate('EINVOICING.PORTAL.PARTIES.LOCATIONS.LIST.SAVE'),
                cancel: this.translator.instantTranslate('EINVOICING.PORTAL.PARTIES.LOCATIONS.LIST.CANCEL'),
                remove: this.translator.instantTranslate('EINVOICING.PORTAL.PARTIES.LOCATIONS.LIST.DELETE')
            };
            this.showPopup(options);
        }
    };
    LocationListComponent.prototype.getCountryById = function (id) {
        var country = _.find(this.countries, function (country) {
            return country.id === id;
        });
        if (util.isUndefined(country)) {
            country = {};
        }
        return country;
    };
    LocationListComponent.prototype.locationChanged = function () {
        this.changed = true;
    };
    LocationListComponent.prototype.setNewItem = function (item, arrayName) {
        this[arrayName].splice(2, 0, item);
    };
    LocationListComponent.prototype.showPopup = function (options) {
        var _this = this;
        this.modalWindow.show(options, function (result) {
            _this.locationSaved(result);
        }, function () {
            if (_this.changed && _this.reloadData) {
                _this.reloadData.emit(null);
            }
        }, function (result) {
            _this.locationDeleted(result);
        });
    };
    LocationListComponent.prototype.locationSaved = function (location) {
        var resource = location.resource;
        var existing = _.find(this.locations, function (item) {
            return item.resource.id === resource.id;
        });
        if (util.isUndefined(existing) === false) {
            if (this.update) {
                this.update.emit(resource);
            }
        }
        else {
            if (this.addNew) {
                this.addNew.emit(resource);
            }
        }
    };
    LocationListComponent.prototype.locationDeleted = function (location) {
        var resource = location.resource;
        if (this.remove) {
            this.remove.emit(resource);
        }
    };
    __decorate([
        core_1.Input(),
        __metadata("design:type", Object)
    ], LocationListComponent.prototype, "boundToObject", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", Object)
    ], LocationListComponent.prototype, "tableOptions", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", Object)
    ], LocationListComponent.prototype, "sortOptions", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", Object)
    ], LocationListComponent.prototype, "readonly", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", Object)
    ], LocationListComponent.prototype, "selfManagement", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", Object)
    ], LocationListComponent.prototype, "partyCodes", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", Object)
    ], LocationListComponent.prototype, "selectedSortItem", void 0);
    __decorate([
        core_1.Output(),
        __metadata("design:type", Object)
    ], LocationListComponent.prototype, "onSortByChanged", void 0);
    __decorate([
        core_1.Output(),
        __metadata("design:type", Object)
    ], LocationListComponent.prototype, "addNew", void 0);
    __decorate([
        core_1.Output(),
        __metadata("design:type", Object)
    ], LocationListComponent.prototype, "update", void 0);
    __decorate([
        core_1.Output(),
        __metadata("design:type", Object)
    ], LocationListComponent.prototype, "remove", void 0);
    __decorate([
        core_1.Output(),
        __metadata("design:type", Object)
    ], LocationListComponent.prototype, "addPartyCode", void 0);
    __decorate([
        core_1.Output(),
        __metadata("design:type", Object)
    ], LocationListComponent.prototype, "updatePartyCode", void 0);
    __decorate([
        core_1.Output(),
        __metadata("design:type", Object)
    ], LocationListComponent.prototype, "deletePartyCode", void 0);
    __decorate([
        core_1.Output(),
        __metadata("design:type", Object)
    ], LocationListComponent.prototype, "reloadData", void 0);
    LocationListComponent = __decorate([
        core_1.Component({
            selector: 'diLocationList',
            templateUrl: 'src/app/portal/parties/locations/list/location-list.component.html'
        }),
        __param(0, core_1.Inject('CLIENT_ENUMS')),
        __param(1, core_1.Inject('enumTranslator')),
        __param(2, core_1.Inject('modalWindow')),
        __param(3, core_1.Inject('staticLookupProxy')),
        __param(4, core_1.Inject('translator')),
        __param(5, core_1.Inject('$stateParams')),
        __param(6, core_1.Inject('identifierFactory')),
        __param(7, core_1.Inject('partyProxy')),
        __metadata("design:paramtypes", [Object, Object, Object, Object, Object, Object, Object, Object])
    ], LocationListComponent);
    return LocationListComponent;
}());
exports.LocationListComponent = LocationListComponent;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(3);
var modal_base_controller_1 = __webpack_require__(23);
var LocationComponentController = (function (_super) {
    __extends(LocationComponentController, _super);
    function LocationComponentController($element, promptWindow, options, close) {
        var _this = _super.call(this, $element, promptWindow, options, close) || this;
        _this.model = options.model;
        _this.title = options.title;
        _this.save = options.save;
        _this.cancel = options.cancel;
        _this.remove = options.remove;
        _this.options = options;
        _this.partyCodeReadonly = false;
        if (_this.model.isEditable && _this.model.isGlobal) {
            _this.partyCodeReadonly = true;
        }
        return _this;
    }
    LocationComponentController.prototype.addPartyCode = function (data) {
        this.options.addPartyCode.emit(data);
    };
    LocationComponentController.prototype.updatePartyCode = function (data) {
        this.options.updatePartyCode.emit(data);
    };
    LocationComponentController.prototype.deletePartyCode = function (data) {
        this.options.deletePartyCode.emit(data);
    };
    LocationComponentController.prototype.onCountryChanged = function (country) {
        this.changed = true;
        if (this.options.onCountryChanged) {
            this.options.onCountryChanged(country);
        }
        this.onDataChanged();
    };
    LocationComponentController = __decorate([
        core_1.Injectable(),
        __param(0, core_1.Inject('$element')),
        __param(1, core_1.Inject('promptWindow')),
        __param(2, core_1.Inject('options')),
        __param(3, core_1.Inject('close')),
        __metadata("design:paramtypes", [Object, Object, Object, Object])
    ], LocationComponentController);
    return LocationComponentController;
}(modal_base_controller_1.ModalControllerBase));
exports.LocationComponentController = LocationComponentController;
LocationComponentController.prototype.constructor.$inject = ['$element', 'promptWindow', 'options', 'close'];


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = __webpack_require__(48);
function load(module) {
    module.service('locationHandlerService', index_1.LocationHandlerService);
    module.service('locationProxy', index_1.LocationProxy);
}
exports.load = load;


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(3);
var resource_handler_base_service_1 = __webpack_require__(24);
var LocationHandlerService = (function (_super) {
    __extends(LocationHandlerService, _super);
    function LocationHandlerService(locationProxy, locationListConfigurationService) {
        var _this = _super.call(this, locationListConfigurationService) || this;
        _this.locationProxy = locationProxy;
        _this.locationListConfigurationService = locationListConfigurationService;
        _this.type = "location";
        return _this;
    }
    LocationHandlerService.prototype.getResourceBook = function (partyId, forPartyId, sortBy) {
        if (sortBy === void 0) { sortBy = 1; }
        return this.locationProxy.getAddressBook(partyId, forPartyId, (sortBy || {}) || sortBy);
    };
    LocationHandlerService.prototype.addNewResource = function (resource, forPartyId) {
        if (forPartyId === void 0) { forPartyId = null; }
        return this.locationProxy.addAddressBookEntry(resource, forPartyId);
    };
    LocationHandlerService.prototype.updateResource = function (resource, resourceId) {
        return this.locationProxy.updateAddressBookEntry(resource, resourceId);
    };
    LocationHandlerService.prototype.removeResource = function (resource, resourceId) {
        return this.locationProxy.removeAddressBookEntry(resource, resourceId);
    };
    LocationHandlerService = __decorate([
        core_1.Injectable(),
        __param(0, core_1.Inject('locationProxy')),
        __param(1, core_1.Inject('locationListConfigurationService')),
        __metadata("design:paramtypes", [Object, Object])
    ], LocationHandlerService);
    return LocationHandlerService;
}(resource_handler_base_service_1.ResourceHandlerServiceBase));
exports.LocationHandlerService = LocationHandlerService;
LocationHandlerService.prototype.constructor.$inject = ['locationProxy', 'locationListConfigurationService'];


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(3);
var LocationProxy = (function () {
    function LocationProxy(http, $q, urlHelper) {
        this.http = http;
        this.$q = $q;
        this.urlHelper = urlHelper;
    }
    LocationProxy.prototype.getAddressBook = function (partyId, addressBookOwnerId, sortOption) {
        var _this = this;
        var requestProperties = {
            partyId: partyId,
            addressBookOwnerId: addressBookOwnerId,
            sortOption: sortOption
        };
        var requestUrl = this.urlHelper.setParameters('Location/GetAddressBook', requestProperties);
        var httpPromise = this.http.get(requestUrl);
        var newPromise = httpPromise.then(function (data) {
            return data;
        }, function (error) {
            error.failureReason = 'EINVOICING.PORTAL.PARTIES.LOCATIONS.ERRORS.RECEIVE_ERROR';
            return _this.$q.reject(error);
        });
        return newPromise;
    };
    LocationProxy.prototype.addAddressBookEntry = function (location, addressBookOwnerId) {
        var _this = this;
        if (location.locationType === 'Accounting' && location.party.accountingCustomerForPartyId === addressBookOwnerId) {
            addressBookOwnerId = location.party.partyId;
        }
        var requestProperties = {
            partyId: location.party.partyId,
            addressBookOwnerId: addressBookOwnerId
        };
        var requestUrl = this.urlHelper.setParameters('Location/AddAddressBookEntry', requestProperties);
        var httpPromise = this.http.post(requestUrl, location)
            .then(function (data) {
            return data;
        }, function (error) {
            error.failureReason = 'EINVOICING.PORTAL.PARTIES.LOCATIONS.ERRORS.SAVE_ERROR';
            return _this.$q.reject(error);
        });
        return httpPromise;
    };
    LocationProxy.prototype.updateAddressBookEntry = function (location, resourceId) {
        var _this = this;
        var requestProperties = {
            locationId: resourceId
        };
        var requestUrl = this.urlHelper.setParameters('Location/UpdateAddressBookEntry', requestProperties);
        var httpPromise = this.http.post(requestUrl, location)
            .then(function (data) {
            return data;
        }, function (error) {
            error.failureReason = 'EINVOICING.PORTAL.PARTIES.LOCATIONS.ERRORS.UPDATE_ERROR';
            return _this.$q.reject(error);
        });
        return httpPromise;
    };
    LocationProxy.prototype.removeAddressBookEntry = function (location, resourceId) {
        var _this = this;
        var requestProperties = {
            locationId: resourceId
        };
        var requestUrl = this.urlHelper.setParameters('Location/RemoveAddressBookEntry', requestProperties);
        var httpPromise = this.http.post(requestUrl, location)
            .then(function (data) {
            return data;
        }, function (error) {
            error.failureReason = 'EINVOICING.PORTAL.PARTIES.LOCATIONS.ERRORS.REMOVE_ERROR';
            return _this.$q.reject(error);
        });
        return httpPromise;
    };
    LocationProxy = __decorate([
        core_1.Injectable(),
        __param(0, core_1.Inject('webApiHttp')),
        __param(1, core_1.Inject('$q')),
        __param(2, core_1.Inject('urlHelper')),
        __metadata("design:paramtypes", [Object, Object, Object])
    ], LocationProxy);
    return LocationProxy;
}());
exports.LocationProxy = LocationProxy;
LocationProxy.prototype.constructor.$inject = ['webApiHttp', '$q', 'urlHelper'];


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(96));


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = __webpack_require__(94);
var core_1 = __webpack_require__(3);
function load(module) {
    module.directive.apply(module, core_1.provide(index_1.PartyCodeComponent));
}
exports.load = load;


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var util = $di.utility.util;
var core_1 = __webpack_require__(3);
var PartyCodeComponent = (function () {
    function PartyCodeComponent(partyProxy, identifierFactory, clientEnums, modalWindow, elementNotifier, $element, $q) {
        this.partyProxy = partyProxy;
        this.identifierFactory = identifierFactory;
        this.clientEnums = clientEnums;
        this.modalWindow = modalWindow;
        this.elementNotifier = elementNotifier;
        this.$element = $element;
        this.$q = $q;
        this.addNewCode = new core_1.EventEmitter();
        this.updatePartyCode = new core_1.EventEmitter();
        this.deletePartyCode = new core_1.EventEmitter();
        this.partyProxy = partyProxy;
        this.identifierFactory = identifierFactory;
        this.clientEnums = clientEnums;
        this.modalWindow = modalWindow;
        this.elementNotifier = elementNotifier;
        this.$element = $element;
        this.$q = $q;
    }
    PartyCodeComponent.prototype.$onInit = function () {
        var _this = this;
        this.partyProxy.getEnabledSchemes().then(function (schemes) {
            _this.partyCodeTypeSchemes = schemes[_this.clientEnums.partyCodeType[_this.partyCodeType]];
            _this.partyCodeOptions = _this.identifierFactory.getDefaultOptions(schemes[_this.clientEnums.partyCodeType[_this.partyCodeType]], 'partyCodes', 'identifier', false, null, _this.getButtonLabels(), true);
        });
    };
    PartyCodeComponent.prototype.editPartyCode = function (partyCode) {
        var _this = this;
        this.identifierFactory.edit(partyCode, this.partyCodeTypeSchemes, this.relatedParties, 'identifier', function (data) {
            data.partyCodeType = _this.clientEnums.partyCodeType[_this.partyCodeType];
            _this.partyCodes = _.map(_this.partyCodes, function (partyCode) {
                if (partyCode.id === data.id) {
                    partyCode.id = data.id;
                    partyCode.code = data.code;
                    partyCode.scheme = data.scheme;
                    partyCode.schemeId = data.schemeId;
                    if (util.isDefined(data.relatedParty)) {
                        partyCode.relatedPartyDetails = data.relatedParty;
                        partyCode.relatedParty = data.relatedParty.id;
                        data.relatedPartyId = data.relatedParty.id;
                    }
                }
                return partyCode;
            });
            _this.updatePartyCode.emit({ data: data });
        }, this.getButtonLabels(), true, this.partyId, this.partyCodeType);
    };
    PartyCodeComponent.prototype.addNewPartyCode = function () {
        var _this = this;
        this.partyCodeOptions[1].addNew(function (data) {
            data.type = _this.partyCodeType;
            _this.addNewCode.emit({ data: data });
            _this.partyCodes.push(data);
        }, this.partyId, this.partyCodeType);
    };
    PartyCodeComponent.prototype.delete = function (partyCode) {
        this.deletePartyCode.emit({ partyCode: partyCode });
    };
    PartyCodeComponent.prototype.getButtonLabels = function () {
        return {
            save: "EINVOICING.PORTAL.COMPONENTS.IDENTIFIER_SELECTOR.ACTIONS.SAVE",
            cancel: "EINVOICING.PORTAL.COMPONENTS.IDENTIFIER_SELECTOR.ACTIONS.CANCEL"
        };
    };
    __decorate([
        core_1.Input(),
        __metadata("design:type", Object)
    ], PartyCodeComponent.prototype, "readonly", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", Object)
    ], PartyCodeComponent.prototype, "partyCodes", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", Object)
    ], PartyCodeComponent.prototype, "relatedParties", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", Object)
    ], PartyCodeComponent.prototype, "partyCodeType", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", Object)
    ], PartyCodeComponent.prototype, "partyId", void 0);
    __decorate([
        core_1.Output(),
        __metadata("design:type", core_1.EventEmitter)
    ], PartyCodeComponent.prototype, "addNewCode", void 0);
    __decorate([
        core_1.Output(),
        __metadata("design:type", core_1.EventEmitter)
    ], PartyCodeComponent.prototype, "updatePartyCode", void 0);
    __decorate([
        core_1.Output(),
        __metadata("design:type", core_1.EventEmitter)
    ], PartyCodeComponent.prototype, "deletePartyCode", void 0);
    PartyCodeComponent = __decorate([
        core_1.Component({
            selector: 'diPartyCode',
            templateUrl: 'src/app/portal/parties/party-codes/party-code.component.html'
        }),
        __param(0, core_1.Inject('partyProxy')),
        __param(1, core_1.Inject('identifierFactory')),
        __param(2, core_1.Inject('CLIENT_ENUMS')),
        __param(3, core_1.Inject('modalWindow')),
        __param(4, core_1.Inject('elementNotifier')),
        __param(5, core_1.Inject('$element')),
        __param(6, core_1.Inject('$q')),
        __metadata("design:paramtypes", [Object, Object, Object, Object, Object, Object, Object])
    ], PartyCodeComponent);
    return PartyCodeComponent;
}());
exports.PartyCodeComponent = PartyCodeComponent;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var party_code_handler_service_1 = __webpack_require__(50);
var party_code_configuration_service_1 = __webpack_require__(49);
function load(module) {
    module.service('partyCodeHandlerService', party_code_handler_service_1.PartyCodeHandlerService);
    module.service('partyCodeConfigurationService', party_code_configuration_service_1.PartyCodeConfigurationService);
}
exports.load = load;


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var util = $di.utility.util;
var core_1 = __webpack_require__(3);
var shared_1 = __webpack_require__(48);
var shared_2 = __webpack_require__(47);
var party_code_handler_service_1 = __webpack_require__(50);
var PartyComponent = (function () {
    function PartyComponent(locationHandlerService, contactHandlerService, partyCodeHandlerService, stateParams, $q, notificationHandler, userRightsRepository, diState, partyProxy, listsParamsStore) {
        this.locationHandlerService = locationHandlerService;
        this.contactHandlerService = contactHandlerService;
        this.partyCodeHandlerService = partyCodeHandlerService;
        this.stateParams = stateParams;
        this.$q = $q;
        this.notificationHandler = notificationHandler;
        this.userRightsRepository = userRightsRepository;
        this.diState = diState;
        this.partyProxy = partyProxy;
        this.listsParamsStore = listsParamsStore;
        this.displayErrorNotification = this.displayErrorNotification.bind(this);
    }
    PartyComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.partyId = this.stateParams.id;
        this.partyName = this.stateParams.partyName;
        this.trySetPartyNameIfNotSetAsync(this.partyId, this.partyName);
        this.forPartyId = this.stateParams.forPartyId;
        this.singleDetails = this.stateParams.singleDetails;
        this.forPartyName = this.stateParams.forPartyName;
        this.trySetPartyNameIfNotSetAsync(this.forPartyId, this.forPartyName);
        var locationPromises = this.initialise(this.locationHandlerService);
        this.$q.all(locationPromises).then(function (_a) {
            var items = _a[0], tableOptions = _a[1], sortOptions = _a[2], parties = _a[3];
            _this.locations = items;
            _this.locationSortOptions = sortOptions;
            _this.locationTableOptions = tableOptions;
            _this.parties = parties;
            _this.locationListObject = {
                index: 1,
                items: items,
                parties: parties
            };
            _this.selectedLocationSortOption = _this.getSelectedOrDefault(sortOptions, _this.locationHandlerService);
        }, this.displayErrorNotification);
        var contactPromises = this.initialise(this.contactHandlerService);
        this.$q.all(contactPromises).then(function (_a) {
            var items = _a[0], tableOptions = _a[1], sortOptions = _a[2], parties = _a[3];
            _this.contacts = items;
            _this.contactSortOptions = sortOptions;
            _this.contactTableOptions = tableOptions;
            _this.parties = parties;
            _this.contactListObject = {
                index: 1,
                items: items,
                parties: parties
            };
            _this.selectedContactSortOption = _this.getSelectedOrDefault(sortOptions, _this.contactHandlerService);
        }, this.displayErrorNotification);
        var partyCodePromises = this.initialise(this.partyCodeHandlerService);
        this.$q.all(partyCodePromises).then(function (_a) {
            var items = _a[0], tableOptions = _a[1], sortOptions = _a[2], parties = _a[3];
            _this.partyCodes = items;
            _this.partyCodeSortOptions = sortOptions;
            _this.partyCodeTableOptions = tableOptions;
            _this.parties = parties;
            _this.partyCodeListObject = {
                index: 1,
                items: items,
                parties: parties
            };
        }, this.displayErrorNotification);
        this.readonly = !this.userRightsRepository.userHasRight("Supervisor");
    };
    PartyComponent.prototype.initialise = function (handlerService) {
        var savedSortOption = this.stateParams[handlerService.type + 'SortOption'];
        var sortOption = 1;
        if (savedSortOption) {
            sortOption = savedSortOption;
        }
        var promises = handlerService.init(this.partyId, this.forPartyId, sortOption);
        var partiesPromise = this.partyProxy.getPartyWithAccountingCustomers(this.partyId);
        promises.push(partiesPromise);
        return promises;
    };
    PartyComponent.prototype.getSelectedOrDefault = function (sortCollection, handlerService) {
        return _.findWhere(sortCollection, { value: this.getSortOption(handlerService) });
    };
    PartyComponent.prototype.getSortOption = function (handlerService) {
        var savedSortOption = this.stateParams[handlerService.type + 'SortOption'];
        var sortOption = 1;
        if (savedSortOption) {
            sortOption = savedSortOption;
        }
        return sortOption;
    };
    PartyComponent.prototype.addNew = function (resource, handlerService) {
        var _this = this;
        var promise = handlerService.addNewResource(resource, this.forPartyId);
        this.$q.when(promise).then(function (data) {
            if (!data) {
                _this.displayErrorNotification({ failureReason: data.message });
            }
            else {
                _this.refreshData(1, handlerService);
                _this.displaySuccessNotification('EINVOICING.PORTAL.PARTIES.ACTIONS.ADDED', handlerService.type);
            }
        }, this.displayErrorNotification);
    };
    PartyComponent.prototype.update = function (resource, handlerService) {
        var _this = this;
        var promise = handlerService.updateResource(resource, resource.id);
        this.$q.when(promise).then(function (data) {
            if (!data) {
                _this.refreshData(1, handlerService);
                _this.displayErrorNotification({ failureReason: data.message });
            }
            else {
                _this.refreshData(1, handlerService);
                _this.displaySuccessNotification('EINVOICING.PORTAL.PARTIES.ACTIONS.UPDATED', _this.titleCase(handlerService.type));
            }
        }, this.displayErrorNotification);
    };
    PartyComponent.prototype.delete = function (resource, handlerService) {
        console.log(resource, "delete");
        //let promise = handlerService.updateResource(resource, resource.id);
        //this.$q.when(promise).then((data) => {
        //        if (!data) {
        //            this.refreshData(1, handlerService);
        //            this.displayErrorNotification({ failureReason: data.message });
        //        } else {
        //            this.refreshData(1, handlerService);
        //            this.displaySuccessNotification('EINVOICING.PORTAL.PARTIES.ACTIONS.UPDATED',
        //                this.titleCase(handlerService.type));
        //        }
        //    },
        //    this.displayErrorNotification);
    };
    PartyComponent.prototype.remove = function (resource, handlerService) {
        var _this = this;
        var promise = handlerService.removeResource(resource, resource.id);
        this.$q.when(promise).then(function () {
            _this.refreshData(1, handlerService);
            _this.displaySuccessNotification('EINVOICING.PORTAL.PARTIES.ACTIONS.REMOVED', _this.titleCase(handlerService.type));
        }, this.displayErrorNotification);
    };
    PartyComponent.prototype.titleCase = function (str) {
        str = str.toLowerCase().split(' ').map(function (word) {
            return (word.charAt(0).toUpperCase() + word.slice(1));
        });
        return str.join(' ');
    };
    PartyComponent.prototype.refreshData = function (sortBy, handlerService) {
        var _this = this;
        var promise = handlerService.getResourceBook(this.partyId, this.forPartyId, sortBy);
        this.$q.when(promise).then(function (items) {
            if (handlerService.type === 'location') {
                _this.locations = items;
                var cloned = _.clone(_this.locationListObject);
                cloned.items = items;
                _this.locationListObject = cloned;
            }
            else if (handlerService.type === 'contact') {
                _this.contacts = items;
                var cloned = _.clone(_this.contactListObject);
                cloned.items = items;
                _this.contactListObject = cloned;
            }
        }, this.displayErrorNotification);
    };
    PartyComponent.prototype.sortByChanged = function (value, handlerService) {
        var newParams = this.listsParamsStore.get("partyDetails");
        if (!newParams) {
            newParams = [];
        }
        newParams[handlerService.type + 'SortOption'] = value;
        var params = _.extend({}, newParams);
        this.listsParamsStore.set("partyDetails", params);
        var redirectParams = _.extend({
            id: this.partyId,
            partyName: this.partyName,
            forPartyId: this.forPartyId,
            forPartyName: this.forPartyName
        }, params);
        this.diState.go(this.stateParams.ownStateName, redirectParams, { reload: true });
    };
    PartyComponent.prototype.displayErrorNotification = function (reason) {
        if (reason === void 0) { reason = {}; }
        this.notificationHandler.showError(reason.failureReason);
    };
    PartyComponent.prototype.displaySuccessNotification = function (message, identifier) {
        this.notificationHandler.showSuccess(message, identifier);
    };
    PartyComponent.prototype.backToList = function () {
        if (this.partyId === this.forPartyId) {
            this.diState.go('portal.parties.mylist');
        }
        else {
            var params = this.listsParamsStore.get("parties");
            this.diState.go('portal.parties.list', params);
        }
    };
    PartyComponent.prototype.trySetPartyNameIfNotSetAsync = function (partyIdPropertyName, partyNamePropertyName) {
        var _this = this;
        if (util.isNumber(partyIdPropertyName) && partyIdPropertyName > 0 &&
            !util.isNonEmptyString(partyNamePropertyName)) {
            this.partyProxy.get(partyIdPropertyName)
                .then(function (party) {
                partyNamePropertyName = _this.stateParams[partyNamePropertyName] = party.name;
            }, function (error) { });
        }
    };
    PartyComponent.prototype.locationSortByChanged = function (value) {
        this.sortByChanged(value, this.locationHandlerService);
    };
    PartyComponent.prototype.locationAddNew = function (resource) {
        this.addNew(resource, this.locationHandlerService);
    };
    PartyComponent.prototype.locationUpdate = function (resource) {
        this.update(resource, this.locationHandlerService);
    };
    PartyComponent.prototype.locationRemove = function (resource) {
        this.remove(resource, this.locationHandlerService);
    };
    PartyComponent.prototype.locationReloadData = function () {
        this.refreshData(1, this.locationHandlerService);
    };
    PartyComponent.prototype.contactSortByChanged = function (value) {
        this.sortByChanged(value, this.contactHandlerService);
    };
    PartyComponent.prototype.contactAddNew = function (resource) {
        this.addNew(resource, this.contactHandlerService);
    };
    PartyComponent.prototype.contactUpdate = function (resource) {
        this.update(resource, this.contactHandlerService);
    };
    PartyComponent.prototype.contactRemove = function (resource) {
        this.remove(resource, this.contactHandlerService);
    };
    PartyComponent.prototype.contactReloadData = function () {
        this.refreshData(1, this.contactHandlerService);
    };
    PartyComponent.prototype.partyCodeSortByChanged = function (value) {
        this.sortByChanged(value, this.partyCodeHandlerService);
    };
    PartyComponent.prototype.partyCodeAddNew = function (resource) {
        this.addNew(resource, this.partyCodeHandlerService);
    };
    PartyComponent.prototype.partyCodeUpdate = function (resource) {
        this.update(resource, this.partyCodeHandlerService);
    };
    PartyComponent.prototype.partyCodeDelete = function (resource) {
        this.delete(resource, this.partyCodeHandlerService);
    };
    PartyComponent.prototype.partyCodeRemove = function (resource) {
        this.remove(resource, this.partyCodeHandlerService);
    };
    PartyComponent.prototype.partyCodeReloadData = function () {
        this.refreshData(1, this.partyCodeHandlerService);
    };
    PartyComponent = __decorate([
        core_1.Component({
            selector: 'diParty',
            templateUrl: 'src/app/portal/parties/party.component.html',
            providers: [
                { provide: 'contactHandlerService', useClass: shared_2.ContactHandlerService },
                { provide: 'locationHandlerService', useClass: shared_1.LocationHandlerService },
                { provide: 'partyCodeHandlerService', useClass: party_code_handler_service_1.PartyCodeHandlerService }
            ]
        }),
        __param(0, core_1.Inject('locationHandlerService')),
        __param(1, core_1.Inject('contactHandlerService')),
        __param(2, core_1.Inject('partyCodeHandlerService')),
        __param(3, core_1.Inject('$stateParams')),
        __param(4, core_1.Inject('$q')),
        __param(5, core_1.Inject('notificationHandler')),
        __param(6, core_1.Inject('userRightsRepository')),
        __param(7, core_1.Inject('diState')),
        __param(8, core_1.Inject('partyProxy')),
        __param(9, core_1.Inject('listsParamsStore')),
        __metadata("design:paramtypes", [shared_1.LocationHandlerService,
            shared_2.ContactHandlerService,
            party_code_handler_service_1.PartyCodeHandlerService, Object, Object, Object, Object, Object, Object, Object])
    ], PartyComponent);
    return PartyComponent;
}());
exports.PartyComponent = PartyComponent;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(3);
var DocumentStateSelectorComponent = (function () {
    function DocumentStateSelectorComponent() {
        this.onChangedState = new core_1.EventEmitter();
    }
    Object.defineProperty(DocumentStateSelectorComponent.prototype, "selectedState", {
        set: function (a) {
            this.item = a;
            console.log(this.item);
        },
        enumerable: true,
        configurable: true
    });
    DocumentStateSelectorComponent.prototype.selectState = function (item) {
        if (!item)
            return;
        if (this.item === item)
            return;
        this.item = item;
        if (this.onChangedState) {
            this.onChangedState.emit(item.value);
        }
    };
    __decorate([
        core_1.Input(),
        __metadata("design:type", Array)
    ], DocumentStateSelectorComponent.prototype, "items", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", Object)
    ], DocumentStateSelectorComponent.prototype, "image", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], DocumentStateSelectorComponent.prototype, "selectedState", null);
    __decorate([
        core_1.Output(),
        __metadata("design:type", Object)
    ], DocumentStateSelectorComponent.prototype, "onChangedState", void 0);
    DocumentStateSelectorComponent = __decorate([
        core_1.Component({
            selector: 'diDocumentStateSelector',
            templateUrl: 'src/app/portal/shared/components/document-state-selector/document-state-selector.html'
        }),
        __metadata("design:paramtypes", [])
    ], DocumentStateSelectorComponent);
    return DocumentStateSelectorComponent;
}());
exports.DocumentStateSelectorComponent = DocumentStateSelectorComponent;


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(99));


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = __webpack_require__(100);
var core_1 = __webpack_require__(3);
function load(module) {
    module.directive.apply(module, core_1.provide(index_1.DocumentStateSelectorComponent));
}
exports.load = load;


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAU0L}
// di.core
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(118)], __WEBPACK_AMD_DEFINE_RESULT__ = function (spaLoader) {
    'use strict';

    return function (module) {
        spaLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CGL01}
// di.core.global
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(104), __webpack_require__(658), __webpack_require__(105), __webpack_require__(107), __webpack_require__(109), __webpack_require__(110), __webpack_require__(112)], __WEBPACK_AMD_DEFINE_RESULT__ = function () {}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    window.$di = window.$di || {};
    window.$di.angular = window.$di.angular || {};
    window.$di.debug = window.$di.debug || {};
    window.$di.event = window.$di.event || {};
    window.$di.exception = window.$di.exception || {};
    window.$di.utility = window.$di.utility || {};
    window.$di.utility.placeholders = window.$di.utility.placeholders || {};
    window.$di.utility.placeholders.arguments = window.$di.utility.placeholders.arguments || {};

    return;
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CGD02}
// di.core.global.debug
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(106)], __WEBPACK_AMD_DEFINE_RESULT__ = function () {}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CGD01}
// di.core.global.debug
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(10)], __WEBPACK_AMD_DEFINE_RESULT__ = function (util) {
    'use strict';

    /** debug helper */

    window.$di.debug.debugger = {
        enabled: false,
        log: _log,
        newLogger: newLogger,
        breakHere: breakHere
    };

    return window.$di.debug.debugger;

    /**
     * logs to the console
     * @param data
     * @returns
     */
    function _log(data, logContext) {
        if (window.$di.debug.debugger.enabled) {
            var logData;

            if (!logContext) {
                logData = data;
            } else {
                logData = {
                    _logContext: logContext,
                    data: data
                };
            }

            console.log(logData);
        }
    }

    /**
     * returns a new logging object which adds context information to each log
     * @param logContext
     */
    function newLogger(logContext) {
        return {
            log: function log(data) {
                _log(data, logContext);
            }
        };
    }

    /**
     * adds breakpoint
     */
    function breakHere(condition) {
        if (this.enabled && (!util.isDefined(condition) || condition)) {
            debugger;
        }
    }
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:/GE01}
// di.core.global.event
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(108)], __WEBPACK_AMD_DEFINE_RESULT__ = function () {}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:NAM01}
// di.core.global.event
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($) {
    'use strict';

    var valListenerAdded = false;

    window.$di.event.jqueryEventSubscriber = {
        listenToVal: listenToVal
    };

    return window.$di.event.jqueryEventSubscriber;

    function listenToVal() {
        if (valListenerAdded) {
            return;
        }

        var originalVal = $.fn.val;

        $.fn.val = function () {
            var result = originalVal.apply(this, arguments);

            if (arguments.length > 0) {
                $(this).trigger('val');
            }

            return result;
        };

        valListenerAdded = true;
    }
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CGE01}
// di.core.global.exception
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(12)], __WEBPACK_AMD_DEFINE_RESULT__ = function () {}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CGP01}
// di.core.global.prototypeExtensions
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(111)], __WEBPACK_AMD_DEFINE_RESULT__ = function () {}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CGP02}
// di.core.global.prototypeExtensions
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    Array.prototype.pushArray = pushArray;
    Array.prototype.clear = clear;
    Array.prototype.fill = fill;

    return;

    function pushArray() {
        this.push.apply(this, this.concat.apply([], arguments));
    }

    function clear() {
        this.length = 0;
    }

    function fill() {
        this.clear();
        this.pushArray.apply(this, arguments);
    }
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CGU02}
// di.core.global.utility
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(113), __webpack_require__(10), __webpack_require__(114)], __WEBPACK_AMD_DEFINE_RESULT__ = function () {}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CGU0C}
// di.core.global.utility
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(10)], __WEBPACK_AMD_DEFINE_RESULT__ = function (util) {
    'use strict';

    window.$di.utility.compatability = {
        transitionEndEvent: getTransitionEndEvent()
    };

    return window.$di.utility.compatability;

    function getTransitionEndEvent() {
        var transitionEndNames = {
            'WebkitTransition': 'webkitTransitionEnd',
            'MozTransition': 'transitionend',
            'OTransition': 'oTransitionEnd',
            'msTransition': 'MSTransitionEnd',
            'transition': 'transitionend'
        };

        if (util.isDefined(window.Modernizr)) {
            return transitionEndNames[window.Modernizr.prefixed('transition')];
        } else {
            return undefined;
        }
    }
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CGU07}
// di.core.global.utility
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(52), __webpack_require__(117), __webpack_require__(115)], __WEBPACK_AMD_DEFINE_RESULT__ = function () {}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CGU0B}
// di.core.global.utility
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(51), __webpack_require__(116)], __WEBPACK_AMD_DEFINE_RESULT__ = function () {}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CGU08}
// di.core.global.utility.placeholders.arguments
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(12)], __WEBPACK_AMD_DEFINE_RESULT__ = function (guard) {
    'use strict';

    var DELIMITER = ',';
    var OPEN_BRACE = '{';
    var CLOSE_BRACE = '}';

    window.$di.utility.placeholders.arguments.split = split;

    return window.$di.utility.placeholders.arguments.split;

    /**
     * Provides the ability to split arguments used in conjunction with the di-translate directive.
     * @param argumentString
     */
    function split(argumentString) {
        guard.throwIfNullOrUndefined("CGU0801E", argumentString, "argumentString");

        var chunks = [];
        var insideBraces = false;
        var lastChunkIndex = 0;

        for (var i = 0; i < argumentString.length; i++) {
            if (argumentString[i] === OPEN_BRACE) {
                insideBraces = true;
            }

            if (insideBraces && argumentString[i] == CLOSE_BRACE) {
                insideBraces = false;
            }

            if (!insideBraces && argumentString[i] === DELIMITER) {
                chunks.push(argumentString.substring(lastChunkIndex, i).trim());
                lastChunkIndex = i + 1;
            }
        }

        // whatever is remaining is unlikely to be an object - push it onto the queue
        if (lastChunkIndex < i) {
            chunks.push(argumentString.substring(lastChunkIndex, i).trim());
        }

        return chunks;
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CGU04}
// di.core.global.utility
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(52), __webpack_require__(51), __webpack_require__(12), __webpack_require__(10)], __WEBPACK_AMD_DEFINE_RESULT__ = function (extract, map, guard, util) {
    'use strict';

    window.$di.utility.placeholders.replace = replace;

    return window.$di.utility.placeholders.replace;

    /**
     * Replaces any placeholders found in a given string with the arguments provided.
     * @param placeholderString
     * @param args
     */
    function replace(placeholderString, args, argumentFilter) {
        guard.throwIfNullOrUndefined("CGU0401E", placeholderString, "placeholderString");
        guard.throwIfNullOrUndefined("CGU0402E", args, "args");

        var placeholders = extract(placeholderString);
        var mappedArguments;
        var filteredArguments;
        var replacing;

        placeholders = extract(placeholderString);
        mappedArguments = map(placeholders, args);

        if (util.isObject(args) && !util.isArray(args)) {
            mappedArguments = args;
        } else {
            mappedArguments = map(placeholders, args);
        }

        if (argumentFilter) {
            filteredArguments = argumentFilter(mappedArguments);
        } else {
            filteredArguments = mappedArguments;
        }

        placeholderString = placeholderString.replace(/<%=([\s.a-zA-Z0-9]+)%>/g, function (str) {
            return str.replace(/\./g, '_');
        });

        replacing = _.template(placeholderString);

        return replacing(filteredArguments);
    }
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAN01}
// di.core.angular
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(120), __webpack_require__(136), __webpack_require__(209), __webpack_require__(215), __webpack_require__(220), __webpack_require__(240), __webpack_require__(222), __webpack_require__(224), __webpack_require__(231), __webpack_require__(253), __webpack_require__(261), __webpack_require__(290), __webpack_require__(294), __webpack_require__(201), __webpack_require__(138), __webpack_require__(229), __webpack_require__(204), __webpack_require__(213), __webpack_require__(236)], __WEBPACK_AMD_DEFINE_RESULT__ = function (authenticationLoader, cachingLoader, exceptionLoader, httpLoader, loggingLoader, userSecurityLoader, sessionLoader, stateLoader, translationLoader, utilityLoader, validationLoader, watchersLoader, windowLoader, currencyLoader, controlsLoader, staticLookupLoader, dateLoader, fileLoader, urlLoader) {
	'use strict';

	return function (module) {
		authenticationLoader(module);
		cachingLoader(module);
		exceptionLoader(module);
		httpLoader(module);
		loggingLoader(module);
		userSecurityLoader(module);
		sessionLoader(module);
		stateLoader(module);
		translationLoader(module);
		utilityLoader(module);
		validationLoader(module);
		watchersLoader(module);
		windowLoader(module);
		currencyLoader(module);
		controlsLoader(module);
		staticLookupLoader(module);
		dateLoader(module);
		fileLoader(module);
		urlLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAA0C}
// di.core.angular.authentication
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.config(configureAuthenticationHttpInterceptor);

        configureAuthenticationHttpInterceptor.$inject = ['$httpProvider'];
        function configureAuthenticationHttpInterceptor($httpProvider) {
            $httpProvider.interceptors.push('authenticationHttpInterceptor');
        }
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAA03}
// di.core.angular.authentication
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(119), __webpack_require__(122), __webpack_require__(123), __webpack_require__(131), __webpack_require__(125), __webpack_require__(124), __webpack_require__(128), __webpack_require__(133), __webpack_require__(129), __webpack_require__(130), __webpack_require__(135), __webpack_require__(126), __webpack_require__(127), __webpack_require__(132), __webpack_require__(134), __webpack_require__(121)], __WEBPACK_AMD_DEFINE_RESULT__ = function (configLoader, authenticationClientEventSubscriberLoader, authenticationControllerLoader, authenticationDirectiveLoader, authenticationHttpInterceptorLoader, authenticationDataLoader, authenticationStoreLoader, userAuthenticationProxyLoader, authenticationTicketValidatorLoader, authorizedObjectsFilterLoader, userRightsRepositoryLoader, authenticationPromptConfiguratorLoader, authenticationResultLoader, loggedOutReasonLoader, userIdleActivityMonitorLoader, activityMonitor) {
	'use strict';

	return function (module) {
		userIdleActivityMonitorLoader(module);
		authenticationClientEventSubscriberLoader(module);
		authenticationControllerLoader(module);
		authenticationDirectiveLoader(module);
		authenticationHttpInterceptorLoader(module);
		authenticationDataLoader(module);
		authenticationStoreLoader(module);
		userAuthenticationProxyLoader(module);
		authenticationTicketValidatorLoader(module);
		authorizedObjectsFilterLoader(module);
		userRightsRepositoryLoader(module);
		authenticationPromptConfiguratorLoader(module);
		configLoader(module);
		authenticationResultLoader(module);
		loggedOutReasonLoader(module);
		activityMonitor(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;
        var util = $di.utility.util;

        module.provider('activityMonitor', activityMonitor);

        function activityMonitor() {

            var provider = {
                configure: configure,
                $get: $get
            };

            provider.$get.$inject = ['userIdleActivityMonitor', 'authenticationData', 'authenticationClientEventSubscriber', 'authenticationTicketValidator', 'promptWindow', 'translator', 'LOGGED_OUT_REASON'];

            return provider;

            function configure(cfg) {}

            function $get(userIdleActivityMonitor, authenticationData, authenticationClientEventSubscriber, authenticationTicketValidator, promptWindow, translator, LOGGED_OUT_REASON) {

                function sessionAboutToExpiry(idle, timeout) {
                    translator.translate('CORE.AUTHENTICATION.SESSION_EXPIRY_TITLE').then(function (translated) {
                        promptWindow.alert({
                            title: translated,
                            message: translator.instantTranslate('CORE.AUTHENTICATION.SESSION_EXPIRY', { idle: idle / 60, timeout: timeout / 60 }),
                            callback: function callback() {
                                if (authenticationData.userData.isAuthenticated) {
                                    start();
                                    authenticationTicketValidator.validateTicket(true, function () {});
                                }
                            }
                        });
                    });
                }

                function sessionTimeout() {
                    authenticationClientEventSubscriber.loggedOut(LOGGED_OUT_REASON.SessionTimeout);
                }

                return {
                    start: start,
                    stop: stop
                };

                function start() {
                    userIdleActivityMonitor.start({
                        idleStartedHandler: sessionAboutToExpiry,
                        idleEndHandler: function idleEndHandler() {},
                        idleTimeoutHandler: sessionTimeout
                    });
                }

                function stop() {
                    userIdleActivityMonitor.stop();
                }
            }
        }

        return activityMonitor;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAA09}
/// di.core.angular.authentication
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var guard = $di.exception.guard;

		module.provider('authenticationClientEventSubscriber', authenticationClientEventSubscriberProvider);

		/**
  * Performs actions in response to common authentication events
  */
		function authenticationClientEventSubscriberProvider() {
			var config = {
				unauthenticatedState: 'welcome',
				authenticatedState: 'portal',
				changePasswordState: 'portal.account.management'
			};

			var provider = {
				configure: configure,
				$get: $get
			};

			provider.$get.$inject = ['$rootScope', 'diState', 'authenticationStore', 'LOGGED_OUT_REASON', 'loggerProxy'];

			return provider;

			/**
   * Configure the service
   * @param cfg
   */
			function configure(cfg) {
				guard.throwIfNotAnObject("CAA0901E", cfg, "cfg");

				config = cfg;
			}

			function $get(rootScope, diState, authenticationStore, LOGGED_OUT_REASON, loggerProxy) {
				var loggedInEventHandlers = [];
				var loggedOutEventHandlers = [];
				var rightsChangedEventHandlers = [];

				return {
					loggedIn: loggedIn,
					loggedOut: loggedOut,
					changePasswordRequested: changePasswordRequested,
					failedLogin: failedLogin,
					server401: server401,
					ticketExpired: ticketExpired,
					unauthorisedState: unauthorisedState,
					authenticatedAccessToLoginState: authenticatedAccessToLoginState,
					rightsChanged: rightsChanged,
					addLoggedInEventHandler: addLoggedInEventHandler,
					addLoggedOutEventHandler: addLoggedOutEventHandler,
					addRightsChangedEventHandler: addRightsChangedEventHandler
				};

				/**
    * Handle user login
    * @param data
    */
				function loggedIn(data, authenticatedState) {
					authenticationStore.setAuthenticationTicket(data);

					for (var i = 0; i < loggedInEventHandlers.length; i++) {
						loggedInEventHandlers[i]();
					}

					if (authenticatedState) {
						diState.go(authenticatedState);
					} else if (rootScope.toState && rootScope.toParams) {
						diState.go(rootScope.toState.name, rootScope.toParams);
					} else {
						diState.go(config.authenticatedState);
					}
				}

				/**
     * Handle a failed loginDAsyncOAuthRepository.GetClientByName('
     */
				function failedLogin() {}

				/**
    * Handle user logout
    */
				function loggedOut(loggedOutReason) {
					loggerProxy.info("CAA0903I", "User logged out.");

					authenticationStore.clear();

					diState.go(config.unauthenticatedState, loggedOutReason ? { reason: loggedOutReason } : undefined).then(function () {
						for (var i = 0; i < loggedOutEventHandlers.length; i++) {
							loggedOutEventHandlers[i](loggedOutReason);
						}
					});
				}

				/**
    * Handle change of password request
    */
				function changePasswordRequested(data) {
					loggedIn(data, config.changePasswordState);
				}

				/**
    * Handle server 401 response
    * @param url
    */
				function server401() {
					loggedOut(LOGGED_OUT_REASON.UnauthorisedServerResponse);
				}

				/**
    * Handle authentication ticket expiry
    * @param expiryDate
    */
				function ticketExpired() {
					loggedOut(LOGGED_OUT_REASON.TicketExpired);
				}

				/**
    * Handle attempted change to unauthorised state
    * @param state
    */
				function unauthorisedState(url) {
					loggerProxy.warning("CAA0902E", "Attempt to access unauthorised state: '" + url + "'");

					loggedOut(LOGGED_OUT_REASON.UnauthorisedState);
				}

				/**
     * Handle attempt to access login view when already logged in.
     * Redirects the user to the authenticated state
     */
				function authenticatedAccessToLoginState() {
					diState.go(config.authenticatedState);
				}

				/**
     * Handle change of rights
     * Redirects the user to the authenticated state, forcing a redraw
     */
				function rightsChanged() {
					for (var i = 0; i < rightsChangedEventHandlers.length; i++) {
						rightsChangedEventHandlers[i]();
					}
				}

				/**
    * Add callback to run when login handled
    * @param eventHandler
    */
				function addLoggedInEventHandler(eventHandler) {
					loggedInEventHandlers.push(eventHandler);
				}

				/**
    * Add callback to run when logout handled
    * @param eventHandler
    */
				function addLoggedOutEventHandler(eventHandler) {
					loggedOutEventHandlers.push(eventHandler);
				}

				/**
     * Add callback to run when rightsChanged handled
     * @param eventHandler
     */
				function addRightsChangedEventHandler(eventHandler) {
					rightsChangedEventHandlers.push(eventHandler);
				}
			}
		}

		return authenticationClientEventSubscriberProvider;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAA06}
// di.core.angular.authentication
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var debug = $di.debug.debugger.newLogger("AuthenticationController");
		var util = $di.utility.util;

		module.controller('AuthenticationController', AuthenticationController);

		AuthenticationController.$inject = ['userAuthenticationProxy', 'authenticationClientEventSubscriber', 'translator', 'promptWindow', 'notifier', '$scope', 'authenticationPromptConfigurator', 'modalSpinner', 'AUTHENTICATION_RESULT', '$stateParams'];

		/**
   * Controller for interacting with authentication views
   */
		function AuthenticationController(userAuthenticationProxy, authenticationClientEventSubscriber, translator, promptWindow, notifier, scope, authenticationPromptConfigurator, modalSpinner, authenticationResult, stateParams) {

			var vm = this;

			vm.username = '';
			vm.password = '';
			vm.login = login;
			vm.forgotPassword = scope.onForgotPasswordClick;
			vm.loginProcessing = false;

			var spinner;

			init();

			return;

			function init() {
				if (util.isNonEmptyString(stateParams.username)) {
					autoLogin(stateParams.username, stateParams.password);
				}
			}
			/**
    * auto login with credentials from url parameters            
    */
			function autoLogin(username, password) {
				vm.username = username;
				vm.password = password;
				vm.login();
			}

			/**
    * Login with the given credentials
    */
			function login() {
				if (vm.loginProcessing === false) {
					showSpinner();
					vm.loginProcessing = true;
					userAuthenticationProxy.login(vm.username, vm.password).then(resolved, rejected);
				}

				return;

				function resolved(data) {
					removeSpinner();
					var authResult = data.result;

					if (authResult.success) {
						if (data.changePasswordOnLogin === "True") {
							handleChangePasswordOnLogin(data);
						} else {
							handleLoginSuccess(authResult);
						}
					} else {
						handleLoginFailure(authResult);
					}

					return;

					function handleChangePasswordOnLogin(data) {
						vm.loginProcessing = false;
						if (scope.subscribeToFirstLogin) {
							scope.subscribeToFirstLogin(data);
						}
					}

					function handleLoginSuccess(authResult) {
						switch (authResult.serverDescription) {
							case authenticationResult.Success:
								vm.loginProcessing = false;
								authenticationClientEventSubscriber.loggedIn(data);
								break;
							case authenticationResult.PasswordAboutToExpire:
								var config = authenticationPromptConfigurator.getPromptConfiguration(authResult.serverDescription);
								config.callback = function (result) {
									vm.loginProcessing = false;
									if (result) {
										authenticationClientEventSubscriber.changePasswordRequested(data);
									} else {
										authenticationClientEventSubscriber.loggedIn(data);
									}
								};
								promptWindow.confirm(config);
								break;
							default:
								vm.loginProcessing = false;

								translator.tryTanslate(authResult.errorMessage).then(function (translated) {
									notifier.error(translated);
								});
								break;
						}
					}

					function handleLoginFailure(authResult) {
						switch (authResult.serverDescription) {
							case authenticationResult.InvalidUsername:
							case authenticationResult.InvalidPassword:
							case authenticationResult.AccountDisabled:
							case authenticationResult.AccountLocked:
								var config = authenticationPromptConfigurator.getPromptConfiguration(authResult.serverDescription);
								config.callback = function () {
									vm.loginProcessing = false;
									if (scope.focusOn) {
										setTimeout(function () {
											scope.focusOn('username');
										}, 10);
									}
								};
								promptWindow.alert(config);
								break;
							case authenticationResult.PasswordExpired:
								vm.loginProcessing = false;
								if (scope.subscribeToPasswordExpired) {
									data.userName = vm.username;
									scope.subscribeToPasswordExpired(data);
								}
								break;
							default:
								vm.loginProcessing = false;

								translator.translate('CORE.AUTHENTICATION.ERRORS.UNKNOWNERROR').then(function (translated) {
									notifier.error(translated);
								});

								break;
						}
					}
				}

				function rejected(error) {
					removeSpinner();
					var errorMessage = "CORE.AUTHENTICATION.ERRORS." + error.failureReason.toUpperCase();

					translator.translate(errorMessage).then(function (translated) {
						notifier.error(translated);
					});

					vm.loginProcessing = false;
				}
			}

			/**
    * Adds spinner to the page			 
    */
			function showSpinner() {
				var opts = {
					length: 19,
					width: 14,
					radius: 42,
					scale: 0.25,
					color: '#000',
					opacity: 0.25,
					zIndex: 2e9
				};

				spinner = modalSpinner.showModalSpinner("#spinnerHolder", opts);
			}

			/**
    * Removes spinner from the page
   */
			function removeSpinner() {
				if (spinner) {
					spinner.remove();
				}
			}
		}

		return AuthenticationController;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAA0H}
// di.core.angular.authentication
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.factory('authenticationData', authenticationData);

        /**
         * Repository for storing authentication data
         */
        function authenticationData() {
            var service = {
                authenticationTicket: {},
                userData: {},
                clear: clear
            };

            clear();

            return service;

            function clear() {
                service.authenticationTicket = {};
                service.userData = {};
            }
        }

        return authenticationData;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAA05}
// di.core.angular.authentication
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.factory('authenticationHttpInterceptor', authenticationHttpInterceptor);

        authenticationHttpInterceptor.$inject = ['authenticationData'];

        /**
         * Interceptor for adding OAuth bearer token to http headers
         */
        function authenticationHttpInterceptor(authenticationData) {
            return {
                request: request
            };

            /**
             * Intercept the request
             * @param requestConfig
             */
            function request(requestConfig) {
                var token = authenticationData.authenticationTicket.token;

                if (token) {
                    requestConfig.headers = requestConfig.headers || {};

                    requestConfig.headers.Authorization = "Bearer " + token;
                }

                return requestConfig;
            }
        }

        return authenticationHttpInterceptor;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:/AA05}
// di.core.angular.authentication
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.factory('authenticationPromptConfigurator', authenticationPromptConfigurator);

        /**
         * Gets the object to configure the window prompt based on the authentication result
         */
        function authenticationPromptConfigurator() {
            var service = {
                getPromptConfiguration: getPromptConfiguration
            };

            return service;

            /**
             * Gets the prompt configuration
             */
            function getPromptConfiguration(authenticationResult) {

                switch (authenticationResult) {
                    case 'PasswordAboutToExpire':
                        return {
                            title: 'CORE.AUTHENTICATION.PASSWORD_EXPIRING',
                            message: 'CORE.AUTHENTICATION.PASSWORD_EXPIRING_MESSAGE',
                            okBtnText: 'CORE.PROMPT.YES',
                            cancelBtnText: 'CORE.PROMPT.NO'
                        };

                    case 'InvalidUsername':
                        return {
                            title: 'CORE.AUTHENTICATION.ERRORS.INVALID_USERNAME',
                            message: 'CORE.AUTHENTICATION.ERRORS.INVALID_USERNAME_MESSAGE'
                        };

                    case 'InvalidPassword':
                        return {
                            title: 'CORE.AUTHENTICATION.ERRORS.INVALID_PASSWORD',
                            message: 'CORE.AUTHENTICATION.ERRORS.INVALID_PASSWORD_MESSAGE'
                        };

                    case 'AccountDisabled':
                        return {
                            title: 'CORE.AUTHENTICATION.ERRORS.ACCOUNT_DISABLED',
                            message: 'CORE.AUTHENTICATION.ERRORS.ACCOUNT_DISABLED_MESSAGE'
                        };

                    case 'AccountLocked':
                        return {
                            title: 'CORE.AUTHENTICATION.ERRORS.ACCOUNT_LOCKED',
                            message: 'CORE.AUTHENTICATION.ERRORS.ACCOUNT_LOCKED_MESSAGE'
                        };

                    default:
                        return {};
                }
            }
        };

        return authenticationPromptConfigurator;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

// di.core.angular.authentication
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.constant('AUTHENTICATION_RESULT', authenticationResult());

        function authenticationResult() {
            return {
                Success: 'Success',
                PasswordAboutToExpire: 'PasswordAboutToExpire',
                InvalidUsername: 'InvalidUsername',
                InvalidPassword: 'InvalidPassword',
                AccountDisabled: 'AccountDisabled',
                AccountLocked: 'AccountLocked',
                PasswordExpired: 'PasswordExpired',
                ServerDown: 'ServerDown'
            };
        }

        return authenticationResult;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAA08}
// di.core.angular.authentication
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;

        module.factory('authenticationStore', authenticationStore);

        authenticationStore.$inject = ['sessionStore', 'authenticationData'];

        /**
         * Repository for storing authentication data
         */
        function authenticationStore(sessionStore, authenticationData) {
            var storageKey = 'authenticationData';

            var service = {
                getAuthenticationData: getAuthenticationData,
                setAuthenticationData: setAuthenticationData,
                setAuthenticationTicket: setAuthenticationTicket,
                clear: clear
            };

            return service;

            /**
             * Gets the authentication data
             */
            function getAuthenticationData() {
                authenticationData.clear();

                var sessionData = sessionStore.get(storageKey, 'authenticationStore');

                if (!sessionData || !sessionData.authenticationTicket || !sessionData.userData || !sessionData.userData.isAuthenticated) {

                    return null;
                }

                authenticationData.authenticationTicket = sessionData.authenticationTicket;
                authenticationData.userData = sessionData.userData;

                return sessionData;
            }

            /**
             * Sets the authentication data
             * @param authenticationTicket
             */
            function setAuthenticationData(data) {
                guard.throwIfNotAnObject("CAA0801E", data, "data");

                clear();

                authenticationData.authenticationTicket = data.authenticationTicket;
                authenticationData.userData = data.userData;

                sessionStore.set(storageKey, data, 'authenticationStore');
            }

            /**
             * Sets the authentication data by parsing the given authenticationTicket
             * @param authenticationTicket
             */
            function setAuthenticationTicket(authenticationTicket) {
                guard.throwIfNotAnObject("CAA0802E", authenticationTicket, "authenticationTicket");

                /*jshint camelcase: false */
                var data = {
                    authenticationTicket: {
                        token: authenticationTicket.access_token,
                        refreshToken: authenticationTicket.refresh_token,
                        issuedDate: new Date(authenticationTicket['.issued']),
                        expiresDate: new Date(authenticationTicket['.expires']),
                        rights: authenticationTicket.rights ? authenticationTicket.rights.split(',') : []
                    },
                    userData: {
                        userId: parseInt(authenticationTicket.userId, 10),
                        username: authenticationTicket.username,
                        isAuthenticated: true
                    }
                };

                setAuthenticationData(data);
            }

            /**
             * Clears all authentication data
             */
            function clear() {
                authenticationData.clear();

                sessionStore.remove(storageKey, 'authenticationStore');
            }
        }

        return authenticationStore;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAA0A}
// di.core.angular.authentication
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5)], __WEBPACK_AMD_DEFINE_RESULT__ = function (moment) {
    'use strict';

    return function (module) {
        var util = $di.utility.util;
        var debug = $di.debug.debugger.newLogger("authenticationTicketValidator");

        module.provider('authenticationTicketValidator', AuthenticationTicketValidatorProvider);

        function AuthenticationTicketValidatorProvider() {
            var expiryToleranceMilliseconds = 10000;
            var validating = false;
            var deferredActions = [];

            var provider = {
                $get: $get
            };

            provider.$get.$inject = ['authenticationData', 'authenticationStore', 'userAuthenticationProxy', 'authenticationClientEventSubscriber', 'LOGGED_OUT_REASON', 'AUTHENTICATION_RESULT', '$q', 'diState'];

            return provider;

            /**
             * Checks the validity of the current stored authentication ticket
             */
            function $get(authenticationData, authenticationStore, userAuthenticationProxy, authenticationClientEventSubscriber, LOGGED_OUT_REASON, AUTHENTICATION_RESULT, $q, diState) {
                var service = {
                    validateTicket: validateTicket
                };

                return service;

                function validateTicket(refresh, action) {
                    var deferredAction = {
                        action: action,
                        deferred: $q.defer()
                    };

                    deferredActions.push(deferredAction);

                    if (validating) {
                        return deferredAction.deferred.promise;
                    }

                    validating = true;

                    validateTicketInner(refresh).then(function (stillValid) {
                        if (stillValid) {
                            for (var i = 0; i < deferredActions.length; i++) {
                                var da = deferredActions[i];
                                da.deferred.resolve(da.action());
                            }
                        }

                        deferredActions = [];

                        validating = false;
                    });

                    return deferredAction.deferred.promise;
                }

                /**
                 * Validates the current stored authentication ticket
                 */
                function validateTicketInner(refresh) {
                    var deferred;

                    if (!authenticationData.userData.isAuthenticated) {
                        return $q.when(true);
                    }

                    var now = moment();
                    var expiresDate = authenticationData.authenticationTicket.expiresDate;

                    if (!expiresDate) {
                        return $q.when();
                    }

                    var expiresDateMoment = moment(expiresDate);
                    var difference = expiresDateMoment.diff(now);

                    if (refresh && util.isDefined(authenticationData.authenticationTicket.refreshToken)) {
                        if (difference <= expiryToleranceMilliseconds) {
                            deferred = $q.defer();

                            userAuthenticationProxy.refreshAuth(authenticationData.authenticationTicket.refreshToken).then(resolved, rejected);

                            return deferred.promise;
                        }
                    } else if (difference <= 0) {
                        authenticationClientEventSubscriber.ticketExpired(expiresDateMoment);

                        return $q.when(false);
                    }

                    return $q.when(true);

                    function resolved(data) {
                        var authenticationResult = data.result;

                        if (authenticationResult.success) {
                            if (data.changePasswordOnLogin === "True") {
                                authenticationClientEventSubscriber.loggedOut(LOGGED_OUT_REASON.ChangePasswordOnLogin);

                                deferred.resolve(true);

                                return;
                            }

                            var oldRights = authenticationData.authenticationTicket.rights.join(',');
                            var newRights = data.rights;

                            authenticationStore.setAuthenticationTicket(data);

                            if (oldRights !== newRights) {
                                diState.reload();

                                authenticationClientEventSubscriber.rightsChanged();
                            }

                            if (authenticationResult.serverDescription === AUTHENTICATION_RESULT.PasswordAboutToExpire) {
                                //TODO: Display warning prompt?
                            }

                            deferred.resolve(true);
                        } else {
                            authenticationClientEventSubscriber.loggedOut(getLoggedOutReason());

                            deferred.resolve(false);
                        }

                        return;

                        function getLoggedOutReason() {
                            switch (authenticationResult.serverDescription) {
                                case AUTHENTICATION_RESULT.AccountDisabled:
                                    return LOGGED_OUT_REASON.AccountDisabled;
                                case AUTHENTICATION_RESULT.AccountLocked:
                                    return LOGGED_OUT_REASON.AccountLocked;
                                case AUTHENTICATION_RESULT.PasswordExpired:
                                    return LOGGED_OUT_REASON.PasswordExpired;
                                default:
                                    return LOGGED_OUT_REASON.UnauthorisedServerResponse;
                            }
                        }
                    }

                    function rejected(data) {
                        authenticationClientEventSubscriber.loggedOut(LOGGED_OUT_REASON.UnauthorisedServerResponse);

                        deferred.resolve(false);
                    }
                }
            }
        }

        return AuthenticationTicketValidatorProvider;
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_, $) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAA0I}
// di.core.angular.authentication
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;
        var util = $di.utility.util;

        module.factory('authorizedObjectsFilter', authorizedObjectsFilter);

        authorizedObjectsFilter.$inject = ['authenticationData', 'associativeArrayConvertor'];

        function authorizedObjectsFilter(authenticationData, associativeArrayConvertor) {
            var objectsDefinitions = [],
                rightsRequired = true,
                requireAllRights = false;

            var service = {
                requireRights: requireRights,
                getAuthorizedObjects: getAuthorizedObjects,
                getAuthorizedObjectsAsAssociative: getAuthorizedObjectsAsAssociative
            };

            return service;

            /**
             * sets flag if object must have rights to be visible
             * @param {} value 
             * @returns {} 
             */
            function requireRights(value) {
                rightsRequired = value;
            }

            /**
             * Generates list of labels that match user rights
             * @param {} definitions 
             * @returns array of objects 
             */
            function getAuthorizedObjectsAsAssociative(data, keyPropName, valuePropName) {
                guard.throwIfNotAnObject("CAA0I02E", data, "data");

                var results = getAuthorizedObjects(data);

                return associativeArrayConvertor.convert(results, keyPropName, valuePropName);
            }

            /**
             * Generates list of objects that match user rights
             * @param {} definitions 
             * @returns array of objects 
             */
            function getAuthorizedObjects(definitions, requireAll) {
                guard.throwIfNotAnObject("CAA0I01E", definitions, "definitions");

                if (util.isDefined(requireAll)) {
                    requireAllRights = requireAll;
                } else {
                    requireAllRights = rightsRequired;
                }

                objectsDefinitions = definitions;
                var userRights = authenticationData.authenticationTicket.rights;

                return findObjectsWithMatchingRights(userRights);

                /**
                 * finds object matching user rights
                 * @param {} userRights 
                 * @returns {} 
                 */
                function findObjectsWithMatchingRights(userRights) {
                    var objectsIndexed = [];
                    var objects = [];
                    var found = [];
                    if (requireAllRights) {
                        found = containsAll(userRights);
                        var index = 1;
                        _.each(found, function (obj) {
                            obj.index = index;
                            objectsIndexed.push(obj);
                            index++;
                        });
                    } else {
                        _.each(userRights, function (right) {
                            found = containsOne(right);
                            var index = 1;
                            _.each(found, function (obj) {
                                obj.index = index;
                                objectsIndexed.push(obj);
                                index++;
                            });
                        });
                    }

                    var sortedObjects = objectsIndexed.sort(compare);

                    _.each(sortedObjects, function (obj) {
                        if (!containsObject(obj, objects)) {
                            objects.push(obj);
                        };
                    });

                    return objects;

                    /**
                     * finds matching objects by all user rights
                     * @param {} rights 
                     * @returns {} 
                     */
                    function containsAll(rights) {
                        var filtered = _.filter(objectsDefinitions, function (obj) {
                            return checkAllRightsExist(obj.rights, rights);
                        });

                        return filtered;

                        function checkAllRightsExist(needles, haystack) {
                            if (!needles) {
                                return !rightsRequired;
                            }

                            for (var i = 0, len = needles.length; i < len; i++) {
                                if ($.inArray(needles[i], haystack) === -1) return false;
                            }
                            return true;
                        }
                    }

                    /**
                     * finds matching objects by a single user right
                     * @param {} right 
                     * @returns {} 
                     */
                    function containsOne(right) {
                        var filtered = _.filter(objectsDefinitions, function (obj) {
                            return checkRightExists(obj.rights, right);
                        });

                        return filtered;

                        function checkRightExists(arr, val) {
                            if (!arr) {
                                return !rightsRequired;
                            }

                            var result = _.filter(arr, function (item) {
                                return item === val;
                            });

                            return result.length > 0;
                        }
                    }

                    /**
                     * tests if array contains object
                     * @param {} obj 
                     * @param {} list 
                     * @returns {} 
                     */
                    function containsObject(obj, list) {
                        var i;
                        for (i = 0; i < list.length; i++) {
                            if (list[i] === obj) {
                                return true;
                            }
                        }

                        return false;
                    }

                    /**
                     * sorts array by index
                     * @param {} a 
                     * @param {} b 
                     * @returns {} 
                     */
                    function compare(a, b) {
                        if (a.index < b.index) return -1;else if (a.index > b.index) return 1;else return 0;
                    }
                }
            }
        }

        return authorizedObjectsFilter;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(4)))

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAA07}
// di.core.angular.authentication
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ng) {
	'use strict';

	return function (module) {
		module.directive('diAuthentication', diAuthentication);

		/**
   * Directive encapsulating the credentials form for user authentication
   */
		function diAuthentication() {
			return {
				restrict: 'E',
				controller: 'AuthenticationController',
				controllerAs: 'authenticationCtrl',
				scope: {
					onForgotPasswordClick: '&?',
					subscribeToFirstLogin: '=',
					subscribeToPasswordExpired: '='
				},
				link: function link(scope, element, attrs) {
					scope.focusOn = function (id) {
						var focusElm = ng.element.find('#' + id);
						if (focusElm[0]) {
							focusElm[0].focus();
						}
					};
					scope.focusOn("username");
				},
				template: template
			};
		}

		function template() {
			var html = '<div\
	id="authenticationpanel">\
	<div>\
		<section\
			class="form">\
			<form\
				di-validate-model="authentication" novalidate>\
				<header\
					class="form-header">\
					<h1\
						class="title"\
						di-translate="CORE.AUTHENTICATION.TITLE">\
					</h1>\
				</header>\
				<div\
					class="form-row form-group">\
					<di-input\
						di-input-label="CORE.AUTHENTICATION.USERNAME"\
						di-input-type="email"\
						validation-property-name="username"\
						validation-model-display-name="CORE.AUTHENTICATION.USERNAME"\
						validate-on-blur="true"\
						ng-model="authenticationCtrl" \
						ng-model-property="username">\
					</di-input>\
				</div>\
				<div class="processing" id="spinnerHolder"></div>\
				<div\
					class="form-row form-group">\
					<di-input\
						di-input-label="CORE.AUTHENTICATION.PASSWORD"\
						di-input-type="password"\
						validation-property-name="password"\
						validation-model-display-name="CORE.AUTHENTICATION.PASSWORD"\
						ng-model="authenticationCtrl" \
						ng-model-property="password">\
					</di-input>\
				</div>\
				<div\
					class="form-row side-by-side form-group">\
					<a\
						href=""\
						ng-click="authenticationCtrl.forgotPassword()"\
						class="right"\
						di-translate="CORE.AUTHENTICATION.FORGOT_PASSWORD">\
					</a>\
				</div>\
				<div \
					class="form-row form-group">\
					<button\
						type="submit"\
						class="btn center btn-success"\
						ng-disabled="authenticationCtrl.loginProcessing"\
						di-validate-click="authenticationCtrl.login()"\
						di-translate="CORE.AUTHENTICATION.SUBMIT">\
					</button>\
				</div>\
			</form>\
		</section>\
	</div>\
</div>';

			return html;
		}

		return diAuthentication;
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

// di.core.angular.authentication
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.constant('LOGGED_OUT_REASON', loggedOutReason());

        function loggedOutReason() {
            return {
                UserLoggedOut: 'USER_LOGGED_OUT',
                UnauthorisedServerResponse: 'UNAUTHORISED_SERVER_RESPONSE',
                UnauthorisedState: 'UNAUTHORISED_STATE',
                TicketExpired: 'TICKET_EXPIRED',
                SessionTimeout: 'SESSION_TIMEOUT',
                AccountDisabled: 'ACCOUNT_DISABLED',
                AccountLocked: 'ACCOUNT_LOCKED',
                PasswordExpired: 'PASSWORD_EXPIRED',
                ChangePasswordOnLogin: 'CHANGE_PASSWORD_ON_LOGIN',
                RightsChanged: 'RIGHTS_CHANGED'
            };
        }

        return loggedOutReason;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAA02}
// di.core.angular.authentication
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var guard = $di.exception.guard;
		var util = $di.utility.util;

		module.provider('userAuthenticationProxy', UserAuthenticationProxyProvider);

		/**
   * Proxy client for authenticating credentials against the webAPI OAuth provider
   */
		function UserAuthenticationProxyProvider() {
			var config = {
				endpoint: '',
				url: './token',
				clientId: 'website'
			};

			var provider = {
				configure: configure,
				$get: $get
			};

			provider.$get.$inject = ['dHttp', '$q', 'urlHelper', 'loggerProxy'];

			return provider;

			/**
    * Configure the service
    * @param cfg
    */
			function configure(cfg) {
				guard.throwIfNotAnObject("CAA0202E", cfg, "cfg");

				config = cfg;
			}

			function $get(dHttp, $q, urlHelper, loggerProxy) {
				var service = {
					login: login,
					refreshAuth: refreshAuth
				};

				return service;

				/**
     * Authenticates the given user credentials against the configured OAuth endpoint address
     * @param username
     * @param password
     */
				function login(username, password) {
					guard.throwIfEmptyString("CAA0207E", username, "username");
					guard.throwIfEmptyString("CAA0208E", password, "password");

					var encodedUsername = urlHelper.encodeUriComponent(username);
					var encodedPassword = urlHelper.encodeUriComponent(password);
					var encodedClientId = urlHelper.encodeUriComponent(config.clientId);

					loggerProxy.info("CAA020BI", "Client requesting authentication. ClientId: '" + config.clientId + "', Username: '" + username + "'");

					var promise = dHttp.postWithHeaders(config.url, 'grant_type=password&username=' + encodedUsername + '&password=' + encodedPassword + '&client_id=' + encodedClientId, {
						'Content-Type': 'application/x-www-form-urlencoded'
					}, config.endpoint).then(resolved, rejected);

					return promise;
				}

				/**
     * 	refreshes authentication data from server using refresh token and client id		
     */
				function refreshAuth(refreshToken) {
					guard.throwIfEmptyString("CAA020AE", refreshToken, "refreshToken");

					var encodedRefreshToken = urlHelper.encodeUriComponent(refreshToken);
					var encodedClientId = urlHelper.encodeUriComponent(config.clientId);

					loggerProxy.info("CAA020CI", "Client requesting new access token. ClientId: '" + config.clientId + "'");

					var promise = dHttp.postWithHeaders(config.url, 'grant_type=refresh_token&refresh_token=' + encodedRefreshToken + '&client_id=' + encodedClientId, {
						'Content-Type': 'application/x-www-form-urlencoded'
					}, config.endpoint).then(resolved, rejected);

					return promise;
				}

				function resolved(data) {
					parseResult(true, data, 'authenticateUserResult');

					return data;
				}

				function rejected(failure) {
					var response = failure.response;

					if (response && response.status === 400 && response.data && response.data.error && response.data.error === "invalid_grant") {

						parseResult(false, failure.response.data, 'error_description');

						//The http promise was rejected, but the http error is just due to failed validation.
						//This is not a genuine error but an expected outcome.
						//Therefore, we return this in the resolved callback of the promise.
						return failure.response.data;
					} else {
						//Anything else is a genuine error
						return $q.reject(failure);
					}
				}

				function parseResult(success, data, resultPropertyName) {
					var errorDetails = data[resultPropertyName];
					var errorId = '0';
					var errorDesc = '';
					var tokenString = '';

					if (util.isDefined(errorDetails)) {
						var errorDetailsArr = errorDetails.split(',');
						var authenticateResultParts = errorDetailsArr[0].split(':');

						if (util.isDefined(authenticateResultParts[0])) {
							errorId = authenticateResultParts[0];
						}

						if (util.isDefined(authenticateResultParts[1])) {
							errorDesc = authenticateResultParts[1];
						}

						if (errorDetailsArr.length > 1) {
							var tokenPartsArr = errorDetailsArr[1].split(':');

							if (util.isDefined(tokenPartsArr[1])) {
								tokenString = tokenPartsArr[1];
							}
						}
					}

					data.result = {
						success: success,
						id: errorId,
						serverDescription: errorDesc,
						token: tokenString
					};
				}
			}
		}

		return UserAuthenticationProxyProvider;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAA0K}
// di.core.angular.authentication
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;
        var util = $di.utility.util;

        module.provider('userIdleActivityMonitor', userIdleActivityMonitorProvider);

        function userIdleActivityMonitorProvider() {
            var config = {
                timeout: 60,
                idle: 60,
                pageTitle: 'Data Interchange | Digital Invoice'
            };

            var provider = {
                configure: configure,
                $get: $get
            };

            provider.$get.$inject = ['$rootScope', 'Idle', 'Title'];

            return provider;

            function configure(cfg, idleProvider) {
                guard.throwIfNotAnObject("CAA0K01E", cfg, "cfg");
                guard.throwIfNotAnObject("CAA0K02E", idleProvider, "idleProvider");

                config = cfg;

                idleProvider.idle(config.idle);
                idleProvider.timeout(config.timeout);
                idleProvider.autoResume('notIdle');
            }

            function $get(rootScope, idle, Title) {

                var idleStartedHandlerFn, idleEndHandlerFn, idleTimeoutHandlerFn;

                rootScope.$on('IdleStart', function () {
                    if (idleStartedHandlerFn && util.isFunction(idleStartedHandlerFn)) {
                        idleStartedHandlerFn(config.idle, config.timeout);
                    }
                });

                rootScope.$on('IdleEnd', function () {
                    if (idleEndHandlerFn && util.isFunction(idleEndHandlerFn)) {
                        idleEndHandlerFn();
                    }
                });

                rootScope.$on('IdleTimeout', function () {
                    stop();

                    if (idleTimeoutHandlerFn && util.isFunction(idleTimeoutHandlerFn)) {
                        idleTimeoutHandlerFn();
                    }
                });

                return {
                    start: start,
                    stop: stop
                };

                function start(handlers) {
                    Title.value(config.pageTitle);
                    idleStartedHandlerFn = handlers.idleStartedHandler;
                    idleEndHandlerFn = handlers.idleEndHandler;
                    idleTimeoutHandlerFn = handlers.idleTimeoutHandler;

                    idle.watch();
                }

                function stop() {
                    idle.unwatch();
                }
            }
        }

        return userIdleActivityMonitorProvider;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAA0J}
// di.core.angular.authentication
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;
        var util = $di.utility.util;

        module.factory('userRightsRepository', userRightsRepository);

        userRightsRepository.$inject = ['authenticationData'];

        function userRightsRepository(authenticationData) {

            var service = {
                userHasRight: userHasRight
            };

            return service;

            /**
             * tests if current user has specific right              
             */
            function userHasRight(rightName) {
                guard.throwIfEmptyString("CAA0H01E", rightName, "rightName");

                var userRights = authenticationData.authenticationTicket.rights;

                var hasRight = _.find(userRights, function (right) {
                    return right === rightName;
                });

                return util.isDefined(hasRight);
            }
        }

        return userRightsRepository;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAC0M}
// di.core.angular.caching
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(137)], __WEBPACK_AMD_DEFINE_RESULT__ = function (scopeCacheFactoryLoader) {
	'use strict';

	return function (module) {
		scopeCacheFactoryLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAC0L}
// di.core.angular.caching
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
			'use strict';

			return function (module) {
						var debug = $di.debug.debugger.newLogger('scopeCacheFactory');

						module.factory('scopeCacheFactory', scopeCacheFactory);

						scopeCacheFactory.$inject = ['$q'];

						/**
       * Factory for creating scopeCache objects
       */
						function scopeCacheFactory($q) {
									var guard = $di.exception.guard;
									var util = $di.utility.util;

									return {
												create: create
									};

									/**
          * Create a new scopeCache associated with the given scope
          * @param scope
          */
									function create(scope) {
												guard.throwIfNotAnObject("CAC0L01E", scope, "scope");

												scope.scopeCacheData = scope.scopeCacheData || {};

												return {
															get: get,
															clear: clear
												};

												function clear() {
															scope.scopeCacheData = {};
												}

												/**
             * Gets data from the scope if it exists otherwise gets data from the given delegate
                      * and then stores it in scope. Always return the data in a promise.
                      * @param delegateName
             * @param delegate
             * @param args
             */
												function get(delegateName, delegate, args) {
															guard.throwIfEmptyString("CAC0L02E", delegateName, "delegateName");
															guard.throwIfNotAFunction("CAC0L03E", delegate, "delegate");

															var cacheKey = delegateName + (util.isDefined(args) ? '_' + JSON.stringify(args) : '');
															var promise;

															if (util.isDefined(scope.scopeCacheData[cacheKey])) {
																		promise = $q.when(scope.scopeCacheData[cacheKey]);
															} else {
																		promise = delegate.apply(this, args).then(resolved, rejected);

																		scope.scopeCacheData[cacheKey] = promise;

																		return promise;
															}

															return promise;

															function resolved(data) {
																		scope.scopeCacheData[cacheKey] = data;

																		return data;
															}

															function rejected(data) {
																		return $q.reject(data);
															}
												}
									}
						}

						return scopeCacheFactory;
			};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAC02}
// di.core.angular.controls
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(139), __webpack_require__(166), __webpack_require__(170), __webpack_require__(153), __webpack_require__(154), __webpack_require__(155), __webpack_require__(156), __webpack_require__(178), __webpack_require__(179), __webpack_require__(173), __webpack_require__(194), __webpack_require__(197), __webpack_require__(185), __webpack_require__(191), __webpack_require__(176), __webpack_require__(151), __webpack_require__(150), __webpack_require__(146), __webpack_require__(160), __webpack_require__(163), __webpack_require__(157), __webpack_require__(142), __webpack_require__(152), __webpack_require__(181)], __WEBPACK_AMD_DEFINE_RESULT__ = function (buttonDirectiveLoader, imageDirectiveLoader, inputLoader, transcludeRepeatDirectiveLoader, transcludeReplaceDirectiveLoader, elementNotifierLoader, elementNotifierStylesLoader, notifierLoader, promptWindowLoader, modalLoader, spinnerLoader, toggleLoader, selectLoader, simpleSelectLoader, multiSelectLoader, diEnabledLoader, diClickLoader, diDataTableLoader, gridPaginationButtonsLoader, gridPaginationPageSizeLoader, enterKeyLoader, chartLoader, diNoDirtyLoader, restrictionsLoader) {
			'use strict';

			return function (module) {
						buttonDirectiveLoader(module);
						imageDirectiveLoader(module);
						inputLoader(module);
						transcludeRepeatDirectiveLoader(module);
						transcludeReplaceDirectiveLoader(module);
						elementNotifierLoader(module);
						elementNotifierStylesLoader(module);
						notifierLoader(module);
						promptWindowLoader(module);
						modalLoader(module);
						spinnerLoader(module);
						toggleLoader(module);
						selectLoader(module);
						simpleSelectLoader(module);
						multiSelectLoader(module);
						diEnabledLoader(module);
						diClickLoader(module);
						diDataTableLoader(module);
						gridPaginationButtonsLoader(module);
						gridPaginationPageSizeLoader(module);
						enterKeyLoader(module);
						chartLoader(module);
						diNoDirtyLoader(module);
						restrictionsLoader(module);
			};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAC0Y}
// di.core.angular.controls.button
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(140), __webpack_require__(141)], __WEBPACK_AMD_DEFINE_RESULT__ = function (buttonContrllerLoader, buttonDirectiveLoader) {
    'use strict';

    return function (module) {
        buttonContrllerLoader(module);
        buttonDirectiveLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAC0Z}
// di.core.angular.controls.button
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var util = $di.utility.util;

        module.controller('DiButtonController', DiButtonController);

        DiButtonController.$inject = ['$scope', 'promptWindow'];

        function DiButtonController(scope, promptWindow) {
            var vm = this;

            vm.clicked = clicked;
            scope.blur = false;

            return;

            /**
            * Event handler for button click			 
            */
            function clicked() {
                var valid = true;

                scope.blur = true;

                //This is a nasty hack to make the Create New button to work! Sorry!
                if (util.isDefined(scope.diToggleTrigger)) {
                    scope.$parent.$parent.diToggleCtrl.toggle();
                    return;
                }

                if (util.isDefined(scope.prompt)) {
                    if (util.isDefined(scope.prePromptAction)) {
                        valid = scope.prePromptAction();

                        //If pre-prompt action returns falsy value other than undefined do not continue
                        if (util.isDefined(valid) && !valid) {
                            return;
                        } else if (util.isObject(valid) && util.isFunction(valid.then)) {
                            //promise must resolve to a configuration object for the prompt
                            valid.then(displayPromptIfRequired);
                            return;
                        }
                    }

                    displayPromptIfRequired();
                } else {
                    scope.action();
                }

                /**
                * Function which uses the provided configuration 
                * or defaults retrieved from the scope to display a confirmation prompt before the 
                * action from the scope is completed
                * @param promptConfiguration - The configuration for the prompt
                */
                function displayPromptIfRequired(promptConfiguration) {
                    var defaultConfiguration = {
                        callback: callback,
                        title: scope.promptTitle,
                        message: scope.promptMessage,
                        condition: scope.promptCondition,
                        okBtnText: scope.promptOkBtnText,
                        cancelBtnText: scope.promptCancelBtnText
                    };

                    if (util.isNullOrUndefined(promptConfiguration)) {
                        promptConfiguration = {};
                    }

                    _.defaults(promptConfiguration, defaultConfiguration);

                    //If condition to display prompt not met, then skip prompt and trigger action
                    if (util.isDefined(promptConfiguration.condition) && !promptConfiguration.condition) {
                        scope.action();
                    } else {
                        promptWindow.confirm(promptConfiguration);
                    }
                }

                function callback(result) {
                    if (result) {
                        scope.action();
                    }
                }
            }
        }

        return DiButtonController;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAC0X}
// di.core.angular.controls.button
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;
		module.directive('diButton', diButton);

		function diButton() {
			return {
				restrict: 'E',
				template: template,
				controller: 'DiButtonController',
				controllerAs: 'diButtonCtrl',
				replace: false,
				transclude: false,
				scope: {
					tooltip: '@',
					validate: '@',
					prompt: '@',
					promptCondition: "=",
					promptTitle: '@',
					promptMessage: '@',
					promptOkBtnText: '@',
					promptCancelBtnText: '@',
					prePromptAction: '&?',
					action: '&',
					image: '@',
					imageColour: '@',
					enabled: '@',
					btnClass: '@',
					btnDisabledClass: '@',
					filled: '@',
					text: '@',
					diToggleTrigger: '@'
				}
			};

			/**
   * This should be placed in a seperate .html file - we need to provide deployment solution for this?
   * Perhaps npm - gulp-angular-templatecache?
   */
			function template(element, attrs) {
				var html = '<div\
	ng-if="text !== undefined"\
	class="btn-container"\
	ng-class="tooltip ? \'tooltip-wrap\' : \'\'"\>\
	<button\
		id="btn"\
		type="button"\
		ng-class="[\'center\', btnClass ? btnClass : \'btn small\', image ? \'center iconed\' : \'\', filled ? \'\' : \'\']"\
		di-click="diButtonCtrl.clicked()">\
		<di-image\
			ng-if="image !== undefined"\
			image-colour="{{::imageColour}}"\
			image="{{::image}}"\
			class="icon">\
		</di-image>\
		<span\
			id="span"\
			di-translate="{{::text}}">\
		</span>\
	</button>\
	<div\
		id="btnDisabled"\
		style="display: none"\
		class="outline"\
		ng-class="[btnDisabledClass ? btnDisabledClass : btnClass ? btnClass : \'btn-disabled small\', image ? \'center iconed\' : \'\']">\
		<di-image\
			ng-if="image !== undefined"\
			id="imageDisabled"\
			image-colour="offWhite"\
			image="{{::image}}"\
			class="icon">\
		</di-image>\
		<span\
			id="spanDisabled"\
			di-translate="{{::text}}">\
		</span>\
	</div>\
	<div\
		ng-if="tooltip"\
		id="tooltip"\
		class="tooltip">\
		<span\
			di-translate="{{::tooltip}}"></span>\
	</div>\
</div>\
<div\
	ng-if="text === undefined"\
	class="btn-container"\
	ng-class="tooltip ? \'tooltip-wrap\' : \'\'">\
	<button\
		id="btn"\
		type="button"\
		ng-class="btnClass ? btnClass : \'btn-icon\'"\
		di-click="diButtonCtrl.clicked()">\
		<di-image\
			ng-if="image !== undefined"\
			id="image"\
			image-colour="{{::imageColour}}"\
			class="icon"\
			image="{{::image}}">\
		</di-image>\
		<span\
			id="span"\
			di-translate="{{::text}}">\
		</span>\
	</button>\
	<div\
		id="btnDisabled"\
		style="display: none"\
		ng-class="btnDisabledClass ? btnDisabledClass : btnClass ? btnClass : \'btn-icon-disabled\'">\
		<di-image\
			ng-if="image !== undefined"\
			id="imageDisabled"\
			image-colour="offWhite"\
			class="icon"\
			image="{{::image}}">\
		</di-image>\
		<span\
			id="spanDisabled">\
		</span>\
	</div>\
	<div\
		ng-if="tooltip"\
		id="tooltip"\
		class="tooltip">\
		<span\
			di-translate="{{::tooltip}}"></span>\
	</div>\
</div>';

				if (util.isDefined(attrs.validate)) {
					html = html.replace('di-click', 'di-validate-click');
				}

				return html;
			}
		}

		return diButton;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF0G}
// di.core.angular.controls.chart
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(144), __webpack_require__(145), __webpack_require__(143)], __WEBPACK_AMD_DEFINE_RESULT__ = function (diChartController, diChartDirective, chartPlotter) {
    'use strict';

    return function (module) {
        diChartController(module);
        diChartDirective(module);
        chartPlotter(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF0D}
// di.core.angular.controls.chart
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(42)], __WEBPACK_AMD_DEFINE_RESULT__ = function (plotly) {
	'use strict';

	return function (module) {
		var guard = $di.exception.guard;

		module.factory('chartPlotter', chartPlotter);

		function chartPlotter() {

			return {
				plot: plot,
				restyle: restyle,
				relayout: relayout,
				addDataSeries: addTraces,
				deleteDataSeries: deleteTraces,
				reorderDataSeries: moveTraces,
				redraw: redraw,
				onEvent: on,
				purge: purge,
				toImage: toImage,
				downloadImage: downloadImage,
				resize: resize,
				reconfigure: updatePlotConfig
			};

			//Plotly's graph description places attributes into two categories: 
			//traces (objects that describe a single series of data in a graph) 
			//and layout (attributes that apply to the rest of the chart, like the title, xaxis, or annotations). 
			//Traces are categorized by chart type (e.g. scatter, heatmap).

			/**
             * Use Plotly.newPlot to create a new plot in an empty <div> element. 
             * You can either supply height and width in layout, or give graphDiv a height and width in css.
             * @returns {} 
             */
			function plot(graphDiv, data, layout, config) {
				guard.throwIfNullOrUndefined("DEF0D01E", graphDiv, 'graphDiv');
				guard.throwIfNullOrUndefined("DEF0D02E", data, 'data');

				plotly.newPlot(graphDiv, data, layout, config);
			}

			/**
             * Edit attributes with Plotly.restyle
             * A more efficient means of changing parameters in the data array. 
             * When restyling, you may choose to have the specified changes effect as many traces as desired. 
             * The update is given as a single object and the traces that are effected are given as a list of traces indices. 
             * Leaving the trace indices unspecified assumes that you want to restyle all the traces.
             * @returns {} 
             */
			function restyle(graphDiv, update, tracesIndices) {
				guard.throwIfNullOrUndefined("DEF0D03E", graphDiv, 'graphDiv');
				guard.throwIfNullOrUndefined("DEF0D04E", update, 'update');

				plotly.restyle(graphDiv, update, tracesIndices);
			}

			/**
             * Update layout attributes with Plotly.relayout
             * A more efficient means of updating just the layout in a graphDiv.
             * The call signature and arguments for relayout are similar (but simpler) to restyle. 
             * Because there are no indices to deal with, arrays need not be wrapped. 
             * Also, no argument specifying applicable trace indices is passed in.
             * @returns {} 
             */
			function relayout(graphDiv, update) {
				guard.throwIfNullOrUndefined("DEF0D05E", graphDiv, 'graphDiv');
				guard.throwIfNullOrUndefined("DEF0D06E", update, 'update');

				plotly.relayout(graphDiv, update);
			}

			/**
             * Add Traces with Plotly.addTraces
             * This allows you to add new traces to an existing graphDiv at any location in its data array.
             * @returns {} 
             */
			function addTraces(graphDiv, traces, index) {
				guard.throwIfNullOrUndefined("DEF0D07E", graphDiv, 'graphDiv');
				guard.throwIfNullOrUndefined("DEF0D08E", traces, 'traces');

				plotly.addTraces(graphDiv, traces, index);
			}

			/**
             * Delete Traces with Plotly.deleteTraces
             * This allows you to remove traces from an existing graphDiv by specifying the indices of the traces to be removed.
             * @returns {} 
             */
			function deleteTraces(graphDiv, indices) {
				guard.throwIfNullOrUndefined("DEF0D09E", graphDiv, 'graphDiv');
				guard.throwIfNullOrUndefined("DEF0D0AE", indices, 'indices');

				plotly.deleteTraces(graphDiv, indices);
			}

			/**
             * Move Traces with Plotly.moveTraces
             * This allows you to reorder traces in an existing graphDiv. 
             * This will change the ordering of the layering and the legend.
             * oldIndex and newIndex can be arrays specifying multiple indices
             * If newIndex is not specified, it will move the trace(s) to the end of the data array
             * @returns {} 
             */
			function moveTraces(graphDiv, oldIndex, newIndex) {
				guard.throwIfNullOrUndefined("DEF0D0BE", graphDiv, 'graphDiv');
				guard.throwIfNullOrUndefined("DEF0D0CE", oldIndex, 'oldIndex');

				plotly.moveTraces(graphDiv, oldIndex, newIndex);
			}

			/**
             * Redraw with Plotly.redraw
             * Use redraw to trigger a complete recalculation and redraw of the graph. 
             * This is not the fastest way to change single attributes, but may be the simplest way. 
             * You can make any arbitrary change to the data and layout objects, including completely replacing them, then call redraw.
             * @returns {} 
             */
			function redraw(graphDiv) {
				guard.throwIfNullOrUndefined("DEF0D0DE", graphDiv, 'graphDiv');

				plotly.redraw(graphDiv);
			}

			/**
             * Using Plotly events
             * Plots emit events prefixed with plotly_ when clicked or hovered over, and event handlers can be bound to events using the on method that is exposed by the plot div object. 
             * It is possible to use jQuery events, but plotly.js no longer bundles jQuery, so we recommend using the plotly.js implementation.
             * As well as plotly_click, there is plotly_beforehover, plotly_hover and plotly_unhover. 
             * @returns {} 
             */
			function on(graphDiv, event, handler) {
				guard.throwIfNullOrUndefined("DEF0D0EE", graphDiv, 'graphDiv');

				graphDiv.on('plotly_' + event, handler);
			}

			/**
             * Purging plotting surface with Plotly.purge
             * Using purge will clear the div, and remove any Plotly plots that have been placed in it.
             * @returns {} 
             */
			function purge(graphDiv) {
				guard.throwIfNullOrUndefined("DEF0D0FE", graphDiv, 'graphDiv');

				plotly.purge(graphDiv);
			}

			/**
             * Generating Image Strings with Plotly.toImage
             * toImage will turn an existing plot into a image string, which could the be used to retrieve a copy of the image.
             * @returns {} 
             */
			function toImage(graphDiv, imageProperties) {
				guard.throwIfNullOrUndefined("DEF0D0GE", graphDiv, 'graphDiv');

				plotly.toImage(graphDiv, imageProperties);
			}

			/**
             * Downloading Images of Plots with Plotly.downloadImage
             * downloadImage will trigger a request to download the image of a Plotly plot.
             * @returns {} 
             */
			function downloadImage(graphDiv, imageProperties) {
				guard.throwIfNullOrUndefined("DEF0D0HE", graphDiv, 'graphDiv');

				plotly.downloadImage(graphDiv, imageProperties);
			}

			/**
             * Resizes the given chart
             * @param {} graphDiv 
             * @returns {} 
             */
			function resize(graphDiv) {
				guard.throwIfNullOrUndefined("DEF0D0IE", graphDiv, 'graphDiv');

				plotly.Plots.resize(graphDiv);
			}

			/**
    * Will plot the chart with the old data and layout and the new configuration
    * @param {} graphDiv 
    * @param {} configObj 
    * @returns {} 
    */
			function updatePlotConfig(graphDiv, configObj) {
				guard.throwIfNullOrUndefined("DEF0D0JE", graphDiv, 'graphDiv');
				guard.throwIfNullOrUndefined("DEF0D0KE", configObj, 'configObj');

				plotly.plot(graphDiv, undefined, undefined, configObj);
			}
		}

		return chartPlotter;
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF0F}
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.controller('DiChartController', DiChartController);

		DiChartController.$inject = ['$scope', 'chartPlotter'];

		function DiChartController(scope, chartPlotter) {
			var vm = this;

			initialise();

			return;

			function initialise() {

				vm.config = _.extend({}, getDefaultConfigOptions(), scope.config);
				vm.layout = _.extend({}, getDefaultLayoutSettings(), scope.layout);
				vm.drawChart = drawChart;
				vm.resizeChart = resizeChart;
				vm.purgeChart = purgeChart;

				setWatches();
			}

			/**
             * Extends the config object defined on the scope with default properties
             * @returns {} 
             */
			function getDefaultConfigOptions() {
				return {
					displaylogo: false,
					autosizable: true,
					autosize: true,
					fillFrame: false,
					showLink: false,
					displayModeBar: false
				};
			}

			/**
             * Extends the layout object defined on the scope with default properties
             * @returns {} 
             */
			function getDefaultLayoutSettings() {
				return {
					paper_bgcolor: 'rgba(0,0,0,0)', //transparent background
					plot_bgcolor: 'rgba(0,0,0,0)', //transparent background
					autosize: true
				};
			}

			/**
             * Draws the chart
             * @returns {} 
             */
			function drawChart() {
				if (util.isDefined(scope.getDirectiveElement)) {
					var elem = scope.getDirectiveElement();
					chartPlotter.plot(elem, scope.data, vm.layout, vm.config);
				}
			}

			/**
             * Resizes the chart
             * @returns {} 
             */
			function resizeChart() {
				if (util.isDefined(scope.getDirectiveElement)) {
					var elem = scope.getDirectiveElement();
					chartPlotter.resize(elem);
				}
			}

			/**
             * Removes the chart
             * @returns {} 
             */
			function purgeChart() {
				if (util.isDefined(scope.getDirectiveElement)) {
					var elem = scope.getDirectiveElement();
					chartPlotter.purge(elem);
				}
			}

			/**
             * Sets up watching the data, layout and config objects
             * @returns {} 
             */
			function setWatches() {

				scope.$watch(function () {
					return scope.config;
				}, function (update) {
					if (!util.isNullOrUndefined(update)) {
						vm.config = _.extend({}, getDefaultConfigOptions(), update);

						if (util.isDefined(scope.getDirectiveElement)) {
							chartPlotter.reconfigure(scope.getDirectiveElement(), vm.config);
						}
					}
				});
				scope.$watchCollection(function () {
					return scope.data;
				}, function (data) {
					if (!util.isNullOrUndefined(data) && util.isDefined(scope.getDirectiveElement)) {
						chartPlotter.redraw(scope.getDirectiveElement());
					}
				});

				scope.$watch(function () {
					return scope.layout;
				}, function (update) {
					if (!util.isNullOrUndefined(update)) {
						vm.layout = _.extend({}, getDefaultLayoutSettings(), update);

						if (util.isDefined(scope.getDirectiveElement)) {
							chartPlotter.relayout(scope.getDirectiveElement(), vm.layout);
						}
					}
				});
			}
		}

		return DiChartController;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF0E}
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (angular) {
	'use strict';

	return function (module) {

		module.directive('diChart', diChart);

		diChart.$inject = ['$window'];

		function diChart($window) {
			return {
				restrict: 'E',
				template: '<div></div>',
				controller: 'DiChartController',
				controllerAs: 'diChartCtrl',
				scope: {
					data: '=',
					layout: '=',
					config: '='
				},
				link: link,
				replace: true
			};

			function link(scope, element, attributes, controller) {
				scope.getDirectiveElement = function () {
					return element[0];
				};

				controller.drawChart();

				angular.element($window).on('resize', onResize);
				scope.$on('$destroy', cleanUp);

				/**
                 * Resizes the chart
                 * @returns {} 
                 */
				function onResize() {
					controller.resizeChart();
				};

				/**
                 *  Performs cleanup
                 * @returns {} 
                 */
				function cleanUp() {
					angular.element($window).off('resize', onResize);
					controller.purgeChart();
				}
			}
		}

		return diChart;
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:ACD02}
// di.core.angular.controls.datatable
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(148), __webpack_require__(147), __webpack_require__(149)], __WEBPACK_AMD_DEFINE_RESULT__ = function (diDataTableDirectiveLoader, diDataTableControllerLoader, diTemplateCompilerLoader) {
    'use strict';

    return function (module) {
        diTemplateCompilerLoader(module);
        diDataTableDirectiveLoader(module);
        diDataTableControllerLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAC0Z}
// di.core.angular.controls.datatable
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.controller('DiDataTableController', DiDataTableController);

		DiDataTableController.$inject = ['$scope', 'translator'];

		/**
   * controller for data table
   * @param {} scope 
   * @param {} translator 
   * @returns {} 
   */
		function DiDataTableController(scope, translator) {
			var vm = this;
			vm.keepWatch = "true";
			vm.currentPage = 0;
			vm.data = [];
			vm.tableOptions = {};

			vm.clicked = clicked;
			vm.dblClicked = dblClicked;

			vm.displayData = displayData;
			vm.selectRow = selectRow;
			vm.getDataForPage = getDataForPage;
			vm.getCurrentlySelectedItems = getCurrentlySelectedItems;
			vm.getTotalPages = getTotalPages;
			vm.updatePagination = updatePagination;
			vm.changePage = changePage;

			vm.onOptionsForResizeLoaded = null;
			vm.onDataLoaded = null;
			vm.onRowClick = null;
			vm.onRowDblClick = null;

			if (util.isDefined(scope.keepWatch)) {
				vm.keepWatch = scope.keepWatch;
			}

			if (scope.rowClick) {
				vm.onRowClick = scope.rowClick;
			}

			if (scope.rowDoubleClick) {
				vm.onRowDblClick = scope.rowDoubleClick;
			}

			vm.onOptionsForButtonsLoaded = null;

			vm.setPaginationPageSizeButtonsOptions = function (setFunc) {
				vm.onOptionsForResizeLoaded = setFunc;
			};

			vm.dataLoaded = function (setFunc) {
				vm.onDataLoaded = setFunc;
			};

			watchItems();

			return;

			/**
    * watcher checking if data has been changed             
    */
			function watchItems() {
				var unwatch = function unwatch() {};
				var loaded = false;

				if (vm.keepWatch === "false") {
					unwatch = scope.$watch(watchExpression, initialiseOnce);
				} else {
					scope.$watchCollection('items', initialise);
				}

				return;

				function watchExpression() {
					loaded = scope.items.length > 0;
					return scope.items.length;
				}

				function initialiseOnce() {
					if (loaded) {
						unwatch();
						initialise();
					}
				}
			}

			/**
    * initializes table settings
    * @returns {} 
    */
			function initialise() {
				if (util.isDefined(scope.options)) {
					vm.currentPage = util.isNumber(scope.options.paginationPageNumber) ? scope.options.paginationPageNumber - 1 : 0;
					vm.tableOptions = scope.options;

					if (!util.isDefined(scope.options.data)) {
						vm.tableOptions.data = [];
					}

					vm.tableOptions.data.fill(scope.items);

					vm.tableOptions.pagination = {
						seek: vm.changePage,
						resize: vm.updatePagination
					};

					if (vm.onOptionsForButtonsLoaded) {
						vm.onOptionsForButtonsLoaded(vm.tableOptions);
					}

					if (vm.onOptionsForResizeLoaded) {
						vm.onOptionsForResizeLoaded(vm.tableOptions);
					}

					if (vm.onDataLoaded) {
						vm.onDataLoaded(vm.tableOptions);
					}

					translateColumnHeaders();

					displayData(vm.currentPage);
				}
			}

			/**
    * translates column names
    * @returns {} 
    */
			function translateColumnHeaders() {
				translator.whenReady().then(function () {
					_.each(vm.tableOptions.columns, function (column) {
						column.name = translator.instantTranslate(column.nameLanguageKey);
						column.visible = util.isDefined(column.visible) ? column.visible : true;
					});
				});
			}

			/**
    * event for row mouse click
    * @param {} item 
    * @returns {} 
    */
			function clicked(item) {
				if (vm.tableOptions.enableSelect === true) {
					selectRow(item, item.isSelected);
					raiseOnSelectionChanged();
				}

				if (vm.onRowClick) {
					vm.onRowClick(item);
				}
			}
			/**
    * event for row mouse double click
    * @param {} item 
    * @returns {} 
    */
			function dblClicked(item) {
				if (vm.tableOptions.enableSelect === true) {
					selectRow(item, false);
				}

				if (vm.onRowDblClick) {
					vm.onRowDblClick(item);
				}
			}

			/**
    * marks item as selected or un-selected depending on settings and previous state
    * @param {} item 
    * @param {} selected 
    * @returns {} 
    */
			function selectRow(item, selected) {
				var wasSelected = selected;

				var multiSelect = vm.tableOptions.multiSelect;

				if (multiSelect === false) {
					clearSelectedRows();
				}

				item.isSelected = !wasSelected;
			}

			function clearSelectedRows() {
				var selectedRows = vm.getCurrentlySelectedItems();
				selectedRows.forEach(function clearSelected(item) {
					item.isSelected = false;
				});
				raiseOnSelectionChanged();
			}

			function raiseOnSelectionChanged() {
				if (scope.onSelectionChanged) {
					var selectedItems = vm.getCurrentlySelectedItems();
					scope.onSelectionChanged(selectedItems);
				}
			}

			/**
    * gets currently selected items
    * @returns {} 
    */
			function getCurrentlySelectedItems() {
				var selectedRows = _.filter(vm.data, function (item) {
					return item.isSelected === true;
				});
				return selectedRows;
			}

			/**
    * changes current page to the one specified
    * @param {} pageNo 
    * @returns {} 
    */
			function changePage(pageNo) {
				vm.tableOptions.paginationPageNumber = pageNo;
				vm.currentPage = pageNo - 1;

				//clear selected rows before vm.data gets cleared and refilled
				clearSelectedRows();
				displayData(vm.currentPage);

				if (scope.onPageNumberChanged) {
					scope.onPageNumberChanged(pageNo);
				}
			}

			/**
    * updates settings when page size is changed
    * @param {} newSize 
    * @returns {} 
    */
			function updatePagination(newSize) {
				vm.tableOptions.paginationPageSize = newSize.value;
				changePage(1); //move to first page when size changes

				if (vm.onOptionsForButtonsLoaded) {
					vm.onOptionsForButtonsLoaded(vm.tableOptions);
				}
				if (scope.onPageSizeChanged) {
					scope.onPageSizeChanged(newSize.value);
				}
			}

			/**
    * loads data into table
    * @param {} page 
    * @returns {} 
    */
			function displayData(page) {
				clearDisplayedRows();
				if (scope.items && scope.items.length > 0) {
					setDisplayedRows(page);
				}
				if (scope.onDataDisplayed) {
					var displayedRows = getCurrentlyDisplayedItems();
					scope.onDataDisplayed(displayedRows);
				}
			}

			/**
    * calculates total number of pages
    * @returns {} 
    */
			function getTotalPages() {
				if (vm.tableOptions.enablePaging) {
					return Math.ceil(scope.items.length / vm.tableOptions.paginationPageSize);
				}

				return 1;
			}

			/**
    * gets data for specified page
    * @param {} pageNumber 
    * @returns {} 
    */
			function getDataForPage(pageNumber) {
				if (pageNumber !== undefined) {
					vm.currentPage = pageNumber;
				} else {
					vm.currentPage = 0;
				}
				var begin = vm.currentPage * vm.tableOptions.paginationPageSize;

				var end = begin + vm.tableOptions.paginationPageSize;

				if (end > scope.items.length) {
					end = scope.items.length;
				}

				var pagedData = scope.items.slice(begin, end);

				if (vm.tableOptions.fixedHeight && getTotalPages() > 1) {

					addMissingRows(pagedData);
				}

				return pagedData;
			}

			/**
    * adds hidden missing rows for last page
    * @param {} pagedData 
    * @returns {} 
    */
			function addMissingRows(pagedData) {
				var minRows = vm.tableOptions.paginationPageSize;

				if (pagedData.length < minRows) {

					var missingRows = minRows - pagedData.length;

					for (var i = 0; i < missingRows; i++) {
						pagedData.push({ isHidden: true });
					}
				}
			}

			/**
    * Resets all items to not displayed and clears the displayed array
    */
			function clearDisplayedRows() {
				vm.data.forEach(function reset(item) {
					setIsDisplayed(item, false);
				});

				vm.data.clear();
			}

			/**
    * Populates the data array with the rows to display and sets them to displayed
    */
			function setDisplayedRows(page) {
				if (vm.tableOptions.enablePaging === true) {
					vm.data.fill(getDataForPage(page));
				} else {
					vm.data.fill(scope.items);
				}

				vm.data.forEach(function set(item) {
					setIsDisplayed(item, true);
				});
			}

			/**
    * Sets the isDisplayed property on the item object to the propertyValue
    */
			function setIsDisplayed(item, propertyValue) {
				if (util.isObject(item) && !item.isHidden) {
					item.isDisplayed = propertyValue;
				}
			}

			/**
    * Returns the currently displayed items
    * @returns {} 
    */
			function getCurrentlyDisplayedItems() {
				var displayedRows = _.filter(vm.data, function (item) {
					return item.isDisplayed;
				});
				return displayedRows;
			}
		}

		return DiDataTableController;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:ACD01}
// di.core.angular.controls.datatable
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {

        module.directive('diDataTable', diDataTable);

        function diDataTable() {
            return {
                restrict: 'E',
                replace: true,
                transclude: {
                    'leftFooter': '?diDataTableLeftFooter'
                },
                template: template,
                controller: 'DiDataTableController',
                controllerAs: 'dataTableCtrl',
                scope: {
                    items: '=',
                    itemsController: '=',
                    options: '=',
                    rowClick: '=',
                    rowDoubleClick: '=',
                    onSelectionChanged: '=',
                    onDataDisplayed: '=',
                    onPageSizeChanged: '=',
                    onPageNumberChanged: '=',
                    keepWatch: '@'
                }
            };

            function template() {
                var html = '<section\
    class="table-wrap">\
    <section\
        class="table-wrap-content">\
        <table\
            class="table">\
            <thead\
                class="table-header">\
                <tr>\
                    <th\
                        class="{{column.headerCellClass || column.cellClass}}"\
                        ng-repeat="column in dataTableCtrl.tableOptions.columns | filter: { visible: true }">\
                        {{column.name}}\
                    </th>\
                    <th\
                        class="{{column.headerCellClass || column.cellClass}}"\
                        ng-repeat="column in dataTableCtrl.tableOptions.actionColumns">\
                    </th>\
                </tr>\
            </thead>\
            <tbody\
                class="table-content"\
                ng-class="{\'has-hover\': (dataTableCtrl.tableOptions.enableSelect === true ||\
                    dataTableCtrl.onRowClick ||\
                    dataTableCtrl.onRowDblClick)\
                    && dataTableCtrl.data.length > 0}">\
                <tr\
                    di-dbl-click="dataTableCtrl.dblClicked(dataItem)"\
                    di-click="dataTableCtrl.clicked(dataItem)"\
                    ng-repeat="dataItem in dataTableCtrl.data"\
                    ng-class="{selected: dataItem.isSelected===true,hidden: dataItem.isHidden===true}"\
                >\
                    <td\
                        class="{{column.cellClass}}"\
                        ng-repeat="column in dataTableCtrl.tableOptions.columns | filter: { visible: true }">\
                        <di-template-compiler\
                            template="column.template"\
                            binding="dataItem"\
                            controller="dataTableCtrl">\
                        </di-template-compiler>\
                    </td>\
                    <td\
                        class="{{column.cellClass}}"\
                        ng-repeat="column in dataTableCtrl.tableOptions.actionColumns">\
                        <di-template-compiler\
                            template="column.template"\
                            binding="dataItem"\
                            controller="itemsController">\
                        </di-template-compiler>\
                    </td>\
                </tr>\
                <tr\
                    ng-if="!dataTableCtrl.data.length > 0">\
                    <td\
                        colspan="{{dataTableCtrl.tableOptions.columns.length + dataTableCtrl.tableOptions.actionColumns.length}}">\
                        <span\
                            di-translate >\
                            CORE.DATA_TABLE.NO_DATA_FOUND\
                        </span>\
                    </td>\
                </tr>\
            </tbody>\
        </table>\
    </section>\
    <footer\
        class="table-wrap-footer"\
        ng-if="dataTableCtrl.tableOptions.enablePaging"\
        >\
        <div\
            class="left"\
            ng-transclude="leftFooter">\
            <di-grid-pagination-page-size\
                set-options="dataTableCtrl.setPaginationPageSizeButtonsOptions"\
                bind-to-object="dataTableCtrl.tableOptions"\
	            bind-to-property="paginationPageSize"\
                ng-show="dataTableCtrl.data.length > 0"\
                >\
            </di-grid-pagination-page-size>\
        </div>\
        <div\
            class="right">\
            <di-grid-pagination-buttons\
                options="dataTableCtrl.tableOptions"\
                >\
            </di-grid-pagination-buttons>\
        </div>\
    </footer>\
</section>';

                return html;
            }
        }

        return diDataTable;
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP3J}
// di.einvoicing.ui.components
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;

        guard.throwIfNotAnObject("EUP3J01E", module, "module");

        module.directive('diTemplateCompiler', diTemplateCompiler);

        diTemplateCompiler.$inject = ['$compile'];

        function diTemplateCompiler(compile) {
            return {
                restrict: 'E',
                scope: {
                    template: '=',
                    binding: '=',
                    controller: '='
                },
                link: doCompileTemplate
            };

            /**
             * Compile the given template HTML.
             * @param scope
             * @param element
             * @param attributes
             */
            function doCompileTemplate(scope, element) {
                if (scope.template) {
                    try {
                        compile(scope.template)(scope, function (compiled) {
                            element.parent().html(compiled);
                        });
                    } catch (ex) {}
                }
            }
        }

        return diTemplateCompiler;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var util = $di.utility.util;

        module.directive('diClick', diClick);

        diClick.$inject = ['$parse'];

        function diClick($parse) {
            return {
                restrict: 'A',
                link: link
            };

            /**
             * Detects single and double mouse clicks and executes a custom function
             */
            function link(scope, element, attr) {
                var waitForSecondClick = false;
                var delay = 300;
                var singleClick = $parse(attr['diClick']);
                var doubleClick = $parse(attr['diDblClick']);
                var clicks = 0,
                    timer = null;

                if (util.isDefined(attr['diDblClick'])) {
                    waitForSecondClick = true;
                }

                element.on('click', function (event) {
                    if (waitForSecondClick) {
                        twoClicks(event);
                    } else {
                        callSingle(event);
                    }
                });

                return;

                /**
                 * tests if there are two or one click
                 * @param {} event 
                 * @returns {} 
                 */
                function twoClicks(event) {
                    clicks++;
                    if (clicks === 1) {
                        timer = setTimeout(function () {
                            callSingle(event);
                            clicks = 0;
                        }, delay);
                    } else {
                        callDouble(event);
                        clearTimeout(timer);
                        clicks = 0;
                    }
                }

                /**
                 * triggers single click event
                 * @param {} event 
                 * @returns {} 
                 */
                function callSingle(event) {
                    scope.$apply(function () {
                        singleClick(scope, { $event: event });
                    });
                }

                /**
                 * triggers double click event
                 * @param {} event 
                 * @returns {} 
                 */
                function callDouble(event) {
                    scope.$apply(function () {
                        doubleClick(scope, { $event: event });
                    });
                }
            }
        }
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAC10}
// di.core.angular.controls
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.directive('diEnabled', diEnabled);

		diEnabled.$inject = ['$animate'];

		function diEnabled($animate) {
			return {
				restrict: 'A',
				multiElement: true,
				link: link

				/**
     * adds disabled class to the element so its possible to switch to disabled state (based on ngShow directive)		 
     */
			};function link(scope, element, attr) {
				scope.$watch(attr.diEnabled, function (value) {

					$animate[value ? 'removeClass' : 'addClass'](element, 'state-disabled', {
						tempClasses: 'state-disabled-animate'
					});
				});
			}
		}

		return diEnabled;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF0U}
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.directive('diNoDirty', diNoDirty);

		function diNoDirty() {
			return {
				restrict: 'A',
				require: "ngModel",
				link: link
			};

			function link(scope, element, attrs, ngModelCtrl) {
				//angular.noop is a function that performs no operations
				ngModelCtrl.$setDirty = angular.noop;
			}
		}

		return diNoDirty;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAU0I}
// di.core.angular.utility
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.directive('diTranscludeRepeat', diTranscludeRepeat);

		function diTranscludeRepeat() {
			return {
				terminal: true,
				restrict: 'EA',
				link: link
			};

			function link(scope, element, attrs, controller, transclude) {
				if (!transclude) {
					$di.exception.guard.throwNew("CAU0I01E", 'Illegal use of diTranscludeReplace directive in the template! ' + 'No parent directive that requires a transclusion found. ');
				}

				var innerScope = scope.$new();

				transclude(innerScope, function (clone) {
					element.empty();
					element.append(clone);
					element.on('$destroy', function () {
						innerScope.$destroy();
					});
				});
			}
		}
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAU0H}
// di.core.angular.utility
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.directive('diTranscludeReplace', diTranscludeReplace);

		function diTranscludeReplace() {
			return {
				terminal: true,
				restrict: 'EA',
				link: link
			};

			function link(scope, element, attr, ctrl, transclude) {
				if (!transclude) {
					$di.exception.guard.throwNew("CAU0H01E", 'Illegal use of diTranscludeReplace directive in the template! ' + 'No parent directive that requires a transclusion found. ');
				}

				transclude(function (clone) {
					if (clone.length) {
						element.replaceWith(clone);
					} else {
						element.remove();
					}
				});
			}
		}
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAC05}
// di.core.angular.controls.elementNotifier
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ng, $) {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;
        var util = $di.utility.util;

        module.provider('elementNotifier', ElementNotifierProvider);

        /**
         * Displays notification to the user, attached to a DOM element
         */
        function ElementNotifierProvider() {
            var defaultOptions = {
                clickToHide: true,
                autoHide: true,
                position: 'top left'
            };

            var config = {
                defaultOptions: defaultOptions
            };

            var provider = {
                configure: configure,
                $get: $get
            };

            return provider;

            /**
             * Configure the service
             * @param config
             */
            function configure(config) {
                guard.throwIfNotAnObject("CAC0501E", config, 'config');

                config = config;
            }

            function $get() {
                return {
                    error: error,
                    info: info,
                    success: success,
                    warning: warning
                };

                /**
                 * Notify the user of an error
                 * @param message
                 * @param title
                 */
                function error(message, element, options) {
                    var notification;

                    options = options || {};
                    options.style = options.style || 'diError';
                    options.className = options.className || 'error';

                    notification = createNotification(element, message, options);

                    return notification;
                }

                /**
                 * Notify the user of information
                 * @param message
                 * @param title
                 */
                function info(message, element, options) {
                    var notification;

                    options = options || {};
                    options.style = options.style || 'diInfo';
                    options.className = options.className || 'info';

                    notification = createNotification(element, message, options);

                    return notification;
                }

                /**
                 * Notify the user of success
                 * @param message
                 * @param title
                 */
                function success(message, element, options) {
                    var notification;

                    options = options || {};
                    options.style = options.style || 'diSuccess';
                    options.className = options.className || 'success';

                    notification = createNotification(element, message, options);

                    return notification;
                }

                /**
                 * Notify of a warning
                 * @param message
                 * @param title
                 */
                function warning(message, element, options) {
                    var notification;

                    options = options || {};
                    options.style = options.style || 'diWarning';
                    options.className = options.className || 'warn';

                    notification = createNotification(element, message, options);

                    return notification;
                }

                function createNotification(element, message, options) {
                    var notElm;

                    setMessage(message);

                    return {
                        element: element,
                        show: show,
                        hide: hide,
                        getMessage: getMessage,
                        setMessage: setMessage,
                        destroy: destroy
                    };

                    function show() {
                        notElm.show();
                        notElm.data('notifyjs').show(true);
                    }

                    function hide() {
                        notElm.data('notifyjs').show(false, function () {
                            notElm.hide();
                        });
                    }

                    function getMessage() {
                        var text = notElm.data('notifyjs').userContainer[0].firstElementChild.innerText;

                        return text;
                    }

                    function setMessage(newMessage) {
                        destroy();

                        notify(newMessage);
                    }

                    function destroy() {
                        if (notElm) {
                            element.removeData('notifyjs');
                            notElm.remove();
                        }
                    }

                    function notify(msg) {
                        var thirdPartyOptions = mapOptionsToThirdPartyOptions();

                        $.notify(element, msg, thirdPartyOptions);

                        notElm = ng.element(element.data('notifyjs'))[0].wrapper;
                        notElm.css('z-index', 1000);

                        return;

                        function mapOptionsToThirdPartyOptions() {
                            var thirdPartyOptions = {
                                arrowShow: true,
                                arrowSize: 5,
                                style: 'bootstrap',
                                showAnimation: 'slideDown',
                                showDuration: 400,
                                hideAnimation: 'slideUp',
                                hideDuration: 400,
                                gap: 2
                            };

                            setOption('clickToHide', 'clickToHide');
                            setOption('autoHide', 'autoHide');
                            setOption('position', 'elementPosition');
                            setOption('className', 'className');
                            setOption('style', 'style');

                            return thirdPartyOptions;

                            function setOption(optionName, thirdPartyOptionName, mappingFunction) {
                                var option;
                                var thirdPartyOption;

                                if (util.isDefined(options[optionName])) {
                                    option = options[optionName];
                                } else if (util.isDefined(config.defaultOptions[optionName])) {
                                    option = config.defaultOptions[optionName];
                                } else if (util.isDefined(defaultOptions[optionName])) {
                                    option = defaultOptions[optionName];
                                }

                                if (mappingFunction) {
                                    thirdPartyOption = mappingFunction(option);
                                } else {
                                    thirdPartyOption = option;
                                }

                                thirdPartyOptions[thirdPartyOptionName] = thirdPartyOption;
                            }
                        }
                    }
                }
            }
        }

        return ElementNotifierProvider;
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAC05}
// di.core.angular.controls.elementNotifierStyles
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($) {
	'use strict';

	return function () {
		$.notify.addStyle('diSuccess', {
			html: '<div>' + '<span class="fa fa-check fa-lg fa-pull-left">' + '</span>' + '<span class="padded-container" data-notify-text/>' + '</div>',
			classes: {
				base: {
					"font-weight": "bold",
					"padding": "8px 0px 8px 14px",
					"text-shadow": "0 1px 0 rgba(255, 255, 255, 0.5)",
					"border": "1px solid #fbeed5",
					"border-radius": "4px",
					"white-space": "nowrap"
				},
				success: {
					"color": "#468847",
					"background-color": "#DFF0D8",
					"border-color": "#D6E9C6"
				}
			}
		});

		$.notify.addStyle('diWarning', {
			html: '<div>' + '<span class="fa fa-warning fa-lg fa-pull-left">' + '</span>' + '<span class="padded-container" data-notify-text/>' + '</div>',
			classes: {
				base: {
					"font-weight": "bold",
					"padding": "8px 0px 8px 14px",
					"text-shadow": "0 1px 0 rgba(255, 255, 255, 0.5)",
					"border": "1px solid #fbeed5",
					"border-radius": "4px",
					"white-space": "nowrap"
				},
				warn: {
					"color": "#C09853",
					"background-color": "#FCF8E3",
					"border-color": "#FBEED5"
				}
			}
		});

		$.notify.addStyle('diInfo', {
			html: '<div> ' + '<span class="fa fa-info-circle fa-lg fa-pull-left">' + '</span>' + '<span class="padded-container" data-notify-text/>' + '</div>',
			classes: {
				base: {
					"font-weight": "bold",
					"padding": "8px 0px 8px 14px",
					"text-shadow": "0 1px 0 rgba(255, 255, 255, 0.5)",
					"border": "1px solid #fbeed5",
					"border-radius": "4px",
					"white-space": "nowrap"
				},
				info: {
					"color": "#3A87AD",
					"background-color": "#D9EDF7",
					"border-color": "#BCE8F1"
				}
			}
		});

		$.notify.addStyle('diError', {
			html: '<div>' + '<span class="fa fa-times fa-lg fa-pull-left">' + '</span>' + '<span class="padded-container" data-notify-text/>' + '</div>',
			classes: {
				base: {
					"font-weight": "bold",
					"padding": "8px 0px 8px 14px",
					"text-shadow": "0 1px 0 rgba(255, 255, 255, 0.5)",
					"border": "1px solid #fbeed5",
					"border-radius": "4px",
					"white-space": "nowrap"
				},
				error: {
					"color": "#B94A48",
					"background-color": "#F2DEDE",
					"border-color": "#EED3D7"
				}
			}
		});
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAC11}
// di.core.angular.controls.enterkey
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(158), __webpack_require__(159)], __WEBPACK_AMD_DEFINE_RESULT__ = function (diEnterDirectiveLoader, enterEventsLoader) {
    'use strict';

    return function (module) {
        diEnterDirectiveLoader(module);
        enterEventsLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAC0N}
// di.core.angular.controls
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.directive('diEnter', diEnter);

		diEnter.$inject = ['enterEvents'];

		function diEnter(enterEvents) {
			return {
				restrict: 'A',
				link: link
			};

			/**
    * detects keystrokes for enter key and executes dependency             
    */
			function link(scope, element, attrs) {
				element.bind("keydown keypress", function (event) {
					if (event.which === 13) {
						enterEvents.keyPressed(scope, element, attrs);
					}
				});
			}
		}
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAC13}
// di.core.angular.controls.enterkey
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.factory('enterEvents', enterEvents);

		enterEvents.$inject = ['formAnalyser', '$timeout'];

		function enterEvents(formAnalyser, $timeout) {
			return {
				keyPressed: keyPressed
			};

			/**
    *  calls custom function
    */
			function keyPressed(scope, element, attrs) {
				element.blur();

				$timeout(function () {
					if (validateForm()) {
						scope.$apply(function () {
							scope.$eval(attrs.diEnter);
						});
					}

					return;

					function validateForm() {
						var form = formAnalyser.getForm(element);
						var skipValidation = canSkipValidation();
						var formIsValid = formAnalyser.isFormValid(form);

						return formIsValid || skipValidation;
					}
				}, 100);

				event.preventDefault();

				return;

				/**
        * checks if form validation may be skipped                
        */
				function canSkipValidation() {
					if (util.isDefined(attrs.diEnterSkipValidation) && attrs.diEnterSkipValidation === "false") {
						return false;
					}

					return true;
				}
			}
		}

		return enterEvents;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:ACG01}
// di.core.angular.controls.gridpaginationbuttons
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(162), __webpack_require__(161)], __WEBPACK_AMD_DEFINE_RESULT__ = function (diGridPaginationButtonsDirectiveLoader, diGridPaginationButtonsControllerLoader) {
    'use strict';

    return function (module) {
        diGridPaginationButtonsDirectiveLoader(module);
        diGridPaginationButtonsControllerLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:ACG03}
// di.core.angular.controls.gridpaginationbuttons
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.controller('DiGridPaginationButtonsController', DiGridPaginationButtonsController);

		DiGridPaginationButtonsController.$inject = ['$scope'];

		/**
         * controller for pagination buttons
         * @param {} $scope 
         * @returns {} 
         */
		function DiGridPaginationButtonsController($scope) {

			var vm = this;
			var switchPage = null;

			vm.items = [];
			vm.current = 1;
			vm.total = 1;
			vm.pageSize = 1;
			vm.maxButtonsShown = 5;

			vm.goToPage = goToPage;
			vm.nextPage = nextPage;
			vm.previousPage = previousPage;
			vm.setTableOptions = setTableOptions;

			vm.tableOptions = setTableOptions($scope.options || []); //null;

			return;

			/**
             * initializes control's options
             * @param {} options 
             * @returns {} 
             */
			function setTableOptions(options) {
				if (util.isDefined(options.data)) {
					vm.tableOptions = options;
					vm.pageSize = options.paginationPageSize;
					vm.maxButtonsShown = options.maxButtonsShown;
					switchPage = options.pagination.seek;
					vm.current = util.isNumber(options.paginationPageNumber) ? options.paginationPageNumber : 1;
					vm.total = Math.ceil(options.data.length / vm.pageSize);

					if (vm.total > 1) {
						updateItems();
					}
				}
			}

			/**
             * changes currently selected page to the one specified
             * @param {} pageNo 
             * @returns {} 
             */
			function goToPage(pageNo) {
				if (pageNo !== '...') {
					vm.current = pageNo;
					if (switchPage) {
						switchPage(vm.current);
					}
					updateItems();
				}
			}

			/**
             * changes current page to next 
             * @returns {} 
             */
			function nextPage() {
				if (vm.current + 1 <= vm.total) {
					vm.current++;
					if (switchPage) {
						switchPage(vm.current);
					}

					updateItems();
				}
			}

			/**
             * changes current page to previous
             * @returns {} 
             */
			function previousPage() {
				if (vm.current - 1 > 0) {
					vm.current--;
					if (switchPage) {
						switchPage(vm.current);
					}

					updateItems();
				}
			}

			/**
             * updates collection of buttons based on current page
             * @returns {} 
             */
			function updateItems() {
				vm.items = getPageNumbers(vm.total, vm.current, vm.maxButtonsShown);
			}

			/**
             * generates collection of page numbers
             * @param {} count 
             * @param {} current 
             * @param {} max 
             * @returns {} 
             */
			function getPageNumbers(count, current, max) {

				var shownPages = max;
				var result = [];

				var leftSide = Math.ceil((shownPages - 1) / 2);
				if (current === 1) {
					leftSide = 0;
				}
				if (current === 2) {
					leftSide = 1;
				}

				var rightSide = shownPages - 1 - leftSide;

				if (current === count) {
					leftSide = shownPages - 1;
					rightSide = 0;
				}
				if (current === count - 1) {
					rightSide = 1;
					leftSide = shownPages - 1 - rightSide;
				}

				var number = 0;

				if (current - leftSide > 1) {
					result.push(1);
				}

				if (current - leftSide > 3) {
					result.push('...');
				} else if (current - leftSide > 2) {
					result.push(2);
				}

				for (var i = leftSide; i > 0; i--) {
					number = current - i;
					if (number > 0) {
						result.push(current - i);
					}
				}

				result.push(current);

				for (var j = 1; j <= rightSide; j++) {
					number = current + j;
					if (number <= count) {
						result.push(number);
					}
				}

				if (count - number > 2) {
					result.push('...');
				} else if (count - number === 2 && number + 1 !== count) {
					result.push(number + 1);
				}

				if (current + rightSide < count) {
					result.push(count);
				}

				return result;
			}
		};

		return DiGridPaginationButtonsController;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:ACG02}
// di.core.angular.controls.gridpaginationbuttons
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.directive('diGridPaginationButtons', diGridPaginationButtons);

        function diGridPaginationButtons() {
            return {
                restrict: 'E',
                replace: true,
                translucent: true,
                scope: {
                    options: '='
                },
                require: ['^diGridPaginationButtons', '^diDataTable'],
                link: function link(scope, element, attrs, ctrls) {
                    var paginationCtrl = ctrls[0];
                    var dataTableCtrl = ctrls[1];

                    dataTableCtrl.onOptionsForButtonsLoaded = paginationCtrl.setTableOptions;
                },
                controller: 'DiGridPaginationButtonsController',
                controllerAs: 'diGridPaginationButtonsCtrl',
                template: '<ul\
                                class="pagination"\
                                ng-show="diGridPaginationButtonsCtrl.total > 1" >\
                            <li\
                                class="pagination-item to-prev2">\
                                    <button type="button"\
                                        class="pagination-button"\
                                        ng-click="diGridPaginationButtonsCtrl.previousPage()" >\
                                            <div style="padding-left:5px;padding-right:5px"><</div>\
                                    </button>\
                            </li>\
                            <li\
                                class="pagination-item"\
                                ng-repeat="item in diGridPaginationButtonsCtrl.items track by $index"\
                                ng-class="{\'is-current\' : item == diGridPaginationButtonsCtrl.current, \'disabled\' : item == \'...\'}" >\
                                    <button type="button"\
                                        class="pagination-button"\
                                        ng-click="diGridPaginationButtonsCtrl.goToPage(item)" >\
                                            {{item}}\
                                    </button>\
                            </li>\
                            <li\
                                class="pagination-item to-next" >\
                                <button type="button"\
                                    class="pagination-button"\
                                    ng-click="diGridPaginationButtonsCtrl.nextPage()" >\
                                </button>\
                            </li>\
                           </ul>'
            };
        }

        return diGridPaginationButtons;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:ACG04}
// di.core.angular.controls.gridpaginationpagesize
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(165), __webpack_require__(164)], __WEBPACK_AMD_DEFINE_RESULT__ = function (diGridPaginationPageSizeDirectiveLoader, diGridPaginationPageSizeController) {
    'use strict';

    return function (module) {
        diGridPaginationPageSizeDirectiveLoader(module);
        diGridPaginationPageSizeController(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:ACG06}
// di.core.angular.controls.gridpaginationpagesize
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var util = $di.utility.util;

        module.controller('DiGridPaginationPageSizeController', DiGridPaginationPageSizeController);

        DiGridPaginationPageSizeController.$inject = ['$scope', 'translator'];

        /**
         * controller for page size control
         * @param {} $scope 
         * @param {} translator 
         * @returns {} 
         */
        function DiGridPaginationPageSizeController($scope, translator) {
            var vm = this;

            var resize = null;
            vm.gridOptions = null;

            vm.sizes = [];
            vm.selectedSize = {};

            vm.update = update;

            initialize();

            return;

            /**
             * initializes control settings
             * @returns {} 
             */
            function initialize() {
                translator.translate("CORE.GRID_PAGINATION_PAGE_SIZE.SHOW").then(function (translated) {
                    $scope.show = translated;
                });

                if ($scope.setOptions) {
                    $scope.setOptions(setTableOptions);
                }
            }

            /**
             * sets control grid options
             * @param {} options 
             * @returns {} 
             */
            function setTableOptions(options) {
                if (util.isDefined(options)) {
                    vm.gridOptions = options;
                    if (vm.gridOptions.paginationPageSizes) {

                        vm.sizes.clear();
                        _.each(vm.gridOptions.paginationPageSizes, function (size) {
                            vm.sizes.push({
                                label: $scope.show + ' ' + size,
                                value: size
                            });
                        });
                    }

                    if (vm.gridOptions.paginationPageSize) {
                        vm.selectedSize = { label: $scope.show + ' ' + vm.gridOptions.paginationPageSize, value: vm.gridOptions.paginationPageSize };
                    }

                    if (vm.gridOptions.pagination && vm.gridOptions.pagination.resize) {
                        resize = vm.gridOptions.pagination.resize;
                    }
                }
            }

            /**
             * updates current page size
             * @param {} size 
             * @returns {} 
             */
            function update(size) {
                var item = _.find(vm.sizes, function (item) {
                    return item.value === size;
                });

                if (util.isDefined(item)) {
                    vm.selectedSize = item;
                }

                if (resize) {
                    resize(size);
                }
            }
        };

        return DiGridPaginationPageSizeController;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:ACG05}
// di.core.angular.controls.gridpaginationpagesize
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.directive('diGridPaginationPageSize', diGridPaginationPageSize);

		function diGridPaginationPageSize() {
			return {
				restrict: 'E',
				replace: true,
				translucent: true,
				scope: {
					setOptions: '=',
					bindToObject: '=',
					bindToProperty: '@'
				},
				controller: 'DiGridPaginationPageSizeController',
				controllerAs: 'diGridPaginationPageSizeCtrl',
				template: template
			};

			function template() {

				var html = '<div class="show-entries select small"><di-select\
                        mode="dropdown"\
	        			ng-show="(diGridPaginationPageSizeCtrl.sizes.length > 0)"\
                        items="diGridPaginationPageSizeCtrl.sizes"\
	                    item-unique-property="value"\
                        bind-to-object="diGridPaginationPageSizeCtrl"\
	                    bind-to-property="selectedSize"\
	                    display-property="label"\
	                    on-change-accessor="diGridPaginationPageSizeCtrl.update"\
                        placeholder="{{show}}">\
                        <span>{{::filteredItem.item.value}}</span>\
                    </di-select></div>';

				return html;
			}
		}

		return diGridPaginationPageSize;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAC0O}
// di.core.angular.controls.image
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(169), __webpack_require__(167), __webpack_require__(168)], __WEBPACK_AMD_DEFINE_RESULT__ = function (imageTemplate, imageCompile, imageDirectiveLoader) {
    'use strict';

    return function (module) {
        imageTemplate(module);
        imageCompile(module);
        imageDirectiveLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAC0P}
// di.core.angular.controls.image
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ng) {
	'use strict';

	return function (module) {
		var util = $di.utility.util;
		var guard = $di.exception.guard;

		module.factory('diImageCompile', diImageCompile);

		diImageCompile.$inject = ['IMAGES', 'COLOUR_CLASSES', 'diImageTemplate'];

		function diImageCompile(IMAGES, COLOUR_CLASSES, diImageTemplate) {
			return {
				compile: compile,
				compileHtml: compileHtml
			};

			function compileHtml(attrs) {
				var elmTag = attrs.rootElement || 'i';

				var imageHtmlTemplate = diImageTemplate.get();

				imageHtmlTemplate = imageHtmlTemplate.replace('{ELM}', elmTag);

				return compileElement(imageHtmlTemplate, attrs);
			}

			function compile(element, attrs) {
				compileElement(element, attrs);
			}

			function compileElement(element, attrs) {
				var rootElm = ng.element(element);
				var cssClass = attrs.class || 'icon';
				var imageData;

				if (attrs.src) {
					compileLinked(attrs.src);
				} else {
					guard.throwIfUndefined("CAC0P01E", attrs.image, "attrs.image");

					imageData = IMAGES[attrs.image];

					guard.throwIfNotAnObject("CAC0P02E", imageData, "Image constant for image '" + attrs.image + "'");

					if (imageData.src) {
						compileLinked(imageData.src);
					} else {
						compileEmbedded();
					}
				}

				rootElm.addClass(cssClass);

				return rootElm.html();

				function compileLinked(src) {
					var imgElm = ng.element('<img />');

					imgElm.attr('src', src);

					rootElm.replaceWith(imgElm);
					rootElm = imgElm;
				}

				function compileEmbedded() {
					var svgElm = findById(rootElm, 'svg');

					setSvgAttrs();

					setSvgPath();

					//Silly hack required to get dynamically generated SVG content to display
					rootElm.html(rootElm.html());

					return;

					function findById(parent, id) {
						var elm = parent.find('#' + id);

						elm.removeAttr('id');

						return elm;
					}

					function setSvgAttrs() {
						var minX = imageData.minX || 0;
						var minY = imageData.minY || 0;
						var width = imageData.width || 0;
						var height = imageData.height || 0;
						var viewbox = imageData.viewBox || minX + ' ' + minY + ' ' + width + ' ' + height;

						if (util.isDefined(imageData.width)) {
							svgElm.attr('width', width);
						}
						if (util.isDefined(imageData.height)) {
							svgElm.attr('height', height);
						}
						svgElm.attr('viewbox', viewbox);
						svgElm.attr('enable-background', 'new ' + viewbox);
						svgElm.attr('xml:space', imageData.xmlSpace || 'preserve');

						if (util.isDefined(imageData.preserveAspectRatio)) {
							svgElm.attr('preserveAspectRatio', imageData.preserveAspectRatio);
						}

						if (util.isDefined(imageData.class)) {
							svgElm.attr('class', imageData.class);
						}
					}

					function setSvgPath() {
						var pathElm = svgElm.find('path');
						var colour;

						if (attrs.imageColour) {
							colour = COLOUR_CLASSES[attrs.imageColour];

							if (util.isUndefined(colour)) {
								colour = attrs.imageColour;
							}
						}

						pathElm.attr('fill', colour || 'none');
						pathElm.attr('d', imageData.data);

						if (imageData.pathStyles) {
							addElementCss(pathElm, imageData.pathStyles);
						}

						return;

						function addElementCss(element, cssStyles) {
							for (var property in cssStyles) {
								if (cssStyles.hasOwnProperty(property)) {
									element.css(property, cssStyles[property]);
								}
							}
						}
					}
				}
			}
		}

		return diImageCompile;
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAC0P}
// di.core.angular.controls.image
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ng) {
    'use strict';

    return function (module) {
        var util = $di.utility.util;
        var guard = $di.exception.guard;

        module.directive('diImage', diImage);

        diImage.$inject = ['diImageCompile', 'diImageTemplate'];

        function diImage(imageCompile, imageTemplate) {
            return {
                restrict: 'E',
                replace: true,
                template: template,
                scope: {
                    image: "@",
                    imageColour: '@'
                },
                link: link
            };

            function template(element, attrs) {
                var elmTag = attrs.rootElement || 'i';
                var html = imageTemplate.get();
                return html.replace('{ELM}', elmTag);
            }

            function link(scope, element, attrs) {

                if (util.isDefined(scope.image)) {
                    attrs.image = scope.image;
                } else if (util.isDefined(scope.$parent.image)) {
                    attrs.image = scope.$parent.image;
                }

                imageCompile.compile(element, attrs);
            }
        }

        return diImage;
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAC0P}
// di.core.angular.controls.image
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ng) {
    'use strict';

    return function (module) {

        module.factory('diImageTemplate', diImageTemplate);

        var html = '<{ELM}>\
    <!--<?xml version="1.0" encoding="utf-8"?>-->\
    <svg\
        id="svg"\
        xmlns="http://www.w3.org/2000/svg"\
        xmlns:xlink="http://www.w3.org/1999/xlink"\
        version="1.1"\
        x="0px" \
        y="0px">\
        <path>\
        </path>\
    </svg>\
</{ELM}>';

        function diImageTemplate() {
            return {
                get: get
            };

            function get() {
                return html;
            }
        }

        return diImageTemplate;
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAC0Y}
// di.core.angular.controls.input
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(172), __webpack_require__(171)], __WEBPACK_AMD_DEFINE_RESULT__ = function (inputControllerLoader, inputDirectiveLoader) {
    'use strict';

    return function (module) {
        inputControllerLoader(module);
        inputDirectiveLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAC01}
//di.core.ng.controls
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.directive('diInput', diInput);

		diInput.$inject = ['$interpolate', 'translator', '$q', 'controlsRestrictionManager', 'formAnalyser'];

		function diInput($interpolate, translator, $q, controlsRestrictionManager, formAnalyser) {
			return {
				restrict: 'E',
				scope: {
					bindModel: '=ngModel',
					bindModelProperty: '@ngModelProperty',
					bindModelOptions: '=ngModelOptions',
					validationPropertyName: "@",
					onChange: '&ngChange'
				},
				controller: 'InputController',
				controllerAs: 'inputCtrl',
				template: template,
				link: function link(scope, element, attrs) {
					scope.inputClass = interpolate('inputClass');
					scope.diInputType = interpolate('diInputType');

					interpolateAndTranslate('diInputLabel').then(function (translated) {
						scope.diInputLabel = translated;
					});

					scope.diShowIcon = interpolate('diShowIcon', 'true') === 'true';

					scope.validationModelDisplayName = interpolate('validationModelDisplayName');
					scope.validationMessagePosition = interpolate('validationMessagePosition');
					scope.validationMessage = interpolate('validationMessage');
					scope.validateOnBlur = interpolate('validateOnBlur', 'false') === 'true';
					scope.diClass = interpolate('diClass');

					interpolateAndTranslate('placeholder').then(function (translated) {
						scope.placeholder = translated;
					});

					var modelName = getModelName();

					if (scope.validationPropertyName && modelName) {
						controlsRestrictionManager.addControlChangeSubscription(modelName + '.' + scope.validationPropertyName, function (disabled) {
							scope.disabled = disabled;
						});
					}

					return;

					function getModelName() {
						var elementWithValidatationModelName = formAnalyser.getElementWithValidationModel(element);
						var innerElement = elementWithValidatationModelName[0];
						if (innerElement) {
							return elementWithValidatationModelName[0].attributes['di-validate-model'].value;
						}
						return '';
					}

					function interpolateAndTranslate(attr, valueIfEmpty) {
						var value = interpolate(attr, valueIfEmpty);

						if (value) {
							return translator.translate(value);
						}

						return $q.when(value);
					}

					function interpolate(attr, valueIfEmpty) {
						var value = attrs[attr];
						var result = (value ? $interpolate(value)(scope) : '') || valueIfEmpty;

						return result;
					}
				}
			};

			/**
   * This should be placed in a seperate .html file - we need to provide deployment solution for this?
   * Perhaps npm - gulp-angular-templatecache?
   */
			function template() {
				var html = '<div>\n\t<div\n\t\tng-if="::diInputType === \'date\'">\n\t\t<label\n\t\t\tng-if="::diInputLabel"\n\t\t\tclass="form-row-label">\n\t\t\t{{::diInputLabel}}\n\t\t</label>\n\t\t<div\n\t\t\tclass ="datepicker"\n            ng-if="::diShowIcon === true">\n\t\t\t<div\n\t\t\t\tclass="datepicker-input">\n\t\t\t\t<span>\n\t\t\t\t\t<di-image\n\t\t\t\t\t\tclass="datepicker-button"\n\t\t\t\t\t\troot-element="button"\n\t\t\t\t\t\timage="calendar"\n\t\t\t\t\t\timage-colour="button"\n                        tabindex="-1"\n\t\t\t\t\t\ttype="button">\n\t\t\t\t\t</di-image>\n\t\t\t\t</span>\n\t\t\t\t<input\n\t\t\t\t\tclass="input form-control date-input"\n\t\t\t\t\ttype="text"\n\t\t\t\t\tng-model="bindModel[bindModelProperty]"\n\t\t\t\t\tng-change="onChange()"\n                    ng-disabled="::disabled"\n\t\t\t\t\tng-click="inputCtrl.showDatePicker()"\n\t\t\t\t\tdi-validate="{{::validationPropertyName}}"\n\t\t\t\t\tvalidate-on-blur="{{::validateOnBlur}}"\n\t\t\t\t\tvalidation-model-display-name="{{::validationModelDisplayName}}"\n\t\t\t\t\tvalidation-message-position="{{::validationMessagePosition}}"\n\t\t\t\t\tvalidation-message="{{::validationMessage}}"\n\t\t\t\t\tplaceholder="{{::placeholder}}" />\n\t\t\t</div>\n\t\t</div>\n        <div\n\t\t\tclass ="datepicker"\n            ng-if="::diShowIcon !== true">\n\t\t\t<div>\t\t\t\t\n\t\t\t\t<input\n\t\t\t\t\tclass ="input form-control date-input"\n\t\t\t\t\ttype="text"\n\t\t\t\t\tng-model="bindModel[bindModelProperty]"\n\t\t\t\t\tng-change="onChange()"\n                    ng-disabled="::disabled"\n\t\t\t\t\tng-click="inputCtrl.showDatePicker()"\n\t\t\t\t\tdi-validate="{{::validationPropertyName}}"\n\t\t\t\t\tvalidate-on-blur="{{::validateOnBlur}}"\n\t\t\t\t\tvalidation-model-display-name="{{::validationModelDisplayName}}"\n\t\t\t\t\tvalidation-message-position="{{::validationMessagePosition}}"\n\t\t\t\t\tvalidation-message="{{::validationMessage}}"\n\t\t\t\t\tplaceholder="{{::placeholder}}" />\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\t<div\n\t\tng-if="::diInputType === \'number\'">\n\t\t<label\n\t\t\tng-if="::diInputLabel"\n\t\t\tclass="form-row-label">\n\t\t\t{{::diInputLabel}}\n\t\t</label>\n\t\t<input\n\t\t\tclass="input form-control"\n\t\t\ttype="number"\n\t\t\tpattern="/^\\d+$/"\n\t\t\tonkeypress="return event.charCode >= 48 && event.charCode <= 57"\n\t\t\tng-model="bindModel[bindModelProperty]"\n\t\t\tng-model-options="bindModelOptions"\n\t\t\tng-change="onChange()"\n            ng-disabled="::disabled"\n\t\t\tdi-validate="{{::validationPropertyName}}"\n\t\t\tvalidate-on-blur="{{::validateOnBlur}}"\n\t\t\tvalidation-model-display-name="{{::validationModelDisplayName}}"\n\t\t\tvalidation-message-position="{{::validationMessagePosition}}"\n\t\t\tvalidation-message="{{::validationMessage}}"\n\t\t\tplaceholder="{{::placeholder}}" />\n\t</div>\n\t<div\n\t\tng-if="::diInputType === \'checkbox\'">\n\t\t<label\n\t\t\tclass="checkbox">\n\t\t\t<input\n\t\t\t\tclass="form-control checkbox-trigger"\n\t\t\t\ttype="checkbox"\n\t\t\t\tng-model="bindModel"\n\t\t\t\tng-change="onChange()" />\n\t\t\t<div\n\t\t\t\tclass="checkbox-base">\n\t\t\t</div>\n\t\t\t<span\n\t\t\t\tclass="checkbox-label">{{::diInputLabel}}</span>\n\t\t</label>\n\t</div>\n\t<div\n\t\tng-if="::diInputType === \'email\'">\n\t\t<label\n\t\t\tng-if="::diInputLabel"\n\t\t\tclass="form-row-label">\n\t\t\t{{::diInputLabel}}\n\t\t</label>\n\t\t<input\n\t\t\tclass="input form-control"\n\t\t\ttype="email"\n\t\t\tng-model="bindModel[bindModelProperty]"\n\t\t\tng-model-options="bindModelOptions"\n\t\t\tng-change="onChange()"\n\t\t\tdi-validate="{{::validationPropertyName}}"\n\t\t\tvalidate-on-blur="{{::validateOnBlur}}"\n\t\t\tvalidation-model-display-name="{{::validationModelDisplayName}}"\n\t\t\tvalidation-message-position="{{::validationMessagePosition}}"\n\t\t\tvalidation-message="{{::validationMessage}}"\n\t\t\tplaceholder="{{::placeholder}}" />\n\t</div>\n\t<div\n\t\tng-if="::diInputType === \'password\'">\n\t\t<label\n\t\t\tng-if="::diInputLabel"\n\t\t\tclass="form-row-label">\n\t\t\t{{::diInputLabel}}\n\t\t</label>\n\t\t<input\n\t\t\tclass="input form-control"\n\t\t\ttype="password"\n\t\t\tng-model="bindModel[bindModelProperty]"\n\t\t\tng-model-options="bindModelOptions"\n\t\t\tng-change="onChange()"            \n\t\t\tdi-validate="{{::validationPropertyName}}"\n\t\t\tvalidate-on-blur="{{::validateOnBlur}}"\n\t\t\tvalidation-model-display-name="{{::validationModelDisplayName}}"\n\t\t\tvalidation-message-position="{{::validationMessagePosition}}"\n\t\t\tvalidation-message="{{::validationMessage}}"\n\t\t\tplaceholder="{{::placeholder}}" />\n\t</div>\n\t<div\n\t\tng-if="::diInputType === \'decimal\'">\n\t\t<label\n\t\t\tng-if="::diInputLabel"\n\t\t\tclass="form-row-label">\n\t\t\t{{::diInputLabel}}\n\t\t</label>\n\t\t<input\n\t\t\tclass="input form-control numericcell"\n\t\t\ttype="text"\n\t\t\tng-model="bindModel[bindModelProperty]"\n\t\t\tng-model-options="bindModelOptions"\n            ng-disabled="::disabled"\n\t\t\tng-change="onChange()"\n\t\t\tdi-validate="{{::validationPropertyName}}"\n\t\t\tvalidate-on-blur="{{::validateOnBlur}}"\n\t\t\tvalidation-model-display-name="{{::validationModelDisplayName}}"\n\t\t\tvalidation-message-position="{{::validationMessagePosition}}"\n\t\t\tvalidation-message="{{::validationMessage}}"\n\t\t\tplaceholder="{{::placeholder}}" />\n\t</div>\n\t<div\n\t\tng-if="::diInputType === \'text\'">\n        <label\n\t\t\tng-if="::diInputLabel"\n\t\t\tclass="form-row-label">\n\t\t\t{{::diInputLabel}}\n\t\t</label>\n\t\t<input\n\t\t\tclass="input form-control"\n\t\t\ttype="text"\n\t\t\tng-model="bindModel[bindModelProperty]"\n\t\t\tng-model-options="bindModelOptions"\n\t\t\tng-change="onChange()"\n            ng-disabled="::disabled"\n\t\t\tdi-validate="{{::validationPropertyName}}"\n\t\t\tvalidate-on-blur="{{::validateOnBlur}}"\n\t\t\tvalidation-model-display-name="{{::validationModelDisplayName}}"\n\t\t\tvalidation-message-position="{{::validationMessagePosition}}"\n\t\t\tvalidation-message="{{::validationMessage}}"\n\t\t\tplaceholder="{{::placeholder}}" />\n\t</div>\n    <div\n\t\tng-if="::diInputType === \'hidden\'">\n       \n\t\t<input\n\t\t\tclass ="input form-control"\n\t\t\ttype="hidden"\n\t\t\tng-model="bindModel[bindModelProperty]"\n\t\t\tng-model-options="bindModelOptions"\n\t\t\tng-change="onChange()"\n            ng-disabled="::disabled"\n\t\t\tdi-validate="{{::validationPropertyName}}"\n\t\t\tvalidate-on-blur="{{::validateOnBlur}}"\n\t\t\tplaceholder="{{::placeholder}}" />\n\t</div>\n    <div\n\t\tng-if="::diInputType === \'textarea\'">\n        <label\n\t\t\tng-if="::diInputLabel"\n\t\t\tclass ="form-row-label">\n\t\t\t\t{{::diInputLabel}}\n\t\t</label>\n\t\t<textarea\n\t\t\tng-class ="::diClass"\t\t\t\n\t\t\tng-model="bindModel[bindModelProperty]"\n\t\t\tng-model-options="bindModelOptions"\n\t\t\tng-change="onChange()"\n            ng-disabled="::disabled"\n\t\t\tdi-validate="{{::validationPropertyName}}"\n\t\t\tvalidate-on-blur="{{::validateOnBlur}}"\n\t\t\tvalidation-model-display-name="{{::validationModelDisplayName}}"\n\t\t\tvalidation-message-position="{{::validationMessagePosition}}"\n\t\t\tvalidation-message="{{::validationMessage}}"\t\t\t\n\t\t\tplaceholder="{{::placeholder}}">\n        </textarea>\n\t</div>\n</div>';

				return html;
			}
		}

		return diInput;
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAC15}
// di.core.angular.controls.input
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(16)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Pikaday) {
    'use strict';

    return function (module) {
        module.controller('InputController', InputController);

        InputController.$inject = ['$scope', '$element', 'DATE_FORMATS', '$timeout'];

        function InputController(scope, element, DATE_FORMATS, $timeout) {
            var vm = this;
            var pikaday;

            vm.showDatePicker = showDatePicker;
            vm.validationModelDisplayName = scope.validationModelDisplayName;

            initialize();

            return;

            function initialize() {
                vm.validationProperty = scope.validationModelProperty;

                $timeout(function () {
                    if (scope.diInputType === "date") {
                        var inputElm = element.find('input');

                        pikaday = new Pikaday({
                            field: inputElm[0],
                            theme: 'di-pikaday',
                            format: DATE_FORMATS.supported[0],
                            onSelect: function onSelect() {
                                $timeout(function () {
                                    inputElm.trigger('input');
                                });
                            }
                        });

                        scope.$on('$destroy', function () {
                            pikaday.destroy();
                            inputElm.remove();
                            pikaday = undefined;
                        });
                    };
                }, 0, false);
            }

            function showDatePicker() {
                pikaday.show();
            }
        }

        return InputController;
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

var _modalResource = __webpack_require__(174);

var _modalWindow = __webpack_require__(175);

!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.controller('ResourceController', _modalResource.ModalResourceController);
        module.service('modalWindow', _modalWindow.ModalWindowService);
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ModalResourceController = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _modalBase = __webpack_require__(23);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //{CODE:ACS02}


var util = $di.utility.util;

var constants = Symbol('constants');

var ModalResourceController = function (_ModalControllerBase) {
    _inherits(ModalResourceController, _ModalControllerBase);

    function ModalResourceController($q, $element, translator, promptWindow, options, close, partyProxy, elementNotifier) {
        _classCallCheck(this, ModalResourceController);

        var _this = _possibleConstructorReturn(this, (ModalResourceController.__proto__ || Object.getPrototypeOf(ModalResourceController)).call(this, $element, promptWindow, options, close));

        _this.$q = $q;
        _this.translator = translator;
        _this.promptWindow = promptWindow;
        _this.partyProxy = partyProxy;
        _this.elementNotifier = elementNotifier;

        _this[constants] = {
            save: 'EINVOICING.PORTAL.ACTIONS.GENERAL.SAVE',
            cancel: 'EINVOICING.PORTAL.ACTIONS.GENERAL.CANCEL',
            close: 'EINVOICING.PORTAL.ACTIONS.GENERAL.CLOSE',
            remove: 'EINVOICING.PORTAL.ACTIONS.GENERAL.REMOVE'
        };

        _this.onCountryChanged = _this.onCountryChanged.bind(_this);
        _this.validateCode = _this.validateCode.bind(_this);
        _this.validationFailed = _this.validationFailed.bind(_this);

        _this.init();
        return _this;
    }

    _createClass(ModalResourceController, [{
        key: 'init',
        value: function init() {
            var _this2 = this;

            this.translator.whenReady().then(function () {
                if (util.isDefined(_this2.options.title)) {
                    _this2.title = _this2.translator.instantTranslate(_this2.options.title);
                }

                _this2.save = _this2.translator.instantTranslate(_this2.options.save || _this2[constants].save);
                _this2.remove = _this2.translator.instantTranslate(_this2.options.remove || _this2[constants].remove);

                var cancelText = _this2.model.isEditable ? _this2.options.cancel || _this2[constants].cancel : _this2.options.close || _this2[constants].close;

                _this2.cancel = _this2.translator.instantTranslate(cancelText);
            });
        }
    }, {
        key: 'onCountryChanged',
        value: function onCountryChanged(country) {
            this.changed = true;

            if (this.options.onCountryChanged) {
                this.options.onCountryChanged(country);
            }

            this.onDataChanged();
        }
    }, {
        key: 'onPreSave',
        value: function onPreSave() {
            if (this.options.validateOnSave && this.changed) {
                this.validateCode(this.model, this.onSave);
            } else {
                this.onSave();
            }
        }
    }, {
        key: 'validateCode',
        value: function validateCode(identifier) {
            var _this3 = this;

            var dataModel = {
                id: identifier.id,
                partyId: identifier.partyId,
                partyCodeType: identifier.partyCodeType,
                codeValue: identifier.code,
                schemeId: identifier.scheme.id,
                relatedPartyId: identifier.relatedParty.id
            };

            var promise = this.partyProxy.validatePartyCode(dataModel).then(function (result) {
                return {
                    success: result.success,
                    message: result.resultData
                };
            });

            this.$q.all([promise]).then(function (_ref) {
                var _ref2 = _slicedToArray(_ref, 1),
                    result = _ref2[0];

                if (result.success === false) {
                    _this3.validationFailed(result);
                } else {
                    _this3.onSave();
                }
            });
        }
    }, {
        key: 'validationFailed',
        value: function validationFailed(result) {
            var el = this.$element[0].querySelector('#codeValue');
            if (util.isNullOrUndefined(el) === false) {

                var notification = this.elementNotifier.error(result.message, el);

                notification.show();
            } else {
                console.log(result.message);
            }
        }
    }]);

    return ModalResourceController;
}(_modalBase.ModalControllerBase);

ModalResourceController.prototype.constructor.$inject = ['$q', '$element', 'translator', 'promptWindow', 'options', 'close', 'partyProxy', 'elementNotifier'];

exports.ModalResourceController = ModalResourceController;

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//{CODE:CAC0A}
var util = $di.utility.util;

var ModalWindowService = function () {
    function ModalWindowService(modalService) {
        _classCallCheck(this, ModalWindowService);

        this.modalService = modalService;
    }

    _createClass(ModalWindowService, [{
        key: 'show',
        value: function show(options, saveCallback, cancelCallback, deleteCallback) {
            this.modalService.showModal({
                templateUrl: options.templateUrl,
                controller: options.controller,
                controllerAs: options.controllerAs || '$ctrl',
                bodyClass: options.css || "custom-modal-open",
                inputs: {
                    options: options
                },
                preventClose: options.preventClose || false,
                preClose: function preClose(modal) {
                    modal.element.modal('hide');
                }
            }).then(function (modal) {
                modal.element.modal();
                modal.close.then(function (result) {
                    switch (result.state) {
                        case 'saved':
                            if (saveCallback && util.isFunction(saveCallback)) {
                                saveCallback(result.object);
                            }
                            break;
                        case 'deleted':
                            if (deleteCallback && util.isFunction(deleteCallback)) {
                                deleteCallback(result.object);
                            }
                            break;
                        default:
                            if (cancelCallback && util.isFunction(cancelCallback)) {
                                cancelCallback(result.object);
                            }
                            break;
                    }
                });
            });
        }
    }]);

    return ModalWindowService;
}();

ModalWindowService.prototype.constructor.$inject = ['ModalService'];

exports.ModalWindowService = ModalWindowService;

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAM03}
// di.core.angular.controls.multiSelect
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(177)], __WEBPACK_AMD_DEFINE_RESULT__ = function (diMultiSelectDirectiveLoader) {
  'use strict';

  return function (module) {
    diMultiSelectDirectiveLoader(module);
  };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAM05}
// di.core.angular.controls.multiSelect
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.directive('diMultiSelect', diMultiSelect);

		function diMultiSelect() {
			return {
				restrict: 'E',
				replace: true,
				scope: {
					selectedOptions: '=',
					availableOptions: '=',
					placeholder: '@',
					labelText: '@',
					icon: '@',
					multiSelect: '@',
					maxItemsToShow: '@',
					onChange: '&'
				},

				template: function template(element, attrs) {
					if (attrs.multiSelect === undefined) {
						attrs.multiSelect = 1;
					}

					var labelCtrl = '<label di-translate="{{::labelText}}"></label>';

					if (!attrs.labelText) {
						labelCtrl = '';
					}

					if (!attrs.maxItemsToShow) {
						attrs.maxItemsToShow = 3;
					}

					var html = '<div>\
					' + labelCtrl + '\
					<div \
						class="input-group">\
						<span\
							class="input-group-addon">\
							<span\
								class="{{::icon}}"></span>\
							</span>\
						<button	type="button"\
							class="btn btn-default"\
							style="-webkit-border-radius: 0px; border-radius: 0px; text-align:left;"\
							ng-model="selectedOptions"\
						    ng-change="onChange()"\
							data-html="1"\
							data-multiple="' + attrs.multiSelect + '"\
							data-animation="am-flip-x"\
							placeholder="{{::placeholder}}"\
							max-length="{{::maxItemsToShow}}"\
							bs-options="filter.value as filter.label for filter in availableOptions" bs-select>\
						<span \
							class="caret">\
						</span>\
						</button>\
					</div>\
					</div>';

					return html;
				}
			};
		}

		return diMultiSelect;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAC03}
// di.core.angular.controls.notifier
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(44)], __WEBPACK_AMD_DEFINE_RESULT__ = function (toastr) {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;
        var util = $di.utility.util;
        module.provider('notifier', NotifierProvider);

        /**
         * Displays toast notifications to the user
         */
        function NotifierProvider() {
            var config = {};

            var provider = {
                configure: configure,
                $get: $get
            };

            return provider;

            /**
             * Configure the service
             * @param config
             */
            function configure(cfg) {
                guard.throwIfNotAnObject("CAL0101E", cfg, 'cfg');

                config = cfg;

                toastr.options.timeOut = cfg.timeOut;
                toastr.options.positionClass = cfg.positionClass;
            }

            function $get() {
                return {
                    error: error,
                    info: info,
                    success: success,
                    warning: warning
                };
            }

            /**
             * Notify the user of an error
             * @param message
             * @param title
             */
            function error(message, title) {
                toastr.error(message, title, {
                    extendedTimeOut: 0, timeOut: config.errorTimeOut || config.timeOut || 0
                });
            }

            /**
             * Notify the user of information
             * @param message
             * @param title
             */
            function info(message, title) {
                toastr.info(message, title, {
                    timeOut: config.infoTimeOut || config.timeOut || 5000
                });
            }

            /**
             * Notify the user of success
             * @param message
             * @param title
             */
            function success(message, title, onClick, timeOut) {
                toastr.success(message, title, {
                    timeOut: timeOut || config.successTimeOut || config.timeOut || 5000,
                    onclick: onClick,
                    closeButton: util.isFunction(onClick)
                });
            }

            /**
             * Notify of a warning
             * @param message
             * @param title
             */
            function warning(message, title, onClick) {
                toastr.warning(message, title, {
                    timeOut: config.warningTimeOut || config.timeOut || 5000,
                    onclick: onClick,
                    closeButton: util.isFunction(onClick)
                });
            }
        }

        return NotifierProvider;
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

// di.core.angular.controls.prompt
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(180)], __WEBPACK_AMD_DEFINE_RESULT__ = function (promptWindowLoader) {
    'use strict';

    return function (module) {
        promptWindowLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAO01}
// di.core.angular.controls.promptWindow
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(34)], __WEBPACK_AMD_DEFINE_RESULT__ = function (bootbox) {
    'use strict';

    return function (module) {
        var util = $di.utility.util;
        var guard = $di.exception.guard;
        var box;

        module.factory('promptWindow', promptWindow);

        promptWindow.$inject = ['translator'];

        function promptWindow(translator) {
            var promptConfig = {
                title: "",
                message: "",
                okBtnText: "",
                okBtnClass: "",
                cancelBtnText: "",
                cancelBtnClass: "",
                callback: undefined,
                condition: true
            };

            return {
                alert: alert,
                confirm: confirm,
                prompt: prompt
            };

            /**
            * Shows a modal pop up with a message and OK button.
            * @param promptConfig
            */
            function alert(inputPromptConfig) {
                closeIfActiveBox();

                var promptConfig = getPromptConfig(inputPromptConfig);
                validatePromptConfig(promptConfig);
                setDefaults(promptConfig);

                translator.whenReady().then(function () {
                    box = bootbox.alert({
                        title: translator.instantTranslate(promptConfig.title.stringToTranslate, promptConfig.title.translationArguments),
                        message: translator.instantTranslate(promptConfig.message.stringToTranslate, promptConfig.message.translationArguments),
                        callback: promptConfig.callback,
                        buttons: {
                            ok: {
                                label: translator.instantTranslate(promptConfig.okBtnText.stringToTranslate, promptConfig.okBtnText.translationArguments),
                                className: promptConfig.okBtnClass
                            }
                        }
                    });
                });
            }

            /**
            * Shows a modal pop up with message and OK, Cancel buttons.
            * Callback returns 'true' for OK button and 'false' otherwise.
            * @param promptConfig
            */
            function confirm(inputPromptConfig) {
                closeIfActiveBox();

                var promptConfig = getPromptConfig(inputPromptConfig);
                validatePromptConfig(promptConfig);
                setDefaults(promptConfig);

                translator.whenReady().then(function () {
                    box = bootbox.confirm({
                        title: translator.instantTranslate(promptConfig.title.stringToTranslate, promptConfig.title.translationArguments),
                        message: translator.instantTranslate(promptConfig.message.stringToTranslate, promptConfig.message.translationArguments),
                        callback: promptConfig.callback,
                        buttons: {
                            confirm: {
                                label: translator.instantTranslate(promptConfig.okBtnText.stringToTranslate, promptConfig.okBtnText.translationArguments),
                                className: promptConfig.okBtnClass
                            },
                            cancel: {
                                label: translator.instantTranslate(promptConfig.cancelBtnText.stringToTranslate, promptConfig.cancelBtnText.translationArguments),
                                className: promptConfig.cancelBtnClass
                            }
                        }
                    });
                });
            }

            /**
            * Shows a modal pop up with message, input control and OK, Cancel buttons.
            * Callback returns text entered into the input control.
            * @param promptConfig
            */
            function prompt(inputPromptConfig) {
                closeIfActiveBox();

                var promptConfig = getPromptConfig(inputPromptConfig);
                validatePromptConfig(promptConfig);
                setDefaults(promptConfig);

                translator.whenReady().then(function () {
                    box = bootbox.prompt({
                        title: translator.instantTranslate(promptConfig.title.stringToTranslate, promptConfig.title.translationArguments),
                        message: translator.instantTranslate(promptConfig.message.stringToTranslate, promptConfig.message.translationArguments),
                        callback: promptConfig.callback,
                        buttons: {
                            confirm: {
                                label: translator.instantTranslate(promptConfig.okBtnText.stringToTranslate, promptConfig.okBtnText.translationArguments),
                                className: promptConfig.okBtnClass
                            },
                            cancel: {
                                label: translator.instantTranslate(promptConfig.cancelBtnText.stringToTranslate, promptConfig.cancelBtnText.translationArguments),
                                className: promptConfig.cancelBtnClass
                            }
                        }
                    });
                });
            }

            /**
             * Closes the active bootbox window before showing another one.             
             */
            function closeIfActiveBox() {
                if (box) {
                    box.modal('hide');
                }
            }

            /**
            * Validates if prompt configuration was supplied before display a modal pop up.
            * @param promptConfig
            */
            function validatePromptConfig(promptConfig) {
                guard.throwIfNullOrUndefined("CAO0108E", promptConfig, "promptConfig");
                guard.throwIfEmptyString("CAO0105E", promptConfig.message.stringToTranslate, "promptConfig.message");
                guard.throwIfEmptyString("CAO0106E", promptConfig.title.stringToTranslate, "promptConfig.title");
            }

            /**
             * Sets default buttons texts if not provided in config              
             */
            function setDefaults(promptConfig) {
                if (util.isUndefined(promptConfig.okBtnText)) {
                    promptConfig.okBtnText.stringToTranslate = "CORE.PROMPT.OK";
                }

                if (util.isUndefined(promptConfig.cancelBtnText)) {
                    promptConfig.cancelBtnText.stringToTranslate = "CORE.PROMPT.CANCEL";
                }

                if (util.isUndefined(promptConfig.okBtnClass)) {
                    promptConfig.okBtnClass = "btn-primary";
                }

                if (util.isUndefined(promptConfig.cancelBtnClass)) {
                    promptConfig.cancelBtnClass = "btn-default";
                }
            }

            function getPromptConfig(inputConfig) {
                var promptConfig = {
                    title: {},
                    message: {},
                    okBtnText: {},
                    cancelBtnText: {}
                };

                var _arr = ['title', 'message', 'okBtnText', 'cancelBtnText'];
                for (var _i = 0; _i < _arr.length; _i++) {
                    var property = _arr[_i];
                    if (util.isObject(inputConfig[property])) {
                        promptConfig[property] = inputConfig[property];
                    } else {
                        promptConfig[property].stringToTranslate = inputConfig[property];
                    }
                }

                return _.extend(inputConfig, promptConfig);
            }
        }

        return promptWindow;
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(184), __webpack_require__(182), __webpack_require__(183)], __WEBPACK_AMD_DEFINE_RESULT__ = function (userEditRestrictionsProxy, controlsRestrictionManager, restrictionStore) {
    'use strict';

    return function (module) {
        module.service('userEditRestrictionsProxy', userEditRestrictionsProxy.UserEditRestrictionsProxyService);

        module.service('controlsRestrictionManager', controlsRestrictionManager.ControlsRestrictionManager);

        module.service('restrictionStore', restrictionStore.RestrictionsStore);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ControlsRestrictionManager = function () {
    function ControlsRestrictionManager(restrictionStore) {
        _classCallCheck(this, ControlsRestrictionManager);

        this.util = $di.utility.util;

        this._restrictionStore = restrictionStore;
        this._subscriptions = new Map();
        this._optionSubscriptions = [];
        this._initialised = false;
        this._allowAddNewLine = true;
        this._allowAddAllowance = true;
        this._allowAddCharge = true;
    }

    _createClass(ControlsRestrictionManager, [{
        key: 'initialise',
        value: function initialise(invoiceId, callback) {
            var _this = this;

            this._invoiceId = invoiceId;
            this._allowSubscriptions = false;
            this._initialised = false;
            this._subscriptions = new Map();
            this._optionSubscriptions = [];

            if (this.util.isNumber(invoiceId) && invoiceId > 0) {
                this._allowSubscriptions = true;
                this._restrictionStore.loadRestrictions(invoiceId).then(function () {
                    _this._initialised = true;
                    _this.loadRestrictionLevelsFromStore();
                    _this.processSubscriptions();

                    callback(_this._userRestrictionLevel);
                });
            }
        }
    }, {
        key: 'loadRestrictionLevelsFromStore',
        value: function loadRestrictionLevelsFromStore() {
            var editRestrictions = this._restrictionStore.getEditRestrictions();

            this._userRestrictionLevel = editRestrictions.userRestrictionLevel.toLowerCase();
            this._entityEditRestrictions = editRestrictions.entityEditStates;

            this._allowAddNewLine = editRestrictions.allowAddNewLine;
            this._allowAddAllowanceCharge = editRestrictions.allowAddAllowanceCharge;
        }
    }, {
        key: 'addOptionsSubscription',
        value: function addOptionsSubscription(subcriptionFunction) {
            this._optionSubscriptions.push(subcriptionFunction);

            if (this._initialised) {
                subcriptionFunction({
                    allowAddNewLine: this._allowAddNewLine,
                    allowAddAllowanceCharge: this._allowAddAllowanceCharge
                });
            }
        }
    }, {
        key: 'addControlChangeSubscription',
        value: function addControlChangeSubscription(fullName, subcriptionFunction) {
            if (!this._allowSubscriptions) return;

            this._subscriptions.set(fullName, subcriptionFunction);

            if (this._initialised) {
                subcriptionFunction(this.disableControl(fullName));
            }
        }
    }, {
        key: 'processSubscriptions',
        value: function processSubscriptions() {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = this._subscriptions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var _step$value = _slicedToArray(_step.value, 2),
                        key = _step$value[0],
                        value = _step$value[1];

                    value(this.disableControl(key));
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = this._optionSubscriptions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var subcriptionFunction = _step2.value;

                    subcriptionFunction({
                        allowAddNewLine: this._allowAddNewLine,
                        allowAddAllowanceCharge: this._allowAddAllowanceCharge
                    });
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }
        }
    }, {
        key: 'disableControl',
        value: function disableControl(name) {
            if (this._userRestrictionLevel === 'none') return false;
            if (this._userRestrictionLevel === 'all') return true;
            if (this._entityEditRestrictions.length === 0) return false;

            var disable = false;

            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
                for (var _iterator3 = this._entityEditRestrictions[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var restriction = _step3.value;

                    var fullName = restriction.entityType.toLowerCase() + '.' + restriction.entityName.toLowerCase();
                    if (fullName === name.toLowerCase()) {
                        disable = !restriction.allowEdit;
                        break;
                    }
                }
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                    }
                } finally {
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }

            return disable;
        }
    }]);

    return ControlsRestrictionManager;
}();

ControlsRestrictionManager.prototype.constructor.$inject = ['restrictionStore'];

exports.ControlsRestrictionManager = ControlsRestrictionManager;

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var RestrictionsStore = function () {
    function RestrictionsStore(userEditRestrictionsProxy, sessionStore) {
        _classCallCheck(this, RestrictionsStore);

        this._userEditRestrictionsProxy = userEditRestrictionsProxy;
        this._sessionStore = sessionStore;
    }

    _createClass(RestrictionsStore, [{
        key: 'loadRestrictions',
        value: function loadRestrictions(invoiceId) {
            var _this = this;

            return this._userEditRestrictionsProxy.getEditRestrictions(invoiceId).then(function (result) {
                _this._sessionStore.set('editRestrictions', result, 'restrictionsStore');
            });
        }
    }, {
        key: 'getEditRestrictions',
        value: function getEditRestrictions() {
            return this._sessionStore.get('editRestrictions', 'restrictionsStore');
        }
    }]);

    return RestrictionsStore;
}();

RestrictionsStore.prototype.constructor.$inject = ['userEditRestrictionsProxy', 'sessionStore'];

exports.RestrictionsStore = RestrictionsStore;

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var UserEditRestrictionsProxyService = function () {
    function UserEditRestrictionsProxyService(webApiHttp, urlHelper) {
        _classCallCheck(this, UserEditRestrictionsProxyService);

        this._webApiHttp = webApiHttp;
        this._urlHelper = urlHelper;
    }

    _createClass(UserEditRestrictionsProxyService, [{
        key: 'getEditRestrictions',
        value: function getEditRestrictions(invoiceId) {
            var requestedParams = {
                invoiceId: invoiceId
            };

            var requestedUrl = this._urlHelper.setParameters('Restrictions/GetEditRestrictions', requestedParams);

            return this._webApiHttp.get(requestedUrl);
        }
    }]);

    return UserEditRestrictionsProxyService;
}();

UserEditRestrictionsProxyService.prototype.constructor.$inject = ['webApiHttp', 'urlHelper'];

exports.UserEditRestrictionsProxyService = UserEditRestrictionsProxyService;

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAC0E}
// di.core.angular.controls.select
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(186), __webpack_require__(187), __webpack_require__(188), __webpack_require__(189), __webpack_require__(190)], __WEBPACK_AMD_DEFINE_RESULT__ = function (objectFilterLoader, selectControllerLoader, selectDirectiveLoader, selectDirectiveUpgradeLoader, selectUpgradeControllerLoader) {
	'use strict';

	return function (module) {
		objectFilterLoader(module);
		selectControllerLoader(module);
		selectDirectiveLoader(module);
		selectUpgradeControllerLoader(module);
		selectDirectiveUpgradeLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAC0G}
// di.core.angular.controls.search
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.filter('diObject', diObjectFilter);

		function diObjectFilter() {
			return function (val, searchData, propertiesToSearch) {
				var searchExp = new RegExp(searchData, "i");
				var matchedObjects = [];

				_.each(val, function (item) {
					var objectMatches = checkObjectMatches(item, searchExp, propertiesToSearch);
					if (objectMatches) {
						matchedObjects.push(item);
					}
				});

				return matchedObjects;
			};

			/**
    * Function which checks if the any of the searchable properties on the specified object
    * are matched by the specified search expression
    * @param item
    * @param searchExp
    * @param propertiesToSearch
    */
			function checkObjectMatches(item, searchExp, propertiesToSearch) {
				return _.some(propertiesToSearch, function (property) {
					if (item[property] !== undefined) {
						var itemMatches = item[property].search(searchExp) > -1;
						return itemMatches;
					} else {
						return false;
					}
				});
			}
		}

		return diObjectFilter;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAC0T}
// di.core.angular.controls.select
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.controller('DiSelectController', DiSelectController);

		DiSelectController.$inject = ['$scope', 'promptWindow', 'controlsRestrictionManager'];

		function DiSelectController(scope, promptWindow, controlsRestrictionManager) {
			var util = $di.utility.util;
			var ngUtil = $di.angular.util;

			var selectedItem = {};
			var searchablePropertyNames;
			var ignoreBoundObjectProperty;
			var highlightedItem;

			var vm = this;

			vm.onItemSelected = onItemSelected;
			vm.filteredItems = [];
			vm.inputKeypress = inputKeypress;
			vm.inputKeyUp = inputKeyUp;
			vm.toggleActions = {};
			vm.selectedItem = {};
			vm.controlState = { disabled: false };
			vm.selectStyle = {};
			scope.onSearchTextChange = applySearch;

			vm.isSelected = isSelected;

			watchBoundObjectProperty();
			watchItems();

			if (scope.validationPropertyName && scope.diValidateModel) {
				controlsRestrictionManager.addControlChangeSubscription(scope.diValidateModel + '.' + scope.validationPropertyName, function (disabled) {
					vm.controlState.disabled = disabled;
					if (disabled) {
						vm.selectStyle = { 'background-color': '#dddddd' };
					}
				});
			}

			return;

			function applySearch(item) {
				if (item) {
					if (canBeShown(item)) {
						var filteredItem = {
							item: item,
							highlighed: false
						};

						if (vm.filteredItems.length == 0) {
							filteredItem.previous = filteredItem;
							filteredItem.next = filteredItem;
						} else {
							filteredItem.previous = vm.filteredItems[vm.filteredItems.length - 1];
							filteredItem.previous.next = filteredItem;
							filteredItem.next = vm.filteredItems[0];
							filteredItem.next.previous = filteredItem;
						}

						vm.filteredItems.push(filteredItem);

						filteredItem.index = vm.filteredItems.length;
					}

					return;
				}

				vm.filteredItems.clear();
				highlightedItem = null;

				if (!scope.items || scope.items.length === 0) {
					return;
				}

				for (var i = 0; i < scope.items.length; i++) {
					applySearch(scope.items[i]);
				}
			}

			function inputKeyUp() {
				var newItem = {};
				var searchText = scope.getSearchText();
				newItem = searchText;
				scope.bindToObject[scope.bindToProperty] = newItem;

				if (scope.watchBinding) {
					watchBoundObjectProperty();
				}

				if (util.isFunction(scope.onChangeAccessor)) {
					var onChangeAccessor = scope.onChangeAccessor();

					if (util.isFunction(onChangeAccessor)) {
						onChangeAccessor(newItem);
					}
				}
			}

			function inputKeypress(evt) {
				var keyCode = evt.keyCode;
				var isHandled = false;
				var toggleFunc = vm.toggleActions.show;

				switch (keyCode) {
					case 9:
						//Tab

						toggleFunc = vm.toggleActions.hide;

						//we want the event to propagate						
						break;

					case 13:
						//Enter
						isHandled = true;
						if (highlightedItem) {
							onItemSelected(highlightedItem.item);
						}

						toggleFunc = vm.toggleActions.hide;

						stopEventPropagation(evt);
						break;

					case 27:
						//Escape
						isHandled = true;
						scope.setSearchText('');

						displaySelectedItem();

						toggleFunc = vm.toggleActions.hide;

						stopEventPropagation(evt);
						break;

					case 38:
						//Up
						isHandled = true;
						if (highlightedItem) {
							highlightedItem = highlightedItem.previous;
						} else if (vm.filteredItems.length > 0) {
							highlightedItem = vm.filteredItems[0];
						}

						stopEventPropagation(evt);
						break;

					case 40:
						//Down
						isHandled = true;
						if (highlightedItem) {
							highlightedItem = highlightedItem.next;
						} else if (vm.filteredItems.length > 0) {
							highlightedItem = vm.filteredItems[0];
						}

						stopEventPropagation(evt);
						break;

					default:
						break;
				}

				toggleFunc();

				if (isHandled && highlightedItem) {
					scope.highlightItem(highlightedItem.index);
				}

				return;

				function stopEventPropagation(evt) {
					evt.stopPropagation();
					evt.preventDefault();
				}
			}

			function displaySelectedItem() {
				var displayText;

				if (!selectedItem) {
					displayText = '';
				} else {
					displayText = selectedItem[scope.displayProperty];
				}
				if (!scope.allowEmptyDisplay && (displayText === '' || util.isUndefined(displayText))) {
					displayText = tryToDisplay(scope.searchableProperties);
				}

				scope.setDisplayText(displayText);
			}

			function tryToDisplay(properties) {
				var found = '';
				var values = properties.split(',');
				_.each(values, function (v) {
					if (util.isNonEmptyString(selectedItem[v]) && found === '') {
						found = selectedItem[v];
					}
				});

				return found;
			}

			function canBeShown(item) {
				if (!searchablePropertyNames) {
					searchablePropertyNames = (scope.searchableProperties || '').split(',');
				}

				if (!searchablePropertyNames || searchablePropertyNames.length === 0) {
					return true;
				}

				var searchText = scope.getSearchText();

				if (searchText === '') {
					return true;
				}

				var noMatches = searchablePropertyNames.every(function (propertyName) {
					if (util.isNullOrUndefined(item[propertyName])) {
						return true;
					}

					var noMatch = !isMatch(searchText, item[propertyName]);

					return noMatch;
				});

				return !noMatches;
			}

			function isMatch(searchWord, propertyValue) {
				var value = propertyValue.toLowerCase();
				var substring = searchWord.toLowerCase();
				return value.indexOf(substring) !== -1;
			}

			function watchBoundObjectProperty() {
				var currentValue = undefined;

				if (scope.watchIncludeDefaultObj !== true) {
					currentValue = scope.bindToObject[scope.bindToProperty];
				}

				ignoreBoundObjectProperty = ngUtil.$watch(scope, function () {
					return scope.bindToObject[scope.bindToProperty];
				}, function (item) {
					itemSelected(item, false);
					vm.selectedItem = item;
					if (!scope.watchBinding) {
						ignoreBoundObjectProperty();
					}
				}, currentValue);
			}

			function watchItems() {
				var unwatch = ngUtil.$watchCollection(scope, 'items', listener);

				return;

				function listener() {
					if (!scope.watchItems) {
						unwatch();
					};

					if (scope.items.length === 1 && scope.selectSingle) {
						onItemSelected(scope.items[0]);
					}

					applySearch();
				}
			}

			function onItemSelected(item) {
				if (util.isDefined(scope.onItemSelectFunction) && util.isFunction(item[scope.onItemSelectFunction])) {
					item[scope.onItemSelectFunction](selectOption);
				} else {
					selectOption(item);
				}
			};

			function selectOption(item) {
				var confirm = false;

				if (util.isFunction(scope.confirm)) {
					var confirmFunc = scope.confirm(item);

					if (util.isFunction(confirmFunc)) {
						confirm = confirmFunc(item);
					} else {
						confirm = confirmFunc;
					}
				}

				if (confirm) {
					promptWindow.confirm({
						title: scope.confirmTitle,
						message: scope.confirmMessage,
						okBtnText: scope.confirmOkBtnText,
						cancelBtnText: scope.confirmCancelBtnText,
						callback: function callback(result) {
							if (result) {
								itemSelected(item, true);
								vm.selectedItem = item;
							} else {
								displaySelectedItem();
								vm.toggleActions.hide();
							}
						}
					});
				} else {
					vm.selectedItem = item;
					itemSelected(item, true);
				}
			}

			function itemSelected(item, updateBoundProperty) {
				selectedItem = item;

				scope.setSearchText('');

				displaySelectedItem();

				applySearch();

				if (updateBoundProperty) {
					ignoreBoundObjectProperty();

					scope.bindToObject[scope.bindToProperty] = item;

					if (scope.watchBinding) {
						watchBoundObjectProperty();
					}

					if (util.isFunction(scope.onChangeAccessor)) {
						var onChangeAccessor = scope.onChangeAccessor();

						if (util.isFunction(onChangeAccessor)) {
							onChangeAccessor(item);
						}
					}
				}
			}

			function isSelected(item) {
				if (util.isFunction(scope.itemCompare)) {
					var itemCompare = scope.itemCompare();

					if (util.isFunction(itemCompare)) {
						return itemCompare(item, vm.selectedItem, displaySelectedItem);
					}
				}

				return util.isDefined(vm.selectedItem) && util.isRealObject(vm.selectedItem) && _.isMatch(item, vm.selectedItem);
			}
		}

		return DiSelectController;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAC0F}
// di.core.angular.controls.select
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;
		var guard = $di.exception.guard;

		module.directive('diSelect', diSelect);

		diSelect.$inject = ['$interpolate', 'translator', '$q'];

		/**
   * Select directive. Functions in three modes depending on 'mode' attribute:
   * autoComplete, dropdown, dropdownSearch
   */
		function diSelect($interpolate, translator, $q) {
			return {
				restrict: 'E',
				replace: true,
				transclude: true,
				scope: {
					bindToObject: '=',
					bindToProperty: '@',
					watchIncludeDefaultObj: '=', //default:false
					onChangeAccessor: '&',
					items: '=',
					validationModel: '=',
					confirm: '=',
					selectSingle: '=',
					itemCompare: '&',
					onItemSelectFunction: '@'
				},
				controller: 'DiSelectController',
				controllerAs: 'selectCtrl',
				link: link,
				template: template
			};

			function link(scope, element, attrs) {
				scope.inputClass = interpolate('inputClass');
				scope.watchItems = interpolate('watchItems', 'false') === 'true';
				scope.watchBinding = interpolate('watchBinding', 'false') === 'true';
				scope.tabIndex = interpolate('tabIndex');
				scope.searchableProperties = interpolate('searchableProperties');

				interpolateAndTranslate('placeholder').then(function (t) {
					scope.placeholder = t;
				});

				scope.displayProperty = interpolate('displayProperty');
				scope.validationName = interpolate('validationName');

				interpolateAndTranslate('validationMessage').then(function (t) {
					scope.validationMessage = t;
				});

				scope.image = interpolate('image');
				scope.imageColour = interpolate('imageColour');
				scope.searchImage = interpolate('searchImage');
				scope.searchImageColour = interpolate('searchImageColour');
				scope.mode = interpolate('mode');
				scope.confirmTitle = interpolate('confirmTitle');
				scope.confirmMessage = interpolate('confirmMessage');
				scope.confirmOkBtnText = interpolate('confirmOkBtnText');
				scope.confirmCancelBtnText = interpolate('confirmCancelBtnText');
				scope.allowEmptyDisplay = interpolate('allowEmptyDisplay', 'false') === 'true';

				var listElm = element.find('#list');
				var searchTextInputElm = element.find('#diSelectSearchTextInput');
				var displayPropertyInputElm = element.find('#diSelectDisplayPropertyInput');
				var focusElm;
				var inputNeedsFocus;
				var hasSearchText;

				switch (attrs.mode) {
					case 'autoComplete':
						focusElm = displayPropertyInputElm;
						displayPropertyInputElm = searchTextInputElm;
						inputNeedsFocus = true;
						hasSearchText = true;
						break;

					case 'dropdown':
						focusElm = displayPropertyInputElm;
						inputNeedsFocus = true;
						hasSearchText = false;
						break;

					case 'dropdownSearch':
						focusElm = searchTextInputElm;
						inputNeedsFocus = true;
						hasSearchText = true;
						break;
				}

				listElm.removeAttr('id');
				searchTextInputElm.removeAttr('id');

				displayPropertyInputElm.removeAttr('id');

				if (inputNeedsFocus) {
					scope.onShow = function () {
						scope.$evalAsync(function () {
							focusElm.focus();
						});
					};
				}

				if (hasSearchText) {
					searchTextInputElm.on('input', function () {
						scope.onSearchTextChange();
					});
				}

				scope.getSearchText = function () {
					if (hasSearchText) {
						return searchTextInputElm.val();
					} else {
						return '';
					}
				};

				scope.copySearchValue = function () {};

				scope.setSearchText = function (searchText) {
					if (hasSearchText) {
						searchTextInputElm.val(searchText);
					}
				};

				scope.setDisplayText = function (displayText) {
					displayPropertyInputElm.val(displayText);
				};

				scope.highlightItem = function (index) {
					var itemInputElm = listElm.find('.itemInput_' + index);
					var itemSpanElms = listElm.find('span');
					var itemSpanElm = listElm.find('.itemSpan_' + index);

					itemSpanElms.removeClass('highlighted');
					itemSpanElm.addClass('highlighted');
					itemInputElm.show();
					itemInputElm.focus();
					searchTextInputElm.focus();
					itemInputElm.hide();
				};

				return;

				function interpolateAndTranslate(attr, valueIfEmpty) {
					var value = interpolate(attr, valueIfEmpty);

					if (value) {
						return translator.translate(value);
					}

					return $q.when(value);
				}

				function interpolate(attr, valueIfEmpty) {
					var value = attrs[attr];
					var result = (value ? $interpolate(value)(scope) : '') || valueIfEmpty;

					return result;
				}
			}

			function template(element, attrs) {
				var html = '';
				var autoCompleteModeHtml = '<div\
	valdr-enabled="true"\
	validation-notification-target\
	class="form-row di-select-auto">\
	<di-toggle\
		close-target-on-click-away\
		close-target-on-click\
		actions-hook="selectCtrl.toggleActions"\
		wrap-class="select"\
		toggle-class="is-active">\
		<input\
			di-toggle-trigger\
			tabindex="0"\
			style="width:100%;"\
			validation-focus-target\
			class="select-label input"\
			ng-keyup="selectCtrl.inputKeyUp($event)"\
			{SEARCH_INPUT_ATTRS}/>\
		<div\
			di-toggle-target\
			class="select-dropdown">\
			{LIST}\
		</div>\
	</di-toggle>\
</div>';

				var dropdownModeHtml = '<div\
	validation-notification-target\
	class="form-row">\
	<di-toggle\
		close-target-on-click-away\
		close-target-on-click\
		on-show="onShow"\
		on-hide="onHide"\
		actions-hook="selectCtrl.toggleActions"\
		wrap-class="select {HAS_IMAGE}"\
		toggle-class="is-active">\
		<div\
			di-toggle-trigger\
			tabindex="0"\
			class="select-label">\
				{IMAGE}\
			<input\
				tabindex="-1"\
				id="diSelectDisplayPropertyInput"\
				validation-focus-target\
				class="select-label-value"\
				ng-keyup="selectCtrl.inputKeypress($event)"\
				readonly/>\
			<button\
				tabindex="-1"\
				class="select-button"\
				type="button"\
			</button>\
		</div>\
		<div\
			di-toggle-target\
			class="select-dropdown">\
			{LIST}\
		</div>\
	</di-toggle>\
</div>';

				var dropdownSearchModeHtml = '<div\
	validation-notification-target\
	class="form-row">\
	<di-toggle\
		close-target-on-click-away\
		close-target-on-click\
		actions-hook="selectCtrl.toggleActions"\
		on-show="onShow"\
		wrap-class="select has-search"\
		toggle-class="is-active">\
		<div\
			di-toggle-trigger\
			tabindex="0"\
			class="select-label">\
			<input\
				tabindex="-1"\
				class="select-label-value"\
				id="diSelectDisplayPropertyInput"\
				readonly/>\
			<button\
				tabindex="-1"\
				class="select-button"\
				type="button"\
			</button>\
		</div>\
		<div\
			di-toggle-target\
			class="select-dropdown">\
			<div\
				class="select-search input-iconed">\
				<input\
					di-toggle-ignore\
					id="diSelectSearchTextInput"\
					validation-focus-target\
					type="search"\
					class="input small rounded dimmed"\
					{SEARCH_INPUT_ATTRS}/>\
				<di-image\
					class="icon icon-16px"\
					image="{SEARCH_IMAGE}"\
					image-colour="{SEARCH_IMAGE_COLOUR}"></di-image>\
			</div>\
				{LIST}\
		</div>\
	</di-toggle>\
</div>';

				var trackBy = attrs.itemUniqueProperty ? ' track by ' + attrs.itemUniqueProperty : '';
				var listHtml = '<div\
					id="list"\
					class="select-list">\
					<span\
						ng-repeat="filteredItem in selectCtrl.filteredItems"' + trackBy + '\
						class="select-item">\
						<input\
							type="text"\
							style="display:none;height:1px;width:1px;border:0;margin:0;padding:0;"\
							ng-keydown="selectCtrl.inputKeypress($event)"\
							class="itemInput_{{::filteredItem.index}}">\
						<span\
							class="itemSpan_{{::filteredItem.index}}"\
							ng-class="{\'is-selected\' : selectCtrl.isSelected(filteredItem.item)}"\
							ng-click="selectCtrl.onItemSelected(filteredItem.item)"\
							di-transclude-repeat>\
						</span>\
					</span>\
				</div>';

				switch (attrs.mode) {
					case 'autoComplete':
						html = autoCompleteModeHtml;
						break;

					case 'dropdown':
						html = dropdownModeHtml;
						break;

					case 'dropdownSearch':
						html = dropdownSearchModeHtml;
						break;

					default:
						guard.throwNew("CAC0F01E", "Unknown di-select mode '" + attrs.mode + "'");
				}

				var searchInputAttrs = 'id="diSelectSearchTextInput"\
					ng-keydown="selectCtrl.inputKeypress($event)"\
					placeholder="{{::(placeholder)}}"';

				if (attrs.validationName) {
					searchInputAttrs += '\
						di-validate="{{::validationName}}"\
						validation-model="bindToObject[bindToProperty]"\
						validation-model-display-name="' + attrs.validationModelDisplayName + '"';
				}

				var imageHtml = '<di-image\
						class="select-label-icon"\
						image="{IMAGE}"\
						image-colour="{IMAGE_COLOUR}">\
					</di-image>';

				if (util.isUndefined(attrs.image)) {
					imageHtml = '';
					html = html.replace('{HAS_IMAGE}', '');
				} else {
					html = html.replace('{HAS_IMAGE}', 'has-icon');
				}

				imageHtml = imageHtml.replace('{IMAGE}', attrs.image || 'sort');
				imageHtml = imageHtml.replace('{IMAGE_COLOUR}', attrs.imageColour || 'button');

				html = html.replace('{SEARCH_INPUT_ATTRS}', searchInputAttrs);
				html = html.replace('{LIST}', listHtml);
				html = html.replace('{IMAGE}', imageHtml);

				html = html.replace('{SEARCH_IMAGE}', attrs.searchImage || 'search');
				html = html.replace('{SEARCH_IMAGE_COLOUR}', attrs.searchImageColour || 'icon');

				return html;
			}
		}

		return diSelect;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:ACG05}
// di.core.angular.controls.diSelectUpgrade
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.directive('diSelectUpgrade', diSelectUpgrade);

        function diSelectUpgrade() {
            return {
                restrict: 'E',
                translucent: true,
                scope: {
                    items: '=',
                    bindToObject: '=',
                    bindToProperty: '@',
                    onChangeAccessor: '&'
                },
                controller: 'DiSelectUpgradeController',
                controllerAs: 'diSelectUpgradeCtrl',
                template: template()
            };

            function template() {

                var html = '<div class="show-entries select small"><di-select\
                        mode="dropdown"\
                        items="diSelectUpgradeCtrl.items"\
	                    item-unique-property="value"\
                        bind-to-object="diSelectUpgradeCtrl"\
	                    bind-to-property="selectedItem"\
	                    display-property="label"\
	                    on-change-accessor="diSelectUpgradeCtrl.onChangeAccessor"\
                        placeholder="{{show}}">\
                        <span>{{::filteredItem.item.value}}</span>\
                    </di-select></div>';

                return html;
            }
        }

        return diSelectUpgrade;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:ACG06}
// di.core.angular.controls.diSelectUpgradeController
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var util = $di.utility.util;

        module.controller('DiSelectUpgradeController', DiSelectUpgradeController);

        DiSelectUpgradeController.$inject = ['$scope', 'translator'];

        function DiSelectUpgradeController(scope, translator) {
            var vm = this;

            vm.items = [];
            vm.selectedItem = {};
            vm.keepWatch = "true";

            watchItems();

            return;

            function watchItems() {
                var unwatch = function unwatch() {};
                var loaded = false;

                if (vm.keepWatch === "false") {
                    unwatch = scope.$watch(watchExpression, initialiseOnce);
                } else {
                    scope.$watchCollection('items', initialise);
                }

                return;

                function watchExpression() {
                    loaded = scope.items.length > 0;
                    return scope.items.length;
                }

                function initialiseOnce() {
                    if (loaded) {
                        unwatch();
                        initialise();
                    }
                }
            }

            function initialise() {
                translator.translate("CORE.GRID_PAGINATION_PAGE_SIZE.SHOW").then(function (translated) {
                    scope.show = translated;
                });

                vm.items.diFill(scope.items);
                vm.onChangeAccessor = onChangeAccessor;
            }

            function onChangeAccessor(value) {
                if (scope.onChangeAccessor) {
                    scope.onChangeAccessor(value);
                }
            }
        };

        return DiSelectUpgradeController;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:ACS01}
// di.core.angular.controls.simpleselect
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(193), __webpack_require__(192)], __WEBPACK_AMD_DEFINE_RESULT__ = function (diSimpleSelectDirectiveLoader, diSimpleSelectControllerLoader) {
    'use strict';

    return function (module) {
        diSimpleSelectDirectiveLoader(module);
        diSimpleSelectControllerLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:ACS02}
// di.core.angular.controls.simpleselect
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var ngUtil = $di.angular.util;
		var util = $di.utility.util;

		module.controller('DiSimpleSelectController', DiSimpleSelectController);

		DiSimpleSelectController.$inject = ['$scope', 'translator'];

		function DiSimpleSelectController(scope, translator) {
			var vm = this;

			vm.item = {};

			vm.onChangeAccessor = onChangeAccessor;

			vm.bindToObject = scope.bindToObject;

			initialize();

			return;

			/**
             * Event when selected option is changed.
             * @param {} option 
             * @returns {} 
             */
			function onChangeAccessor(option) {
				if (scope.onChanged) {
					scope.onChanged(option.value);
				}
			}

			/**
    * Translate labels collection using translator service.
    * @param filters
    */
			function translateFilterLabels(filters) {
				return translator.whenReady().then(function () {
					_.each(filters, function (filter) {
						filter.label = translator.instantTranslate(filter.label);
					});
				});
			}

			/**
    * Sets default item when options are loaded.
    * @returns {} 
    */
			function initialize() {
				var unwatch = ngUtil.$watchCollection(scope, 'items', function (items) {
					if (items) {
						vm.items = items;
						translateFilterLabels(vm.items).then(function () {
							var item = _.find(vm.items, function (option) {
								return option.value === scope.defaultValue;
							});

							if (util.isDefined(item)) {
								vm.item = item;
							} else {
								vm.item = items[0];
							}

							//unwatch();
						});
					}
				});
			}
		}

		return DiSimpleSelectController;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:ACS03}
// di.core.angular.controls.simpleselect
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.directive('diSimpleSelect', diSimpleSelect);

		function diSimpleSelect() {
			return {
				restrict: 'E',
				replace: true,
				scope: {
					items: '=',
					defaultValue: '=',
					onChanged: "=",
					bindToObject: '=',
					bindToProperty: '@',
					watchBinding: '='
				},
				controller: "DiSimpleSelectController",
				controllerAs: "diSimpleSelectCtrl",
				template: template
			};

			function template(element, attrs) {
				var html = '<div class="select">\
                                <di-select\
                                    mode="dropdown"\
                                    image="{ICON}"\
                                    image-colour="button"\
                                    items="diSimpleSelectCtrl.items"\
                                    item-unique-property="value"\
                                    {BIND_OBJECT}\
									bind-to-property="{BIND_PROPERTY}"\
									display-property="label"\
                                    {WATCH_INC_DEFAULT}\
									watch-binding="{WATCH_BINDING}"\
									on-change-accessor="diSimpleSelectCtrl.onChangeAccessor">\
                                    {{::filteredItem.item.label}}\
                                </di-select>\
                             </div>';

				html = html.replace('{ICON}', attrs.icon || 'sort');

				if (attrs.bindToObject) {
					html = html.replace('{BIND_OBJECT}', 'bind-to-object="diSimpleSelectCtrl.bindToObject"');
					html = html.replace('{WATCH_INC_DEFAULT}', 'watch-include-default-obj="true"');
					html = html.replace('{WATCH_BINDING}', attrs.watchBinding || 'false');
				} else {
					html = html.replace('{BIND_OBJECT}', 'bind-to-object="diSimpleSelectCtrl"');
					html = html.replace('{WATCH_INC_DEFAULT}', '');
					html = html.replace('{WATCH_BINDING}', 'false');
				}

				html = html.replace('{BIND_PROPERTY}', attrs.bindToProperty || 'item');

				return html;
			}
		}

		return diSimpleSelect;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAC0H}
// di.core.angular.controls.spinner
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(196), __webpack_require__(195)], __WEBPACK_AMD_DEFINE_RESULT__ = function (spinnerGeneratorLoader, modalSpinnerLoader) {
	'use strict';

	return function (module) {
		spinnerGeneratorLoader(module);
		modalSpinnerLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAC0D}
// di.core.angular.controls.spinner
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ng) {
	'use strict';

	return function (module) {
		module.factory('modalSpinner', modalSpinner);

		modalSpinner.$inject = ['spinnerGenerator'];

		function modalSpinner(spinnerGenerator) {

			var modalSpinnerClass = 'modal-spinner';

			return {
				showModalSpinner: showModalSpinner
			};

			/**
    * Places a spinner as a child of the specified element			 
    */
			function showModalSpinner(key, spinnerOptions) {
				var options;
				var modalElement = '<div class="' + modalSpinnerClass + '"></div>';
				var spinner;

				if (key === undefined) {
					key = "body";
				}

				ng.element(key).prepend(modalElement);

				spinnerOptions = spinnerOptions || {};
				options = ng.extend({}, { color: '#FFF', position: 'fixed' }, spinnerOptions);

				spinner = spinnerGenerator.generateNewSpinner(options).spin();
				ng.element(key).children('.' + modalSpinnerClass).append(spinner.el);

				return {
					remove: remove
				};

				/**
     * Function to remove the spinner in an animated way
     */
				function remove() {
					var elementToRemove = ng.element(key).children('.' + modalSpinnerClass);
					elementToRemove.fadeOut(300, function () {
						elementToRemove.remove();
					});
				}
			}
		}

		return modalSpinner;
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAC0C}
// di.core.angular.controls.spinner
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(43)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Spinner) {
	'use strict';

	return function (module) {
		module.factory('spinnerGenerator', spinnerGenerator);

		function spinnerGenerator() {

			return {
				generateNewSpinner: generateNewSpinner
			};

			/**
    * Generates a new spinnerGenerator
    * @param spinnerGeneratorOptions
    */
			function generateNewSpinner(spinnerOptions) {
				return new Spinner(spinnerOptions);
			}
		}

		return spinnerGenerator;
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAC07}
// di.core.angular.controls.toggle
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(198), __webpack_require__(199), __webpack_require__(200)], __WEBPACK_AMD_DEFINE_RESULT__ = function (toggleControllerLoader, toggleDirectiveLoader, overrideToggleFactory) {
    'use strict';

    return function (module) {
        toggleControllerLoader(module);
        toggleDirectiveLoader(module);
        overrideToggleFactory(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAC0R}
// di.core.angular.controls.toggle
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.controller('DiToggleController', DiToggleController);

        DiToggleController.$inject = ['$scope', '$timeout'];

        function DiToggleController(scope, $timeout) {
            var vm = this;

            vm.toggle = toggle;
            vm.show = show;
            vm.hide = hide;

            if (scope.actionsHook) {
                scope.actionsHook.toggle = vm.toggle;
                scope.actionsHook.show = vm.show;
                scope.actionsHook.hide = vm.hide;
            }

            return;

            function toggle() {
                if (scope.controlState && scope.controlState.disabled) return;

                if (scope.isVisible()) {
                    hide();
                } else {
                    show();
                }

                whenDigestComplete(scope.onToggle);
            }

            function show() {
                scope.setVisible(true);

                whenDigestComplete(scope.onShow);
            }

            function hide() {
                if (shouldOverrideToggleHide()) {
                    return;
                }

                scope.setVisible(false);

                whenDigestComplete(scope.onHide);
            }

            function whenDigestComplete(func) {
                if (func) {
                    var innerFunc = func();

                    if (innerFunc) {
                        $timeout(innerFunc);
                    }
                }
            }

            /**
            * Checks if any overrides should prevent a "toggle hide" i.e datepicker open
            */
            function shouldOverrideToggleHide() {
                if (scope.shouldOverrideToggleHide) {
                    return scope.shouldOverrideToggleHide();
                }

                return false;
            }
        }

        return DiToggleController;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAC0S}
// di.core.angular.controls.toggle
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ng) {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.directive('diToggle', diToggle);

		diToggle.$inject = ['$compile', 'uniqueIdGenerator', 'overrideToggleFactory'];

		function diToggle($compile, uniqueIdGenerator, overrideToggleFactory) {
			return {
				restrict: 'E',
				replace: true,
				transclude: true,
				template: '<div>\
    <di-transclude-replace></di-transclude-replace>\
</div>',
				controller: 'DiToggleController',
				controllerAs: 'diToggleCtrl',
				scope: {
					wrapClass: '@',
					toggleClass: '@',
					onShow: '&',
					onHide: '&',
					onToggle: '&',
					actionsHook: '=',
					adjustPosition: '='
				},
				link: link
			};

			function link(scope, element, attrs) {
				var newScope = scope.$new();

				scope.$on('$destroy', function () {
					newScope.$destroy();
				});

				scope.shouldOverrideToggleHide = overrideToggleFactory.shouldOverrideToggleHide;

				var parentElm = ng.element(element);
				var triggerElms = findByAttrAndRemove(parentElm, 'di-toggle-trigger');
				var targetElms = findByAttrAndRemove(parentElm, 'di-toggle-target');
				var ignoreElms = findByAttrAndRemove(parentElm, 'di-toggle-ignore');
				var ignoreClass = uniqueIdGenerator.newId('toggle_click_away_ignore');
				var adjustPosition = true;

				if (scope.adjustPosition === false) {
					adjustPosition = false;
				}

				scope.isVisible = function () {
					return parentElm.hasClass(scope.toggleClass);
				};

				scope.setVisible = function (visible) {
					if (visible) {
						parentElm.addClass(scope.toggleClass);
						if (adjustPosition) {
							moveUp(triggerElms[0], targetElms[0]);
						}
					} else {
						parentElm.removeClass(scope.toggleClass);
					}
				};

				parentElm.addClass(scope.wrapClass);

				triggerElms.attr('di-click', 'diToggleCtrl.toggle()');

				//click and enter should have the same outcome
				if (!triggerElms.is("a, button, details, embed, iframe, keygen, label, select, textarea, " //element is not natively interactive
				+ "audio[controls], img[usemap], input[type!='hidden'], menu[type='toolbar'], object[usemap], video[controls]") && !triggerElms.is("[tabindex^='-']") //and does not have a negative tabindex
				&& !triggerElms.is("[disabled]")) //and is not disabled
					{
						triggerElms.attr('ng-keyup', '$event.keyCode == 13 ? [diToggleCtrl.toggle(), $event.stopPropagation(), $event.preventDefault()] : undefined');
					}

				triggerElms.addClass(ignoreClass);

				if (util.isDefined(attrs.closeTargetOnClickAway)) {
					triggerElms.attr('di-click-away', 'diToggleCtrl.hide()');
					triggerElms.attr('di-click-away-ignore', ignoreClass);

					ignoreElms.addClass(ignoreClass);

					if (util.isUndefined(attrs.closeTargetOnClick)) {
						targetElms.addClass(ignoreClass);
					}
				} else {
					if (util.isDefined(attrs.closeTargetOnClick)) {
						targetElms.attr('ng-click', 'diToggleCtrl.hide()');
					}
				}

				$compile(triggerElms)(newScope);

				return;

				function findByAttrAndRemove(parent, attr) {
					var elms = parent.find('[' + attr + ']');

					elms.removeAttr(attr);

					return elms;
				}

				/**
                 * moves panel above field if not visible
                 * @param {} field 
                 * @param {} panel                 
                 */
				function moveUp(field, panel) {
					var pEl = field,
					    fieldBottom,
					    panelTop;

					var viewportHeight = window.innerHeight || document.documentElement.clientHeight;
					var scrollTop = window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop;

					if (util.isFunction(field.getBoundingClientRect)) {
						var clientRect = field.getBoundingClientRect();

						fieldBottom = clientRect.bottom + window.pageYOffset;
					} else {
						fieldBottom = pEl.offsetTop + pEl.offsetHeight;

						while (pEl = pEl.offsetParent) {
							fieldBottom += pEl.offsetTop;
						}
					}

					var panelHeight = getHeight(panel);

					if (fieldBottom + panelHeight > viewportHeight + scrollTop) {
						var margin = getTopMargin(panel);

						var newPanelTop = fieldBottom - getHeight(field) - panelHeight - margin;

						panelTop = 0 - panelHeight - margin * 2;

						if (newPanelTop - scrollTop > 0) {
							panel.style.top = panelTop + 'px';
						} else {
							panel.style.top = '';
						}
					} else {
						panel.style.top = '';
					}

					return;

					/**
                     * gets top margin value of the element
                     * @param {} elm                  
                     */
					function getTopMargin(elm) {
						var current = ng.element(elm);

						return parseInt(current.css("marginTop"));
					}

					/**
                     * gets height of the element
                     * @param {} elm                 
                     */
					function getHeight(elm) {
						var current = ng.element(elm);

						return current.outerHeight();
					}
				}
			}
		}

		return diToggle;
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAC14}
// di.core.angular.controls.toggle
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ng) {
    'use strict';

    return function (module) {

        module.factory('overrideToggleFactory', overrideToggleFactory);

        function overrideToggleFactory() {
            return {
                shouldOverrideToggleHide: shouldOverrideToggleHide
            };

            /**
            * Checks if the 'pikaDay' datepicker is visible -  used for custom date selection
            */
            function shouldOverrideToggleHide() {
                var pikadayDivs = ng.element(document).find(document.querySelectorAll('.pika-single'));

                for (var i = 0; i < pikadayDivs.length; i++) {

                    if (ng.element(pikadayDivs[i]).hasClass('is-hidden') === false) {
                        return true;
                    }
                }
                return false;
            }
        }

        return overrideToggleFactory;
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAN02}
// di.core.angular
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(203), __webpack_require__(202)], __WEBPACK_AMD_DEFINE_RESULT__ = function (currencyFilterLoader, currencyCacheLoader) {
    'use strict';

    return function (module) {
        currencyFilterLoader(module);
        currencyCacheLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP1X}
// di.core.angular.currency
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_) {
	'use strict';

	return function (module) {
		module.factory('currencyCache', currencyCache);

		currencyCache.$inject = ['$sce', 'translator', 'staticLookupProxy', 'sessionStore', '$q'];

		function currencyCache(sce, translator, staticLookup, sessionStore, q) {
			var currencies = null;
			var util = $di.utility.util;
			var sessionStorageKey = 'Currency';
			var sessionStoragePrefix = 'currencyStore';

			return {
				getCurrencies: getCurrencies,
				getCurrencyByIsoCode: getCurrencyByIsoCode,
				getCurrencyById: getCurrencyById
			};

			/**
    * Gets all available currencies defined in the system.
    */
			function getCurrencies() {
				var defer = q.defer();

				if (!util.isNullOrUndefined(currencies)) {
					defer.resolve(currencies);
					return defer.promise;
				}

				var currenciesFromStore = getCurrenciesFromStore();
				if (!util.isNullOrUndefined(currenciesFromStore)) {
					defer.resolve(currenciesFromStore);
					return defer.promise;
				}

				var promise = staticLookup.get('Currency').then(success);

				return promise;

				function success(data) {
					currencies = data;

					_.each(currencies, function (currency) {
						currency.label = sce.trustAsHtml("<i></i> " + "<b>" + currency.symbol + "</b> " + currency.name);
						currency.value = currency.code;
					});

					currencies = _.sortBy(currencies, function (currency) {
						return currency.name;
					});

					sessionStore.set(sessionStorageKey, currencies, sessionStoragePrefix);

					return currencies;
				}
			}

			function getCurrenciesFromStore() {
				var sessionCurrency = sessionStore.get(sessionStorageKey, sessionStoragePrefix);

				return sessionCurrency;
			}

			/**
    * Gets currency by its ISO code.
    * @param isoCode
    */
			function getCurrencyByIsoCode(isoCode) {

				if (typeof currencies == 'undefined' || currencies == null) {
					currencies = getCurrenciesFromStore();
				}

				return _.find(currencies, function (currency) {
					return isoCode === currency.value;
				});
			}

			/**
    * Gets currency by its database Id field.
    * @param id
    */
			function getCurrencyById(id) {

				if (typeof currencies == 'undefined' || currencies == null) {
					currencies = getCurrenciesFromStore();
				}

				return _.find(currencies, function (currency) {
					return id === currency.id;
				});
			}
		}

		return currencyCache;
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP2T}
// di.core.angular.currency
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var util = $di.utility.util;

        module.filter('diCurrency', diCurrencyFilter);

        diCurrencyFilter.$inject = ['$filter', 'currencyCache'];

        function diCurrencyFilter(filter, currencyCache) {
            function getCurrency(val, currencyId) {
                if (util.isNullOrUndefined(currencyId)) {
                    return filter('number')(val, 2);
                }

                var currency = currencyCache.getCurrencyById(currencyId);

                if (util.isNullOrUndefined(currency)) {
                    if (val < 0) {
                        return "(" + filter('currency')(Math.abs(val), 2) + ")";
                    }
                    return filter('number')(val, 2);
                } else {
                    if (val < 0) {
                        return "(" + filter('currency')(Math.abs(val), currency.symbol, currency.digitsAfterDecimal) + ")";
                    }
                    return filter('currency')(val, currency.symbol, currency.digitsAfterDecimal);
                }
            };

            return getCurrency;
        }

        return diCurrencyFilter;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAD01}
// di.core.angular.date
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(205), __webpack_require__(206), __webpack_require__(207)], __WEBPACK_AMD_DEFINE_RESULT__ = function (diDateFilter, diDateFormats, diMoment) {
	'use strict';

	return function (module) {
		diDateFilter(module);
		diDateFormats(module);
		diMoment(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAD02}
// di.core.angular.date
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5)], __WEBPACK_AMD_DEFINE_RESULT__ = function (moment) {
	'use strict';

	return function (module) {
		module.filter('diDate', diDate);

		diDate.$inject = ['translator', 'diMoment', 'DATE_FORMATS'];

		function diDate(translator, diMoment, dateFormats) {
			return function (input, format) {
				if (!input) {
					return translator.instantTranslate('CORE.DATE.NOT_SPECIFIED');
				}

				var momentValue;
				if (moment.isMoment(input) && input.isValid()) {
					momentValue = input;
				} else {
					momentValue = moment(new Date(input));
					if (!moment.isMoment(momentValue) || !momentValue.isValid()) {
						momentValue = diMoment(input);
					}
				}

				if (moment.isMoment(momentValue) && momentValue.isValid()) {
					return momentValue.format(format || dateFormats.supported[0]);
				} else {
					return translator.instantTranslate('CORE.DATE.NOT_SPECIFIED');
				}
			};
		}

		return diDate;
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF13}
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5)], __WEBPACK_AMD_DEFINE_RESULT__ = function (moment) {
	'use strict';

	return function (module) {
		module.constant('DATE_FORMATS', dateFormats());

		function dateFormats() {
			var supportedDateFormats = ["DD/MM/YYYY", moment.localeData().longDateFormat('L'), moment.localeData().longDateFormat('l'), moment.localeData().longDateFormat('LL'), moment.localeData().longDateFormat('ll'), moment.localeData().longDateFormat('LLL'), moment.localeData().longDateFormat('lll'), moment.localeData().longDateFormat('LLLL'), moment.localeData().longDateFormat('llll')].concat([moment.ISO_8601, "YYYY/MM/DD"]);

			return {
				supported: supportedDateFormats
			};
		}

		return dateFormats;
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF14}
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5)], __WEBPACK_AMD_DEFINE_RESULT__ = function (moment) {
	'use strict';

	return function (module) {
		module.factory('diMoment', diMoment);

		diMoment.$inject = ['DATE_FORMATS'];

		function diMoment(dateFormats) {
			return function (input) {

				var inputMoment = moment(input, dateFormats.supported, moment.locale(), true);

				return inputMoment;
			};
		}

		return diMoment;
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAE06}
// di.core.angular.exception
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.config(configureExceptionHandler);
        module.config(configureExceptionHttpInterceptor);

        configureExceptionHandler.$inject = ['$provide'];
        function configureExceptionHandler($provide) {
            $provide.decorator('$exceptionHandler', extendExceptionHandler);
        }

        extendExceptionHandler.$inject = ['$delegate', 'exceptionHandler'];
        function extendExceptionHandler(delegate, exceptionHandler) {
            return function (exception, cause) {
                delegate(exception, cause);

                exception.cause = cause;

                exceptionHandler.handleException(exception);
            };
        }

        configureExceptionHttpInterceptor.$inject = ['$httpProvider'];
        function configureExceptionHttpInterceptor($httpProvider) {
            $httpProvider.interceptors.push('exceptionHttpInterceptor');
        }
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAE03}
// di.core.angular.exception
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(208), __webpack_require__(210), __webpack_require__(211), __webpack_require__(212)], __WEBPACK_AMD_DEFINE_RESULT__ = function (configLoader, exceptionHandlerLoader, exceptionHttpInterceptorLoader, stackTraceLoader) {
    'use strict';

    return function (module) {
        exceptionHandlerLoader(module);
        exceptionHttpInterceptorLoader(module);
        stackTraceLoader(module);

        configLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAE01}
// di.core.angular.exception
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;

        module.provider('exceptionHandler', ExceptionHandlerProvider);

        /**
         * Handles exceptions
         */
        function ExceptionHandlerProvider() {
            var config = {
                appErrorPrefix: undefined,
                notify: true
            };

            var provider = {
                configure: configure,
                $get: $get
            };

            provider.$get.$inject = ['$log', 'loggerProxy', 'stackTrace'];

            return provider;

            /**
             * Configure the service
             * @param cfg
             */
            function configure(cfg) {
                guard.throwIfNotAnObject("CAE0101E", cfg, 'cfg');

                config = cfg;
            }

            function $get($log, loggerProxy, stackTraceService) {
                var logger = $di.debug.debugger.newLogger("Error");

                return {
                    handleException: handleException
                };

                /**
                 * Handles the given exception
                 * @param exception
                 */
                function handleException(exception) {
                    var appErrorPrefix = config.appErrorPrefix || '';

                    if (config.notify) {
                        try {
                            logger.log(exception.message);
                        } catch (ex) {
                            ex.source = "CAE0102E";

                            loggerProxy.error(ex);
                        }
                    }

                    try {
                        var loggedEx = new Error(appErrorPrefix + exception.message);

                        loggedEx.stackTrace = stackTraceService.print({ e: exception });

                        loggerProxy.error(loggedEx);
                    } catch (ex) {
                        ex.source = "CAE0103E";

                        $log.error('Error: ' + ex.message);
                    }
                }
            }
        }

        return ExceptionHandlerProvider;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAE05}
// di.core.angular.exception
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;

        module.factory('exceptionHttpInterceptor', exceptionHttpInterceptor);

        exceptionHttpInterceptor.$inject = ['exceptionHandler', '$q'];

        /**
         * Interceptor for catching http response errors
         */
        function exceptionHttpInterceptor(exceptionHandler, $q) {
            return {
                responseError: responseError
            };

            function responseError(httpResponse) {
                if (handleResponseError(httpResponse)) {
                    var exception = guard.getNewError("CAE0502E", "HTTP response error");

                    if (httpResponse.status) {
                        exception.cause = httpResponse.status + ': ' + httpResponse.config.url;
                    }

                    exceptionHandler.handleException(exception);
                }

                return $q.reject(httpResponse);
            }

            /**
             * Only handle/log exceptions that could not be anticipated
             * @param httpResponse
             */
            function handleResponseError(httpResponse) {
                if (httpResponse.status === 401) {
                    //Ignore '401 - Unauthorised'
                    return false;
                }

                if (httpResponse.status === 400 && httpResponse.data && httpResponse.data.error && httpResponse.data.error === "invalid_grant") {
                    //Ignore '400 - Bad Request' if failed login
                    return false;
                }

                return true;
            }
        }

        return exceptionHttpInterceptor;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAE02}
// di.core.angular.exception
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(33)], __WEBPACK_AMD_DEFINE_RESULT__ = function (stackTrace) {
    'use strict';

    return function (module) {
        module.factory('stackTrace', stackTraceFactory);

        /**
         * Produces better exception stack traces
         */
        function stackTraceFactory() {
            return {
                print: stackTrace
            };
        }

        return stackTraceFactory;
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAF01}
// di.core.angular.file
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(214)], __WEBPACK_AMD_DEFINE_RESULT__ = function (fileDownloaderLoader) {
    'use strict';

    return function (module) {
        fileDownloaderLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAF02}
// di.core.angular.file
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;

        module.provider('fileDownloader', FileDownloaderProvider);

        /**
         * 
         */
        function FileDownloaderProvider() {
            var config = {
                endpoint: 'webApi',
                tokenParameterName: 'access_token'
            };

            var provider = {
                configure: configure,
                $get: $get
            };

            provider.$get.$inject = ['endpoints', 'authenticationData', 'authenticationTicketValidator', 'urlHelper', '$window'];

            return provider;

            /**
             * Configure the service
             * @param cfg
             */
            function configure(cfg) {
                guard.throwIfNotAnObject("CAF0201E", cfg, "cfg");
                config = cfg;
            }

            function $get(endpoints, authenticationData, authenticationTicketValidator, urlHelper, $window) {
                return {
                    downloadFile: validateAuthenticationTicketAndDownloadFile
                };

                function validateAuthenticationTicketAndDownloadFile(relativeUrl) {
                    authenticationTicketValidator.validateTicket(true, downloadFile);

                    return;

                    function downloadFile() {
                        var url = endpoints.getUrl(relativeUrl, config.endpoint);

                        var token = authenticationData.authenticationTicket.token;

                        url = urlHelper.setParameter(url, config.tokenParameterName, token);

                        $window.open(url);
                    }
                }
            }
        }

        return FileDownloaderProvider;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAH02}
// di.core.angular.http
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(217), __webpack_require__(219), __webpack_require__(216), __webpack_require__(218)], __WEBPACK_AMD_DEFINE_RESULT__ = function (dHttpLoader, webApiHttpLoader, authHttpLoader, serverResponseHandlerLoader) {
    'use strict';

    return function (module) {
        dHttpLoader(module);
        webApiHttpLoader(module);
        authHttpLoader(module);
        serverResponseHandlerLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAH03}
// di.core.angular.http
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var guard = $di.exception.guard;

		module.factory('authHttp', authHttp);

		authHttp.$inject = ['dHttp', 'authenticationTicketValidator'];

		/**
   * wrapper for dHttp service adding token expiry verification		
   */
		function authHttp(dHttp, authenticationTicketValidator) {
			var service = {
				get: get,
				getWithHeaders: getWithHeaders,
				post: post,
				postWithHeaders: postWithHeaders,
				doDelete: doDelete,
				doDeleteWithHeaders: doDeleteWithHeaders
			};

			return service;

			/**
   * Make a get request to the given url and (optional) endpoint
   * @param relativeUrl
   * @param endpoint
   */
			function get(relativeUrl, endpoint) {
				guard.throwIfEmptyString("CAH0303E", relativeUrl, "relativeUrl");

				return authenticationTicketValidator.validateTicket(true, function () {
					return dHttp.get(relativeUrl, endpoint);
				});
			}

			/**
   * Make a post request to the given url and (optional) endpoint
   * @param relativeUrl
   * @param data
   * @param endpoint
   */
			function post(relativeUrl, data, endpoint) {
				guard.throwIfEmptyString("CAH0307E", relativeUrl, "relativeUrl");

				return authenticationTicketValidator.validateTicket(true, function () {
					return dHttp.post(relativeUrl, data, endpoint);
				});
			}

			/**
   * Make a delete request to the given url and (optional) endpoint
   * @param relativeUrl
   * @param data
   * @param endpoint
   */
			function doDelete(relativeUrl, data, endpoint) {
				guard.throwIfEmptyString("CAH030AE", relativeUrl, "relativeUrl");

				return authenticationTicketValidator.validateTicket(true, function () {
					return dHttp.doDelete(relativeUrl, data, endpoint);
				});
			}

			/**
   * Make a get request with headers to the given url and (optional) endpoint
   * @param relativeUrl
   * @param headers
   * @param endpoint
   */
			function getWithHeaders(relativeUrl, headers, endpoint) {
				guard.throwIfEmptyString("CAH0308E", relativeUrl, "relativeUrl");

				return authenticationTicketValidator.validateTicket(true, function () {
					return dHttp.getWithHeaders(relativeUrl, headers, endpoint);
				});
			}

			/**
   * Make a post request with headers to the given url and (optional) endpoint
   * @param relativeUrl
   * @param data
   * @param headers
   * @param endpoint
   */
			function postWithHeaders(relativeUrl, data, headers, endpoint) {
				guard.throwIfEmptyString("CAH0309E", relativeUrl, "relativeUrl");

				return authenticationTicketValidator.validateTicket(true, function () {
					return dHttp.postWithHeaders(relativeUrl, data, headers, endpoint);
				});
			}

			/**
   * Make a delete request with headers to the given url and (optional) endpoint
   * @param relativeUrl
   * @param data
   * @param headers
   * @param endpoint
   */
			function doDeleteWithHeaders(relativeUrl, data, headers, endpoint) {
				guard.throwIfEmptyString("CAH030BE", relativeUrl, "relativeUrl");

				return authenticationTicketValidator.validateTicket(true, function () {
					return dHttp.doDeleteWithHeaders(relativeUrl, data, headers, endpoint);
				});
			}
		}

		return authHttp;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAH03}
// di.core.angular.http
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;

        module.provider('dHttp', DHttpProvider);

        /**
         * An http service layer for communicating with named endpoints
         * Endpoints are defined during config with a baseUrl.
         * Requests can then be made using a relative url and the name of the
         * endpoint. If no endpoint name is given then the configured
         * defaultEndpoint is used.
         */
        function DHttpProvider() {
            var provider = {
                $get: $get
            };

            provider.$get.$inject = ['$http', '$q', 'authenticationClientEventSubscriber', 'endpoints'];

            return provider;

            function $get($http, $q, authenticationClientEventSubscriber, endpoints) {
                return {
                    get: get,
                    getWithHeaders: getWithHeaders,
                    post: post,
                    postWithHeaders: postWithHeaders,
                    doDelete: doDelete,
                    doDeleteWithHeaders: doDeleteWithHeaders
                };

                /**
                 * Make a get request to the given url and (optional) endpoint
                 * @param relativeUrl
                 * @param endpoint
                 */
                function get(relativeUrl, endpoint) {
                    guard.throwIfEmptyString("CAH0303E", relativeUrl, "relativeUrl");

                    var promise = makeRequest(endpoint, relativeUrl, 'GET');

                    return promise;
                }

                /**
                 * Make a post request to the given url and (optional) endpoint
                 * @param relativeUrl
                 * @param data
                 * @param endpoint
                 */
                function post(relativeUrl, data, endpoint) {
                    guard.throwIfEmptyString("CAH0307E", relativeUrl, "relativeUrl");

                    var promise = makeRequest(endpoint, relativeUrl, 'POST', data);

                    return promise;
                }

                /**
                    * Make a delete request to the given url and (optional) endpoint
                    * @param relativeUrl
                    * @param data
                    * @param endpoint
                    */
                function doDelete(relativeUrl, data, endpoint) {
                    guard.throwIfEmptyString("CAH030AE", relativeUrl, "relativeUrl");

                    var promise = makeRequest(endpoint, relativeUrl, 'DELETE', data);

                    return promise;
                }

                /**
                 * Make a get request with headers to the given url and (optional) endpoint
                 * @param relativeUrl
                 * @param headers
                 * @param endpoint
                 */
                function getWithHeaders(relativeUrl, headers, endpoint) {
                    guard.throwIfEmptyString("CAH0308E", relativeUrl, "relativeUrl");

                    var promise = makeRequest(endpoint, relativeUrl, 'GET', null, headers);

                    return promise;
                }

                /**
                 * Make a post request with headers to the given url and (optional) endpoint
                 * @param relativeUrl
                 * @param data
                 * @param headers
                 * @param endpoint
                 */
                function postWithHeaders(relativeUrl, data, headers, endpoint) {
                    guard.throwIfEmptyString("CAH0309E", relativeUrl, "relativeUrl");

                    var promise = makeRequest(endpoint, relativeUrl, 'POST', data, headers);

                    return promise;
                }

                /**
                    * Make a delete request with headers to the given url and (optional) endpoint
                    * @param relativeUrl
                    * @param data
                    * @param headers
                    * @param endpoint
                    */
                function doDeleteWithHeaders(relativeUrl, data, headers, endpoint) {
                    guard.throwIfEmptyString("CAH030BE", relativeUrl, "relativeUrl");

                    var promise = makeRequest(endpoint, relativeUrl, 'DELETE', data, headers);

                    return promise;
                }

                function makeRequest(endpoint, relativeUrl, method, data, headers) {
                    var url = endpoints.getUrl(relativeUrl, endpoint);

                    var config = {
                        url: url,
                        method: method
                    };

                    if (headers) {
                        config.headers = headers;
                    }

                    if (data) {
                        config.data = data;
                    }

                    var promise = $http(config);

                    var handledPromise = getHandledPromise(promise);

                    return handledPromise;
                }

                function getHandledPromise(promise) {
                    var handledPromise = promise.then(resolved, rejected);

                    function resolved(response) {
                        return response.data;
                    }

                    function rejected(response) {
                        return $q.reject({
                            response: response,
                            failureReason: getFailureReason()
                            /*
                                'ServerDown'
                                'Unauthorized'
                                'NotFound'
                                'Redirection'
                                'FailedLogin'
                                'ClientError'
                                'ServerError'
                                'UnknownError'
                            */
                        });

                        function getFailureReason() {
                            var failureReason;

                            switch (response.status) {
                                case -1:
                                case 0:
                                    failureReason = 'ServerDown';
                                    break;

                                case 401:
                                    failureReason = 'Unauthorized';

                                    authenticationClientEventSubscriber.server401(response.config.url);
                                    break;

                                case 404:
                                    failureReason = 'NotFound';
                                    break;

                                default:
                                    var statusPrefix = (response.status || 0).toString().substring(0, 1);

                                    switch (statusPrefix) {
                                        case "3":
                                            failureReason = 'Redirection';
                                            break;

                                        case "4":
                                            failureReason = 'ClientError';
                                            break;

                                        case "5":
                                            failureReason = 'ServerError';
                                            break;

                                        default:
                                            failureReason = 'UnknownError';
                                    }
                            }

                            return failureReason;
                        }
                    }

                    return handledPromise;
                }
            }
        }

        return DHttpProvider;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

// di.core.angular.http
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.factory('serverResponseHandler', serverResponseHandler);

		serverResponseHandler.$inject = ['$q'];

		/**
   * Server response handler		 
   * @returns
   */
		function serverResponseHandler(q) {
			var defaultErrorMessage = 'CORE.HTTP.DEFAULT_ERROR';

			return {
				handleServerResponsePromise: handleServerResponsePromise
			};

			/**
    * Handles the standard server response object by ensuring the request is marked as
    * successful and that error details have been provided.
    * If the request was successful then the response content is returned
    * @param promise
    */
			function handleServerResponsePromise(promise) {
				var newPromise = promise.then(success, failure);

				function success(responseObject) {
					if (!responseObject.success) {
						return q.reject({
							response: responseObject,
							failureReason: defaultErrorMessage
						});
					}

					return responseObject.responseContent;
				}

				function failure(rejectedPromise) {
					return q.reject(rejectedPromise);
				}

				return newPromise;
			}
		}

		return serverResponseHandler;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAH04}
// di.core.angular.http
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ng) {
	'use strict';

	return function (module) {
		var guard = $di.exception.guard;
		var util = $di.utility.util;

		module.provider('webApiHttp', WebApiHttpProvider);

		/**
   * An http service layer for communicating with a webAPI returning IServiceResponse objects
   * Requests are made using a relative url, via a default endpoint specified in the configuration
   */
		function WebApiHttpProvider() {
			var config = {
				endpointName: 'webApi'
			};

			var defaultHeaders = {
				accept: 'text/json; application/json'
			};

			var provider = {
				configure: configure,
				$get: $get
			};

			provider.$get.$inject = ['authHttp', 'serverResponseHandler'];

			return provider;

			/**
    * Configure the service
    * @param cfg
    */
			function configure(cfg) {
				guard.throwIfNotAnObject("CAH0405E", cfg, "cfg");
				config = cfg;
			}

			function $get(dHttp, serverResponseHandler) {
				return {
					get: get,
					getWithHeaders: getWithHeaders,
					post: post,
					postWithHeaders: postWithHeaders,
					doDelete: doDelete,
					doDeleteWithHeaders: doDeleteWithHeaders
				};

				/**
     * Make a get request to the given url
     * @param relativeUrl
     */
				function get(relativeUrl) {
					guard.throwIfEmptyString("CAH0401E", relativeUrl, "relativeUrl");

					var dHttpPromise = dHttp.getWithHeaders(relativeUrl, defaultHeaders, config.endpointName);
					var promise = serverResponseHandler.handleServerResponsePromise(dHttpPromise);

					return promise;
				}

				/**
     * Make a post request to the given url
     * @param relativeUrl
     * @param data
     */
				function post(relativeUrl, data) {
					guard.throwIfEmptyString("CAH0402E", relativeUrl, "relativeUrl");

					var dHttpPromise = dHttp.postWithHeaders(relativeUrl, data, defaultHeaders, config.endpointName);
					var promise = serverResponseHandler.handleServerResponsePromise(dHttpPromise);

					return promise;
				}

				/**
     * Make a delete request to the given url
     * @param relativeUrl
     * @param data
     */
				function doDelete(relativeUrl, data) {
					guard.throwIfEmptyString("CAH0406E", relativeUrl, "relativeUrl");

					var dHttpPromise = dHttp.doDeleteWithHeaders(relativeUrl, data, defaultHeaders, config.endpointName);
					var promise = serverResponseHandler.handleServerResponsePromise(dHttpPromise);

					return promise;
				}

				/**
     * Make a get request with headers to the given url
     * @param relativeUrl
     * @param headers
     */
				function getWithHeaders(relativeUrl, headers) {
					guard.throwIfEmptyString("CAH0403E", relativeUrl, "relativeUrl");

					var mergedHeaders = ng.extend({}, defaultHeaders, headers);

					var dHttpPromise = dHttp.getWithHeaders(relativeUrl, mergedHeaders, config.endpointName);
					var promise = serverResponseHandler.handleServerResponsePromise(dHttpPromise);

					return promise;
				}

				/**
     * Make a post request with headers to the given url
     * @param relativeUrl
     * @param data
     * @param headers
     */
				function postWithHeaders(relativeUrl, data, headers) {
					guard.throwIfEmptyString("CAH0404E", relativeUrl, "relativeUrl");

					var mergedHeaders = ng.extend({}, defaultHeaders, headers);

					var dHttpPromise = dHttp.postWithHeaders(relativeUrl, data, mergedHeaders, config.endpointName);
					var promise = serverResponseHandler.handleServerResponsePromise(dHttpPromise);

					return promise;
				}

				/**
     * Make a delete request with headers to the given url
     * @param relativeUrl
     * @param data
     * @param headers
     */
				function doDeleteWithHeaders(relativeUrl, data, headers) {
					guard.throwIfEmptyString("CAH0407E", relativeUrl, "relativeUrl");

					var mergedHeaders = ng.extend({}, defaultHeaders, headers);

					var dHttpPromise = dHttp.doDeleteWithHeaders(relativeUrl, data, mergedHeaders, config.endpointName);
					var promise = serverResponseHandler.handleServerResponsePromise(dHttpPromise);

					return promise;
				}
			}
		}

		return WebApiHttpProvider;
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAL02}
// di.core.angular.logging
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(221)], __WEBPACK_AMD_DEFINE_RESULT__ = function (loggerProxyLoader) {
    'use strict';

    return function (module) {
        loggerProxyLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAL04}
// di.core.angular.logging
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($) {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;

        module.provider('loggerProxy', LoggerProxyProvider);

        /**
         * Logger for posting log messages to the webAPI server
         */
        function LoggerProxyProvider() {
            var config = {
                endpoint: 'webApi',
                url: 'log',
                logInfoToServer: true,
                logWarningToServer: true,
                logErrorToServer: true
            };

            var provider = {
                configure: configure,
                $get: $get
            };

            provider.$get.$inject = ['$log', '$window', 'endpoints', 'authenticationData'];

            return provider;

            /**
             * Configure the service
             * @param cfg
             */
            function configure(cfg) {
                guard.throwIfNotAnObject("CAL0402E", cfg, "cfg");

                config = cfg;
            }

            function $get($log, window, endpoints, authenticationData) {
                var service = {
                    info: info,
                    warning: warning,
                    error: error,
                    log: log
                };

                return service;

                /**
                 * Log
                 * @param {} message 
                 * @returns {} 
                 */
                function log(message) {
                    $log.log(message);
                }

                /**
                 * Log information
                 * @param source
                 * @param message
                 */
                function info(source, message) {
                    $log.info('Info: ' + message);

                    if (config.logInfoToServer) {
                        sendToServer({
                            source: source,
                            severity: 'Info',
                            message: message,
                            exception: null
                        });
                    }
                }

                /**
                 * Log warning
                 * @param source
                 * @param message
                 */
                function warning(source, message) {
                    $log.warn('Warning: ' + message);

                    if (config.logWarningToServer) {
                        sendToServer({
                            source: source,
                            severity: 'Warning',
                            message: message,
                            exception: null
                        });
                    }
                }

                /**
                 * Log error
                 * @param exception
                 */
                function error(exception) {
                    $log.error('Error: ' + exception.message + '. Cause: ' + (exception.cause || '') + '. StackTrace: ' + (exception.stackTrace || ''));

                    if (config.logErrorToServer) {
                        sendToServer({
                            source: exception.source,
                            severity: 'Error',
                            message: exception.message,
                            exception: exception
                        });
                    }
                }

                function sendToServer(logEntry) {

                    $.ajax({
                        type: 'POST',
                        url: endpoints.getUrl(config.url, config.endpoint),
                        contentType: 'application/json',
                        data: JSON.stringify({
                            currentUrl: window.location.href,
                            userId: authenticationData.userData.userId || 0,
                            source: logEntry.source || '',
                            severity: logEntry.severity || 'log',
                            message: logEntry.message,
                            exception: logEntry.exception || null
                        })
                    });
                }
            }
        }

        return LoggerProxyProvider;
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAS04}
// di.core.angular.session
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(223)], __WEBPACK_AMD_DEFINE_RESULT__ = function (sessionStoreLoader) {
    'use strict';

    return function (module) {
        sessionStoreLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAS05}
// di.core.angular.session
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;
        var util = $di.utility.util;

        module.provider('sessionStore', SessionStoreProvider);

        /**
         * Stores data in local storage or cookies
         */
        function SessionStoreProvider() {
            var config = {};

            var provider = {
                configure: configure,
                $get: $get
            };

            provider.$get.$inject = ['localStorageService'];

            return provider;

            /**
             * Configure the service
             * @param cfg
             */
            function configure(cfg) {
                guard.throwIfNotAnObject("CAS0501E", cfg, "cfg");

                config = cfg;
            }

            function $get(localStorage) {
                var items = {};

                var service = {
                    get: get,
                    set: set,
                    remove: remove
                };

                return service;

                /**
                 * Get data from storage
                 * @param key
                 * @param prefix
                 */
                function get(key, prefix) {
                    var fullKey = generateKey(key, prefix);
                    var item = items[fullKey];

                    if (util.isNullOrUndefined(item)) {
                        item = localStorage.get(fullKey);
                    }

                    return item;
                }

                /**
                 * Put data to storage
                 * @param key
                 * @param value
                 * @param prefix
                 */
                function set(key, value, prefix) {
                    var fullKey = generateKey(key, prefix);

                    items[fullKey] = value;
                    localStorage.set(fullKey, value);
                }

                /**
                 * Remove data from storage
                 * @param key
                 * @param prefix
                 */
                function remove(key, prefix) {
                    var fullKey = generateKey(key, prefix);

                    items[fullKey] = null;
                    localStorage.remove(fullKey);
                }

                function generateKey(key, prefix) {
                    guard.throwIfEmptyString("CAS0503E", prefix, "prefix");
                    guard.throwIfEmptyString("CAS0504E", key, "key");

                    var fullKey = prefix + '_' + key;

                    return fullKey;
                }
            }
        }

        return SessionStoreProvider;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAS08}
// di.core.angular.state
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(228), __webpack_require__(225), __webpack_require__(226), __webpack_require__(227)], __WEBPACK_AMD_DEFINE_RESULT__ = function (stateHelperLoader, diStateLoader, stateAuthenticatorLoader, stateDecoratorLoader) {
	'use strict';

	return function (module) {
		stateHelperLoader(module);
		diStateLoader(module);
		stateAuthenticatorLoader(module);
		stateDecoratorLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAS0A}
// di.core.angular.state
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var guard = $di.exception.guard;

		module.factory('diState', diState);

		diState.$inject = ['$state', '$q'];

		/**
   * Di state manager
   * @param $state
   * @returns
   */
		function diState($state, $q) {
			var stateSubscriptions = {};

			return {
				go: go,
				goBack: goBack,
				reload: reload,
				subscribeToStateChange: subscribeToStateChange
			};

			/**
    * Method which transitions to the specified state
    * @param to
    * @param params
    * @param options
    */
			function go(to, params, options) {
				guard.throwIfEmptyString("CAS0A01E", to, 'to');

				var promise = $state.go(to, params, options);

				var subscriptions = stateSubscriptions[to];

				if (subscriptions && subscriptions.length > 0) {
					for (var i = 0; i < subscriptions.length; i++) {
						subscriptions[i]();
					}
				}

				return promise;
			}

			/**
    * Transitions to the previous state, provided it has been stored
    * @returns {promise of the transition} 
    */
			function goBack() {
				if ($state.from && $state.from.name) {
					var promise = go($state.from.name, $state.fromParams);

					return promise;
				}

				return $q.reject('No previous state available.');
			}

			/**
    * Navigates to the current state and forces a reload
    */
			function reload() {
				var currentState = getCurrentState();

				return go(currentState.name, currentState.params, { reload: true });
			}

			/**
   	 * Subscribe to the given state
   	 * @param state
   	 * @param callback
   	 */
			function subscribeToStateChange(state, callback) {
				stateSubscriptions[state] = stateSubscriptions[state] || [];

				stateSubscriptions[state].push(callback);
			}

			/**
    * Gets a new object with the current state name and params
    * @returns {} 
    */
			function getCurrentState() {
				var stateName = $state.$current !== undefined && $state.$current.self !== undefined ? $state.$current.self.name : undefined;
				var currentParams = $state.params;

				return {
					name: stateName,
					params: currentParams
				};
			}
		}
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAA0B}
// di.core.angular.authentication
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var guard = $di.exception.guard;
		var util = $di.utility.util;
		var debug = $di.debug.debugger.newLogger("stateAuthenticator");

		module.provider('stateAuthenticator', StateAuthenticatorProvider);

		/**
   * Authenticates access to states
   */
		function StateAuthenticatorProvider() {
			var config = {
				securityEnabled: true,
				loginState: 'welcome'
			};

			var provider = {
				configure: configure,
				$get: $get
			};

			provider.$get.$inject = ['authenticationData', 'authenticationClientEventSubscriber'];

			return provider;

			/**
    * Configure the service
    * @param cfg
    */
			function configure(cfg) {
				guard.throwIfNotAnObject("CAA0B02E", cfg, "cfg");

				config = cfg;
			}

			function $get(authenticationData, authenticationClientEventSubscriber) {
				var service = {
					authenticateState: authenticateState
				};

				return service;

				/**
     * Authenticate access to the given state
     * @param state
     */
				function authenticateState(state) {
					guard.throwIfNotAnObject("CAA0B06E", state, "state");

					var requiredRights = (state.data || {}).rights;
					var userRights;
					var isValid = true;

					if (state.name === config.loginState && authenticationData.userData.isAuthenticated === true) {
						authenticationClientEventSubscriber.authenticatedAccessToLoginState();
						return false;
					}

					if (config.securityEnabled && util.isArray(requiredRights) && requiredRights.length !== 0) {
						userRights = authenticationData.authenticationTicket.rights;

						if (!userRights) {
							isValid = false;
						} else {
							requiredRights.every(function (requiredRight) {
								if (!_.contains(userRights, requiredRight)) {
									isValid = false;

									return false;
								} else {
									return true;
								}
							});
						}
					}

					if (isValid) {
						return true;
					} else {
						authenticationClientEventSubscriber.unauthorisedState(state.url);

						return false;
					}
				}
			}
		}

		return StateAuthenticatorProvider;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF1J}
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {

		module.decorator('$state', stateDecorator);

		stateDecorator.$inject = ["$delegate", "$rootScope"];

		/*
   * Adds the functionality of storing the previous state
   */
		function stateDecorator(delegate, rootScope) {

			return decorated();

			function decorated() {
				var state = delegate;

				state.from = undefined;
				state.fromParams = undefined;

				rootScope.$on("$stateChangeSuccess", function (ev, to, toParams, from, fromParams) {
					state.from = from;
					state.fromParams = fromParams;
				});

				return state;
			}
		}

		return stateDecorator;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAS07}
// di.core.angular.state
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var guard = $di.exception.guard;
		var util = $di.utility.util;
		var debug = $di.debug.debugger.newLogger("stateHelper");

		module.provider('stateHelper', StateHelperProvider);

		StateHelperProvider.$inject = ['$stateProvider'];

		/**
   * Adds states to the $stateProvider using a state object
   */
		function StateHelperProvider($stateProvider) {
			var stateRights = {};

			var provider = {
				addStates: addStates,
				$get: function $get() {}
			};

			return provider;

			/**
    * Adds the given state information to the $stateProvider
    * @param stateData
    */
			function addStates(stateData) {
				guard.throwIfNotAnObject("CAS0702E", stateData, "stateData");

				var parentRights;

				if (stateData.parentStateName) {
					parentRights = stateRights[stateData.parentStateName];
				}

				addStatesArray(stateData.states, stateData.templateBaseUrl, stateData.parentStateName, parentRights);
			}

			/**
    * Adds the specified array of states to the state provider)
    * @param statesArray
    * @param templateBaseUrl
    * @param parentStateName
    * @param parentRights
    * @param templateName
    */
			function addStatesArray(statesArray, templateBaseUrl, parentStateName, parentRights, templateName) {
				for (var i = 0; i < statesArray.length; i++) {
					var state = statesArray[i];

					if (state.onlyCreateStateCollection && util.isNullOrUndefined(state.stateCollection)) {
						guard.throwNew("CAS0703E", "A state collection must be provided when onlyCreateStateCollection is true.");
					}

					if (!state.onlyCreateStateCollection) {
						createState(state, templateBaseUrl, parentStateName, parentRights, templateName);
					}

					if (state.stateCollection) {
						var newTemplateName = (util.isNonEmptyString(parentStateName) ? parentStateName + '.' : '') + state.stateName;
						var rights = state.rights || [];

						if (parentRights) {
							rights = rights.concat(parentRights);
						}

						addStatesArray(state.stateCollection, templateBaseUrl, parentStateName, rights, newTemplateName);
					}
				}
			}

			/**
    * Creates the state entry for the specified state with the specified additional rights
    * @param state
    * @param templateBaseUrl
    * @param parentStateName
    * @param parentRights
    * @param templateName
    */
			function createState(state, templateBaseUrl, parentStateName, parentRights, templateName) {
				var qualifiedStateName = (util.isNonEmptyString(parentStateName) ? parentStateName + '.' : '') + state.stateName;

				var rights = state.rights || [];

				if (parentRights) {
					rights = rights.concat(parentRights);
				}

				var stateObj = {
					abstract: util.isDefined(state.isAbstract) ? state.isAbstract : false,
					url: '/' + (state.url || state.stateName),
					templateUrl: templateBaseUrl + '/' + (templateName || qualifiedStateName) + '.html',
					parent: parentStateName,
					data: state.data || {},
					params: state.params || {}
				};

				stateObj.data.rights = rights;

				$stateProvider.state(qualifiedStateName, stateObj);
				stateRights[qualifiedStateName] = rights;

				if (state.childStates) {
					addStatesArray(state.childStates, templateBaseUrl, qualifiedStateName, rights);
				}
			}
		}

		return StateHelperProvider;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAS0B}
// di.core.angular.staticLookup
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(230)], __WEBPACK_AMD_DEFINE_RESULT__ = function (staticLookupProxyLoader) {
  'use strict';

  return function (module) {
    staticLookupProxyLoader(module);
  };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP1X}
// di.core.angular.currency
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.factory('staticLookupProxy', staticLookupProxy);

		staticLookupProxy.$inject = ['webApiHttp', '$q', 'urlHelper'];

		/**
   * Static lookup proxy.		 
   * @returns
   */
		function staticLookupProxy(http, q, urlHelper) {

			return {
				get: get
			};

			/**
    * Function to get all requested static data from the database.
    * @param types
    */
			function get(type) {
				var requestParameters = {
					type: type
				};

				var requestUrl = urlHelper.setParameters('StaticLookup/Get', requestParameters);

				var httpPromise = http.get(requestUrl);

				var newPromise = httpPromise.then(success, error);

				return newPromise;

				/**
    * Successfull callback when all promises are resolved.
    * @param data
    */
				function success(data) {
					return data;
				}

				/**
    * Failure callback when one of N promises failed.
    * @param error
    */
				function error(err) {
					err.failureReason = "CORE.PROXIES.RECEIVE_ERROR";

					return q.reject(err);
				}
			}
		}

		return staticLookupProxy;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAT0A}
// di.core.angular.translation
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(232), __webpack_require__(233), __webpack_require__(234), __webpack_require__(235)], __WEBPACK_AMD_DEFINE_RESULT__ = function (diTranslateDirectiveLoader, diTranslateFilterLoader, diTranslateLink, translatorLoader) {
   'use strict';

   return function (module) {
      diTranslateDirectiveLoader(module);
      diTranslateFilterLoader(module);
      diTranslateLink(module);
      translatorLoader(module);
   };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAT06}
// di.core.angular.translation
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.directive('diTranslate', diTranslate);

        diTranslate.$inject = ['diTranslateLink'];

        function diTranslate(translateLink) {
            return {
                restrict: 'A',
                link: link
            };

            /**
             * Translates the value given to the directive along with replacing the arguments appropriately.
             */
            function link(scope, element, attrs) {
                translateLink.link(scope, element, attrs);
            }
        }

        return diTranslate;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAT0B}
// di.core.angular.translation
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.filter('diTranslate', diTranslate);

        diTranslate.$inject = ['translator'];

        function diTranslate(translator) {
            return function (input) {
                return translator.instantTranslate(input);
            };
        }

        return diTranslate;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAT06}
// di.core.angular.translation
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.factory('diTranslateLink', diTranslateLink);

        diTranslateLink.$inject = ['translator'];

        function diTranslateLink(translator) {
            return {
                link: link
            };

            /**
             * Translates the value given to the directive along with replacing the arguments appropriately.
             */
            function link(scope, element, attrs) {
                var languageKey = attrs.diTranslate;
                var args = attrs.translateArguments;
                var targetProperty = attrs.targetProperty;

                if (languageKey === "") {
                    if (element[0].textContent) {
                        languageKey = element[0].textContent;
                    } else if (targetProperty) {
                        languageKey = attrs[targetProperty];
                    }
                }

                translator.translate(languageKey, args).then(function (translated) {
                    if (targetProperty) {
                        element[0][targetProperty] = translated;
                    } else {
                        if (element[0].nodeName === 'INPUT') {
                            element[0].value = translated;
                        } else {
                            element[0].textContent = translated;
                        }
                    }
                });
            }
        }

        return diTranslateLink;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAT08}
// di.core.angular.translation
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;
        var util = $di.utility.util;
        var debug = $di.debug.debugger.newLogger("translator");

        module.factory('translator', translator);

        translator.$inject = ['$rootScope', '$translate', '$q'];

        function translator($rootScope, $translate, $q) {
            var deregisterTranslateChangeStart = $rootScope.$on('$translateChangeStart', translationChanged);
            var deregisterTranslateRefreshStart = $rootScope.$on('$translateRefreshStart', translationChanged);
            var deregisterTranslateChangeSuccess = $rootScope.$on('$translateChangeSuccess', translationLoaded);

            var translationIsLoaded = false;
            var requests = [];

            tearDown();

            return {
                whenReady: whenReady,
                translate: translate,
                instantTranslate: instantTranslate,
                changeLanguage: changeLanguage,
                getCurrentLanguage: getCurrentLanguage
            };

            /**
            *  Destroy all state, any event listeners and subscriptions
            */
            function tearDown() {
                $rootScope.$on('$destroy', function () {
                    deregisterTranslateChangeStart();
                    deregisterTranslateRefreshStart();
                    deregisterTranslateChangeSuccess();
                });
            }

            function whenReady() {
                if (translationIsLoaded) {
                    return $q.when();
                }

                var request = {
                    defferal: $q.defer()
                };

                requests.push(request);

                return request.defferal.promise;
            }

            /**
            * Translate a given string while replacing any placeholders in the string with the provided arguments.
            * @param stringToTranslate
            * @param translationArguments
            */
            function translate(stringToTranslate, translationArguments) {
                if (translationIsLoaded) {
                    return $q.when(instantTranslate(stringToTranslate, translationArguments));
                }

                var request = {
                    stringToTranslate: stringToTranslate,
                    translationArguments: translationArguments,
                    defferal: $q.defer()
                };

                requests.push(request);
                return request.defferal.promise;
            }

            function translateMappedArguments(args) {
                return _.each(args, function (value, key) {
                    return args[key] = util.isString(value) ? $translate.instant(value) : value;
                });
            }

            function translationChanged() {
                translationIsLoaded = false;
            }

            function translationLoaded() {
                translationIsLoaded = true;
                _.each(requests, function (request) {
                    if (util.isDefined(request.stringToTranslate)) {
                        var translated = instantTranslate(request.stringToTranslate, request.translationArguments);
                        request.defferal.resolve(translated);
                    } else {
                        request.defferal.resolve();
                    }
                });

                requests = [];
            }

            function instantTranslate(stringToTranslate, translationArguments) {
                var translated = $translate.instant(stringToTranslate);
                var args;

                if (translationArguments) {
                    if (util.isObject(translationArguments)) {
                        args = translationArguments;
                    } else {
                        args = $di.utility.placeholders.arguments.split(translationArguments);
                    }

                    translated = $di.utility.placeholders.replace(translated, args, translateMappedArguments);
                }

                return translated;
            }

            /**
             * Changes the language resource file used throughout the application.
             * @param prefix
             */
            function changeLanguage(prefix) {
                guard.throwIfNullOrUndefined("CAT0807E", prefix, "prefix");

                $translate.use(prefix);
            }

            /**
             * Gets the ISO code of the current language being used throughout the application.
             */
            function getCurrentLanguage() {
                return $translate.use();
            }
        }
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAU02}
// di.core.angular.url
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(238), __webpack_require__(239), __webpack_require__(237)], __WEBPACK_AMD_DEFINE_RESULT__ = function (endpointsLoader, urlHelperLoader, absoluteUrlLoader) {
	'use strict';

	return function (module) {
		endpointsLoader(module);
		urlHelperLoader(module);
		absoluteUrlLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF1K}
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var util = $di.utility.util;

        module.factory('absoluteUrl', absoluteUrl);

        /*
        * Appends http:// to the start of a URI that does not have a URI scheme (protocol)
        */
        function absoluteUrl() {

            return {
                isAbsoluteUrl: isAbsoluteUrl
            };

            function isAbsoluteUrl(input) {
                if (util.isNonEmptyString(input)) {
                    //https://tools.ietf.org/html/rfc3986#appendix-B
                    var uriRegex = /^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/gi;

                    var capturingGroups = uriRegex.exec(input);
                    // scheme = $2
                    if (util.isArray(capturingGroups) && capturingGroups.length > 2 && util.isDefined(capturingGroups[2])) {
                        return true;
                    }
                }
                return false;
            };
        }

        return absoluteUrl;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAU0D}
// di.core.angular.url
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;
        var util = $di.utility.util;

        module.provider('endpoints', EndpointsProvider);

        /**
         * 
         */
        function EndpointsProvider() {
            var config = {
                endpoints: {
                    siteOne: 'http://siteone.com',
                    siteTwo: 'http://sitetwo.com'
                },
                defaultEndpoint: 'siteOne'
            };

            var provider = {
                configure: configure,
                $get: $get
            };

            provider.$get.$inject = ['urlHelper'];

            return provider;

            /**
             * Configure the service
             * @param cfg
             */
            function configure(cfg) {
                guard.throwIfNotAnObject("CAH0302E", cfg, "cfg");
                config = cfg;
            }

            function $get(urlHelper) {
                return {
                    endpointConfig: config,
                    getUrl: getUrl
                };

                function getUrl(relativeUrl, endpoint) {
                    guard.throwIfEmptyString("CAU0D02E", relativeUrl, "relativeUrl");

                    var endpointUrl = getEndpointUrl(endpoint);
                    var url;

                    if (!util.isString(endpointUrl)) {
                        if (config.defaultEndpoint) {
                            endpointUrl = getEndpointUrl(config.defaultEndpoint);
                        }
                    }

                    if (!util.isString(endpointUrl)) {
                        endpointUrl = '';
                    }

                    url = urlHelper.combine(endpointUrl, relativeUrl);

                    return url;
                }

                function getEndpointUrl(endpoint) {
                    var endpointUrl = null;

                    if (util.isString(endpoint)) {
                        endpointUrl = config.endpoints[endpoint];

                        if (!util.isString(endpointUrl)) {
                            guard.throwNew("CAU0D01E", "Invalid endpoint '" + endpoint + "'");
                        }
                    } else {
                        endpointUrl = config.endpoints[config.defaultEndpoint];
                    }

                    return endpointUrl;
                }
            }
        }

        return EndpointsProvider;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAU07}
// di.core.angular.url
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(45)], __WEBPACK_AMD_DEFINE_RESULT__ = function (URI) {
    'use strict';

    return function (module) {
        module.factory('urlHelper', urlHelper);

        /**
        * Helper to perform operations with Urls
        */
        function urlHelper() {
            return {
                combine: combine,
                getParameters: getParameters,
                setParameter: setParameter,
                setParameters: setParameters,
                encodeUriComponent: encodeUriComponent
            };

            /**
            * Combines multiple URL parts together to make a valid URL
            */
            function combine() {
                var protocol;
                var urlParts = [];

                for (var i = 0; i < arguments.length; i++) {
                    var argument = arguments[i];

                    if (!argument) {
                        continue;
                    }

                    argument = argument.toString();

                    if (~argument.indexOf('://') && !protocol) {
                        protocol = argument.split('://')[0];
                        argument = argument.split('://')[1];
                    }

                    var argumentUrlParts = argument.split('/');

                    argumentUrlParts.forEach(function (urlPart) {
                        if (urlPart === '..') {
                            urlParts.pop();
                        } else if (urlPart === '.' || urlPart === '') {
                            return;
                        } else {
                            urlParts.push(urlPart);
                        }
                    });
                }

                var url = urlParts.join('/');

                if (protocol) {
                    url = protocol + '://' + url;
                }

                return url;
            }

            /**
             * Gets the querystring parameters for the given url
             * @param url
             */
            function getParameters(url) {
                var urlParams = new URI(url).search(true);

                return urlParams;
            }

            /**
             * Sets a querystring parameter on the given url
             * @param url
             * @param name
             * @param value
             */
            function setParameter(url, name, value) {
                var params = {};
                params[name] = value;

                url = setParameters(url, params);

                return url;
            }

            /**
             * Sets the querystring parameters on the given url
             * @param url
             * @param params
             */
            function setParameters(url, params) {
                var urlObj = new URI(url);

                urlObj.setSearch(params);

                url = urlObj.toString();

                return url;
            }

            /**
             * Function which calls the native encodeURIComponent method
             * @param value - The value to url encode
             * @returns - The url encoded value 
             */
            function encodeUriComponent(value) {
                return encodeURIComponent(value);
            }
        }

        return urlHelper;
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

// di.core.angular.userSecurity
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(242), __webpack_require__(249), __webpack_require__(243), __webpack_require__(241), __webpack_require__(251), __webpack_require__(250), __webpack_require__(252), __webpack_require__(245), __webpack_require__(244), __webpack_require__(248), __webpack_require__(246), __webpack_require__(247)], __WEBPACK_AMD_DEFINE_RESULT__ = function (changePasswordDirectiveLoader, setPasswordDirectiveLoader, forgotPasswordDirectiveLoader, changePasswordController, setPasswordController, forgotPasswordController, userSecurityProxy, passwordPolicyDirectiveLoader, getSecurityQuestionDirectiveLoader, securityAnswerDirectiveLoader, resetPasswordDirectiveLoader, resetPasswordSuccessDirectiveLoader) {
				'use strict';

				return function (module) {
								changePasswordDirectiveLoader(module);
								setPasswordDirectiveLoader(module);
								forgotPasswordDirectiveLoader(module);
								changePasswordController(module);
								setPasswordController(module);
								forgotPasswordController(module);
								userSecurityProxy(module);
								passwordPolicyDirectiveLoader(module);
								getSecurityQuestionDirectiveLoader(module);
								securityAnswerDirectiveLoader(module);
								resetPasswordDirectiveLoader(module);
								resetPasswordSuccessDirectiveLoader(module);
				};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAU08}
// di.core.angular.userSecurity
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.controller('ChangePasswordController', ChangePasswordController);

        ChangePasswordController.$inject = ['userSecurityProxy', 'notifier', 'elementNotifier', 'translator', '$scope', 'diState', 'authenticationClientEventSubscriber', 'AUTHENTICATION_RESULT'];

        function ChangePasswordController(userSecurityProxy, notifier, elementNotifier, translator, scope, diState, authenticationClientEventSubscriber, AUTHENTICATION_RESULT) {
            var vm = this;

            vm.username = '';
            vm.oldPassword = '';
            vm.newPassword = '';
            vm.confirmPassword = '';
            vm.changePassword = changePassword;

            scope.subscribeToUsernameChange(function (username) {
                vm.username = username;
            });

            /**
            *  Sends a request to the server to change a users password
            */
            function changePassword() {
                var promise = userSecurityProxy.changePassword(vm.username, vm.oldPassword, vm.newPassword);

                promise.then(resolve, reject);

                function resolve(data) {
                    if (data.success) {
                        translator.translate('CORE.USER_SECURITY.PASSWORD_CHANGED').then(function (translated) {
                            notifier.success(translated);
                            diState.go('portal.account.management', null, { reload: true });
                        });
                    } else {
                        if (data.passwordValidationMessage) {
                            elementNotifier.error(data.passwordValidationMessage, scope.newPasswordElement);
                        } else {
                            translator.translate('CORE.USER_SECURITY.ERRORS.' + data.failureReason.toUpperCase()).then(function (translated) {
                                elementNotifier.error(translated, scope.oldPasswordElement);
                            });
                        }
                        if (data.failureReason === AUTHENTICATION_RESULT.AccountLocked || data.failureReason === AUTHENTICATION_RESULT.AccountDisabled) {
                            authenticationClientEventSubscriber.unauthorisedState(data.failureReason);
                        }
                    }
                }

                function reject(error) {
                    translator.translate(error.failureReason).then(function (translated) {
                        notifier.error(translated);
                    });
                }
            }
        }

        return ChangePasswordController;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAU09}
//di.core.angular.userSecurity
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.directive('diChangePassword', diChangePassword);

		function diChangePassword() {

			return {
				restrict: 'E',
				controller: 'ChangePasswordController',
				controllerAs: 'changePasswordCtrl',
				scope: {
					subscribeToUsernameChange: '='
				},
				link: function link(scope, element) {
					scope.oldPasswordElement = element.find('#oldPassword');
					scope.newPasswordElement = element.find('#newPassword');
					scope.confirmPasswordElement = element.find('#confirmPassword');

					scope.$on('$destroy', function () {
						scope.oldPasswordElement = null;
						scope.newPasswordElement = null;
						scope.confirmPasswordElement = null;
					});
				},
				template: '<div\
	class="panel panel-primary">\
	<div\
		class="panel-heading">\
		<h3\
            class="form-row-title"\
            di-translate="CORE.USER_SECURITY.CHANGE_PASSWORD">Change password</h3>\
	</div>\
	<div\
		class="panel-body">\
		<form\
			class="form-horizontal"\
			di-validate-model="changePassword">\
			<div\
				di-translate="CORE.USER_SECURITY.CHANGE_PASSWORD_INFO"></div>\
			<di-password-policy></di-password-policy>\
			<div\
				class="form-group form-row">\
				<di-input\
					di-input-label="CORE.USER_SECURITY.OLD_PASSWORD"\
					di-input-type="password"\
					id="oldPassword"\
					input-class="form-control input"\
					validation-property-name="oldPassword"\
					validation-model-display-name="CORE.USER_SECURITY.OLD_PASSWORD"\
					ng-model="changePasswordCtrl"\
					ng-model-property="oldPassword">\
				</di-input>\
			</div>\
			<div\
				class="form-group form-row">\
				<di-input\
					di-input-label="CORE.USER_SECURITY.NEW_PASSWORD"\
					di-input-type="password"\
					id="newPassword"\
					input-class="form-control input"\
					validation-property-name="newPassword"\
					validation-model-display-name="CORE.USER_SECURITY.NEW_PASSWORD"\
					ng-model="changePasswordCtrl"\
					ng-model-property="newPassword">\
				</di-input>\
			</div>\
			<div\
				class="form-group form-row">\
				<di-input\
					di-input-label="CORE.USER_SECURITY.CONFIRM_PASSWORD"\
					di-input-type="password"\
					id="confirmPassword"\
					input-class="form-control input"\
					validation-property-name="confirmPassword"\
					validation-model-display-name="CORE.USER_SECURITY.CONFIRM_PASSWORD"\
					validation-model-compare-display-name="CORE.USER_SECURITY.CONFIRM_PASSWORDS"\
					ng-model-options="{ updateOn: \'default blur\', debounce: {\'default\': 1000, \'blur\': 0} }"\
					ng-model="changePasswordCtrl"\
					ng-model-property="confirmPassword"\
                    validation-message="CORE.USER_SECURITY.ERRORS.PASSWORDS_DO_NOT_MATCH">\
				</di-input>\
			</div>\
			<div\
				class="form-group form-row">\
				<div\
					class="right">\
					<di-button\
						filled\
						text="CORE.USER_SECURITY.CHANGE_PASSWORD_BUTTON"\
						validate\
						action="changePasswordCtrl.changePassword()">\
					</di-button>\
				</div>\
			</div>\
		</form>\
	</div>\
</div>'
			};
		}

		return diChangePassword;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAU0A}
//di.core.angular.userSecurity
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ng) {
	'use strict';

	return function (module) {
		module.directive('diForgotPassword', diForgotPassword);

		function diForgotPassword() {

			return {
				restrict: 'E',
				controller: 'ForgotPasswordController',
				controllerAs: 'forgotPasswordCtrl',
				scope: {
					onPasswordReset: '&?',
					onBackToLoginClick: '&?',
					subscribeToResetTokenChange: '=',
					onForgotPasswordClick: '&?'
				},
				link: link,
				template: '<div\
	class="panel panel-primary">\
	<div\
		class="panel-heading">\
		<span\
		<header>\
			<h1\
				class="title"\
				di-translate="CORE.USER_SECURITY.RESET_PASSWORD">\
			</h1>\
		</header>\
		</span>\
	</div>\
	<div\
		class="panel-body">\
		<di-get-security-question\
			ng-show="forgotPasswordCtrl.isState(forgotPasswordCtrl.EMAIL_ADDRESS_STATE)">\
		</di-get-security-question>\
		<di-security-answer\
			ng-show="forgotPasswordCtrl.isState(forgotPasswordCtrl.SECURITY_QUESTION_STATE)">\
		</di-security-answer>\
		<di-reset-password\
			ng-show="forgotPasswordCtrl.isState(forgotPasswordCtrl.RESET_PASSWORD_STATE)">\
		</di-reset-password>\
		<di-reset-password-success\
			ng-show="forgotPasswordCtrl.isState(forgotPasswordCtrl.RESET_PASSWORD_SUCCESS_STATE)">\
		</di-reset-password-sucess>\
	</div>\
	<div\
        class="processing"\
        id="spinnerHolder">\
    </div>\
</div>'
			};

			function link(scope) {
				scope.showhHideControl = showhHideControl;
				scope.findElementById = findElementById;
				return;

				/**
     * shows or hides control by id                 
     */
				function showhHideControl(id, show) {
					var element = findElementById(id);
					if (element) {
						if (show) {
							element.removeClass("buttons-hidden");
						} else {
							element.addClass("buttons-hidden");
						}
					}
				}

				/**
     * finds element by id                
     */
				function findElementById(id) {
					return ng.element(ng.element.find('#' + id));
				}
			}
		}

		return diForgotPassword;
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//di.core.angular.userSecurity
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.directive('diGetSecurityQuestion', diGetSecurityQuestion);

		function diGetSecurityQuestion() {

			return {
				require: '^diForgotPassword',
				restrict: 'E',
				link: function link(scope, element) {
					scope.emailAddressElement = element.find('#emailAddress');

					scope.$on('$destroy', function () {
						scope.emailAddressElement = null;
					});
				},
				template: '<form\
	di-validate-model="forgotPasswordEmail">\
	<div\
		di-translate="CORE.USER_SECURITY.FORGOT_PASSWORD_INFO"></div>\
	<br/>\
	<div\
		class="form-group form-row">\
		<di-input\
			di-input-label="CORE.USER_SECURITY.EMAIL"\
			di-input-type="email"\
			id="emailAddress"\
			input-class="input form-control"\
			validation-property-name="emailAddress"\
			validation-model-display-name="CORE.USER_SECURITY.EMAIL"\
			ng-model-options="{ updateOn: \'default blur\', debounce: {\'default\': 1000, \'blur\': 0} }"\
			di-enter="forgotPasswordCtrl.getSecurityQuestion()"\
			di-enter-skip-validation="false"\
			ng-model="forgotPasswordCtrl"\
			ng-model-property="emailAddress">\
		</di-input>\
	</div>\
	<div\
		class="form-group form-row">\
		<button\
			id="securityQuestionButton"\
			ng-if="!forgotPasswordCtrl.processing"\
			class="btn btn-success center"\
			di-translate="CORE.USER_SECURITY.CONTINUE"\
			di-validate-click="forgotPasswordCtrl.getSecurityQuestion()"></button>\
		<button\
			ng-if="forgotPasswordCtrl.processing"\
			id="securityQuestionButtonProcessing"\
			class="btn-processing buttons-hidden"\
			di-translate="CORE.USER_SECURITY.CONTINUE"\
			disabled"></button>\
	</div>\
	<div\
		class="form-group form-row">\
		<a\
			href=""\
			ng-click="forgotPasswordCtrl.backToLogin()"\
			class="left"\
			di-translate="CORE.USER_SECURITY.BACK_TO_LOGIN">\
		</a>\
	</div>\
</form>'
			};
		}

		return diGetSecurityQuestion;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAU0K}
//di.core.angular.userSecurity
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.directive('diPasswordPolicy', diPasswordPolicy);

        function diPasswordPolicy() {
            return {
                restrict: 'E',
                template: '<div>\
    <br />\
    <div\
	    di-translate="CORE.USER_SECURITY.SET_PASSWORD_INFO_DETAILS.HEADER"></div>\
    <ul>\
	    <li\
            di-translate="CORE.USER_SECURITY.SET_PASSWORD_INFO_DETAILS.RULES.1"></li>\
	    <li\
            di-translate="CORE.USER_SECURITY.SET_PASSWORD_INFO_DETAILS.RULES.2"></li>\
	    <li\
            di-translate="CORE.USER_SECURITY.SET_PASSWORD_INFO_DETAILS.RULES.3"></li>\
	    <li\
            di-translate="CORE.USER_SECURITY.SET_PASSWORD_INFO_DETAILS.RULES.4"></li>\
	    <li\
            di-translate="CORE.USER_SECURITY.SET_PASSWORD_INFO_DETAILS.RULES.5"></li>\
    </ul>\
</div>'
            };
        }

        return diPasswordPolicy;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//di.core.angular.userSecurity
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.directive('diResetPassword', diResetPassword);

		function diResetPassword() {

			return {
				require: '^diForgotPassword',
				restrict: 'E',
				link: function link(scope, element) {
					scope.resetTokenElement = element.find('#resetToken');
					scope.newPasswordElement = element.find('#newPassword');
					scope.confirmPasswordElement = element.find('#confirmPassword');

					scope.$on('$destroy', function () {
						scope.resetTokenElement = null;
						scope.newPasswordElement = null;
						scope.confirmPasswordElement = null;
					});
				},
				template: '<form\
	class="form-horizontal"\
	di-validate-model="resetPassword">\
	<di-password-policy></di-password-policy>\
	<div\
		class="form-group form-row" style="display:none">\
		<di-input\
			di-input-label="CORE.USER_SECURITY.RESET_CODE"\
			di-input-type="text"\
			id="resetToken"\
			input-class="form-control input"\
			validation-property-name="resetToken"\
			validation-model-display-name="CORE.USER_SECURITY.RESET_CODE"\
			ng-model="forgotPasswordCtrl"\
			ng-model-property="resetToken">\
		</di-input>\
	</div>\
	<div\
		class="form-group form-row">\
		<di-input\
			di-input-label="CORE.USER_SECURITY.NEW_PASSWORD"\
			di-input-type="password"\
			id="newPassword"\
			input-class="form-control input"\
			validation-property-name="newPassword"\
			validation-model-display-name="CORE.USER_SECURITY.NEW_PASSWORD"\
			ng-model="forgotPasswordCtrl"\
			ng-model-property="newPassword">\
		</di-input>\
	</div>\
	<div\
		class="form-group form-row">\
		<di-input\
			di-input-label="CORE.USER_SECURITY.CONFIRM_PASSWORD"\
			di-input-type="password"\
			id="confirmPassword"\
			input-class="form-control input"\
			validation-property-name="confirmPassword"\
			validation-model-display-name="CORE.USER_SECURITY.CONFIRM_PASSWORD"\
			validation-model-compare-display-name="CORE.USER_SECURITY.CONFIRM_PASSWORDS"\
			ng-model-options="{ updateOn: \'default blur\', debounce: {\'default\': 1000, \'blur\': 0} }"\
			ng-model="forgotPasswordCtrl"\
			ng-model-property="confirmPassword"\
			validation-message="CORE.USER_SECURITY.ERRORS.PASSWORDS_DO_NOT_MATCH">\
		</di-input>\
	</div>\
	<div\
		class="form-group form-row">\
		<button\
			id="resetPasswordButton"\
			class="btn btn-success center"\
			di-translate="CORE.USER_SECURITY.RESET_PASSWORD"\
			di-validate-click="forgotPasswordCtrl.resetPassword()"></button>\
			<button\
			id="resetPasswordButtonProcessing"\
			class="btn-processing buttons-hidden"\
			di-translate="CORE.USER_SECURITY.RESET_PASSWORD"\
			disabled"></button>\
	</div>\
	<div\
		class="form-group form-row">\
		<a\
			href=""\
			ng-click="forgotPasswordCtrl.backToLogin()"\
			class="left"\
			di-translate="CORE.USER_SECURITY.BACK_TO_LOGIN">\
		</a>\
	</div>\
</form>'
			};
		}

		return diResetPassword;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//di.core.angular.userSecurity
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.directive('diResetPasswordSuccess', diResetPasswordSuccess);

		function diResetPasswordSuccess() {

			return {
				restrict: 'E',
				template: '<form\
	class="form-horizontal">\
	<div\
		di-translate="CORE.USER_SECURITY.RESET_PASSWORD_SUCCESS">\
	</div>\
	</br>\
	<div\
		class="form-group form-row">\
		<a\
			href=""\
			ng-click="forgotPasswordCtrl.backToLogin()"\
			class="left"\
			di-translate="CORE.USER_SECURITY.BACK_TO_LOGIN">\
		</a>\
	</div>\
</form>'
			};
		}

		return diResetPasswordSuccess;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//di.core.angular.userSecurity
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.directive('diSecurityAnswer', diSecurityAnswer);

		function diSecurityAnswer() {

			return {
				require: '^diForgotPassword',
				restrict: 'E',
				link: function link(scope, element) {
					scope.securityAnswerElement = element.find('#securityAnswer');

					scope.$on('$destroy', function () {
						scope.securityAnswerElement = null;
					});
				},
				template: '<form\
	class="form-horizontal"\
	di-validate-model="forgotPasswordSecurity">\
	<div\
		di-translate="CORE.USER_SECURITY.SECURITY_QUESTION_INFO"></div>\
	<br/>\
	<div\
		<b\
			ng-bind="forgotPasswordCtrl.securityQuestion"></b>\
	</div>\
	<br/>\
	<div\
		class="form-group form-row">\
		<di-input\
			di-input-label="CORE.USER_SECURITY.ANSWER"\
			di-input-type="password"\
			id="securityAnswer"\
			input-class="form-control input"\
			validation-property-name="securityAnswer"\
			validation-model-display-name="CORE.USER_SECURITY.SECURITY_ANSWER"\
			ng-model="forgotPasswordCtrl"\
			ng-model-property="securityAnswer">\
		</di-input>\
	<br/>\
	</div>\
    <br/>\
	<div\
		class="form-group form-row">\
		<button\
			id="requestPasswordResetButton"\
			class="btn btn-success center"\
			di-translate="CORE.USER_SECURITY.SEND_EMAIL"\
			di-validate-click="forgotPasswordCtrl.requestPasswordReset()"></button>\
		<button\
			id="requestPasswordResetButtonProcessing"\
			class="btn-processing buttons-hidden"\
			di-translate="CORE.USER_SECURITY.SEND_EMAIL"\
			disabled"></button>\
	</div>\
	<div\
		class="form-group form-row">\
		<a\
			href=""\
			ng-click="forgotPasswordCtrl.backToLogin()"\
			class="left"\
			di-translate="CORE.USER_SECURITY.BACK_TO_LOGIN">\
		</a>\
	</div>\
</form>'
			};
		}

		return diSecurityAnswer;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAU0J}
//di.core.angular.userSecurity
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ng) {
	'use strict';

	return function (module) {
		module.directive('diSetPassword', diSetPassword);

		function diSetPassword() {

			return {
				restrict: 'E',
				controller: 'SetPasswordController',
				controllerAs: 'setPasswordCtrl',
				scope: {
					onBackToLogin: '&?',
					onPasswordReset: '=',
					subscribeToUsernameChange: '=',
					setPassword: '='
				},
				link: function link(scope, element) {
					scope.userNameElement = element.find('#userName');
					scope.tokenElement = element.find('#token');
					scope.newPasswordElement = element.find('#newPassword');
					scope.confirmPasswordElement = element.find('#confirmPassword');

					scope.$on('$destroy', function () {
						scope.userNameElement = null;
						scope.tokenElement = null;
						scope.newPasswordElement = null;
						scope.confirmPasswordElement = null;
					});

					scope.findElement = findElement;

					scope.showhHideControl = showhHideControl;

					return;

					/**
      * finds element by name                
      */
					function findElement(name) {
						return ng.element(name);
					}

					/**
      * shows or hides control by id                 
      */
					function showhHideControl(id, show) {
						var element = findElementById(id);
						if (element) {
							if (show) {
								element.removeClass("buttons-hidden");
							} else {
								element.addClass("buttons-hidden");
							}
						}
					}

					/**
      * finds element by id                
      */
					function findElementById(id) {
						return ng.element(ng.element.find('#' + id));
					}
				},
				template: '<div\
	class="panel panel-primary">\
	<div\
		class="panel-heading">\
		<span\
		<header>\
			<h1\
				class="title"\
				ng-if="setPasswordCtrl.passwordExpired"\
				di-translate="CORE.USER_SECURITY.PASSWORD_EXPIRED">\
			</h1>\
			<h1\
				class="title"\
				ng-if="!setPasswordCtrl.passwordExpired"\
				di-translate="CORE.USER_SECURITY.FIRST_TIME_LOGIN">\
			</h1>\
		</header>\
		</span>\
	</div>\
	<div\
		class="panel-body">\
		<form\
			class="form-horizontal"\
			di-validate-model="{{setPasswordCtrl.validationModel}}">\
			<div\
				ng-if="!setPasswordCtrl.passwordExpired"\
				class="panel-heading">\
				<h3\
					class="form-row-title"\
					di-translate="CORE.USER_SECURITY.SET_NEW_PASSWORD">Set new password</h3>\
				<div\
					class="form-group form-row"\
					di-translate="CORE.USER_SECURITY.SET_PASSWORD_INFO">\
				</div>\
			</div>\
			<div\
				ng-if="setPasswordCtrl.passwordExpired"\
				di-translate="CORE.USER_SECURITY.PASSWORD_EXPIRED_INFO">\
			</div>\
			<di-password-policy></di-password-policy>\
			<br/>\
			<input\
				type="hidden"\
				id="userName"\
				class="form-control input"\
				ng-model="setPasswordCtrl.userName"/>\
			<input\
				type="hidden"\
				id="token"\
				class="form-control input"\
				ng-model="setPasswordCtrl.token"/>\
			<div\
				class="form-group form-row">\
				<di-input\
					di-input-label="CORE.USER_SECURITY.NEW_PASSWORD"\
					di-input-type="password"\
					id="newPassword"\
					input-class="form-control input"\
					validation-property-name="newPassword"\
					validation-model-display-name="CORE.USER_SECURITY.NEW_PASSWORD"\
					ng-model="setPasswordCtrl"\
					ng-model-property="newPassword">\
				</di-input>\
			</div>\
		<div\
			class="form-group form-row">\
			<di-input\
				di-input-label="CORE.USER_SECURITY.CONFIRM_PASSWORD"\
				di-input-type="password"\
				id="confirmPassword"\
				input-class="form-control input"\
				validation-property-name="confirmPassword"\
				ng-model-options="{ updateOn: \'default blur\', debounce: {\'default\': 1000, \'blur\': 0} }"\
				validation-model-display-name="CORE.USER_SECURITY.CONFIRM_PASSWORD"\
				validation-model-compare-display-name="CORE.USER_SECURITY.CONFIRM_PASSWORDS"\
				ng-model="setPasswordCtrl"\
				ng-model-property="confirmPassword"\
				validation-message="CORE.USER_SECURITY.ERRORS.PASSWORDS_DO_NOT_MATCH">\
			</di-input>\
		</div>\
		<div\
			class="form-group form-row">\
		</div>\
		<div\
			ng-if="!setPasswordCtrl.passwordExpired"\
			class="panel-heading">\
			<h3\
				class="form-row-title\
				di-translate="CORE.USER_SECURITY.SECURITY_QUESTION">Security questions</h3>\
			<div\
				class="form-group form-row"\
				di-translate="CORE.USER_SECURITY.SET_SECURITY_QUESTION_INFO">\
			</div>\
			<br />\
		</div>\
		<div\
			ng-if="!setPasswordCtrl.passwordExpired"\
			class="form-group form-row">\
			<div\
				class="form-group form-row">\
				<label\
					class="form-row-label"\
					di-translate="CORE.USER_SECURITY.SECURITY_QUESTION"></label>\
				<di-select\
					mode="dropdown"\
					items="setPasswordCtrl.securityQuestions"\
					item-unique-property="id"\
					bind-to-object="setPasswordCtrl"\
					bind-to-property="securityQuestion"\
					display-property="question"\
					di-validate="securityQuestion"\
					validation-model="setPasswordCtrl.securityQuestion"\
					validation-model-display-name="CORE.USER_SECURITY.SECURITY_QUESTION"\
					watch-binding="true">\
					{{::filteredItem.item.question}}\
				</di-select>\
			</div>\
			<div\
				class="form-group form-row">\
				<label\
					class="form-row-label"\
					di-translate="CORE.USER_SECURITY.SECURITY_ANSWER"></label>\
				<input\
					id="securityAnswer"\
					type="password"\
					class="form-control input"\
					di-validate="securityAnswer"\
					validation-model-display-name="CORE.USER_SECURITY.SECURITY_ANSWER"\
					ng-model="setPasswordCtrl.securityAnswer" />\
			</div>\
		</div>\
		<div\
			ng-if="setPasswordCtrl.passwordExpired"\
			class="form-group form-row">\
			<button\
				id="setPasswordButton"\
				class="btn btn-success center"\
				di-translate="CORE.USER_SECURITY.SET_PASSWORD"\
				di-validate-click="setPasswordCtrl.setPassword()"></button>\
			<button\
				id="setPasswordButtonProcessing"\
				class="btn-processing buttons-hidden"\
				di-translate="CORE.USER_SECURITY.SET_PASSWORD"\
				disabled"></button>\
		</div>\
		<div\
			ng-if="!setPasswordCtrl.passwordExpired"\
			class="form-group form-row">\
			<button\
				id="setPasswordQuestionButton"\
				class="btn btn-success center"\
				di-translate="CORE.USER_SECURITY.SET_PASSWORD_AND_SECURITY"\
				di-validate-click="setPasswordCtrl.setPasswordAndQuestion()"></button>\
			<button\
				id="setPasswordQuestionButtonProcessing"\
				class="btn-processing buttons-hidden"\
				di-translate="CORE.USER_SECURITY.SET_PASSWORD_AND_SECURITY"\
				disabled"></button>\
		</div>\
		<div\
			class="form-group form-row">\
			<a\
				href=""\
				ng-click="setPasswordCtrl.backToLogin()"\
				class="left"\
				di-translate="CORE.USER_SECURITY.BACK_TO_LOGIN">\
			</a>\
		</div>\
	</form>\
	<div\
		class="processing"\
		id="spinnerHolder">\
	</div>\
</div>'
			};
		}

		return diSetPassword;
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAU0B}
// di.core.angular.userSecurity
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.controller('ForgotPasswordController', ForgotPasswordController);

		ForgotPasswordController.$inject = ['userSecurityProxy', 'notifier', 'elementNotifier', 'translator', '$scope', 'modalSpinner', 'AUTHENTICATION_RESULT', 'promptWindow'];

		function ForgotPasswordController(userSecurityProxy, notifier, elementNotifier, translator, scope, modalSpinner, AUTHENTICATION_RESULT, promptWindow) {
			var vm = this;
			var spinner;

			vm.EMAIL_ADDRESS_STATE = 0;
			vm.SECURITY_QUESTION_STATE = 1;
			vm.RESET_PASSWORD_STATE = 2;
			vm.RESET_PASSWORD_SUCCESS_STATE = 3;

			vm.currentState = vm.EMAIL_ADDRESS_STATE;
			vm.emailAddress = '';
			vm.securityQuestion = '';
			vm.securityAnswer = '';
			vm.resetToken = '';
			vm.newPassword = '';
			vm.confirmPassword = '';
			vm.setResetToken = setResetToken;
			vm.isState = isState;
			vm.requestPasswordReset = requestPasswordReset;
			vm.getSecurityQuestion = getSecurityQuestion;
			vm.resetPassword = resetPassword;
			vm.forgotPassword = forgotPassword;
			vm.backToLogin = backToLogin;

			scope.subscribeToResetTokenChange(setResetToken);

			/**
    * Handler for forgot password link click
    * @returns {} 
    */
			function forgotPassword() {
				if (scope.onForgotPasswordClick) {
					scope.onForgotPasswordClick();
				}
			}

			/**
    * Handler for back to login click
    * @returns {} 
    */
			function backToLogin() {
				if (scope.onBackToLoginClick) {
					scope.onBackToLoginClick();
				}
			}

			/**
    * Checks to see if a given state is the current state
    */
			function isState(state) {
				return vm.currentState === state;
			}

			/**
    * Sets the reset token against the view
    */
			function setResetToken(resetToken) {
				vm.resetToken = resetToken;

				if (vm.resetToken) {
					vm.currentState = vm.RESET_PASSWORD_STATE;
				} else {
					vm.currentState = vm.EMAIL_ADDRESS_STATE;
				}
			}

			/**
    * Gets the users security question from the server through the proxy
    */
			function getSecurityQuestion() {
				startStopProcessing('securityQuestionButton', 'securityQuestionButtonProcessing');

				userSecurityProxy.getSecurityQuestion(vm.emailAddress).then(resolve, reject);

				return;

				function resolve(data) {
					startStopProcessing('securityQuestionButton', 'securityQuestionButtonProcessing', false);

					if (data.success) {
						vm.securityQuestion = data.securityQuestion;

						vm.currentState = vm.SECURITY_QUESTION_STATE;
					} else {
						if (data.failureReason !== AUTHENTICATION_RESULT.InvalidUsername) {
							translator.translate('CORE.USER_SECURITY.ERRORS.' + data.failureReason.toUpperCase()).then(function (translated) {
								elementNotifier.error(translated, scope.emailAddressElement);
							});
						} else {
							vm.currentState = vm.RESET_PASSWORD_SUCCESS_STATE;
						}
					}
				}

				function reject(error) {
					startStopProcessing('requestPasswordResetButton', 'requestPasswordResetButtonProcessing', false);

					if (error.failureReason === AUTHENTICATION_RESULT.ServerDown) {
						translator.translate("CORE.AUTHENTICATION.ERRORS." + error.failureReason.toUpperCase()).then(function (translated) {
							notifier.error(translated);
						});
					} else {
						vm.currentState = vm.RESET_PASSWORD_SUCCESS_STATE;
					}
				}
			}

			/**
    * Sends a HTTP post request to the server to send an email with password reminder.
    */
			function requestPasswordReset() {
				startStopProcessing('requestPasswordResetButton', 'requestPasswordResetButtonProcessing');

				var promise = userSecurityProxy.requestPasswordReset(vm.emailAddress, vm.securityAnswer);

				promise.then(resolve, reject);

				function resolve(data) {
					startStopProcessing('requestPasswordResetButton', 'requestPasswordResetButtonProcessing', false);
					if (data.success) {
						promptWindow.alert({ title: 'CORE.USER_SECURITY.FORGOT_PASSWORD', message: 'CORE.USER_SECURITY.RESET_PASSWORD_SUCCESS' });
						backToLogin();
					} else {
						translator.translate('CORE.USER_SECURITY.ERRORS.' + data.failureReason.toUpperCase()).then(function (translated) {
							elementNotifier.error(translated, scope.securityAnswerElement);
						});
					}
				}

				function reject(error) {
					startStopProcessing('requestPasswordResetButton', 'requestPasswordResetButtonProcessing', false);
					translator.translate(error.failureReason).then(function (translated) {
						notifier.error(translated);
					});
				}
			}

			/**
    *  Sends a request to the server to reset a users password
    */
			function resetPassword() {
				startStopProcessing('resetPasswordButton', 'resetPasswordButtonProcessing');

				var promise = userSecurityProxy.resetPassword(vm.resetToken, vm.newPassword);

				promise.then(resolve, reject);

				function resolve(data) {
					startStopProcessing('resetPasswordButton', 'resetPasswordButtonProcessing', false);
					if (data.success) {
						translator.translate('CORE.USER_SECURITY.PASSWORD_RESET').then(function (translated) {
							notifier.success(translated);
						});

						vm.resetToken = '';
						vm.newPassword = '';
						vm.confirmPassword = '';

						vm.currentState = vm.EMAIL_ADDRESS_STATE;
						if (scope.onPasswordReset) {
							scope.onPasswordReset();
						}
					} else {
						if (data.passwordValidationMessage) {
							elementNotifier.error(data.passwordValidationMessage, scope.newPasswordElement);
						} else {
							translator.translate('CORE.USER_SECURITY.ERRORS.' + data.failureReason.toUpperCase()).then(function (translated) {
								elementNotifier.error(translated, scope.resetTokenElement);
							});
						}
					}
				}

				function reject(error) {
					startStopProcessing('resetPasswordButton', 'resetPasswordButtonProcessing', false);
					translator.translate(error.failureReason).then(function (translated) {
						notifier.error(translated);
					});
				}
			}

			/**
    * hides or shows action buttons            
    */
			function startStopProcessing(buttonActive, buttonInactive, startOrStop) {
				if (startOrStop !== false) {
					showSpinner();
					if (scope.showhHideControl) {
						scope.showhHideControl(buttonActive, false);
						scope.showhHideControl(buttonInactive, true);
					}
				} else {
					removeSpinner();
					if (scope.showhHideControl) {
						scope.showhHideControl(buttonActive, true);
						scope.showhHideControl(buttonInactive, false);
					}
				}
			}

			/**
    * Adds spinner to the page			 
    */
			function showSpinner() {
				var opts = {
					length: 19,
					width: 14,
					radius: 42,
					scale: 0.25,
					color: '#000',
					opacity: 0.25,
					zIndex: 2e9
				};

				spinner = modalSpinner.showModalSpinner("#spinnerHolder", opts);
			}

			/**
    * Removes spinner from the page
   */
			function removeSpinner() {
				if (spinner) {
					spinner.remove();
				}
			}
		}

		return ForgotPasswordController;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAU08}
// di.core.angular.userSecurity
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.controller('SetPasswordController', SetPasswordController);

		SetPasswordController.$inject = ['userSecurityProxy', 'notifier', 'elementNotifier', 'translator', '$scope', 'modalSpinner'];

		function SetPasswordController(userSecurityProxy, notifier, elementNotifier, translator, scope, modalSpinner) {
			var vm = this;
			var spinner;
			vm.passwordExpired = false;
			vm.validationModel = 'setPassword';
			vm.userName = '';
			vm.token = '';
			vm.newPassword = '';
			vm.confirmPassword = '';
			vm.securityQuestions = [];
			vm.securityQuestion = '';
			vm.securityAnswer = '';
			vm.setPassword = setPassword;
			vm.setPasswordAndQuestion = setPasswordAndQuestion;
			vm.backToLogin = backToLogin;

			scope.subscribeToUsernameChange(function (username, token, passwordExpired) {
				vm.userName = username;
				vm.token = token;
				vm.passwordExpired = passwordExpired;
				if (vm.passwordExpired) {
					vm.validationModel = 'passwordExpired';
				} else {
					getSecurityQuestions();
				}
			});

			return;

			/**
    * Loads security questions			 
    */
			function getSecurityQuestions() {
				var promise = userSecurityProxy.getSecurityQuestions();
				promise.then(resolve, reject);

				function resolve(data) {
					var questions = [];

					_.each(data, function (item, index) {
						questions.push({
							id: index,
							question: item
						});
					});
					vm.securityQuestions.fill(questions);

					removeSpinner();
				}

				function reject() {
					removeSpinner();
				}
			}

			function backToLogin() {
				if (scope.onBackToLogin) {
					scope.onBackToLogin();
				}
			}

			/**
    *  Sends a request to the server to set a users password
    */
			function setPassword() {
				startStopProcessing('setPasswordButton', 'setPasswordButtonProcessing');

				userSecurityProxy.setPasswordWithToken(vm.userName, vm.token, vm.newPassword).then(resolve, reject);
			}

			function setPasswordAndQuestion() {
				startStopProcessing('setPasswordQuestionButton', 'setPasswordQuestionButtonProcessing');
				userSecurityProxy.setPasswordAndQuestionWithToken(vm.userName, vm.token, vm.newPassword, vm.securityQuestion.question, vm.securityAnswer).then(resolve, reject);
			}

			function resolve(data) {
				if (data.success) {
					translator.translate('CORE.USER_SECURITY.PASSWORD_CHANGED').then(function (translated) {
						notifier.success(translated);
					});

					vm.token = '';

					if (scope.onPasswordReset) {
						scope.onPasswordReset(vm.userName, vm.newPassword);
					} else {
						if (vm.passwordExpired === true) {
							startStopProcessing('setPasswordButton', 'setPasswordButtonProcessing', false);
						} else {
							startStopProcessing('setPasswordQuestionButton', 'setPasswordQuestionButtonProcessing', false);
						}

						vm.userName = '';
						vm.newPassword = '';
						vm.confirmPassword = '';
						vm.securityQuestion = '';
						vm.securityAnswer = '';
					}
				} else {
					if (data.passwordValidationMessage) {
						elementNotifier.error(data.passwordValidationMessage, scope.newPasswordElement);
					} else {
						translator.translate('CORE.USER_SECURITY.ERRORS.' + data.failureReason.toUpperCase()).then(function (translated) {
							elementNotifier.error(translated, scope.newPasswordElement);
						});
					}

					if (vm.passwordExpired === true) {
						startStopProcessing('setPasswordButton', 'setPasswordButtonProcessing', false);
					} else {
						startStopProcessing('setPasswordQuestionButton', 'setPasswordQuestionButtonProcessing', false);
					}
				}
			}

			function reject(error) {
				if (vm.passwordExpired === true) {
					startStopProcessing('setPasswordButton', 'setPasswordButtonProcessing', false);
				} else {
					startStopProcessing('setPasswordQuestionButton', 'setPasswordQuestionButtonProcessing', false);
				}
				translator.translate(error.failureReason).then(function (translated) {
					notifier.error(translated);
				});
			}

			/**
          * hides or shows action buttons            
          */
			function startStopProcessing(buttonActive, buttonInactive, startOrStop) {
				if (startOrStop !== false) {
					showSpinner();
					if (scope.showhHideControl) {
						scope.showhHideControl(buttonActive, false);
						scope.showhHideControl(buttonInactive, true);
					}
				} else {
					removeSpinner();
					if (scope.showhHideControl) {
						scope.showhHideControl(buttonActive, true);
						scope.showhHideControl(buttonInactive, false);
					}
				}
			}

			/**
    * Adds spinner to the page			 
    */
			function showSpinner() {
				var opts = {
					length: 19,
					width: 14,
					radius: 42,
					scale: 0.25,
					color: '#000',
					opacity: 0.25,
					zIndex: 2e9
				};

				spinner = modalSpinner.showModalSpinner("#spinnerHolder", opts);
			}

			/**
    * Removes spinner from the page
   */
			function removeSpinner() {
				if (spinner) {
					spinner.remove();
				}
			}
		}

		return SetPasswordController;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAU0C}
// di.core.angular.userSecurity
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var guard = $di.exception.guard;

		module.provider('userSecurityProxy', userSecurityProxyProvider);

		function userSecurityProxyProvider() {
			var config = {
				endpoint: 'app',
				getSecurityQuestionUrl: '',
				requestPasswordResetUrl: '',
				changePasswordUrl: '',
				resetPasswordUrl: '',
				resetPasswordSiteUrl: '',
				getUserUrl: '',
				getQuestionsUrl: '',
				setSecurityQuestionUrl: '',
				setPasswordWithTokenUrl: ''
			};

			var provider = {
				configure: configure,
				$get: $get
			};

			provider.$get.$inject = ['webApiHttp', 'endpoints', 'urlHelper'];

			return provider;

			/**
    * Configure the service
    * @param cfg
    */
			function configure(cfg) {
				guard.throwIfNotAnObject("CAU0C01E", cfg, "cfg");

				config = cfg;
			}

			function $get(http, endpoints, urlHelper) {
				return {
					requestPasswordReset: requestPasswordReset,
					getSecurityQuestion: getSecurityQuestion,
					changePassword: changePassword,
					resetPassword: resetPassword,
					getUser: getUser,
					getSecurityQuestions: getSecurityQuestions,
					setSecurityQuestionAndAnswer: setSecurityQuestionAndAnswer,
					requestPasswordResetOnUserBehalf: requestPasswordResetOnUserBehalf,
					setPasswordWithToken: setPasswordWithToken,
					setPasswordAndQuestionWithToken: setPasswordAndQuestionWithToken
				};

				/**
     * Gets a security question for a given username (email) from the server
     * @param email - Email address of the user we want the question of
     * @returns promise
     */
				function getSecurityQuestion(email) {
					guard.throwIfEmptyString("CAU0C02E", email, "email");

					var requestParams = {
						email: email
					};

					var url = urlHelper.setParameters(config.getSecurityQuestionUrl, requestParams);

					return http.get(url);
				}

				/**
    * Sends a HTTP post request to the server to send an email with password reminder.
    * @param email - Email address entered by a user in the forgot password input control.
    */
				function requestPasswordReset(emailAddress, securityAnswer) {
					guard.throwIfEmptyString("CAU0C03E", emailAddress, "emailAddress");
					guard.throwIfEmptyString("CAU0C04E", securityAnswer, "securityAnswer");

					var request = {
						emailAddress: emailAddress,
						securityAnswer: securityAnswer,
						resetBaseUrl: endpoints.getUrl(config.resetPasswordSiteUrl, config.endpoint)
					};

					return http.post(config.requestPasswordResetUrl, request);
				}

				/**
    * Sends a HTTP post request to the server to change a users password
    * @param username - User name to change the password of.
    * @param oldPassword - The users current password, used for verification
    * @param newPassword - The new password to set. 
    */
				function changePassword(username, oldPassword, newPassword) {
					guard.throwIfEmptyString("CAU0C05E", username, "username");
					guard.throwIfEmptyString("CAU0C06E", oldPassword, "oldPassword");
					guard.throwIfEmptyString("CAU0C07E", newPassword, "newPassword");

					var request = {
						username: username,
						oldPassword: oldPassword,
						newPassword: newPassword
					};

					return http.post(config.changePasswordUrl, request);
				}

				/**
    * Sends a HTTP post request to the server to reset a users password
    * @param resetToken - Token used for password reset
    * @param newPassword - The new password to set. 
    */
				function resetPassword(resetToken, newPassword) {
					guard.throwIfEmptyString("CAU0C08E", resetToken, "resetToken");
					guard.throwIfEmptyString("CAU0C09E", newPassword, "newPassword");

					var request = {
						resetToken: resetToken,
						newPassword: newPassword
					};

					return http.post(config.resetPasswordUrl, request);
				}

				/**
     * Gets a user object for a given username (email) from the server
     * @param email - Email address of the user to get
     * @returns promise
     */
				function getUser(username) {
					guard.throwIfEmptyString("CAU0C0AE", username, "username");

					var requestParams = {
						username: username
					};

					var url = urlHelper.setParameters(config.getUserUrl, requestParams);

					return http.get(url);
				}

				/**
     * Gets a list of possible security questions from the server
     */
				function getSecurityQuestions() {
					return http.get(config.getQuestionsUrl);
				}

				/**
     * Sets a security question and answer against a user
     * @param {} username - to set the question against
     * @param {} securityQuestion - to set against the user
     * @param {} securityAnswer - to set against the user
     */
				function setSecurityQuestionAndAnswer(username, securityQuestion, securityAnswer) {
					guard.throwIfEmptyString("CAU0C0BE", username, "username");
					guard.throwIfEmptyString("CAU0C0CE", securityQuestion, "securityQuestion");
					guard.throwIfNull("CAU0C0DE", securityAnswer, "securityAnswer");

					var request = {
						username: username,
						securityQuestion: securityQuestion,
						securityAnswer: securityAnswer
					};

					return http.post(config.setSecurityQuestionUrl, request);
				}

				/**
    * Sends a HTTP post request to the server to send an email with password reminder on behalf of the user.				
    */
				function requestPasswordResetOnUserBehalf(id, emailAddress) {
					guard.throwIfInvalidId("CAU0C0EE", id, "id");
					guard.throwIfEmptyString("CAU0C0FE", emailAddress, "emailAddress");

					var request = {
						userId: id,
						emailAddress: emailAddress,
						securityAnswer: 'supervisor',
						resetBaseUrl: endpoints.getUrl(config.resetPasswordSiteUrl, config.endpoint)
					};

					return http.post(config.requestPasswordResetUrlOnUserBehalf, request);
				}

				/**
    * Sends a HTTP post request to the server to set user password using reset token.				
    */
				function setPasswordWithToken(username, token, newPassword) {
					guard.throwIfEmptyString("CAU0C0GE", username, "username");
					guard.throwIfEmptyString("CAU0C0HE", token, "token");
					guard.throwIfEmptyString("CAU0C0IE", newPassword, "newPassword");

					var request = {
						username: username,
						token: token,
						newPassword: newPassword
					};

					return http.post(config.setPasswordWithTokenUrl, request);
				}

				/**
    * Sends a HTTP post request to the server to set user password and security question/answer using reset token.				
    */
				function setPasswordAndQuestionWithToken(username, token, newPassword, securityQuestion, securityAnswer) {
					guard.throwIfEmptyString("CAU0C0JE", username, "username");
					guard.throwIfEmptyString("CAU0C0KE", token, "token");
					guard.throwIfEmptyString("CAU0C0LE", newPassword, "newPassword");
					guard.throwIfEmptyString("CAU0C0ME", securityQuestion, "securityQuestion");
					guard.throwIfNull("CAU0C0NE", securityAnswer, "securityAnswer");

					var request = {
						username: username,
						token: token,
						newPassword: newPassword,
						securityQuestion: securityQuestion,
						securityAnswer: securityAnswer
					};

					return http.post(config.setPasswordAndQuestionWithTokenUrl, request);
				}
			}
		}

		return userSecurityProxyProvider;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAU02}
// di.core.angular.utility
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(254), __webpack_require__(257), __webpack_require__(260), __webpack_require__(255), __webpack_require__(258), __webpack_require__(259)], __WEBPACK_AMD_DEFINE_RESULT__ = function (associativeArrayConvertorLoader, guardedInjectorLoader, uniqueIdGeneratorLoader, filtersLoader, identityIncrementorLoader, randomStringGeneratorLoader) {
	'use strict';

	return function (module) {
		associativeArrayConvertorLoader(module);
		guardedInjectorLoader(module);
		uniqueIdGeneratorLoader(module);
		filtersLoader(module);
		identityIncrementorLoader(module);
		randomStringGeneratorLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAU03}
// di.core.angular.utility
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.factory('associativeArrayConvertor', associativeArrayConvertor);

        function associativeArrayConvertor() {
            var guard = $di.exception.guard;
            var util = $di.utility.util;

            return {
                convert: convert
            };

            function convert(itemToConvert, indexer, property) {
                if (util.isArray(itemToConvert)) {
                    return convertArrayToAssociativeArray(itemToConvert, indexer, property);
                } else if (util.isObject(itemToConvert)) {
                    return convertAssoicativeArrayToArray(itemToConvert);
                } else {
                    guard.throwNew("CAU0301E", "itemToConvert must be either an Array or an Object");
                    return [];
                }
            }

            function convertArrayToAssociativeArray(array, indexer, property) {
                if (!util.isDefined(property)) {
                    return _.indexBy(array, indexer);
                }

                var results = {};
                _.each(array, function (obj) {
                    results[obj[indexer]] = obj[property];
                });

                return results;
            }

            function convertAssoicativeArrayToArray(associativeArray) {
                return _.values(associativeArray);
            }
        }

        return associativeArrayConvertor;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF0Y}
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(256)], __WEBPACK_AMD_DEFINE_RESULT__ = function (diYesNoFilterLoader) {
	'use strict';

	return function (module) {
		diYesNoFilterLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF0X}
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.filter('diYesNo', diYesNo);

		diYesNo.$inject = ['translator'];

		function diYesNo(translator) {
			return function (input) {
				return input === true ? translator.instantTranslate('CORE.FILTERS.YES_NO.YES') : input === false ? translator.instantTranslate('CORE.FILTERS.YES_NO.NO') : '';
			};
		}

		return diYesNo;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAU01}
// di.core.angular.utility
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;

        module.factory('guardedInjector', guardedInjector);

        guardedInjector.$inject = ['$injector'];

        /**
         * Guarded injector that will not throw an exception when a get request
         * is made for a component that cannot be resolved
         */
        function guardedInjector($injector) {
            var service = {
                get: get
            };

            return service;

            /**
             * Attempts to resolve the given component from the $injector
             * If the component does not exist, the given object or function is
             * returned instead
             * @param name
             * @param valueIfNotFound
             */
            function get(name, valueIfNotFound) {
                guard.throwIfEmptyString("CAU0102E", name, "name");

                if ($injector.has(name)) {
                    return $injector.get(name);
                } else {
                    return valueIfNotFound;
                }
            }
        }

        return guardedInjector;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF1P}
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.factory('identityIncrementor', identityIncrementor);

		function identityIncrementor() {
			return {
				reset: reset,
				getNext: getNextIdentifier
			};

			/*
    * Sets an identity property named identityName on each element in the collection,
    * starting from identitySeed if specified, or 1 otherwise,
    * using an increment of identityIncrement if specified, or 1 otherwise.
    * Returns the same collection with modified elements
    */
			function reset(collection, identityName, identityIncrement, identitySeed) {
				if (util.isArray(collection) && util.isNonEmptyString(identityName)) {
					_.each(collection, function (item, index) {
						var id = index * (util.isNumber(identityIncrement) ? identityIncrement : 1) + (util.isNumber(identitySeed) ? identitySeed : 1);
						item[identityName] = id;
					});
				}

				return collection;
			}

			/*
    * Returns the next element to be used as identity for the given collection.
    * When the collection is empty, returns the identitySeed if specified, or 1 otherwise
    * When the collection is not empty, returns the maximum identity value incremented by identityIncrement or 1 if identityIncrement is not specified
    */
			function getNextIdentifier(collection, identityName, identityIncrement, identitySeed) {
				if (!util.isNonEmptyArray(collection) || !util.isNonEmptyString(identityName)) {
					return util.isNumber(identitySeed) ? identitySeed : 1;
				}
				var max = _.max(collection, function (item) {
					return item[identityName] || 0;
				});
				return (max[identityName] || 0) + (util.isNumber(identityIncrement) ? identityIncrement : 1);
			}
		}

		return identityIncrementor;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAU0G}
// di.core.angular.utility
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var util = $di.utility.util;
        var guard = $di.exception.guard;

        module.factory('randomStringGenerator', randomStringGenerator);

        /**
         * Generates unique id for html elements
         */
        function randomStringGenerator() {
            var MAX_LENGTH = 10;
            var CHAR_ARRAY = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';

            var service = {
                generate: generate,
                reset: reset
            };

            return service;

            /**
             * Generates unique identifier
             */
            function generate(length) {
                var maxLength = length || MAX_LENGTH;

                return randomString(maxLength, CHAR_ARRAY);
            }

            /**
             * Resets unique identifier for collection
             */
            function reset(collection, identityName, length) {
                if (util.isArray(collection) && util.isNonEmptyString(identityName)) {
                    _.each(collection, function (item) {
                        item[identityName] = generate();
                    });
                }

                return collection;
            }

            function randomString(length, chars) {
                var result = '';
                for (var i = length; i > 0; --i) {
                    result += chars[Math.round(Math.random() * (chars.length - 1))];
                }return result;
            }
        }

        return randomStringGenerator;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAU0G}
// di.core.angular.utility
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;

        module.factory('uniqueIdGenerator', uniqueIdGenerator);

        /**
         * Generates unique id for html elements
         */
        function uniqueIdGenerator() {
            var lastId = 0;

            var service = {
                newId: newId
            };

            return service;

            /**
             * Generates unique id for html elements
             */
            function newId(prefix) {
                var id = (prefix || 'element') + '_' + ++lastId;

                return id;
            }
        }

        return uniqueIdGenerator;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAV02}
// di.core.angular.validation
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(268), __webpack_require__(269), __webpack_require__(270), __webpack_require__(267), __webpack_require__(280), __webpack_require__(273), __webpack_require__(275), __webpack_require__(278), __webpack_require__(283), __webpack_require__(285), __webpack_require__(286), __webpack_require__(284), __webpack_require__(287), __webpack_require__(289), __webpack_require__(288), __webpack_require__(277), __webpack_require__(263), __webpack_require__(274), __webpack_require__(276), __webpack_require__(271), __webpack_require__(272), __webpack_require__(282), __webpack_require__(281), __webpack_require__(279)], __WEBPACK_AMD_DEFINE_RESULT__ = function (diValidateClickDirectiveLoader, diValidateDirectiveLoader, diValidateDirectiveModelLoader, diRequireIfDirectiveLoader, requireIfValidatorLoader, formAnalyserLoader, idValidatorLoader, positiveWholeNumberValidatorLoader, ruleViolationSelectorLoader, validationMessageGeneratorLoader, validationNotifierLoader, validationInitialiserLoader, validationRulesProxyLoader, validationRulesStoreLoader, validationRulesSetterLoader, pastOrTodayValidatorLoader, comparersLoader, greaterValidatorLoader, lessValidatorLoader, equalAlwaysValidatorLoader, equalIfSelfSetValidatorLoader, requiredIfPairSetValidatorLoader, requiredIfPairNotSetValidatorLoader, productCodeCustomValidator) {
	'use strict';

	return function (module) {
		diValidateClickDirectiveLoader(module);
		diValidateDirectiveLoader(module);
		diValidateDirectiveModelLoader(module);
		diRequireIfDirectiveLoader(module);
		requireIfValidatorLoader(module);
		formAnalyserLoader(module);
		idValidatorLoader(module);
		positiveWholeNumberValidatorLoader(module);
		ruleViolationSelectorLoader(module);
		validationMessageGeneratorLoader(module);
		validationNotifierLoader(module);
		validationInitialiserLoader(module);
		validationRulesProxyLoader(module);
		validationRulesStoreLoader(module);
		validationRulesSetterLoader(module);
		pastOrTodayValidatorLoader(module);
		comparersLoader(module);
		greaterValidatorLoader(module);
		lessValidatorLoader(module);
		equalAlwaysValidatorLoader(module);
		equalIfSelfSetValidatorLoader(module);
		requiredIfPairSetValidatorLoader(module);
		requiredIfPairNotSetValidatorLoader(module);
		module.service('productCodeCustomValidator', productCodeCustomValidator.ProductCodeCustomValidator);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAV0K}
// di.core.angular.validation
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.config(comparerRegistrarConfig);

        comparerRegistrarConfig.$inject = ['comparerRegistrarProvider'];

        function comparerRegistrarConfig(comparerRegistrar) {
            comparerRegistrar.addComparer('momentComparer');
        }
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAV0J}
// di.core.angular.validation
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(262), __webpack_require__(264), __webpack_require__(265), __webpack_require__(266)], __WEBPACK_AMD_DEFINE_RESULT__ = function (configLoader, comparerRegistrarLoader, defaultComparerLoader, momentComparerLoader) {
	'use strict';

	return function (module) {
		configLoader(module);
		comparerRegistrarLoader(module);
		defaultComparerLoader(module);
		momentComparerLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF07}
//di.core.angular.validation.comparers
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var guard = $di.exception.guard;
		module.provider('comparerRegistrar', comparerRegistrarProvider);

		/**
         * Provides comparers used by the custom compare validator
         */
		function comparerRegistrarProvider() {
			var comparerNames = ['defaultComparer'];
			var comparers = [];

			var provider = {
				addComparer: addComparer,
				$get: $get
			};

			provider.$get.$inject = ['$injector'];
			return provider;

			/**
            * Registers the comparer to the list of available comparers
            * @param {} comparerName 
            * @returns {} 
            */
			function addComparer(comparerName) {
				guard.throwIfEmptyString("DEF0701E", comparerName, "comparerName");

				if (comparerNames.indexOf(comparerName) === -1) {
					comparerNames.push(comparerName);
				}
			}

			/**
             * Gets the comparer proxy
             * @param {} $inject 
             * @returns {} 
             */
			function $get($inject) {
				angular.forEach(comparerNames, function (comparerName) {
					var comparer = $inject.get(comparerName);
					comparers[comparer.name] = comparer;
				});

				var service = {
					compare: compare
				};

				return service;

				function compare(firstValue, secondValue, compareOperation, comparerName) {
					var comparer = comparers[comparerName] || comparers['default'];
					return comparer.compare(firstValue, secondValue, compareOperation);
				}
			}
		}

		return comparerRegistrarProvider;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF08}
//di.core.angular.validation.comparers
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.factory('defaultComparer', defaultComparer);

		/**
         * Comparer to compare given values
         */
		function defaultComparer() {
			var service = {
				name: 'default',
				compare: compare
			};

			return service;

			/**
             * Returns the result of comparing the given values by using the specified operation
             */
			function compare(firstValue, secondValue, compareOperation) {
				try {
					switch (compareOperation) {
						case 'equalAlways':
							return firstValue === secondValue;

						case 'equalIfSelfSet':
							return util.isNullOrUndefined(firstValue) || firstValue === '' || firstValue === secondValue;

						case 'requiredIfPairSet':
							if (util.isNullOrUndefined(secondValue) || secondValue === '') {
								return true;
							}
							return !util.isNullOrUndefined(firstValue) && firstValue !== '';

						case 'requiredIfPairNotSet':
							if (util.isNullOrUndefined(secondValue) || secondValue === '') {
								return !util.isNullOrUndefined(firstValue) && firstValue !== '';
							}
							return true;
						default:
							return false;
					}
				} catch (e) {
					return false;
				}
			}
		}

		return defaultComparer;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF09}
//di.core.angular.validation.comparers
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5)], __WEBPACK_AMD_DEFINE_RESULT__ = function (moment) {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.factory('momentComparer', momentComparer);

		momentComparer.$inject = ['diMoment'];

		/**
         * Comparer to compare moments
         */
		function momentComparer(diMoment) {
			var service = {
				name: 'moment',
				compare: compare
			};

			return service;

			/**
             * Returns the result of comparing the given values by using the specified operation
             */
			function compare(firstValue, secondValue, compareOperation) {
				try {
					var firstValueAsMoment = getMoment(firstValue);
					var secondValueAsMoment = getMoment(secondValue);

					switch (compareOperation) {
						case 'equalAlways':
							return equalAlways(firstValue, secondValue, firstValueAsMoment, secondValueAsMoment);

						case 'equalIfSelfSet':
							return util.isNullOrUndefined(firstValue) || firstValue === '' || !firstValueAsMoment.isValid() || equalAlways(firstValue, secondValue, firstValueAsMoment, secondValueAsMoment);

						case 'requiredIfPairSet':
							if (util.isNullOrUndefined(secondValue) || secondValue === '' || !secondValueAsMoment.isValid()) {
								return true;
							}
							return !util.isNullOrUndefined(firstValue) && firstValue !== '' && firstValueAsMoment.isValid();

						case 'requiredIfPairNotSet':
							if (util.isNullOrUndefined(secondValue) || secondValue === '' || !secondValueAsMoment.isValid()) {
								return !util.isNullOrUndefined(firstValue) && firstValue !== '' && firstValueAsMoment.isValid();
							}
							return true;

						default:
							return false;
					}
				} catch (e) {
					return false;
				}
			}
			/*Returns a moment for the given value*/
			function getMoment(value) {
				if (value instanceof moment) return value;
				return diMoment(value);
			}

			/* Returns true if both values are null, undefined or empty string, or one of the values is an invalid moment, or the moments are the same, and false otherwise*/
			function equalAlways(firstValue, secondValue, firstValueAsMoment, secondValueAsMoment) {
				return firstValue === secondValue || (util.isNullOrUndefined(firstValue) || firstValue === '') && (util.isNullOrUndefined(secondValue) || secondValue === '') || !firstValueAsMoment.isValid() || !secondValueAsMoment.isValid() || firstValueAsMoment.isSame(secondValueAsMoment); // equality operators do not not work correctly with moment
			}
		}

		return momentComparer;
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAV0H}
//di.core.angular.validation
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.directive('diRequireIf', diRequireIf);

        diRequireIf.$inject = ['requireIfValidator'];

        function diRequireIf(validator) {
            return {
                restrict: 'A',
                require: "ngModel",
                scope: {
                    otherModelValue: "=diRequireIf"
                },
                link: function link(scope, element, attributes, ngModel) {

                    ngModel.$validators.requireIf = function (modelValue) {
                        return validator.validate(modelValue, scope.otherModelValue);
                    };

                    scope.$watch("otherModelValue", function () {
                        ngModel.$validate();
                    });
                }
            };
        };

        return diRequireIf;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAV0C}
// di.core.angular.validation
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.directive('diValidateClick', diValidateClick);

        diValidateClick.$inject = ['$parse', 'formAnalyser'];

        /**
         * Directive for assigning ng-click event which only fires if the form
         * closest to the target element is valid
         */
        function diValidateClick($parse, formAnalyser) {
            return {
                restrict: 'A',
                compile: compile
            };

            function compile($element, attr) {
                var fn = $parse(attr.diValidateClick);

                return function ngEventHandler(scope, element) {
                    element.on('click', function (event) {
                        var callback = function callback() {
                            fn(scope, { $event: event });
                        };

                        var form = formAnalyser.getForm(element);

                        formAnalyser.dirtyTrackedElements(form, true);

                        var formIsValid = formAnalyser.isFormValid(form);

                        // We set the form to be submitted here to set the Angular $submitted flag to true 
                        // as the default di-button type has been changed from "submit" to "button".
                        var formInstance = formAnalyser.getFormInstance(scope);

                        if (formInstance) {
                            formInstance.$setSubmitted(true);
                        }

                        if (formIsValid) {
                            scope.$apply(callback);
                        }
                    });
                };
            }
        }

        return diValidateClick;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAV03}
// di.core.angular.validation
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ng) {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		$di.event.jqueryEventSubscriber.listenToVal();

		module.directive('diValidate', diValidate);

		diValidate.$inject = ['$compile', '$interpolate', 'validationNotifier', 'validationMessageGenerator', 'translator', 'formAnalyser', 'ruleViolationSelector', '$timeout', '$q'];

		/**
   * Attribute directive for validating form elements
   */
		function diValidate($compile, $interpolate, validationNotifier, validationMessageGenerator, translator, formAnalyser, ruleViolationSelector, $timeout, $q) {
			return {
				priority: 1000,
				restrict: 'A',
				terminal: true,
				link: link
			};

			function link(scope, uiElement, attrs) {
				var unsubscribeErrorWatch = function unsubscribeErrorWatch() {};
				var validatedElement;
				var focusElement;
				var notificationElement;
				var form = formAnalyser.getForm(uiElement);
				var elementWithValidationModel = formAnalyser.getElementWithValidationModel(uiElement);

				var modelName = formAnalyser.getValidationModel(elementWithValidationModel);
				if (modelName === "{{::diValidateModel}}") {
					modelName = interpolate(modelName);
				}

				var propertyName = interpolate(attrs.diValidate);
				var elementWorksWithValdr = checkElementWorksWithValdr();
				var elementIsBoundToValidationProperty = checkElementIsBoundToValidationProperty();
				var validateOnBlur = interpolate(attrs.validateOnBlur, 'false') === 'true';
				var checkCount = 0;

				if (elementWorksWithValdr && elementIsBoundToValidationProperty) {
					validatedElement = uiElement;
					focusElement = uiElement;
					notificationElement = uiElement;

					addFocusEvents('focus', 'blur');

					var eventName = validateOnBlur ? 'blur' : 'input';

					uiElement.on(eventName, checkErrorState);
				} else {
					scope.$evalAsync(function () {
						var explicitFocusElement = uiElement.find('[validation-focus-target]');
						var explicitNotificationElement = uiElement.find('[validation-notification-target]');

						focusElement = explicitFocusElement.length ? explicitFocusElement : uiElement.parent();
						notificationElement = explicitNotificationElement.length ? explicitNotificationElement : uiElement;

						if (explicitFocusElement.length) {
							addFocusEvents('focus', 'blur');
						} else {
							addFocusEvents('focusin', 'focusout');
						}
					});

					validatedElement = ng.element('<input type="text" style="display: none" />');
					validatedElement.attr('ng-model', attrs.validationModel || attrs.ngModel);

					uiElement.parent().append(validatedElement);

					uiElement.change(function () {
						validatedElement.val(uiElement.val());
					});

					formAnalyser.trackElement(form, validatedElement);
				}

				addValdrAttributes(validatedElement);

				validatedElement.on('val', function () {
					checkErrorState();
				});

				formAnalyser.trackElement(form, uiElement);

				scope.$on('$destroy', function () {
					unsubscribeErrorWatch();
					formAnalyser.forgetElement(form, uiElement);
				});

				uiElement.removeAttr('di-validate');

				if (validatedElement !== uiElement) {
					$compile(validatedElement)(scope);
				}

				$compile(uiElement)(scope);

				return;

				function checkErrorState() {
					checkCount++;

					var currentCheckCount = checkCount;

					$timeout(function () {
						if (currentCheckCount === checkCount) {
							setErrorState(checkIsInvalid());
						}
					}, 200);
				}

				function addFocusEvents(inEvent, outEvent) {
					focusElement.on(inEvent, function () {
						if (getErrorState()) {
							showNotification();
						}
					});

					focusElement.on(outEvent, function () {
						hideNotification();
					});
				}

				function checkIsInvalid() {
					var hasInvalid = validatedElement.hasClass('ng-invalid');
					var warnWhenClean = attrs.validationWarnWhenClean && attrs.validationWarnWhenClean.toLowerCase() === 'true';

					var showByCleanDirty = warnWhenClean || uiElement.hasClass('ng-dirty');
					var isError = hasInvalid && showByCleanDirty;

					return isError;
				}

				function setErrorState(hasError) {
					var elementHasFocus = focusElement.is(':focus');
					var stateHasChanged = hasError !== getErrorState();

					if (stateHasChanged) {
						uiElement.toggleClass('has-errors', hasError);
					}

					if (elementHasFocus && hasError) {
						if (stateHasChanged) {
							showNotification();
						}
					} else {
						hideNotification();
					}
				}

				function getErrorState() {
					return uiElement.hasClass('has-errors');
				}

				function checkElementWorksWithValdr() {
					var nodeName = uiElement[0].nodeName;

					return nodeName === 'INPUT' || nodeName === 'SELECT' || nodeName === 'TEXTAREA';
				}

				function checkElementIsBoundToValidationProperty() {
					return !attrs.validationModel || attrs.validationModel === attrs.ngModel;
				}

				function addValdrAttributes(element) {
					element.attr('valdr-type', modelName);
					element.attr('name', propertyName);
				}

				function showNotification() {
					var errorMessagePromise = getErrorMessage();
					if (errorMessagePromise) {
						errorMessagePromise.then(function (errorMessage) {
							var validationNotificationPosition = interpolate(attrs.validationMessagePosition, 'top');
							validationNotifier.showNotification(notificationElement, errorMessage, validationNotificationPosition);
						});
					} else {
						setErrorState(false);
					}
				}

				function hideNotification() {
					validationNotifier.hideNotification(notificationElement);
				}

				function getErrorMessage() {
					var errorMessage = interpolate(attrs.validationMessage, '');

					if (util.isNonEmptyString(errorMessage)) {
						return translator.translate(errorMessage);
					}

					if (util.isNonEmptyString(errorMessage)) {
						return translator.translate(errorMessage);
					}
					var propertyDisplayName = interpolate(attrs.validationModelDisplayName, propertyName);
					var propertyCompareDisplayName = interpolate(attrs.validationModelCompareDisplayName);
					var ruleViolations = formAnalyser.getRuleViolations(validatedElement);

					if (util.isUndefined(ruleViolations)) {
						return;
					}

					var selectedRuleViolation = ruleViolationSelector.getMostImportantRuleViolation(ruleViolations, modelName, propertyName);

					errorMessage = validationMessageGenerator.generateMessage(selectedRuleViolation, propertyDisplayName, propertyCompareDisplayName || (selectedRuleViolation || {}).requireModelsDisplayName || propertyName);

					return $q.when(errorMessage);
				}

				function interpolate(value, valueIfEmpty) {
					var result = (value ? $interpolate(value)(scope) : '') || valueIfEmpty;

					return result;
				}
			}
		}

		return diValidate;
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAV04}
// di.core.angular.validation
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;

        module.directive('diValidateModel', diValidateModel);

        /**
         * Attribute directive for assiging validation model to a form
         */
        function diValidateModel() {
            return {
                restrict: 'A',
                link: link
            };

            function link(scope, element, attrs) {
                element.attr('valdr-type', attrs.diValidateModel);
            }
        }

        return diValidateModel;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:/AV04}
// di.core.angular.validation
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.factory('equalAlwaysValidator', equalAlwaysValidator);

		equalAlwaysValidator.$inject = ['comparerRegistrar'];

		/**
   * returns false when value is not equal to the constraint value and true otherwise
   */
		function equalAlwaysValidator(comparerRegistrar) {
			var service = {
				name: 'equalAlways',
				validate: validate
			};

			return service;

			function validate(value, params, requiredModels) {
				var propertyName = (params["requireModels"] || [])[0];
				if (propertyName) {
					var comparerName = params["clientComparerName"] || "default";

					var otherModelValue = (requiredModels || {})[propertyName];

					var valid = comparerRegistrar.compare(value, otherModelValue, 'equalAlways', comparerName);
					return valid;
				}
				return true;
			}
		}

		return equalAlwaysValidator;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:/AV02}
// di.core.angular.validation
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.factory('equalIfSelfSetValidator', equalIfSelfSetValidator);

		equalIfSelfSetValidator.$inject = ['comparerRegistrar'];

		/**
   * returns false when value is set and not equal to the constraint value and true otherwise
   */
		function equalIfSelfSetValidator(comparerRegistrar) {
			var service = {
				name: 'equalIfSelfSet',
				validate: validate
			};

			return service;

			function validate(value, params, requiredModels) {
				var propertyName = (params["requireModels"] || [])[0];
				if (propertyName) {
					var comparerName = params["clientComparerName"] || "default";

					var otherModelValue = (requiredModels || {})[propertyName];

					var valid = comparerRegistrar.compare(value, otherModelValue, 'equalIfSelfSet', comparerName);
					return valid;
				}
				return true;
			}
		}

		return equalIfSelfSetValidator;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAV0D}
// di.core.angular.validation
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ng) {
    'use strict';

    return function (module) {
        var util = $di.utility.util;

        $di.event.jqueryEventSubscriber.listenToVal();

        module.factory('formAnalyser', formAnalyser);

        formAnalyser.$inject = ['$timeout'];

        /**
         * Helper service for analysing form and input elements during validation
         */
        function formAnalyser($timeout) {
            var service = {
                getForm: getForm,
                getFormInstance: getFormInstance,
                getElementWithValidationModel: getElementWithValidationModel,
                getValidationModel: getValidationModel,
                isFormValid: isFormValid,
                getRuleViolations: getRuleViolations,
                trackElement: trackElement,
                forgetElement: forgetElement,
                getTrackedElements: getTrackedElements,
                dirtyTrackedElements: dirtyTrackedElements,
                allowCascadingDirty: allowCascadingDirty
            };

            return service;

            /**
             * Gets the html form containing the given element
             * @param element
             */
            function getForm(element) {
                element = ng.element(element);
                var form = element.closest('form, ng-form, [ng-form]');

                return form;
            }

            /**
             * Gets the angular form instance from the nearest scope object
             * @param element
             */
            function getFormInstance(scope, formInstance) {
                if (!scope) {
                    return null;
                }

                if (formInstance) {
                    return formInstance;
                }

                if (util.isDefined(scope.$$parentForm)) {
                    return scope.$$parentForm;
                }

                var foundForm = _.find(scope, function (item) {
                    if (util.isObject(item) && util.isDefined(item.$$parentForm)) {
                        return item.$$parentForm;
                    }
                });

                if (foundForm) {
                    return foundForm;
                }

                return getFormInstance(scope.$parent, foundForm);
            }

            function getElementWithValidationModel(element) {
                var el = ng.element(ng.element(element[0]).closest("[di-validate-model]"));

                return el;
            }

            /**
             * Gets validation model of the form associated with the given element
             * @param element
             */
            function getValidationModel(form) {
                var model = form.attr('di-validate-model');

                return model;
            }

            /**
             * Checks if the form associated with the given element is valid
             * @param element
             */
            function isFormValid(form) {
                form = ng.element(form);
                var isValid = form.hasClass('ng-valid');

                return isValid;
            }

            /**
             * Gets the ruleViolations associated with the given element
             * @param element
             */
            function getRuleViolations(element) {
                var ngModelController = element.data('$ngModelController');
                var ruleViolations = ngModelController.valdrViolations;

                return ruleViolations;
            }

            /**
             * Adds the given element to the array of validated elements stored in the form's data collection
             * @param element
             */
            function trackElement(form, element) {
                var trackedElements = getTrackedElements(form);

                trackedElements.push(element);
            }

            /**
             * Removes the given element from the array of tracked elements on the form
             * @param {} form 
             * @param {} element 
             * @returns {} 
             */
            function forgetElement(form, element) {
                var trackedElements = getTrackedElements(form);

                var i = trackedElements.indexOf(element);

                if (i !== -1) {
                    trackedElements.splice(i, 1);
                }
            }

            /**
             * Gets the array of validated elements stored in the form's data collection
             * @param form
             */
            function getTrackedElements(form) {
                form = ng.element(form);

                var trackedElements = form.data('trackedElements');

                if (!trackedElements) {
                    trackedElements = [];

                    form.data('trackedElements', trackedElements);
                }

                return trackedElements;
            }

            /**
             * Marks all tracked elements as dirty
             * @param {} form 
             * @param {} dirtyChildForms 
             * @returns {} 
             */
            function dirtyTrackedElements(form, dirtyChildForms) {
                form = ng.element(form);

                if (!dirtyChildForms) {
                    $timeout(function () {
                        dirtyTrackedElementsForForm(form);
                    });

                    return;
                }

                $timeout(function () {
                    var allForms = form.parent().find('form, ng-form, [ng-form]');

                    for (var i = 0; i < allForms.length; i++) {
                        var formToDirty = ng.element(allForms[i]);

                        if (formToDirty.data('excludeFromValidationDirtying')) {
                            continue;
                        }

                        dirtyTrackedElementsForForm(formToDirty);
                    }
                });

                return;

                function dirtyTrackedElementsForForm(formToDirty) {
                    var trackedElements = getTrackedElements(formToDirty);

                    if (util.isArray(trackedElements)) {
                        for (var ii = 0; ii < trackedElements.length; ii++) {
                            var element = trackedElements[ii];

                            element.toggleClass('ng-dirty', true);
                            element.trigger('val');
                            element.trigger('input');
                        }
                    }
                }
            }

            function allowCascadingDirty(form, allow) {
                form = ng.element(form);

                if (allow) {
                    form.data('excludeFromValidationDirtying', 'true');
                } else {
                    form.removeData('excludeFromValidationDirtying');
                }
            }
        }

        return formAnalyser;
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF10}
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.factory('greaterValidator', greaterValidator);
		var util = $di.utility.util;

		/**
         * Validator service for validating numbers are greater than the constraint value
         */
		function greaterValidator() {
			var service = {
				name: 'greater',
				validate: validate
			};

			return service;

			/**
             * Tests that the given number is greater than the specified constraint
             */
			function validate(value, constraint) {
				if (util.isNullOrUndefined(value) || value === '') {
					return true;
				}

				var minValue = Number(constraint.value);
				var valueAsNumber = Number(value);

				if (!util.isNumber(valueAsNumber)) {
					return false;
				}

				return valueAsNumber > minValue;
			}
		}

		return greaterValidator;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAV01}
// di.core.angular.validation
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;

        module.factory('idValidator', idValidator);

        /**
         * Validator service for validating Id values
         */
        function idValidator() {
            var service = {
                name: 'id',
                validate: validate
            };

            return service;

            /**
             * Tests that the given value is a valid Id
             * @param value
             * @param args
             */
            function validate(value, args) {
                try {
                    guard.throwIfInvalidId("", parseFloat(value), "value");

                    return true;
                } catch (e) {
                    return false;
                }
            }
        }

        return idValidator;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF11}
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.factory('lessValidator', lessValidator);
		var util = $di.utility.util;

		/**
         * Validator service for validating numbers are less than the constraint value
         */
		function lessValidator() {
			var service = {
				name: 'less',
				validate: validate
			};

			return service;

			/**
             * Tests that the given number is less than the specified constraint
             */
			function validate(value, constraint) {
				if (util.isNullOrUndefined(value) || value === '') {
					return true;
				}

				var maxValue = Number(constraint.value);
				var valueAsNumber = Number(value);

				if (!util.isNumber(valueAsNumber)) {
					return false;
				}

				return valueAsNumber < maxValue;
			}
		}

		return lessValidator;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF05}
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5)], __WEBPACK_AMD_DEFINE_RESULT__ = function (moment) {
	'use strict';

	return function (module) {
		module.factory('pastOrTodayValidator', pastOrTodayValidator);

		pastOrTodayValidator.$inject = ['diMoment'];

		/**
         * Validator service for validating dates are in the past or today
         */
		function pastOrTodayValidator(diMoment) {
			var service = {
				name: 'pastOrToday',
				validate: validate
			};

			return service;

			/**
             * Tests that the given date is a date in the past or today
             */
			function validate(value) {
				try {
					return isInThePastOrToday(value);
				} catch (e) {
					return false;
				}
			}

			function isInThePastOrToday(value) {
				if (isEmpty(value)) return true;

				var date = diMoment(value);
				if (!date.isValid()) {
					return false;
				}

				date = date.startOf('day'); // set to 12:00 am today
				var today = moment().startOf('day');
				return date <= today;
			}

			function isEmpty(value) {
				return value === undefined || value === null || value === '';
			}
		}

		return pastOrTodayValidator;
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAV0F}
// di.core.angular.validation
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.factory('positiveWholeNumberValidator', positiveWholeNumberValidator);

        /**
         * Validator service for validating positive whole numbers values
         */
        function positiveWholeNumberValidator() {
            var service = {
                name: 'positiveWholeNumber',
                validate: validate
            };

            return service;

            /**
             * Tests that the given value is a valid positive whole number
             */
            function validate(value) {
                try {

                    return isQuantity(value);
                } catch (e) {
                    return false;
                }

                function isQuantity(value) {
                    var regex = /^0$|^[1-9][0-9]*$/;

                    return regex.test(value);
                }
            }
        }

        return positiveWholeNumberValidator;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ProductCodeCustomValidator = function () {
    function ProductCodeCustomValidator(comparerRegistrar) {
        _classCallCheck(this, ProductCodeCustomValidator);

        this._comparerRegistrar = comparerRegistrar;
        this.name = 'productCodeCustom';
    }

    _createClass(ProductCodeCustomValidator, [{
        key: "validate",
        value: function validate(value, params, requiredModels) {
            var productType = (requiredModels || {})["productType"];
            var propertyName = (params["requireModels"] || [])[1];

            if (productType && propertyName) {
                var otherModelValue = (requiredModels || {})[propertyName];
                var comparerName = params["clientComparerName"] || "default";

                //first check is service product type
                if (productType === 2) {
                    return true;
                } else {
                    //perform a requiredIfPairNotSet comparison 
                    var valid = this._comparerRegistrar.compare(value, otherModelValue, 'requiredIfPairNotSet', comparerName);
                    return valid;
                }
            }
            return true;
        }
    }]);

    return ProductCodeCustomValidator;
}();

ProductCodeCustomValidator.prototype.constructor.$inject = ['comparerRegistrar'];

exports.ProductCodeCustomValidator = ProductCodeCustomValidator;

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAV0I}
// di.core.angular.validation
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var util = $di.utility.util;

        module.factory('requireIfValidator', requireIfValidator);

        /**
         * Validator service for validating conditionally required values
         */
        function requireIfValidator() {
            var service = {
                validate: validate
            };

            return service;

            /**
             * Tests for required value if second value is provided            
             */
            function validate(firstValue, secondValue) {
                if (util.isNonEmptyString(secondValue)) return util.isNonEmptyString(firstValue);else return true;
            }
        }

        return requireIfValidator;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:/AV05}
// di.core.angular.validation
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.factory('requiredIfPairNotSetValidator', requiredIfPairNotSetValidator);

		requiredIfPairNotSetValidator.$inject = ['comparerRegistrar'];

		/**
   * returns false when value is not set and constraint value is not set and true otherwise
   */
		function requiredIfPairNotSetValidator(comparerRegistrar) {
			var service = {
				name: 'requiredIfPairNotSet',
				validate: validate
			};

			return service;

			function validate(value, params, requiredModels) {
				var propertyName = (params["requireModels"] || [])[0];
				if (propertyName) {
					var comparerName = params["clientComparerName"] || "default";

					var otherModelValue = (requiredModels || {})[propertyName];

					var valid = comparerRegistrar.compare(value, otherModelValue, 'requiredIfPairNotSet', comparerName);
					return valid;
				}
				return true;
			}
		}

		return requiredIfPairNotSetValidator;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:/AV03}
// di.core.angular.validation
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.factory('requiredIfPairSetValidator', requiredIfPairSetValidator);

		requiredIfPairSetValidator.$inject = ['comparerRegistrar'];

		/**
   * returns false when value is not set and constraint value is set and true otherwise
   */
		function requiredIfPairSetValidator(comparerRegistrar) {
			var service = {
				name: 'requiredIfPairSet',
				validate: validate
			};

			return service;

			function validate(value, params, requiredModels) {
				var propertyName = (params["requireModels"] || [])[0];
				if (propertyName) {
					var comparerName = params["clientComparerName"] || "default";

					var otherModelValue = (requiredModels || {})[propertyName];

					if (otherModelValue !== null && otherModelValue !== undefined && otherModelValue.toString() === 'NaN') return true;

					var valid = comparerRegistrar.compare(value, otherModelValue, 'requiredIfPairSet', comparerName);
					return valid;
				}
				return true;
			}
		}

		return requiredIfPairSetValidator;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAV0E}
// di.core.angular.validation
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;

        module.factory('ruleViolationSelector', ruleViolationSelector);

        ruleViolationSelector.$inject = ['validationRulesStore'];

        /**
         * Retrieves ruleViolation entries from an array of ruleViolations
         */
        function ruleViolationSelector(validationRulesStore) {
            var service = {
                getMostImportantRuleViolation: getMostImportantRuleViolation
            };

            return service;

            /**
             * Selects the rule violation with the highest priority validation rule
             * @param ruleViolations
             * @param modelName
             * @param propertyName
             */
            function getMostImportantRuleViolation(ruleViolations, modelName, propertyName) {
                guard.throwIfNotArray("CAV0E01E", ruleViolations, "ruleViolations");

                var validationRules = validationRulesStore.getValidationRules();
                var highestPriority = 0;
                var ruleViolation;
                var validationRule;
                var selectedRuleViolation;

                for (var i = 0; i < ruleViolations.length; i++) {
                    ruleViolation = ruleViolations[i];
                    validationRule = validationRules[modelName][propertyName][ruleViolation.validator];

                    if (highestPriority === 0 || validationRule.priority < highestPriority) {
                        highestPriority = validationRule.priority;

                        selectedRuleViolation = ruleViolation;
                    }
                }

                return selectedRuleViolation;
            }
        }

        return ruleViolationSelector;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAV08}
// di.core.angular.validation
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;

        module.provider('validationInitialiser', ValidationInitialiserProvider);

        ValidationInitialiserProvider.$inject = ['valdrProvider'];

        /**
         * Manages validation configuration and setup
         */
        function ValidationInitialiserProvider(valdrProvider) {
            var definitions = {
                rules: {
                    size: {
                        messageMask: 'CORE.VALIDATION.RULES.MESSAGE_MASKS.SIZE'
                    },
                    minLength: {
                        messageMask: 'CORE.VALIDATION.RULES.MESSAGE_MASKS.MIN_LENGTH'
                    },
                    maxLength: {
                        messageMask: 'CORE.VALIDATION.RULES.MESSAGE_MASKS.MAX_LENGTH'
                    },
                    min: {
                        messageMask: 'CORE.VALIDATION.RULES.MESSAGE_MASKS.MIN'
                    },
                    max: {
                        messageMask: 'CORE.VALIDATION.RULES.MESSAGE_MASKS.MAX'
                    },
                    required: {
                        messageMask: 'CORE.VALIDATION.RULES.MESSAGE_MASKS.REQUIRED'
                    },
                    pattern: {
                        messageMask: 'CORE.VALIDATION.RULES.MESSAGE_MASKS.PATTERN'
                    },
                    email: {
                        messageMask: 'CORE.VALIDATION.RULES.MESSAGE_MASKS.EMAIL'
                    },
                    digits: {
                        messageMask: 'CORE.VALIDATION.RULES.MESSAGE_MASKS.DIGITS'
                    },
                    url: {
                        messageMask: 'CORE.VALIDATION.RULES.MESSAGE_MASKS.URL'
                    },
                    future: {
                        messageMask: 'CORE.VALIDATION.RULES.MESSAGE_MASKS.FUTURE'
                    },
                    past: {
                        messageMask: 'CORE.VALIDATION.RULES.MESSAGE_MASKS.PAST'
                    },
                    id: {
                        messageMask: 'CORE.VALIDATION.RULES.MESSAGE_MASKS.ID'
                    },
                    positiveWholeNumber: {
                        messageMask: 'CORE.VALIDATION.RULES.MESSAGE_MASKS.POSITIVE_WHOLE_NUMBER'
                    },
                    equalIfSelfSet: {
                        messageMask: 'CORE.VALIDATION.RULES.MESSAGE_MASKS.EQUAL_IF_SELF_SET'
                    },
                    equalAlways: {
                        messageMask: 'CORE.VALIDATION.RULES.MESSAGE_MASKS.EQUAL_ALWAYS'
                    },
                    requiredIfPairSet: {
                        messageMask: 'CORE.VALIDATION.RULES.MESSAGE_MASKS.REQUIRED_IF_PAIR_SET'
                    },
                    requiredIfPairNotSet: {
                        messageMask: 'CORE.VALIDATION.RULES.MESSAGE_MASKS.REQUIRED_IF_PAIR_NOT_SET'
                    },
                    productCodeCustom: {
                        messageMask: 'CORE.VALIDATION.RULES.MESSAGE_MASKS.REQUIRED_IF_PAIR_NOT_SET'
                    },
                    pastOrToday: {
                        messageMask: 'CORE.VALIDATION.RULES.MESSAGE_MASKS.PAST_OR_TODAY'
                    },
                    greater: {
                        messageMask: 'CORE.VALIDATION.RULES.MESSAGE_MASKS.MIN_EXCLUSIVE'
                    },
                    less: {
                        messageMask: 'CORE.VALIDATION.RULES.MESSAGE_MASKS.MAX_EXCLUSIVE'
                    }
                }
            };

            var provider = {
                addValidator: addValidator,
                $get: $get
            };

            provider.$get.$inject = ['valdr'];

            return provider;

            /**
             * Adds a custom validator
             * @param validationRules
             */
            function addValidator(validatorServiceName) {
                guard.throwIfEmptyString("CAV0801E", validatorServiceName, "validatorServiceName");

                valdrProvider.addValidator(validatorServiceName);
            }

            function $get(valdr) {
                var service = {
                    definitions: definitions,
                    applyValidationRules: applyValidationRules
                };

                return service;

                /**
                 * Applies given validationRules
                 * @param validationRules
                 */
                function applyValidationRules(validationRules) {
                    guard.throwIfNotAnObject("CAV0803E", validationRules, "validationRules");

                    valdr.addConstraints(validationRules);
                }
            }
        }

        return ValidationInitialiserProvider;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAV0B}
// di.core.angular.validation
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;

        module.factory('validationMessageGenerator', validationMessageGenerator);

        validationMessageGenerator.$inject = ['validationInitialiser', 'translator'];

        /**
         * Service for generating validation error messages
         */
        function validationMessageGenerator(validationInitialiser, translator) {
            var service = {
                generateMessage: generateMessage
            };

            return service;

            /**
             * Genererates an error message for the given ruleViolsation and property display name
             * @param ruleViolations
             * @param displayName
             */
            function generateMessage(ruleViolation, displayName, compareDisplayName) {
                guard.throwIfNotAnObject("CAV0B01E", ruleViolation, "ruleViolation");
                guard.throwIfEmptyString("CAV0B02E", displayName, "displayName");
                guard.throwIfUndefined("CAV0B04E", validationInitialiser.definitions.rules[ruleViolation.validator], "Unknown validation rule: '" + ruleViolation.validator + "'");

                var messageMask = validationInitialiser.definitions.rules[ruleViolation.validator].messageMask;
                var translationArgs = {};

                switch (ruleViolation.validator) {
                    case 'size':
                        translationArgs = { displayName: displayName, min: ruleViolation.min, max: ruleViolation.max };
                        break;

                    case 'minLength':
                        translationArgs = { displayName: displayName, number: ruleViolation.number };
                        break;

                    case 'maxLength':
                        translationArgs = { displayName: displayName, number: ruleViolation.number };
                        break;

                    case 'min':
                        translationArgs = { displayName: displayName, value: ruleViolation.value };
                        break;

                    case 'max':
                        translationArgs = { displayName: displayName, value: ruleViolation.value };
                        break;

                    case 'required':
                        translationArgs = { displayName: displayName };
                        break;

                    case 'pattern':
                        translationArgs = { displayName: displayName };
                        break;

                    case 'email':
                        translationArgs = { displayName: displayName };
                        break;

                    case 'digits':
                        translationArgs = { displayName: displayName, fraction: ruleViolation.fraction };
                        break;

                    case 'url':
                        translationArgs = { displayName: displayName };
                        break;

                    case 'future':
                        translationArgs = { displayName: displayName };
                        break;

                    case 'past':
                        translationArgs = { displayName: displayName };
                        break;

                    case 'id':
                        translationArgs = { displayName: displayName };
                        break;

                    case 'positiveWholeNumber':
                        translationArgs = { displayName: displayName };
                        break;

                    case 'equalAlways':
                        translationArgs = { displayName: displayName, compareDisplayName: compareDisplayName };
                        break;

                    case 'equalIfSelfSet':
                        translationArgs = { displayName: displayName, compareDisplayName: compareDisplayName };
                        break;

                    case 'requiredIfPairSet':
                        translationArgs = { displayName: displayName, compareDisplayName: compareDisplayName };
                        break;

                    case 'requiredIfPairNotSet':
                        translationArgs = { displayName: displayName, compareDisplayName: compareDisplayName };
                        break;
                    case 'productCodeCustom':
                        translationArgs = { displayName: displayName, compareDisplayName: compareDisplayName };
                        break;
                    case 'pastOrToday':
                        translationArgs = { displayName: displayName };
                        break;

                    case 'greater':
                        translationArgs = { displayName: displayName, value: ruleViolation.value };
                        break;

                    case 'less':
                        translationArgs = { displayName: displayName, value: ruleViolation.value };
                        break;
                }

                var errorMessage = translator.instantTranslate(messageMask, translationArgs);

                return errorMessage;
            }
        }

        return validationMessageGenerator;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAV0A}
// di.core.angular.validation
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;

        module.factory('validationNotifier', validationNotifier);

        validationNotifier.$inject = ['elementNotifier'];

        /**
         * Displays/hides validation messages for form elements
         */
        function validationNotifier(notifier) {
            var dataKey = 'validationNotifier';

            var service = {
                showNotification: showNotification,
                hideNotification: hideNotification
            };

            return service;

            /**
             * Displays a validation message on the given element
             * @param element
             * @param errorMessage
             * @param position
             */
            function showNotification(element, errorMessage, position) {
                guard.throwIfNotAnObject("CAV0A01E", element, "element");
                guard.throwIfEmptyString("CAV0A02E", errorMessage, "errorMessage");

                var validationNotification = element.data(dataKey);

                if (validationNotification) {
                    if (validationNotification.getMessage() !== errorMessage) {
                        validationNotification.setMessage(errorMessage);
                    }

                    validationNotification.show();
                } else {
                    validationNotification = notifier.error(errorMessage, element, {
                        clickToHide: false,
                        autoHide: false,
                        position: position
                    });

                    element.data(dataKey, validationNotification);
                }
            }

            /**
             * Hides the validation message on the given element
             * @param element
             */
            function hideNotification(element) {
                guard.throwIfNotAnObject("CAV0A03E", element, "element");

                var validationNotification = element.data(dataKey);

                if (validationNotification) {
                    validationNotification.hide();
                }
            }
        }

        return validationNotifier;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAV05}
// di.core.angular.validation
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;

        module.provider('validationRulesProxy', ValidationRulesProxyProvider);

        /**
         * Proxy client for retrieving validation rules from the webAPI server
         */
        function ValidationRulesProxyProvider() {
            var config = {
                url: 'EntityValidationRule/GetEntityValidationRules'
            };

            var provider = {
                configure: configure,
                $get: $get
            };

            provider.$get.$inject = ['webApiHttp', '$q', 'urlHelper'];

            return provider;

            /**
             * Configure the service
             * @param cfg
             */
            function configure(cfg) {
                guard.throwIfNotAnObject("CAV0502E", cfg, "cfg");

                config = cfg;
            }

            function $get(webApiHttp, $q, urlHelper) {
                var service = {
                    getValidationRules: getValidationRules
                };

                return service;

                /**
                 * Retrieves validation rules for all entities for the given user
                 * @param userId
                 */
                function getValidationRules(entityNames) {
                    var url = config.url;

                    var requestParameters = {
                        entityNames: entityNames
                    };

                    var requestUrl = urlHelper.setParameters(url, requestParameters);

                    var promise = webApiHttp.get(requestUrl).then(success, failure);

                    function success(validationRulesString) {
                        return JSON.parse(validationRulesString);
                    }

                    function failure(data) {
                        return $q.reject(data);
                    }

                    return promise;
                }
            }
        }

        return ValidationRulesProxyProvider;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAV0L}
// di.core.angular.validation
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;

        module.factory('validationRulesSetter', validationRulesSetter);

        validationRulesSetter.$inject = ['validationRulesProxy', 'validationRulesStore', 'validationInitialiser'];

        function validationRulesSetter(validationRulesProxy, validationRulesStore, validationInitialiser) {
            var service = {
                setValidationRules: setValidationRules
            };

            return service;

            function setValidationRules(entityNames) {
                guard.throwIfEmptyString("CAV0L01E", entityNames, "entityNames");

                validationRulesProxy.getValidationRules(entityNames).then(resolved, rejected);

                function resolved(validationRules) {
                    validationRulesStore.setValidationRules(validationRules);

                    validationInitialiser.applyValidationRules(validationRules);
                }

                function rejected() {}
            }
        }

        return validationRulesSetter;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAV06}
// di.core.angular.validation
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ng) {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;

        module.factory('validationRulesStore', validationRulesStore);

        validationRulesStore.$inject = ['sessionStore'];

        /**
         * Stores and retrieves validation rules from local storage
         */
        function validationRulesStore(sessionStore) {
            var storeKey = 'validationRules';

            var service = {
                getValidationRules: getValidationRules,
                setValidationRules: setValidationRules,
                clear: clear
            };

            return service;

            /**
             * Gets validation rules
             * @param name
             */
            function getValidationRules() {
                var validationRules = sessionStore.get(storeKey, 'validationRulesStore');

                return validationRules;
            }

            /**
             * Stores the given validation rules in local storage
             * @param rules
             */
            function setValidationRules(validationRules) {
                guard.throwIfNotAnObject("CAV0602E", validationRules, "validationRules");

                var existingRules = sessionStore.get(storeKey, 'validationRulesStore');

                var mergedRules = ng.extend({}, existingRules, validationRules);

                sessionStore.set(storeKey, mergedRules, 'validationRulesStore');
            }

            /**
             * Removes validation rules from local storage
             */
            function clear() {
                sessionStore.remove(storeKey, 'validationRulesStore');
            }
        }

        return validationRulesStore;
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAW04}
// di.core.angular.watchers
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(292), __webpack_require__(293), __webpack_require__(291)], __WEBPACK_AMD_DEFINE_RESULT__ = function (watcherHelperLoader, watchersTogglerDirectiveLoader, debounceLoader) {
    'use strict';

    return function (module) {
        watcherHelperLoader(module);
        watchersTogglerDirectiveLoader(module);
        debounceLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAW06}
// di.core.angular.watchers
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.factory('debounce', debounce);

        debounce.$inject = ['$timeout'];

        function debounce($timeout) {

            return function (callback, interval) {
                var timeout = null;
                return function () {
                    $timeout.cancel(timeout);
                    var args = arguments;
                    timeout = $timeout(function () {
                        callback.apply(this, args);
                    }, interval);
                };
            };
        }

        return debounce;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAW03}
// di.core.angular.watchers
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.factory('watcherHelper', watcherHelper);

        function watcherHelper() {

            //var guard = $di.exception.guard;
            //var util = $di.utility.util;

            return {
                toggleWatchers: toggleWatchers
            };

            function toggleWatchers(scope, enable) {

                var digest,
                    current,
                    next = scope;
                do {
                    current = next;
                    if (enable) {
                        if (current.hasOwnProperty("$$watchersBackup")) {
                            current.$$watchers = current.$$watchersBackup;
                            delete current.$$watchersBackup;
                            delete current.$watch;
                            digest = !scope.$root.$$phase;
                        }
                    } else {
                        if (!current.hasOwnProperty("$$watchersBackup")) {
                            current.$$watchersBackup = current.$$watchers;
                            current.$$watchers = null;
                            current.$watch = watchDuringDisable;
                        }
                    }
                    next = current.$$childHead;
                    while (!next && current !== scope) {
                        if (current.$$nextSibling) {
                            next = current.$$nextSibling;
                        } else {
                            current = current.$parent;
                        }
                    }
                } while (next);
                if (digest) {
                    scope.$digest();
                }

                return;

                function watchDuringDisable() {
                    scope.$$watchersBackup = scope.$$watchersBackup || [];
                    scope.$$watchers = scope.$$watchersBackup;
                    var unwatch = scope.constructor.prototype.$watch.apply(scope, arguments);
                    scope.$$watchers = null;
                    return unwatch;
                }
            }
        }

        return watcherHelper;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAW05}
// di.core.angular.watchers
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var util = $di.utility.util;

        module.directive('diWatchersToggler', diWatchersToggler);

        diWatchersToggler.$inject = ['$parse'];

        function diWatchersToggler($parse) {
            return {
                restrict: 'EA',
                link: function link($scope, element, attrs) {
                    var watchers = {
                        suspended: false
                    };

                    var identifier = attrs.diWatchersToggler;

                    $scope.$evalAsync(suspendWatchers);

                    $scope.$on('suspendWatchers', function (event, id) {
                        if (id === identifier) {
                            suspendWatchers();
                        }
                    });

                    $scope.$on('resumeWatchers', function (event, id) {
                        if (id === identifier) {
                            resumeWatchers();
                        }
                    });

                    $scope.$on('refreshWatchers', function () {
                        refreshSuspendedWatchers();
                    });

                    return;

                    function suspendWatchers() {
                        if (!watchers.suspended) {
                            var suspendScopeWatchers = function suspendScopeWatchers(scope) {
                                if (!watchers[scope.$id]) {
                                    watchers[scope.$id] = scope.$$watchers || [];
                                    scope.$$watchers = [];
                                    scope.$watch = mockScopeWatch(scope.$id);
                                }

                                return;

                                function mockScopeWatch(scopeId) {
                                    return function (watchExp, listener, objectEquality, prettyPrintExpression) {
                                        watchers[scopeId].unshift({
                                            fn: angular.isFunction(listener) ? listener : angular.noop,
                                            last: void 0,
                                            get: $parse(watchExp),
                                            exp: prettyPrintExpression || watchExp,
                                            eq: !!objectEquality
                                        });
                                    };
                                }
                            };

                            iterateScopeMembers(suspendScopeWatchers);

                            watchers.suspended = true;

                            return;
                        }
                    }

                    function resumeWatchers() {
                        if (watchers.suspended) {
                            var resumeScopeWatchers = function resumeScopeWatchers(scope) {
                                if (util.isDefined(watchers[scope.$id])) {
                                    scope.$$watchers = watchers[scope.$id];

                                    if (scope.hasOwnProperty('$watch')) {
                                        delete scope.$watch;
                                    }

                                    delete watchers[scope.$id];
                                }
                            };

                            iterateScopeMembers(resumeScopeWatchers);

                            watchers.suspended = false;

                            return;
                        }
                    }

                    function refreshSuspendedWatchers() {
                        if (watchers.suspended) {
                            resumeWatchers();
                            suspendWatchers();
                        }
                    }

                    function iterateScopeMembers(operationOnScope) {
                        var root = $scope;
                        var pendingChildHeads = [root.$$childHead];
                        var currentScope;

                        while (pendingChildHeads.length) {
                            currentScope = pendingChildHeads.shift();

                            while (currentScope) {
                                operationOnScope(currentScope);
                                pendingChildHeads.push(currentScope.$$childHead);
                                currentScope = currentScope.$$nextSibling;
                            }
                        }
                    }
                }
            };
        }

        return diWatchersToggler;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAU0F}
// di.core.angular.window
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(295), __webpack_require__(296)], __WEBPACK_AMD_DEFINE_RESULT__ = function (diClickAwayDirectiveLoader, windowEventSubscriberLoader) {
	'use strict';

	return function (module) {
		diClickAwayDirectiveLoader(module);
		windowEventSubscriberLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAW02}
// di.core.angular.window
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ng) {
    'use strict';

    return function (module) {
        var moduleName = 'diClickAway';

        module.directive(moduleName, diClickAway);

        diClickAway.$inject = ['$parse', 'uniqueIdGenerator', 'windowEventSubscriber'];

        function diClickAway($parse, uniqueIdGenerator, windowEventSubscriber) {
            return {
                restrict: 'A',
                link: link
            };

            function link(scope, element, attrs) {
                var className = uniqueIdGenerator.newId(moduleName);
                var callback = $parse(attrs.diClickAway);
                var ignoreClass = attrs.diClickAwayIgnore;
                var childElements;

                element = ng.element(element);

                element.addClass(className);

                windowEventSubscriber.subscribeToClickAwayByClass(className, function (clickedElement) {
                    if (className && ignoreClass && clickedElement.closest('.' + ignoreClass).length > 0) {
                        return;
                    }

                    scope.$apply(callback);
                }, scope);

                element.removeAttr('di-click-away');
            }
        }

        return diClickAway;
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAW01}
// di.core.angular.window
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ng) {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;

        module.factory('windowEventSubscriber', windowEventSubscriber);

        windowEventSubscriber.$inject = ['$window'];

        /**
         * Provides a mechanism for subscribing to window-level events
         */
        function windowEventSubscriber($window) {
            var service = {
                subscribeToClickAway: subscribeToClickAway,
                subscribeToClickAwayByClass: subscribeToClickAwayByClass
            };

            return service;

            /**
             * When the window is clicked on an element without the given class
             * then the given callback is called with a reference to the clicked element.
             */
            function subscribeToClickAwayByClass(className, callback, scope) {
                subscribeToClickAway(comparer, callback, scope);

                function comparer(clickedElement) {
                    return clickedElement.closest('.' + className).length > 0;
                }
            }

            /**
             * When the window is clicked outside of an element
             * then the given callback is called with a reference to the clicked element.
             * The comparer function is used to test the clicked element
             */
            function subscribeToClickAway(comparer, callback, scope) {
                guard.throwIfNotAFunction("CAU0E01E", comparer, "comparer");
                guard.throwIfNotAFunction("CAU0E02E", callback, "callback");

                var jqWindow = ng.element($window);

                var newWindowClickFun = function newWindowClickFun(event) {
                    var clickedElement = event.target;

                    if (!clickedElement) {
                        return;
                    }

                    clickedElement = ng.element(clickedElement);

                    if (!comparer(clickedElement)) {
                        callback(clickedElement);
                    }
                };

                jqWindow.on('click', newWindowClickFun);

                scope.$on('$destroy', function () {
                    jqWindow.off('click', newWindowClickFun);
                });
            }
        }

        return windowEventSubscriber;
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP0B}
// di.einvoicing.ui.portal.core

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(300)], __WEBPACK_AMD_DEFINE_RESULT__ = function (configModule) {
    'use strict';

    var config = configModule.config;

    return function (module) {
        module.constant('PORTAL_CONFIG', config);

        module.config(endpointsConfig);
        module.config(configureLocationProvider);
        module.config(httpConfig);
        module.config(loggerProxyConfig);
        module.config(exceptionHandlerConfig);
        module.config(notifierConfig);
        module.config(translationModuleConfig);
        module.config(userAuthenticationProxyConfig);
        module.config(stateAuthenticatorConfig);
        module.config(authenticationClientEventSubscriberConfig);
        module.config(validationInitialiserConfig);
        module.config(configureValdrDateValidation);
        module.config(invoiceListConfiguratorConfig);
        module.config(auditListConfiguratorConfig);
        module.config(purchaseOrderListConfiguratorConfig);
        module.config(purchaseOrderViewerLinesConfiguratorConfig);
        module.config(userSecurityProxyConfig);
        module.config(documentAttachmentConfiguratorConfig);
        module.config(relatedDocumentsConfiguratorConfig);
        module.config(grnListConfiguratorConfig);
        module.config(serviceStatusMonitorConfig);
        module.config(userIdleActivityMonitorConfig);
        module.config(forceUrlReloaderConfig);

        $di.debug.debugger.enabled = config.debuggerEnabled;

        endpointsConfig.$inject = ['endpointsProvider'];

        function endpointsConfig(endpointsProvider) {
            endpointsProvider.configure({
                endpoints: {
                    webApi: config.app.webApiAddress,
                    app: config.app.appUrl
                },
                defaultEndpoint: 'webApi'
            });
        }

        configureLocationProvider.$inject = ['$locationProvider'];

        function configureLocationProvider($locationProvider) {
            $locationProvider.html5Mode(true);
        }

        httpConfig.$inject = ['$httpProvider'];

        function httpConfig($httpProvider) {
            $httpProvider.defaults.useXDomain = true;

            $httpProvider.defaults.headers.common['Cache-Control'] = 'no-cache';
            $httpProvider.defaults.headers.common['Pragma'] = 'no-cache';
            $httpProvider.defaults.headers.common['ClientVersion'] = config.app.version;

            delete $httpProvider.defaults.headers.common['X-Requested-With'];
        }

        loggerProxyConfig.$inject = ['loggerProxyProvider'];

        function loggerProxyConfig(loggerProxyProvider) {
            loggerProxyProvider.configure({
                endpoint: 'webApi',
                url: 'log',
                logInfoToServer: true,
                logWarningToServer: true,
                logErrorToServer: true
            });
        }

        exceptionHandlerConfig.$inject = ['exceptionHandlerProvider'];

        function exceptionHandlerConfig(exceptionHandlerProvider) {
            exceptionHandlerProvider.configure({
                appErrorPrefix: '[EInvoicing] ',
                appTitle: 'Di.EInvoicing.Ui.Portal',
                version: '1.1.0',
                notify: true
            });
        }

        notifierConfig.$inject = ['notifierProvider'];

        function notifierConfig(notifierProvider) {
            notifierProvider.configure({
                "closeButton": true,
                successTimeOut: 5000,
                infoTimeOut: 5000,
                warningTimeOut: 10000,
                errorTimeOut: 0,
                positionClass: 'toast-top-center'
            });
        }

        translationModuleConfig.$inject = ['$translateProvider'];

        function translationModuleConfig($translateProvider) {
            $translateProvider.useStaticFilesLoader({
                prefix: './src/languages/',
                suffix: '.json'
            });
            $translateProvider.useSanitizeValueStrategy(null);
        }

        webApiHttpConfig.$inject = ['webApiHttpProvider'];

        function webApiHttpConfig(webApiHttpProvider) {
            webApiHttpProvider.configure({
                endpointName: 'webApi'
            });
        }

        userAuthenticationProxyConfig.$inject = ['userAuthenticationProxyProvider'];

        function userAuthenticationProxyConfig(userAuthenticationProxyProvider) {
            userAuthenticationProxyProvider.configure({
                endpoint: 'webApi',
                url: 'token',
                clientId: 'Di.EInvoicing.Ui.Portal'
            });
        }

        stateAuthenticatorConfig.$inject = ['stateAuthenticatorProvider'];

        function stateAuthenticatorConfig(stateAuthenticatorProvider) {
            stateAuthenticatorProvider.configure({
                securityEnabled: true,
                loginState: 'welcome'
            });
        }

        authenticationClientEventSubscriberConfig.$inject = ['authenticationClientEventSubscriberProvider'];

        function authenticationClientEventSubscriberConfig(authenticationClientEventHandlerProvider) {
            authenticationClientEventHandlerProvider.configure({
                unauthenticatedState: 'welcome',
                authenticatedState: 'portal.dashboard',
                changePasswordState: 'portal.account.management'
            });
        }

        validationInitialiserConfig.$inject = ['validationInitialiserProvider'];

        function validationInitialiserConfig(validationInitialiserProvider) {
            validationInitialiserProvider.addValidator('idValidator');
            validationInitialiserProvider.addValidator('positiveWholeNumberValidator');
            validationInitialiserProvider.addValidator('pastOrTodayValidator');
            validationInitialiserProvider.addValidator('greaterValidator');
            validationInitialiserProvider.addValidator('lessValidator');
            validationInitialiserProvider.addValidator('equalAlwaysValidator');
            validationInitialiserProvider.addValidator('equalIfSelfSetValidator');
            validationInitialiserProvider.addValidator('requiredIfPairSetValidator');
            validationInitialiserProvider.addValidator('requiredIfPairNotSetValidator');
            validationInitialiserProvider.addValidator('productCodeCustomValidator');
        }

        configureValdrDateValidation.$inject = ['$provide'];
        function configureValdrDateValidation($provide) {
            $provide.decorator('futureAndPastSharedValidator', futureAndPastSharedValidatorWithDiMoment);
        }

        futureAndPastSharedValidatorWithDiMoment.$inject = ['$delegate', 'diMoment'];
        function futureAndPastSharedValidatorWithDiMoment(delegate, diMoment) {
            return {
                validate: function validate(value, comparison) {
                    var valueAsDiMoment = diMoment(value);
                    return delegate.validate(valueAsDiMoment, comparison);
                }
            };
        }

        invoiceListConfiguratorConfig.$inject = ['invoiceListConfiguratorProvider'];

        function invoiceListConfiguratorConfig(invoiceListConfiguratorProvider) {

            var cfg = {
                data: [],
                columns: [],
                enableSelect: true,
                multiSelect: true,
                enablePaging: true,
                fixedHeight: true,
                maxItemsToShow: 500,
                paginationPageSizes: [5, 10, 15, 20, 25, 50],
                paginationPageSize: 10,
                paginationPageNumber: 1,
                maxButtonsShown: 3,
                pagination: {
                    seek: function seek() {}
                }
            };

            invoiceListConfiguratorProvider.configure(cfg);
        }

        purchaseOrderListConfiguratorConfig.$inject = ['purchaseOrderListConfiguratorProvider'];

        function purchaseOrderListConfiguratorConfig(purchaseOrderListConfiguratorProvider) {

            var cfg = {
                data: [],
                columns: [],
                enableSelect: true,
                multiSelect: true,
                enablePaging: true,
                fixedHeight: true,
                maxItemsToShow: 500,
                paginationPageSizes: [5, 10, 15, 20, 25, 50],
                paginationPageSize: 10,
                paginationPageNumber: 1,
                maxButtonsShown: 3,
                pagination: {
                    seek: function seek() {}
                }
            };

            purchaseOrderListConfiguratorProvider.configure(cfg);
        }

        auditListConfiguratorConfig.$inject = ['auditListConfiguratorProvider'];

        function auditListConfiguratorConfig(auditListConfiguratorProvider) {

            var cfg = {
                data: [],
                columns: [],
                enableSelect: true,
                multiSelect: false,
                enablePaging: true,
                fixedHeight: true,
                maxItemsToShow: 500,
                paginationPageSizes: [20, 25, 50],
                paginationPageSize: 20,
                paginationPageNumber: 1,
                maxButtonsShown: 3,
                pagination: {
                    seek: function seek() {}
                }
            };

            auditListConfiguratorProvider.configure(cfg);
        }

        purchaseOrderViewerLinesConfiguratorConfig.$inject = ['purchaseOrderViewerLinesConfiguratorProvider'];

        function purchaseOrderViewerLinesConfiguratorConfig(purchaseOrderViewerLinesConfiguratorProvider) {

            var cfg = {
                data: [],
                columns: [],
                enableSelect: false,
                multiSelect: false,
                enablePaging: false,
                fixedHeight: true,
                maxItemsToShow: 500
            };

            purchaseOrderViewerLinesConfiguratorProvider.configure(cfg);
        }

        userSecurityProxyConfig.$inject = ['userSecurityProxyProvider'];

        function userSecurityProxyConfig(userSecurityProxyProvider) {
            userSecurityProxyProvider.configure({
                endpoint: 'app',
                getSecurityQuestionUrl: 'UserSecurity/GetSecurityQuestion',
                requestPasswordResetUrl: 'UserSecurity/RequestPasswordResetEmail',
                changePasswordUrl: 'UserSecurity/ChangePassword',
                resetPasswordUrl: 'UserSecurity/ResetPassword',
                resetPasswordSiteUrl: '/welcome/',
                getUserUrl: 'UserSecurity/GetUser',
                getQuestionsUrl: 'UserSecurity/GetSecurityQuestions',
                setSecurityQuestionUrl: 'UserSecurity/SetSecurityQuestion',
                requestPasswordResetUrlOnUserBehalf: 'UserSecurity/RequestPasswordResetEmailOnUserBehalf',
                setPasswordWithTokenUrl: 'UserSecurity/SetPasswordWithToken',
                setPasswordAndQuestionWithTokenUrl: 'UserSecurity/SetPasswordAndQuestionWithToken'
            });
        }

        documentAttachmentConfiguratorConfig.$inject = ['documentAttachmentConfiguratorProvider'];

        function documentAttachmentConfiguratorConfig(documentAttachmentConfigurationProvider) {
            documentAttachmentConfigurationProvider.configure({
                maximumAttachmentSize: '10MB',
                disallowedFileExtensions: ['ade', 'adp', 'app', 'asp', 'bas', 'bat', 'cer', 'chm', 'cmd', 'cnt', 'com', 'cpl', 'crt', 'csh', 'der', 'exe', 'fxp', 'gadget', 'grp', 'hlp', 'hpj', 'hta', 'inf', 'ins', 'isp', 'its', 'jar', 'jnlp', 'js', 'jse', 'ksh', 'lnk', 'mad', 'maf', 'mag', 'mam', 'maq', 'mar', 'mas', 'mat', 'mau', 'mav', 'maw', 'mcf', 'mda', 'mdb', 'mde', 'mdt', 'mdw', 'mdz', 'msc', 'msh', 'msh1', 'msh2', 'mshxml', 'msh1xml', 'msh2xml', 'msi', 'msp', 'mst', 'ops', 'osd', 'pcd', 'pif', 'pl', 'plg', 'prf', 'prg', 'ps1', 'ps1xml', 'ps2', 'ps2xml', 'psc1', 'psc2', 'pst', 'reg', 'scf', 'scr', 'sct', 'shb', 'shs', 'tmp', 'url', 'vb', 'vbe', 'vbp', 'vbs', 'vsmacros', 'vsw', 'ws', 'wsc', 'wsf', 'wsh', 'xbap', 'xll', 'xnk']
            });
        }

        relatedDocumentsConfiguratorConfig.$inject = ['relatedDocumentsConfiguratorProvider'];

        function relatedDocumentsConfiguratorConfig(relatedDocumentsConfiguratorProvider) {
            var cfg = {
                data: [],
                columns: [],
                enableSelect: true,
                multiSelect: false,
                enablePaging: true,
                fixedHeight: true,
                maxItemsToShow: 500,
                paginationPageSizes: [5, 10, 15, 20, 25, 50],
                paginationPageSize: 10,
                paginationPageNumber: 1,
                maxButtonsShown: 3,
                pagination: {
                    seek: function seek() {}
                }
            };

            relatedDocumentsConfiguratorProvider.configure(cfg);
        }

        grnListConfiguratorConfig.$inject = ['grnListConfiguratorProvider'];

        function grnListConfiguratorConfig(grnListConfiguratorProvider) {
            var cfg = {
                data: [],
                columns: [],
                enableSelect: true,
                multiSelect: false,
                enablePaging: true,
                fixedHeight: true,
                maxItemsToShow: 500,
                paginationPageSizes: [5, 10, 15, 20, 25, 50],
                paginationPageSize: 10,
                paginationPageNumber: 1,
                maxButtonsShown: 3,
                pagination: {
                    seek: function seek() {}
                }
            };

            grnListConfiguratorProvider.configure(cfg);
        }

        serviceStatusMonitorConfig.$inject = ['serviceStatusMonitorProvider'];

        function serviceStatusMonitorConfig(serviceStatusMonitorProvider) {
            var cfg = {
                pollingInterval: 600000
            };

            serviceStatusMonitorProvider.configure(cfg);
        }

        userIdleActivityMonitorConfig.$inject = ['userIdleActivityMonitorProvider', 'IdleProvider'];

        function userIdleActivityMonitorConfig(userIdleActivityMonitorProvider, idleProvider) {
            var cfg = {
                timeout: Number(config.app.sessionTimeout),
                idle: Number(config.app.sessionIdle),
                pageTitle: 'Data Interchange | Digital Invoice'
            };

            userIdleActivityMonitorProvider.configure(cfg, idleProvider);
        }

        forceUrlReloaderConfig.$inject = ['forceUrlReloaderProvider'];

        function forceUrlReloaderConfig(forceUrlReloaderProvider) {
            forceUrlReloaderProvider.configure({
                enableForceUrlReload: config.app.enableForceUrlReload,
                forceUrlReloadLimit: Number(config.app.forceUrlReloadLimit),
                stateNames: config.app.forceUrlStateNames
            });
        }
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP2E}
// di.einvoicing.ui.portal.core
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
		'use strict';

		return function (module) {
				module.run(configureInitialLanguage);
				module.run(stateChangeStartEventHandler);
				module.run(initLoginLogoutEventHandler);
				module.run(applyValidationRules);
				module.run(readAuthenticationStore);

				configureInitialLanguage.$inject = ['languageHandler'];
				function configureInitialLanguage(languageHandler) {
						languageHandler.applyLanguage();
				}

				stateChangeStartEventHandler.$inject = ['$rootScope', 'headerData', 'stateAuthenticator', 'forceUrlReloader'];
				function stateChangeStartEventHandler($rootScope, headerData, stateAuthenticator, forceUrlReloader) {
						$rootScope.stateChangeCounter = {
								forceRefresh: false,
								stateChangeCount: 0
						};

						$rootScope.$on('$stateChangeStart', function (event, toState, toParams, fromState, fromParams) {

								forceUrlReloader.process($rootScope, toState, toParams, fromState, fromParams);

								var authorized = stateAuthenticator.authenticateState(toState);

								if (!authorized) {
										$rootScope.toState = toState;
										$rootScope.toParams = toParams;
										event.preventDefault();
										return;
								} else {
										$rootScope.toState = null;
										$rootScope.toParams = null;
								}

								if (toState.data && toState.data.header) {
										headerData.set(toState.data.header);
								}
						});
				}

				initLoginLogoutEventHandler.$inject = ['authenticationClientEventHandler'];
				function initLoginLogoutEventHandler(authenticationClientEventHandler) {
						authenticationClientEventHandler.init();
				}

				applyValidationRules.$inject = ['validationInitialiser', 'validationRulesStore'];
				function applyValidationRules(validationInitialiser, validationRulesStore) {
						var validationRules = validationRulesStore.getValidationRules();

						if (validationRules) {
								validationInitialiser.applyValidationRules(validationRules);
						}
				}

				readAuthenticationStore.$inject = ['authenticationStore'];
				function readAuthenticationStore(authenticationStore) {
						authenticationStore.getAuthenticationData();
				}
		};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP2D}
// di.einvoicing.ui.portal
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.config(configureAppStates);

        configureAppStates.$inject = ['stateHelperProvider', '$urlRouterProvider'];
        function configureAppStates(stateHelperProvider, $urlRouterProvider) {
            $urlRouterProvider.otherwise(function ($injector) {
                var authenticationData = $injector.get('authenticationData');

                if (authenticationData.userData.isAuthenticated === true) {
                    return 'portal/dashboard';
                } else {
                    return 'welcome';
                }
            });

            stateHelperProvider.addStates({
                templateBaseUrl: "src/app/_states",
                states: [{
                    stateName: "portal",
                    isAbstract: true,
                    rights: ["User"],
                    data: {
                        header: { title: "EINVOICING.PORTAL.HEADER.MESSAGE" }
                    }
                }, {
                    stateName: "welcome",
                    url: 'welcome?{username}&{password}',
                    params: {
                        reason: undefined,
                        username: undefined,
                        password: undefined
                    },
                    onlyCreateStateCollection: false,
                    stateCollection: [{
                        stateName: "resetPassword",
                        url: 'welcome/{resetToken}',
                        params: {
                            resetToken: ''
                        }
                    }]
                }, {
                    stateName: "impersonate",
                    url: 'impersonate?{username}&{password}',
                    params: {
                        username: undefined,
                        password: undefined
                    }
                }]
            });
        }
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var config = exports.config = {
    app: {
        clientLogEnabled: true,
        webApiAddress: 'http://localhost:9000',
        appUrl: 'http://localhost:4444/',
        sessionTimeout: 300,
        sessionIdle: 1200,
        enableForceUrlReload: true,
        forceUrlReloadLimit: 20,
        forceUrlStateNames: "['portal.invoices.editById', 'portal.invoices.viewById']",
        version: "1.2.0.ABCD"
    },
    utilities: {
        integrator: {
            endpointName: 'app',
            configFilePath: 'integrator/clickonce.json'
        }
    }
};

/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUW02}
// di.einvoicing.ui.portal.impersonate
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(302)], __WEBPACK_AMD_DEFINE_RESULT__ = function (impersonateControllerLoader) {
    'use strict';

    return function (module) {
        var snippetContext = $di.angular.snippetRegistrar.createContext(module, 'src/app/impersonate');
        snippetContext.registerSnippet('diImpersonate', 'impersonate.html', 'ImpersonateController');
        impersonateControllerLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUW01}
// di.einvoicing.ui.portal.welcome
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
		'use strict';

		return function (module) {
				var util = $di.utility.util;

				module.controller('ImpersonateController', ImpersonateController);

				ImpersonateController.$inject = ['$stateParams', 'diState', 'authenticationStore', 'authenticationClientEventSubscriber'];

				function ImpersonateController(stateParams, diState, authenticationStore) {
						var vm = this;

						vm.autoLogin = autoLogin;

						if (util.isNonEmptyString(stateParams.username)) {
								vm.autoLogin(stateParams.username, stateParams.password);
						}

						return;

						function autoLogin(u, p) {
								authenticationStore.clear();
								diState.go('welcome', { username: u, password: p });
						}
				}

				return ImpersonateController;
		};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP04}
// di.einvoicing.ui.portal
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(1),
// Non-angular libraries
__webpack_require__(5), __webpack_require__(4), __webpack_require__(21), __webpack_require__(0), __webpack_require__(22), __webpack_require__(16), __webpack_require__(71)], __WEBPACK_AMD_DEFINE_RESULT__ = function (r, ng, moment) {
    'use strict';

    //Valdr references moment globally so need to add it to the global window

    window.moment = window.moment || moment;

    //Set the locale for moment
    if (navigator.language) {
        window.moment.locale(navigator.language);
    } else if (navigator.languages) {
        window.moment.locale(navigator.languages);
    } else if (navigator.userLanguage) {
        window.moment.locale(navigator.userLanguage);
    }

    __webpack_require__.e/* require */(0/* limit */).then(function() { /* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_REQUIRE_ARRAY__ = [__webpack_require__(73), __webpack_require__(72)]; (function (document, module) {
        ng.bootstrap(document, [module.name], {
            strictDi: true
        });
    }.apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__));
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(15)(module)))}).catch(__webpack_require__.oe);
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(305), __webpack_require__(488), __webpack_require__(647), __webpack_require__(358), __webpack_require__(306), __webpack_require__(455), __webpack_require__(589), __webpack_require__(323), __webpack_require__(580), __webpack_require__(476), __webpack_require__(332), __webpack_require__(454), __webpack_require__(331), __webpack_require__(607), __webpack_require__(439)], __WEBPACK_AMD_DEFINE_RESULT__ = function (statesLoader, sharedLoader, sharedServicesLoader, invoicesLoader, accountLoader, purchaseOrdersLoader, usersLoader, auditLoader, summariesLoader, relatedLoader, grnLoader, portalController, forceUrlReloaderLoader, utilitiesLoader, partiesLoader) {
	'use strict';

	return function (module) {
		statesLoader(module);
		sharedLoader(module);
		sharedServicesLoader(module);
		invoicesLoader(module);
		accountLoader(module);
		purchaseOrdersLoader(module);
		usersLoader(module);
		auditLoader(module);
		summariesLoader(module);
		relatedLoader(module);
		grnLoader(module);
		portalController(module);
		forceUrlReloaderLoader(module);
		utilitiesLoader(module);
		partiesLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP2R}
// di.einvoicing.ui.portal.portal.invoices
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.config(configureInvoiceStates);

		configureInvoiceStates.$inject = ['stateHelperProvider'];

		function configureInvoiceStates(stateHelperProvider) {
			stateHelperProvider.addStates({
				templateBaseUrl: "src/app/portal/_states",
				parentStateName: 'portal',
				states: [{
					stateName: "invoices",
					rights: ["InvoiceReader"],
					data: {
						header: { title: "EINVOICING.PORTAL.INVOICES.HEADER.TITLE" }
					}
				}, {
					stateName: "orders",
					rights: ["PurchaseOrderReader"],
					data: {
						header: { title: "EINVOICING.PORTAL.PURCHASE_ORDERS.HEADER.TITLE" }
					}
				}, {
					stateName: "users",
					data: {
						header: { title: "EINVOICING.PORTAL.USERS.HEADER.TITLE" }
					}
				}, {
					stateName: "audit",
					data: {
						header: { title: "EINVOICING.PORTAL.AUDIT.HEADER.TITLE" }
					}
				}, {
					stateName: "related",
					data: {
						header: { title: "EINVOICING.PORTAL.RELATED.HEADER.TITLE" }
					}
				}, {
					stateName: "account",
					data: {
						header: { title: "EINVOICING.PORTAL.ACCOUNT.HEADER.TITLE" }
					}
				}, {
					stateName: "grn",
					data: {
						header: { title: "EINVOICING.PORTAL.GRN.HEADER.TITLE" }
					}
				}, {
					stateName: 'dashboard'
				}, {
					stateName: 'utilities'
				}, {
					stateName: 'parties'
				}]
			});
		}
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(307), __webpack_require__(310), __webpack_require__(315), __webpack_require__(308), __webpack_require__(311), __webpack_require__(313)], __WEBPACK_AMD_DEFINE_RESULT__ = function (statesLoader, accountService, settingsLoader, accountManagementLoader, notificationSettingsLoader, securityQuestionLoader) {
	'use strict';

	return function (module) {
		statesLoader(module);

		module.service('accountService', accountService.AccountService);

		settingsLoader(module);
		accountManagementLoader(module);
		notificationSettingsLoader(module);
		securityQuestionLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP32}
// di.einvoicing.ui.portal.portal.account
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.config(configureInvoiceStates);

		configureInvoiceStates.$inject = ['stateHelperProvider'];

		function configureInvoiceStates(stateHelperProvider) {
			stateHelperProvider.addStates({
				templateBaseUrl: "src/app/portal/account/_states",
				parentStateName: 'portal.account',
				states: [{
					stateName: "settings",
					data: {
						header: { title: "EINVOICING.PORTAL.ACCOUNT.SETTINGS.HEADER.TITLE" }
					}
				}, {
					stateName: "management",
					data: {
						header: { title: "EINVOICING.PORTAL.ACCOUNT.MANAGEMENT.HEADER.TITLE" }
					}
				}, {
					stateName: "parties",
					data: {
						header: { title: "" }
					},
					params: {
						pageTitle: undefined,
						ownStateName: 'portal.account.parties'
					}
				}]
			});
		}
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(309)], __WEBPACK_AMD_DEFINE_RESULT__ = function (accountManagement) {
    'use strict';

    return function (module) {
        module.component(accountManagement.AccountManagementComponent.selector, accountManagement.AccountManagementComponent);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AccountManagementComponent = exports.AccountManagementComponent = {
    selector: 'diAccountManagement',
    controller: function () {
        function controller(accountService, authenticationData, modalSpinner, notificationHandler, diState) {
            _classCallCheck(this, controller);

            this.accountService = accountService;
            this.authenticationData = authenticationData;
            this.modalSpinner = modalSpinner;
            this.notificationHandler = notificationHandler;
            this.diState = diState;

            this.getUser = this.getUser.bind(this);
            this.subscribeToUsernameChange = this.subscribeToUsernameChange.bind(this);
        }

        _createClass(controller, [{
            key: '$onInit',
            value: function $onInit() {
                this.currentUsername = this.authenticationData.userData.username;
                this.currentUser = this.accountService.currentUser;
                this.getUser();
            }
        }, {
            key: 'getUser',
            value: function getUser() {
                var _this = this;

                this.showSpinner();
                this.accountService.getUser(function () {
                    _this.removeSpinner();
                }, function (error) {
                    _this.removeSpinner();
                    if (error) {
                        _this.notificationHandler.showError(error);
                    } else {
                        _this.notificationHandler.showError('EINVOICING.PORTAL.ACCOUNT.MANAGEMENT.COULD_NOT_LOAD_USER');
                    }
                    _this.diState.goBack().catch(function () {
                        _this.diState.go('portal.dashboard');
                    });
                });
            }
        }, {
            key: 'subscribeToUsernameChange',
            value: function subscribeToUsernameChange(subscription) {
                subscription(this.currentUsername);
            }
        }, {
            key: 'showSpinner',
            value: function showSpinner() {
                window.spinner = this.modalSpinner.showModalSpinner("#spinnerHolder");
            }
        }, {
            key: 'removeSpinner',
            value: function removeSpinner() {
                if (window.spinner) {
                    window.spinner.remove();
                }
            }
        }]);

        return controller;
    }(),
    templateUrl: 'src/app/portal/account/account-management/account-management.component.html'
};

AccountManagementComponent.controller.prototype.constructor.$inject = ['accountService', 'authenticationData', 'modalSpinner', 'notificationHandler', 'diState'];

/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AccountService = function () {
    function AccountService(userProxy, authenticationData) {
        _classCallCheck(this, AccountService);

        this.userProxy = userProxy;
        this.authenticationData = authenticationData;

        this.currentUser = {};
        this.notifiableEvents = [];
    }

    _createClass(AccountService, [{
        key: 'getUser',
        value: function getUser(success, error) {
            var _this = this;

            var promise = this.userProxy.getById(this.authenticationData.userData.userId);
            promise.then(function (data) {
                _this.currentUser = data.user;
                _this.notifiableEvents = data.notifiableEvents;
                success();
            }, function (message) {
                if (message && message.failureReason) {
                    error(message.failureReason);
                } else {
                    error();
                }
            });
        }
    }]);

    return AccountService;
}();

AccountService.prototype.constructor.$inject = ['userProxy', 'authenticationData'];

exports.AccountService = AccountService;

/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(312)], __WEBPACK_AMD_DEFINE_RESULT__ = function (notificationsSettings) {
    'use strict';

    return function (module) {
        module.component(notificationsSettings.NotificationSettingsComponent.selector, notificationsSettings.NotificationSettingsComponent);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($, _) {

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var NotificationSettingsComponent = exports.NotificationSettingsComponent = {
    selector: 'diNotificationSettings',
    controller: function () {
        function controller(accountService, associativeArrayConvertor, clientEnums, enumTranslator, notificationHandler, userProxy) {
            _classCallCheck(this, controller);

            this.accountService = accountService;
            this.associativeArrayConvertor = associativeArrayConvertor;
            this.clientEnums = clientEnums;
            this.enumTranslator = enumTranslator;
            this.notificationHandler = notificationHandler;
            this.userProxy = userProxy;

            this.setNotifications = this.setNotifications.bind(this);
            this.saveNotifications = this.saveNotifications.bind(this);
            this.setFrequencies = this.setFrequencies.bind(this);
            this.allNotificationFrequencies = [];
        }

        _createClass(controller, [{
            key: '$onInit',
            value: function $onInit() {
                var _this = this;

                this.accountService.getUser(function () {
                    _this.setFrequencies();
                    _this.setNotifications();
                }, function () {});
            }
        }, {
            key: 'setFrequencies',
            value: function setFrequencies() {
                var _this2 = this;

                var allFrequencies = this.associativeArrayConvertor.convert(this.clientEnums.notificationFrequency);

                $.each(allFrequencies, function (key, value) {
                    if ($di.utility.util.isNumber(value)) _this2.allNotificationFrequencies.push({
                        id: value,
                        name: ''
                    });
                });

                this.enumTranslator.translateCollection(this.clientEnums.notificationFrequency, this.allNotificationFrequencies, "id", "name");
            }
        }, {
            key: 'setNotifications',
            value: function setNotifications() {
                var _this3 = this;

                this.notifiableEvents = this.accountService.notifiableEvents;
                _.each(this.notifiableEvents, function (item) {
                    _this3.enumTranslator.translate(_this3.clientEnums.eventType, item.notifiableEvent.eventType).then(function (translated) {
                        item.notifiableEvent.eventTypeName = translated;
                    });
                });

                _.each(this.notifiableEvents, function (notification) {
                    notification.notifiableEvent.frequencies = [];
                    notification.notifiableEvent.frequencies.fill(_this3.allNotificationFrequencies);

                    _.each(notification.notifiableEvent.frequencies, function (frq) {
                        frq.enabled = false;
                        if (notification.notifiableEvent.notificationFrequency === frq.id) {
                            frq.enabled = true;
                            return;
                        }
                    });
                });
            }
        }, {
            key: 'saveNotifications',
            value: function saveNotifications() {
                var _this4 = this;

                var promise = this.userProxy.saveUserNotifications({
                    user: this.accountService.currentUser,
                    notifiableEvents: this.notifiableEvents
                });

                promise.then(function (data) {
                    _this4.setNotifications(data);

                    _this4.notificationHandler.showSuccess('EINVOICING.PORTAL.ACCOUNT.MANAGEMENT.NOTIFICATIONS_SAVED');
                }, function () {
                    _this4.notificationHandler.showError('EINVOICING.PORTAL.ACCOUNT.MANAGEMENT.NOTIFICATIONS_ERROR');
                });
            }
        }]);

        return controller;
    }(),
    templateUrl: 'src/app/portal/account/notifications-settings/notifications-settings.component.html'
};
NotificationSettingsComponent.controller.prototype.constructor.$inject = ['accountService', 'associativeArrayConvertor', 'CLIENT_ENUMS', 'enumTranslator', 'notificationHandler', 'userProxy'];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4), __webpack_require__(0)))

/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(314)], __WEBPACK_AMD_DEFINE_RESULT__ = function (securityQuestion) {
    'use strict';

    return function (module) {
        module.component(securityQuestion.SecurityQuestionComponent.selector, securityQuestion.SecurityQuestionComponent);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SecurityQuestionComponent = exports.SecurityQuestionComponent = {
    selector: 'diSecurityQuestion',
    controller: function () {
        function controller(accountService, authenticationData, userSecurityProxy, modalSpinner, notificationHandler) {
            _classCallCheck(this, controller);

            this.accountService = accountService;
            this.userSecurityProxy = userSecurityProxy;
            this.modalSpinner = modalSpinner;
            this.notificationHandler = notificationHandler;

            this.securityAnswer = '';
            this.securityQuestions = [];
            this.securityQuestion = '';
            this.securityAnswerTemplate = '';
            this.securityQuestionEditable = false;
            this.currentUsername = authenticationData.userData.username;

            this.editSecurityQuestion = this.editSecurityQuestion.bind(this);
            this.cancelSecurityQuestionEdit = this.cancelSecurityQuestionEdit.bind(this);
            this.setSecurityQuestionAndAnswer = this.setSecurityQuestionAndAnswer.bind(this);
        }

        _createClass(controller, [{
            key: '$onInit',
            value: function $onInit() {
                if (this.accountService.currentUser.securityAnswerHash) {
                    this.securityAnswerTemplate = '********';
                } else {
                    this.securityAnswerTemplate = '';
                }

                this.getSecurityQuestions();
            }
        }, {
            key: 'getSecurityQuestions',
            value: function getSecurityQuestions() {
                var _this = this;

                this.showSpinner();

                var promise = this.userSecurityProxy.getSecurityQuestions();
                promise.then(function (data) {
                    var questions = [];

                    _.each(data, function (item, index) {
                        questions.push({
                            id: index,
                            question: item
                        });
                    });

                    _this.securityQuestions.fill(questions);

                    _this.findSelectedQuestion();

                    _this.removeSpinner();
                }, function () {
                    _this.removeSpinner();
                });
            }
        }, {
            key: 'showSpinner',
            value: function showSpinner() {
                window.spinner = this.modalSpinner.showModalSpinner("#spinnerHolder");
            }
        }, {
            key: 'removeSpinner',
            value: function removeSpinner() {
                if (window.spinner) {
                    window.spinner.remove();
                }
            }
        }, {
            key: 'findSelectedQuestion',
            value: function findSelectedQuestion() {
                var _this2 = this;

                var currentQuestion = _.find(this.securityQuestions, function (item) {
                    return item.question === _this2.accountService.currentUser.securityQuestion;
                });

                if (currentQuestion) {
                    this.securityQuestion = currentQuestion;
                } else if (this.accountService.currentUser.securityQuestion) {
                    this.securityQuestions.push({
                        id: this.securityQuestions.length,
                        question: this.accountService.currentUser.securityQuestion
                    });
                    this.findSelectedQuestion();
                }
            }
        }, {
            key: 'editSecurityQuestion',
            value: function editSecurityQuestion() {
                this.securityAnswer = '';
                this.securityQuestionEditable = true;
            }
        }, {
            key: 'cancelSecurityQuestionEdit',
            value: function cancelSecurityQuestionEdit() {
                this.findSelectedQuestion();
                this.securityAnswer = '';

                this.securityQuestionEditable = false;
            }
        }, {
            key: 'setSecurityQuestionAndAnswer',
            value: function setSecurityQuestionAndAnswer() {
                var _this3 = this;

                var promise = this.userSecurityProxy.setSecurityQuestionAndAnswer(this.currentUsername, this.securityQuestion.question, this.securityAnswer);

                promise.then(function () {
                    _this3.notificationHandler.showSuccess('EINVOICING.PORTAL.ACCOUNT.MANAGEMENT.SECURITY_QUESTION_SET');

                    _this3.securityQuestionEditable = false;

                    _this3.accountService.getUser(function () {}, function () {});
                });
            }
        }]);

        return controller;
    }(),
    templateUrl: 'src/app/portal/account/security-question/security-question.component.html'
};

SecurityQuestionComponent.controller.prototype.constructor.$inject = ['accountService', 'authenticationData', 'userSecurityProxy', 'modalSpinner', 'notificationHandler'];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(316), __webpack_require__(318)], __WEBPACK_AMD_DEFINE_RESULT__ = function (accountSettingsLoader, languageSelectorLoader) {
    'use strict';

    return function (module) {
        accountSettingsLoader(module);
        languageSelectorLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(317)], __WEBPACK_AMD_DEFINE_RESULT__ = function (accountSettings) {
    'use strict';

    return function (module) {
        module.component(accountSettings.AccountSettingsComponent.selector, accountSettings.AccountSettingsComponent);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AccountSettingsComponent = exports.AccountSettingsComponent = {
    selector: 'diAccountSettings',
    templateUrl: 'src/app/portal/account/settings/account-settings/account-settings.component.html',
    controller: function controller() {
        _classCallCheck(this, controller);
    }
};

/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP2X}
// di.einvoicing.ui.portal.components
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(322), __webpack_require__(321), __webpack_require__(320), __webpack_require__(319)], __WEBPACK_AMD_DEFINE_RESULT__ = function (diLanguageDirectiveLoader, languageSelectorControllerLoader, languageHandlerLoader, languageDataLoader) {
    'use strict';

    return function (module) {
        diLanguageDirectiveLoader(module);
        languageSelectorControllerLoader(module);
        languageHandlerLoader(module);
        languageDataLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP36}
// di.einvoicing.ui.portal.components
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.factory('languageData', languageData);

        languageData.$inject = ['staticLookupProxy'];

        var languages = null;

        function languageData(staticLookup) {
            return {
                getLanguages: getLanguages
            };

            /**
             * Gets a collection of languages that the application supports.
             */
            function getLanguages() {
                var promise = staticLookup.get('Language').then(success);

                return promise;

                function success(data) {
                    languages = data;

                    languages.sort(function (a, b) {
                        return a.name > b.name;
                    });

                    return languages;
                }
            }
        }

        return languageData;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP30}
// di.einvoicing.ui.portal.components
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5)], __WEBPACK_AMD_DEFINE_RESULT__ = function (moment) {
	'use strict';

	return function (module) {
		var guard = $di.exception.guard;
		var util = $di.utility.util;

		module.factory('languageHandler', languageHandler);

		languageHandler.$inject = ['$locale', 'translator', 'userSettingsStore'];

		function languageHandler(locale, translator, userSettingsStore) {
			return {
				setLanguage: setLanguage,
				applyLanguage: applyLanguage,
				getCurrentLanguage: getCurrentLanguage
			};

			/**
    * Sets the language of the site.
    * @param language
    */
			function setLanguage(language) {
				guard.throwIfNotAString("EUP3004E", language, "language");

				userSettingsStore.language.set(language);

				applyLanguage();
			}

			/**
    * Applies the currently selected value, defaulting to the locale service if none is defined.
    */
			function applyLanguage() {
				var languageToApply = getCurrentLanguage();

				if (util.isNullOrUndefined(languageToApply) || languageToApply.length === 0) {
					languageToApply = locale.id;
				}

				translator.changeLanguage(languageToApply);
			}

			/**
    * Returns the language currently in use.
    */
			function getCurrentLanguage() {
				return userSettingsStore.language.get();
			}
		}

		return languageHandler;
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP2Z}
// di.einvoicing.ui.portal.components
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var util = $di.utility.util;

        module.controller('LanguageSelectorController', LanguageSelectorController);

        LanguageSelectorController.$inject = ['languageData', 'languageHandler'];

        function LanguageSelectorController(languageData, languageHandler) {
            var vm = this;

            vm.selectedLanguage = languageHandler.getCurrentLanguage();
            vm.selectableLanguages = null;
            vm.languageChanged = languageChanged;

            languageData.getLanguages().then(function (data) {
                vm.selectableLanguages = data;
            });

            /**
             * Handles the language being changed.
             * @param language
             */
            function languageChanged() {
                if (!util.isNullOrUndefined(vm.selectedLanguage) && util.isNonEmptyString(vm.selectedLanguage)) {

                    languageHandler.setLanguage(vm.selectedLanguage);
                }
            }
        }

        return LanguageSelectorController;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP2Y}
// di.einvoicing.ui.portal.components
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.directive('diLanguageSelector', diLanguageSelector);

        function diLanguageSelector() {
            return {
                restrict: 'E',
                replace: true,
                templateUrl: 'src/app/shared/components/language-selector/di-language-selector.html',
                controller: 'LanguageSelectorController',
                controllerAs: 'languageSelectorCtrl'
            };
        }

        return diLanguageSelector;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(324), __webpack_require__(327), __webpack_require__(325)], __WEBPACK_AMD_DEFINE_RESULT__ = function (statesLoader, auditListsLoader, auditActionButtonsLoader) {
	'use strict';

	return function (module) {
		statesLoader(module);
		auditListsLoader(module);
		auditActionButtonsLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.config(configureAuditStates);

		configureAuditStates.$inject = ['stateHelperProvider'];
		function configureAuditStates(stateHelperProvider) {
			stateHelperProvider.addStates({
				templateBaseUrl: "src/app/portal/audit/_states",
				parentStateName: 'portal.audit',
				states: [{
					stateName: "list",
					url: 'document/{id:int}',
					params: {
						id: 0
					}
				}]
			});
		}
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(326)], __WEBPACK_AMD_DEFINE_RESULT__ = function (auditActionButtons) {
    'use strict';

    return function (module) {
        module.component(auditActionButtons.AuditActionButtonsComponent.selector, auditActionButtons.AuditActionButtonsComponent);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AuditActionButtonsComponent = exports.AuditActionButtonsComponent = {
    selector: 'diAuditActionButtons',
    templateUrl: 'src/app/portal/audit/audit-action-buttons/audit-action-buttons.component.html',
    bindings: {
        selectedStates: '<',
        actionButtonsOptions: '<',
        onViewAudit: '&'
    },
    controller: function () {
        function controller() {
            _classCallCheck(this, controller);
        }

        _createClass(controller, [{
            key: 'viewAudit',
            value: function viewAudit() {
                this.onViewAudit();
            }
        }]);

        return controller;
    }()
};

/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(328), __webpack_require__(329), __webpack_require__(330)], __WEBPACK_AMD_DEFINE_RESULT__ = function (auditListConfiguratorLoader, auditListControllerLoader, auditListDirectiveLoader) {
	'use strict';

	return function (module) {
		auditListConfiguratorLoader(module);
		auditListControllerLoader(module);
		auditListDirectiveLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP5T}
// di.einvoicing.ui.portal.portal.audit.lists
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var guard = $di.exception.guard;

		module.provider('auditListConfigurator', AuditListConfiguratorProvider);

		/**
   * Manages audit list configuration and set up.
   */
		function AuditListConfiguratorProvider() {
			var config = {};

			var buttonsConfiguration = {
				type: "AUDIT",
				visibleButtons: [],
				buttons: [{
					rights: ["User"],
					name: 'view',
					statesRequired: ['VIEWABLE']
				}]
			};

			// Grid columns configuration
			var columnDefinitions = [{
				rights: ['User'],
				field: 'dateCreated',
				nameLanguageKey: 'EINVOICING.PORTAL.AUDIT.LISTS.COLUMN_HEADERS.DATE_CREATED',
				template: '<span>{{binding.dateCreatedTz | diDate : "DD/MM/YYYY HH:mm:ss z"}}</span>'
			}, {
				rights: ['User'],
				field: 'userDisplayName',
				nameLanguageKey: 'EINVOICING.PORTAL.AUDIT.LISTS.COLUMN_HEADERS.CREATED_BY',
				template: '<span>{{binding.userDisplayName}}</span>'
			}, {
				rights: ['User'],
				field: 'eventTypeName',
				nameLanguageKey: 'EINVOICING.PORTAL.AUDIT.LISTS.COLUMN_HEADERS.EVENT_TYPE',
				template: '<span ng-class="{\'viewable\': binding.isDocumentVersioned || binding.documentChangedEventId > 0}">{{binding.eventTypeName}}</span>'
			}];

			// Status filters configuration
			var eventTypeFilters = [{ value: 0, label: "EINVOICING.PORTAL.AUDIT.LISTS.FILTERS.ALL" }, { value: 2, label: "EINVOICING.PORTAL.AUDIT.LISTS.FILTERS.EVENT_TYPE.1" }, { value: 3, label: "EINVOICING.PORTAL.AUDIT.LISTS.FILTERS.EVENT_TYPE.2" }, { value: 4, label: "EINVOICING.PORTAL.AUDIT.LISTS.FILTERS.EVENT_TYPE.3" }, { value: 5, label: "EINVOICING.PORTAL.AUDIT.LISTS.FILTERS.EVENT_TYPE.4" }, { value: 6, label: "EINVOICING.PORTAL.AUDIT.LISTS.FILTERS.EVENT_TYPE.5" }, { value: 7, label: "EINVOICING.PORTAL.AUDIT.LISTS.FILTERS.EVENT_TYPE.6" }, { value: 8, label: "EINVOICING.PORTAL.AUDIT.LISTS.FILTERS.EVENT_TYPE.7" }, { value: 9, label: "EINVOICING.PORTAL.AUDIT.LISTS.FILTERS.EVENT_TYPE.8" }, { value: 10, label: "EINVOICING.PORTAL.AUDIT.LISTS.FILTERS.EVENT_TYPE.9" }, { value: 11, label: "EINVOICING.PORTAL.AUDIT.LISTS.FILTERS.EVENT_TYPE.10" }, { value: 12, label: "EINVOICING.PORTAL.AUDIT.LISTS.FILTERS.EVENT_TYPE.11" }, { value: 13, label: "EINVOICING.PORTAL.AUDIT.LISTS.FILTERS.EVENT_TYPE.12" }, { value: 40, label: "EINVOICING.PORTAL.AUDIT.LISTS.FILTERS.EVENT_TYPE.13" }];

			var dateTimeDefaultFilters = [{ value: "All", label: "EINVOICING.PORTAL.AUDIT.LISTS.FILTERS.DATE.ALL" }, { value: "Last30Days", label: "EINVOICING.PORTAL.AUDIT.LISTS.FILTERS.DATE.LAST_30_DAYS" }, { value: "ThisMonth", label: "EINVOICING.PORTAL.AUDIT.LISTS.FILTERS.DATE.THIS_MONTH" }, { value: "LastMonth", label: "EINVOICING.PORTAL.AUDIT.LISTS.FILTERS.DATE.LAST_MONTH" }, { value: "Today", label: "EINVOICING.PORTAL.AUDIT.LISTS.FILTERS.DATE.TODAY" }, { value: "Yesterday", label: "EINVOICING.PORTAL.AUDIT.LISTS.FILTERS.DATE.YESTERDAY" }, { value: "Custom", label: "EINVOICING.PORTAL.AUDIT.LISTS.FILTERS.DATE.CUSTOM", isHidden: true }];

			var dateTypesOptions = [{ value: 1, label: "EINVOICING.PORTAL.AUDIT.LISTS.FILTERS.DATE.TYPES.CREATED" }];

			var sortOptions = [{ value: 1, label: "EINVOICING.PORTAL.AUDIT.LISTS.FILTERS.SORT.TYPE_ASC" }, { value: 2, label: "EINVOICING.PORTAL.AUDIT.LISTS.FILTERS.SORT.TYPE_DESC" }, { value: 3, label: "EINVOICING.PORTAL.AUDIT.LISTS.FILTERS.SORT.CREATED_DATE_ASC" }, { value: 4, label: "EINVOICING.PORTAL.AUDIT.LISTS.FILTERS.SORT.CREATED_DATE_DESC" }, { value: 5, label: "EINVOICING.PORTAL.AUDIT.LISTS.FILTERS.SORT.CREATED_BY_ASC" }, { value: 6, label: "EINVOICING.PORTAL.AUDIT.LISTS.FILTERS.SORT.CREATED_BY_DESC" }];

			var initialEventTypeFilter = getOptionByValue(eventTypeFilters, 0);
			var initialDateTimeFilter = getOptionByValue(dateTimeDefaultFilters, 'All');
			var initialDateType = getOptionByValue(dateTypesOptions, 1);
			var initialSortOption = getOptionByValue(sortOptions, 4);

			// Provider definition
			var provider = {
				configure: configure,
				$get: $get
			};

			provider.$get.$inject = ['authorizedObjectsFilter'];

			return provider;

			function getOptionByValue(filterItems, value) {
				var filterItem = _.find(filterItems, function (obj) {
					return obj.value === value;
				});

				return filterItem;
			}

			/**
    * Configure the service
    * @param cfg
    */
			function configure(cfg) {
				guard.throwIfNotAnObject("EUP2H01E", cfg, 'cfg');

				config = cfg;
			}

			/**
    * Gets required configuration for the grid.
    */
			function $get(authorizedObjectsFilter) {
				return {
					getTableConfiguration: getTableConfiguration,
					getEventTypeFilters: getEventTypeFilters,
					getDateTimeFilters: getDateTimeFilters,
					getDateTypesOptions: getDateTypesOptions,
					getSortableColumns: getSortableColumns,
					getButtonsConfiguration: getButtonsConfiguration,

					getInitialFilter: getInitialFilter,
					getInitialEventTypeFilter: getInitialEventTypeFilter,
					getInitialDateTimeFilter: getInitialDateTimeFilter,
					getInitialDateType: getInitialDateType,
					getInitialSortOption: getInitialSortOption
				};

				/**
     * Gets initial set of all filters.
     */
				function getInitialFilter() {
					var initialFilters = [];

					initialFilters.push(initialEventTypeFilter);

					initialFilters.push(initialDateTimeFilter);

					return initialFilters;
				}

				/**
     * Gets initial set of even type filters.
     */
				function getInitialEventTypeFilter() {
					return initialEventTypeFilter;
				}

				/**
     * Gets initial set of date time filters.
     */
				function getInitialDateTimeFilter() {
					return initialDateTimeFilter;
				}

				/**
     * gets initial date type option
     */
				function getInitialDateType() {
					return initialDateType;
				}

				/**
     * Gets grid configuration options.
     */
				function getTableConfiguration() {
					authorizedObjectsFilter.requireRights(true);

					config.columns = authorizedObjectsFilter.getAuthorizedObjects(columnDefinitions);

					return config;
				}

				function getButtonsConfiguration() {
					authorizedObjectsFilter.requireRights(true);
					buttonsConfiguration.visibleButtons.fill(authorizedObjectsFilter.getAuthorizedObjects(buttonsConfiguration.buttons, true));
					return buttonsConfiguration;
				}

				/**
     * Gets grid default filters.
     */
				function getEventTypeFilters() {
					return eventTypeFilters;
				}

				/**
     * Gets date time default filters for the grid.
     */
				function getDateTimeFilters() {
					return dateTimeDefaultFilters;
				}

				/**
     * gets list of available date types
     */
				function getDateTypesOptions() {
					return dateTypesOptions;
				}

				/**
     * Gets the column intially used to sort the grid results
     */
				function getInitialSortOption() {
					return initialSortOption;
				}

				/**
     * Gets the columns which can be used to sort the grid
     */
				function getSortableColumns() {
					return sortOptions;
				}
			}
		}

		return AuditListConfiguratorProvider;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP5U}
// di.einvoicing.ui.portal.portal.audit.lists
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(40)], __WEBPACK_AMD_DEFINE_RESULT__ = function (moment) {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.controller('AuditListController', AuditListController);

		AuditListController.$inject = ['$scope', 'diState', '$stateParams', 'translator', 'notificationHandler', 'auditProxy', 'auditListConfigurator', 'elementNotifier', 'CLIENT_ENUMS', 'enumTranslator', 'authorizedObjectsFilter', 'modalSpinner', 'dateFormatter'];

		/**
   * Manages and configure audit list grid.
   */
		function AuditListController(scope, diState, stateParams, translator, notificationHandler, auditProxy, auditListConfigurator, elementNotifier, clientEnums, enumTranslator, authorizedObjectsFilter, modalSpinner, dateFormatter) {
			var vm = this;

			var resultsReachedNotification;
			vm.summary = {};

			vm.tableOptions = {};
			vm.actionButtonsOptions = {};
			vm.selectedFilters = {};
			vm.labels = {};
			vm.audits = [];
			vm.selectedStates = [];
			vm.sortOptions = [];
			vm.eventTypeOptions = [];
			vm.dateOptions = [];
			vm.dateTypes = [];

			vm.getAudits = getAudits;

			vm.viewAudit = viewAudit;
			vm.goToViewCurrent = goToViewCurrent;
			vm.orderChanged = orderChanged;
			vm.eventTypeChanged = eventTypeChanged;
			vm.dateChanged = dateChanged;
			vm.dateTypeChanged = dateTypeChanged;
			vm.onSelectedChanged = onSelectedChanged;
			vm.clearFilters = clearFilters;
			var spinner;
			initialise();

			return;

			/**
    * Initialises the audits table by configuring it and getting initial set of data.
    */
			function initialise() {
				setLabels();

				vm.tableOptions = auditListConfigurator.getTableConfiguration();
				vm.actionButtonsOptions = auditListConfigurator.getButtonsConfiguration();

				vm.sortOptions = auditListConfigurator.getSortableColumns();
				vm.eventTypeOptions = auditListConfigurator.getEventTypeFilters();
				vm.dateOptions = auditListConfigurator.getDateTimeFilters();
				vm.dateTypes = auditListConfigurator.getDateTypesOptions();

				translateColumnHeaders();
				vm.selectedFilters.dateType = auditListConfigurator.getInitialDateType();
				vm.selectedFilters.dateTimeFilter = auditListConfigurator.getInitialDateTimeFilter();
				vm.selectedFilters.eventTypeFilter = auditListConfigurator.getInitialEventTypeFilter();
				vm.selectedFilters.sortOption = auditListConfigurator.getInitialSortOption();
				vm.selectedFilters.customDateTimeFilter = { toDate: '', fromDate: '' };

				getSummary();

				return;

				function getSummary() {
					if (util.isNumber(stateParams.id)) {

						auditProxy.getAuditDocummentSummaryByDocumentId(stateParams.id).then(resolved, rejected);
					}

					return;

					function resolved(data) {
						vm.summary = data;

						translator.translate(vm.labels[vm.summary.documentTypeName.toLowerCase()]).then(function (translated) {
							vm.labels.summaryTitle = translated;
							vm.labels.summaryTitle += ' [' + vm.summary.documentNumber + ']';
						});

						getAudits();
					}

					function rejected() {
						notificationHandler.showError('EINVOICING.PORTAL.AUDIT.LISTS.ERROR_GETTING_AUDITS');
					}
				}

				/**
     * sets labels values depending on user rights
     */
				function setLabels() {
					var data = [{
						rights: ["User"],
						key: "title",
						label: "EINVOICING.PORTAL.AUDIT.LISTS.HEADER.TITLE"
					}, {
						rights: ["Supplier"],
						key: "invoice",
						label: "EINVOICING.PORTAL.AUDIT.LISTS.HEADER.TYPE.SUPPLIER_INVOICE"
					}, {
						rights: ["Buyer"],
						key: "invoice",
						label: "EINVOICING.PORTAL.AUDIT.LISTS.HEADER.TYPE.BUYER_INVOICE"
					}, {
						rights: ["Supplier"],
						key: "purchase order",
						label: "EINVOICING.PORTAL.AUDIT.LISTS.HEADER.TYPE.SUPPLIER_ORDER"
					}, {
						rights: ["Buyer"],
						key: "purchase order",
						label: "EINVOICING.PORTAL.AUDIT.LISTS.HEADER.TYPE.BUYER_ORDER"
					}];

					translator.whenReady().then(function () {
						_.each(data, function (item) {
							item.label = translator.instantTranslate(item.label);
						});

						vm.labels = authorizedObjectsFilter.getAuthorizedObjectsAsAssociative(data, 'key', 'label');
					});
				}

				/**
     * Translates each column header on the grid.
     */
				function translateColumnHeaders() {

					translator.whenReady().then(function () {
						_.each(vm.tableOptions.columns, function (column) {
							column.name = translator.instantTranslate(column.nameLanguageKey);
						});
					});
				}
			}

			/**
    * Reloads audits list.
    */
			function getAudits() {
				if (util.isDefined(resultsReachedNotification)) {
					resultsReachedNotification.hide();
				}
				showSpinner();

				var maxItemsToGet = vm.tableOptions.maxItemsToShow;
				var eventType = vm.selectedFilters.eventTypeFilter.value;
				var dateTimeFilters = vm.selectedFilters.dateTimeFilter.value;
				var sortOption = vm.selectedFilters.sortOption.value;
				var customDateTimeFilter = null;

				if (vm.selectedFilters.customDateTimeFilter.fromDate !== "" && vm.selectedFilters.customDateTimeFilter.toDate !== "") {
					customDateTimeFilter = vm.selectedFilters.customDateTimeFilter;
				}

				auditProxy.getAuditsByDocumentId(vm.summary.documentId, maxItemsToGet, eventType, dateTimeFilters, customDateTimeFilter, sortOption).then(resolved, rejected);

				return;

				function resolved(data) {
					if (data.length >= vm.tableOptions.maxItemsToShow) {

						translator.translate("EINVOICING.PORTAL.AUDIT.LISTS.MAXIMUM_INVOICES_REACHED").then(function (translated) {
							resultsReachedNotification = elementNotifier.warning(translated, findElement('#auditList'), { clickToHide: true });
							resultsReachedNotification.show();
						});
					}

					_.each(data, function (item) {
						item.dateCreatedTz = dateFormatter.toDateTimeWithZone(item.dateCreated);
					});

					if (data.length > 0) {
						if (data[0].documentType === 3) {
							changedEventAuditConverter(data);
						}

						vm.tableOptions.data.fill(data);
						vm.audits.fill(data);
					}
					removeSpinner();

					return;

					/**
       * Finds element in DOM
       */
					function findElement(key) {
						if (util.isFunction(scope.findElement)) {
							var element = scope.findElement(key);

							return element;
						}

						return null;
					}

					function changedEventAuditConverter(data) {
						//TODO:- hide anything with eventTypeId 41
						var sortedDataByDate = _.sortBy(data, function (item) {
							return item.dateCreated;
						});

						_.each(sortedDataByDate, function (item, index) {
							if (item.documentVersion > 1 && index > 0 && item.eventTypeId === 35) {
								translator.translate("EINVOICING.PORTAL.AUDIT.LISTS.REPLACE_TEXT.ORDER_UPDATED").then(function (translated) {
									item.eventTypeName = translated;
								});
							}
						});

						return data;
					}
				}

				function rejected() {
					removeSpinner();
					notificationHandler.showError('EINVOICING.PORTAL.AUDIT.LISTS.ERROR_GETTING_AUDITS');
				}
			}

			function viewAudit() {
				var audit = getSelectedAudit();

				if (audit.isDocumentVersioned === false && audit.documentChangedEventId === 0) {
					return;
				}

				switch (audit.documentType) {
					case 2:
						diState.go('portal.invoices.viewByAuditId', { id: audit.headerId, aid: audit.id });
						break;
					case 3:
						diState.go('portal.orders.viewByAuditId', { id: audit.headerId, aid: audit.documentChangedEventId > 1 ? audit.documentChangedEventId : audit.id });
						break;
				}
			}

			function goToViewCurrent() {
				switch (vm.summary.documentType) {
					case 2:
						diState.go('portal.invoices.viewById', { id: vm.summary.headerId });
						break;
					case 3:
						diState.go('portal.orders.viewById', { id: vm.summary.headerId });
						break;
				}
			}

			/**
    * Gets selected audit
    */
			function getSelectedAudit() {
				var selectedRows = getCurrentlySelectedAudits();

				if (selectedRows.length <= 0 || selectedRows.length > 1) {
					return {};
				}
				return selectedRows[0];

				/**
     * Get currently selected audits from the grid.
     */
				function getCurrentlySelectedAudits() {
					return _.filter(vm.audits, function (audit) {
						return audit.isSelected === true;
					});
				}
			}

			/**
    * resets the search filters on the page back to the default values
    */
			function clearFilters() {
				vm.selectedFilters.dateType = auditListConfigurator.getInitialDateType();
				vm.selectedFilters.dateTimeFilter = auditListConfigurator.getInitialDateTimeFilter();
				vm.selectedFilters.eventTypeFilter = auditListConfigurator.getInitialEventTypeFilter();
				vm.selectedFilters.sortOption = auditListConfigurator.getInitialSortOption();
				vm.selectedFilters.customDateTimeFilter = { toDate: '', fromDate: '' };

				getAudits();
			}

			/**
    * Event handler when rows selection changes
    */
			function onSelectedChanged(items) {
				var array = [];
				_.each(items, function (item) {
					if (item.isDocumentVersioned || item.documentChangedEventId > 0) {
						array.push("VIEWABLE");
					} else array.push("SELECTED");
				});

				vm.selectedStates.fill(array);
			}

			/**
    * Event handler when order filter has changed
    */
			function orderChanged(value) {
				var item = _.find(vm.sortOptions, function (option) {
					return option.value === value;
				});

				if (util.isUndefined(item)) {
					return;
				}

				vm.selectedFilters.sortOption = item;
			}

			/**
    * Event handler when event type filter has changed
    */
			function eventTypeChanged(value) {
				var item = _.find(vm.eventTypeOptions, function (option) {
					return option.value === value;
				});

				if (util.isUndefined(item)) {
					return;
				}

				vm.selectedFilters.eventTypeFilter = item;
			}

			/**
    * event when date filter has changed
    * @param {} value
    * @returns {}
    */
			function dateChanged(value, customDate) {
				var item = _.find(vm.dateOptions, function (option) {
					return option.value === value;
				});

				if (util.isUndefined(item)) {
					return;
				}

				vm.selectedFilters.dateTimeFilter = item;
				if (customDate) {
					vm.selectedFilters.customDateTimeFilter = customDate;
				}
			}

			/**
    * Event handler when date type changes
    */
			function dateTypeChanged(value) {
				var item = _.find(vm.dateTypes, function (option) {
					return option.value === value;
				});

				if (util.isUndefined(item)) {
					return;
				}

				vm.selectedFilters.dateType = item;
			}

			/**
   * Adds spinner to the page
   */
			function showSpinner() {
				spinner = modalSpinner.showModalSpinner("#spinnerHolder");
			}

			/**
    * Removes spinner from the page
   */
			function removeSpinner() {
				if (spinner) {
					spinner.remove();
				}
			}
		}

		return AuditListController;
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ng) {
    'use strict';

    return function (module) {
        module.directive('diAuditList', diAuditList);

        function diAuditList() {
            return {
                restrict: 'E',
                replace: true,
                scope: {},
                controller: "AuditListController",
                controllerAs: "auditListCtrl",
                templateUrl: 'src/app/portal/audit/audit-list/audit-list.html',
                link: link
            };

            function link(scope) {
                scope.findElement = findElement;

                return;

                function findElement(name) {
                    return ng.element(name);
                }
            }
        }

        return diAuditList;
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP95}
// di.core.angular.forceUrlReloader
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;

        module.provider('forceUrlReloader', ForceUrlReloaderProvider);

        /**
        * Handles memory leak issue. Will force a window to reload once the "forceUrlRefreshCountLimit" is reached.
        */
        function ForceUrlReloaderProvider() {
            var config = {
                enableForceUrlReload: false,
                forceUrlReloadLimit: 10,
                stateNames: []
            };

            var provider = {
                configure: configure,
                $get: $get
            };

            return provider;

            /**
            * Configure the service
            * @param cfg
            */
            function configure(cfg) {
                guard.throwIfNotAnObject("EUP9501E", cfg, "cfg");
                config = cfg;
            }

            function $get() {
                var service = {
                    process: process
                };

                return service;

                function process($rootScope, toState, toParams, fromState, fromParams) {
                    if (config.enableForceUrlReload === true) {
                        //check if moving from a known from state - aka has known memory issues!
                        if (config.stateNames.indexOf(fromState.name) >= 0) {
                            $rootScope.stateChangeCounter.stateChangeCount++;

                            if ($rootScope.stateChangeCounter.stateChangeCount >= config.forceUrlReloadLimit) {
                                $rootScope.stateChangeCounter.stateChangeCount = 0;
                                $rootScope.stateChangeCounter.forceRefresh = true;
                            }
                        }
                        //only reload from a previous state (prevent infinite refresh), check if moving from diffent state, and "forceRefresh" flag set.
                        if (fromState.name !== '' && fromState.name !== toState.name && $rootScope.stateChangeCounter.forceRefresh === true && config.stateNames.indexOf(fromState.name) < 0) {
                            $rootScope.stateChangeCounter.forceRefresh = false;
                            window.location.reload();
                        }
                    }
                }
            }
        }

        return ForceUrlReloaderProvider;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(333), __webpack_require__(353), __webpack_require__(352), __webpack_require__(334), __webpack_require__(336), __webpack_require__(340), __webpack_require__(342), __webpack_require__(344), __webpack_require__(346)], __WEBPACK_AMD_DEFINE_RESULT__ = function (statesLoader, grnRepositoryLoader, grnProxyLoader, grnActionButtonsLoader, grnDetailsLoader, grnFooterLoader, grnHeaderLoader, grnLinesLoader, grnListLoader) {
	'use strict';

	return function (module) {
		grnProxyLoader(module);
		statesLoader(module);
		grnRepositoryLoader(module);
		grnActionButtonsLoader(module);
		grnDetailsLoader(module);
		grnFooterLoader(module);
		grnHeaderLoader(module);
		grnLinesLoader(module);
		grnListLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP74}
// di.einvoicing.ui.portal.portal.grn
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.config(configureGrnStates);

		configureGrnStates.$inject = ['stateHelperProvider'];

		function configureGrnStates(stateHelperProvider) {
			stateHelperProvider.addStates({
				templateBaseUrl: "src/app/portal/grn/_states",
				parentStateName: 'portal.grn',
				states: [{
					stateName: "list",
					url: 'list?{dateType:int}&{dateTimeFilter}&{statusFilter:int}&{sortOption:int}&{fromDate:date}&{toDate:date}&{searchText}',
					data: {
						header: { title: "EINVOICING.PORTAL.GRN.LISTS.HEADER.TITLE" }
					},
					params: {
						dateType: undefined,
						dateTimeFilter: undefined,
						statusFilter: undefined,
						sortOption: undefined,
						fromDate: undefined,
						toDate: undefined,
						searchText: undefined,
						pageSize: undefined,
						pageNumber: undefined
					}
				}, {
					stateName: 'viewById',
					url: "id/{id:int}",
					params: {
						id: 0
					}
				}]
			});
		}
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(335)], __WEBPACK_AMD_DEFINE_RESULT__ = function (grnActionButtons) {
	'use strict';

	return function (module) {
		module.component(grnActionButtons.GrnActionButtonsComponent.selector, grnActionButtons.GrnActionButtonsComponent);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var GrnActionButtonsComponent = exports.GrnActionButtonsComponent = {
    selector: 'diGrnActionButtons',
    bindings: {
        selectedStates: '<',
        selectedActions: '<',
        selectedItemsCount: '<',
        buttonsSetOneOptions: '<',
        buttonsSetTwoOptions: '<',
        onViewGrn: '&',
        onGoToRelated: '&'
    },
    templateUrl: 'src/app/portal/grn/grn-action-buttons/grn-action-buttons.component.html',
    controller: function controller() {
        _classCallCheck(this, controller);
    }
};

/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(338), __webpack_require__(339), __webpack_require__(337)], __WEBPACK_AMD_DEFINE_RESULT__ = function (grnViewConfiguratorLoader, grnViewControllerLoader, grnDetailsDirectiveLoader) {
	'use strict';

	return function (module) {
		grnViewConfiguratorLoader(module);
		grnViewControllerLoader(module);
		grnDetailsDirectiveLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.directive('diGrnDetails', diGrnDetails);

        function diGrnDetails() {
            return {
                restrict: 'E',
                scope: {},
                controller: 'GrnViewController',
                controllerAs: 'grnController',
                templateUrl: 'src/app/portal/grn/grn-details/grn-details.html'
            };
        }
        return diGrnDetails;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP7K}
// di.einvoicing.ui.portal.portal.grn
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var guard = $di.exception.guard;

		module.provider('grnViewConfigurator', grnViewConfiguratorProvider);

		function grnViewConfiguratorProvider() {
			var config = {};
			var buttonsConfiguration = {};

			var columnDefinitions = [{
				rights: ['Supplier', 'Buyer'],
				field: 'lineNumber',
				nameLanguageKey: 'EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COLUMN_HEADERS.ID',
				template: '<span>{{binding.lineNumber}}</span>'
			}, {
				rights: ['Supplier'],
				field: 'suppliersProductCode',
				nameLanguageKey: 'EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COLUMN_HEADERS.SUPPLIER_CODE',
				template: '<span>{{ binding.suppliersProductCode }}</span>'
			}, {
				rights: ['Buyer'],
				field: 'customersProductCode',
				nameLanguageKey: 'EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COLUMN_HEADERS.CUSTOMER_CODE',
				template: '<span>{{ binding.customersProductCode }}</span>'
			}, {
				rights: ['Supplier', 'Buyer'],
				field: 'productTypeName',
				nameLanguageKey: 'EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COLUMN_HEADERS.PRODUCT_TYPE',
				template: '<span>{{ binding.productTypeName }}</span>'
			}, {
				rights: ['Supplier', 'Buyer'],
				field: 'itemName',
				nameLanguageKey: 'EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COLUMN_HEADERS.ITEM_NAME',
				template: '<span>{{ binding.itemName }}</span>'
			}, {
				rights: ['Supplier', 'Buyer'],
				field: 'itemDescription',
				nameLanguageKey: 'EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COLUMN_HEADERS.ITEM_DESCRIPTION',
				template: '<span>{{ binding.itemDescription }}</span>'
			}, {
				rights: ['Supplier', 'Buyer'],
				field: 'quantity',
				nameLanguageKey: 'EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COLUMN_HEADERS.QUANTITY',

				template: '<span>{{ binding.quantity }}</span>',
				cellClass: 'centeredcell'
			}, {
				rights: ['Supplier', 'Buyer'],
				field: 'quantityUnit',
				nameLanguageKey: 'EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COLUMN_HEADERS.QUANTITY_UNIT',
				template: '<span>{{ binding.quantityUnit }}</span>',
				cellClass: 'centeredcell'
			}];

			// Provider definition
			var provider = {
				configure: configure,
				$get: $get
			};

			provider.$get.$inject = ['authorizedObjectsFilter', 'CLIENT_ENUMS'];

			return provider;

			function configure(cfg) {
				guard.throwIfNotAnObject("EUP2H01E", cfg, 'cfg');

				config = cfg;
			}

			function $get(authorizedObjectsFilter, clientEnums) {
				buttonsConfiguration = {
					type: "Grn",
					visibleButtons: [],
					buttonsSetOne: [{
						rights: ["Foo"],
						name: 'render',
						action: clientEnums.userActions.downloadGoodsReceiptNote,
						singleAction: true
					}, {
						rights: ["User"],
						name: 'related',
						action: clientEnums.userActions.viewRelatedDocumentsGoodsReceiptNote,
						singleAction: true
					}]
				};
				return {
					getButtonsSetOneConfiguration: getButtonsSetOneConfiguration,
					getTableConfiguration: getTableConfiguration
				};

				function getButtonsSetOneConfiguration() {
					return getConfiguration(buttonsConfiguration.buttonsSetOne);
				}

				function getTableConfiguration() {
					config.columns = authorizedObjectsFilter.getAuthorizedObjects(columnDefinitions, false);
					return config;
				}

				function getConfiguration(array) {
					authorizedObjectsFilter.requireRights(true);

					var configuration = {
						type: "Grn",
						visibleButtons: []
					};
					configuration.visibleButtons.fill(authorizedObjectsFilter.getAuthorizedObjects(array, true));
					return configuration;
				}
			}
		};

		return grnViewConfiguratorProvider;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP7L}
// di.einvoicing.ui.portal.portal.grn.viewer
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	return function (module) {
		var util = $di.utility.util;
		module.controller('GrnViewController', GrnViewController);

		GrnViewController.$inject = ['$scope', 'authorizedObjectsFilter', 'grnViewConfigurator', 'grnProxy', 'documentAttributeResolver', 'notificationHandler', '$stateParams', 'modalSpinner', 'diState', 'documentStateResolver'];

		function GrnViewController(scope, authorizedObjectsFilter, grnViewConfigurator, grnProxy, documentAttributeResolver, notificationHandler, stateParams, modalSpinner, diState, documentStateResolver) {
			var vm = this;

			var spinner;

			vm.grn = {
				lines: [],
				attributes: []
			};

			var functionToGetGrn;
			var parameterToGetGrn;
			vm.selectedStates = [];
			vm.selectedAttributes = [];
			vm.backToList = backToList;
			vm.goToRelated = goToRelated;
			vm.tableOptions = grnViewConfigurator.getTableConfiguration();

			initialise();

			function initialise() {
				setLabels();
				vm.buttonsSetOneOptions = grnViewConfigurator.getButtonsSetOneConfiguration();

				loadGrn();
			}

			function setLabels() {
				var data = [{
					rights: ["Supplier"],
					key: "title",
					label: "EINVOICING.PORTAL.GRN.VIEWER.HEADER.TITLE_SUPPLIER"
				}, {
					rights: ["Buyer"],
					key: "title",
					label: "EINVOICING.PORTAL.GRN.VIEWER.HEADER.TITLE_BUYER"
				}, {
					rights: ["Supplier"],
					key: "notLoaded",
					label: "EINVOICING.PORTAL.GRN.VIEWER.COULD_NOT_LOAD_GRN"
				}, {
					rights: ["Buyer"],
					key: "notLoaded",
					label: "EINVOICING.PORTAL.GRN.VIEWER.COULD_NOT_LOAD_GRN"
				}, {
					rights: ["Supplier"],
					key: "detailsHeading",
					label: "EINVOICING.PORTAL.GRN.VIEWER.COMPONENTS.DETAILS.HEADING_SUPPLIER"
				}, {
					rights: ["Buyer"],
					key: "detailsHeading",
					label: "EINVOICING.PORTAL.GRN.VIEWER.COMPONENTS.DETAILS.HEADING_BUYER"
				}, {
					rights: ["Supplier"],
					key: "orderNumber",
					label: "EINVOICING.PORTAL.GRN.VIEWER.COMPONENTS.DETAILS.ORDER_NUMBER_SUPPLIER"
				}, {
					rights: ["Buyer"],
					key: "orderNumber",
					label: "EINVOICING.PORTAL.GRN.VIEWER.COMPONENTS.DETAILS.ORDER_NUMBER_BUYER"
				}, {
					rights: ["Supplier"],
					key: "goodsReceiptNoteNumber",
					label: "EINVOICING.PORTAL.GRN.LISTS.COLUMN_HEADERS.GRN_NUMBER"
				}, {
					rights: ["Buyer"],
					key: "goodsReceiptNoteNumber",
					label: "EINVOICING.PORTAL.GRN.LISTS.COLUMN_HEADERS.GRN_NUMBER"
				}];

				vm.labels = authorizedObjectsFilter.getAuthorizedObjectsAsAssociative(data, 'key', 'label');
			}

			function loadGrn() {
				if (util.isNumber(stateParams.id)) {
					functionToGetGrn = grnProxy.getById;
					parameterToGetGrn = stateParams.id;
				}

				if (functionToGetGrn) {
					showSpinner();
					functionToGetGrn(parameterToGetGrn).then(resolved, rejected);
				}

				function resolved(data) {
					removeSpinner();
					util.extend(vm.grn, data);

					setState(vm.grn.clientDocumentState);

					return;
				}

				function rejected() {
					removeSpinner();
					notificationHandler.showError(vm.labels.notLoaded, parameterToGetGrn);

					backToList();
				}
			}

			function setState(stateId) {
				var state = documentStateResolver.getDocumentState(stateId);
				vm.grn.clientDocumentState = stateId;
				vm.selectedStates.fill(state);

				documentStateResolver.calculateCurrentState('grn', vm.grn.clientDocumentState, true).then(function (state) {
					vm.currentState = state;
				});
			}

			function goToRelated() {
				if (util.isDefined(vm.grn.documentId)) {
					diState.go('portal.related.list', { id: vm.grn.documentId });
				}
			}

			function backToList() {
				diState.goBack().catch(function (reason) {
					diState.go('portal.grn.list');
				});
			}

			/**
    * Adds spinner to the page			 
    */
			function showSpinner() {
				if (!spinner) {
					spinner = modalSpinner.showModalSpinner("#spinner-container");
				}
			}

			/**
    * Removes spinner from the page
   */
			function removeSpinner() {
				if (spinner) {
					spinner.remove();
					spinner = undefined;
				}
			}
		}
		return GrnViewController;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(341)], __WEBPACK_AMD_DEFINE_RESULT__ = function (grnFooter) {
	'use strict';

	return function (module) {
		module.component(grnFooter.GrnFooterComponent.selector, grnFooter.GrnFooterComponent);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var GrnFooterComponent = exports.GrnFooterComponent = {
    selector: 'diGrnFooter',
    bindings: {
        deliveryNotes: '<'
    },
    templateUrl: 'src/app/portal/grn/grn-footer/grn-footer.component.html',
    controller: function controller() {
        _classCallCheck(this, controller);
    }
};

/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(343)], __WEBPACK_AMD_DEFINE_RESULT__ = function (grnHeader) {
	'use strict';

	return function (module) {
		module.component(grnHeader.GrnHeaderComponent.selector, grnHeader.GrnHeaderComponent);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var GrnHeaderComponent = exports.GrnHeaderComponent = {
    selector: 'diGrnHeader',
    bindings: {
        grn: '<',
        currentState: '<',
        labels: '<'
    },
    templateUrl: 'src/app/portal/grn/grn-header/grn-header.component.html',
    controller: function controller() {
        _classCallCheck(this, controller);
    }
};

/***/ }),
/* 344 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(345)], __WEBPACK_AMD_DEFINE_RESULT__ = function (grnLines) {
	'use strict';

	return function (module) {
		module.component(grnLines.GrnLinesComponent.selector, grnLines.GrnLinesComponent);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var GrnLinesComponent = exports.GrnLinesComponent = {
    selector: 'diGrnLines',
    bindings: {
        lines: '<',
        tableOptions: '<'
    },
    templateUrl: 'src/app/portal/grn/grn-lines/grn-lines.component.html',
    controller: function controller() {
        _classCallCheck(this, controller);
    }
};

/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(350), __webpack_require__(347), __webpack_require__(348), __webpack_require__(349)], __WEBPACK_AMD_DEFINE_RESULT__ = function (grnSearchLoader, grnListConfigurator, grnListController, grnListDirective) {
	'use strict';

	return function (module) {
		grnSearchLoader(module);
		grnListConfigurator(module);
		grnListController(module);
		grnListDirective(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP77}
// di.einvoicing.ui.portal.portal.grn.lists
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	"use strict";

	return function (module) {
		var guard = $di.exception.guard;
		var util = $di.utility.util;

		module.provider("grnListConfigurator", GrnListConfiguratorProvider);

		/**
   * Manages grn list configuration and set up.
   */
		function GrnListConfiguratorProvider() {
			var config = {};

			var buttonsConfiguration = {};

			// Grid columns configuration
			var columnDefinitions = [{
				order: 1,
				rights: ["Supplier", "Buyer"],
				field: "goodsReceiptNoteNumber",
				nameLanguageKey: "EINVOICING.PORTAL.GRN.LISTS.COLUMN_HEADERS.GRN_NUMBER",
				template: "<span>{{binding.goodsReceiptNoteNumber}}</span>"
			}, {
				order: 2,
				rights: ["Supplier"],
				field: "purchaseOrderNumber",
				nameLanguageKey: "EINVOICING.PORTAL.GRN.LISTS.COLUMN_HEADERS.ORDER_NUMBER_SUPPLIER",
				template: '<span ng-if="binding.purchaseOrderId > 0"><a ui-sref="portal.orders.viewById({{\'{id : binding.purchaseOrderId}\'}})">{{binding.purchaseOrderNumber}}</a></span><span ng-if="binding.purchaseOrderId == 0">{{binding.purchaseOrderNumber}}</span>'
			}, {
				order: 2,
				rights: ["Buyer"],
				field: "purchaseOrderNumber",
				nameLanguageKey: "EINVOICING.PORTAL.GRN.LISTS.COLUMN_HEADERS.ORDER_NUMBER_BUYER",
				template: '<span ng-if="binding.purchaseOrderId > 0"><a ui-sref="portal.orders.viewById({{\'{id : binding.purchaseOrderId}\'}})">{{binding.purchaseOrderNumber}}</a></span><span ng-if="binding.purchaseOrderId == 0">{{binding.purchaseOrderNumber}}</span>'
			}, {
				order: 3,
				rights: ["User"],
				field: "createdDateTime",
				nameLanguageKey: "EINVOICING.PORTAL.GRN.LISTS.COLUMN_HEADERS.CREATED_DATE",
				template: '<span>{{ binding.createdDateTime | diDate }}</span>',
				cellClass: "centeredcell"
			}, {
				order: 4,
				rights: ["Supplier", "Buyer"],
				field: "issuedDateTime",
				nameLanguageKey: "EINVOICING.PORTAL.GRN.LISTS.COLUMN_HEADERS.ISSUED_DATE",
				template: '<span>{{ binding.issuedDateTime | diDate }}</span>',
				cellClass: "centeredcell"
			}, {
				order: 5,
				rights: ["Supplier", "Buyer"],
				field: "deliveryDateTime",
				nameLanguageKey: "EINVOICING.PORTAL.GRN.LISTS.COLUMN_HEADERS.DELIVERY_DATE",
				template: '<span>{{ binding.deliveryDateTime | diDate }}</span>',
				cellClass: "centeredcell"
			}, {
				order: 6,
				rights: ["Buyer"],
				field: "supplier",
				nameLanguageKey: "EINVOICING.PORTAL.GRN.LISTS.COLUMN_HEADERS.SUPPLIER",
				template: '<div class="tooltip-wrap">\
									<span class="text-ellipsis">{{binding.supplier}}</span>\
									<div ng-if="(binding.supplier || \'\').length >= 35"\
										ng-class="((binding.supplier || \'\').length > 70) ? [\'tooltip\', \'tooltip-multiline\'] : \'tooltip\'">\
										<span>\
											{{ ::binding.supplier }}\
										</span>\
									</div>\
								</div>',
				cellClass: 'max-width-300'
			}, {
				order: 6,
				rights: ["Supplier"],
				field: "customer",
				nameLanguageKey: "EINVOICING.PORTAL.GRN.LISTS.COLUMN_HEADERS.BUYER",
				template: '<div class="tooltip-wrap">\
									<span class="text-ellipsis">{{binding.customer}}</span>\
									<div ng-if="(binding.customer || \'\').length >= 35"\
										ng-class="((binding.customer || \'\').length > 70) ? [\'tooltip\', \'tooltip-multiline\'] : \'tooltip\'">\
										<span>\
											{{ ::binding.customer }}\
										</span>\
									</div>\
								</div>',
				cellClass: 'max-width-300'
			}, {
				order: 7,
				rights: ["Supplier", "Buyer"],
				field: "totalLines",
				nameLanguageKey: "EINVOICING.PORTAL.GRN.LISTS.COLUMN_HEADERS.LINES",
				template: "<span>{{ binding.totalLines }}</span>",
				cellClass: "centeredcell"
			}, {
				order: 8,
				rights: ["Supplier", "Buyer"],
				field: "calculatedState",
				nameLanguageKey: "EINVOICING.PORTAL.GRN.LISTS.COLUMN_HEADERS.STATE",
				template: "<span>{{binding.calculatedState}}</span>",
				cellClass: "centeredcell"
			}];

			// Status filters configuration
			var statusFilters = [{
				rights: ["Buyer"],
				order: 1,
				value: 1,
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.ALL_BUYER"
			}, {
				rights: ["Supplier"],
				order: 1,
				value: 1,
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.ALL_SUPPLIER"
			}, {
				rights: ["Buyer"],
				order: 2,
				value: 2,
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.STATE.INVALID"
			}, {
				rights: ["Buyer"],
				order: 3,
				value: 3,
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.STATE.PENDING"
			}, {
				rights: ["Buyer"],
				order: 4,
				value: 4,
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.STATE.SUBMITTED"
			}, {
				rights: ["Buyer"],
				order: 5,
				value: 8,
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.STATE.SENTRECEIVED_BUYER"
			}, {
				rights: ["Supplier"],
				order: 6,
				value: 8,
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.STATE.SENTRECEIVED_SUPPLIER"
			}, {
				rights: ["User"],
				order: 7,
				value: 5,
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.STATE.RECONCILIATIONINVALID"
			}];

			var dateTimeDefaultFilters = [{
				value: "Last30Days",
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.DATE.LAST_30_DAYS",
				dateTypes: [1, 2, 3]
			}, {
				value: "LastMonth",
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.DATE.LAST_MONTH",
				dateTypes: [1, 2, 3]
			}, {
				value: "ThisMonth",
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.DATE.THIS_MONTH",
				dateTypes: [1, 2, 3]
			}, {
				value: "Yesterday",
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.DATE.YESTERDAY",
				dateTypes: [1, 2, 3]
			}, {
				value: "Today",
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.DATE.TODAY",
				dateTypes: [1, 2, 3]
			}, {
				value: "Custom",
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.DATE.CUSTOM",
				isHidden: true,
				dateTypes: [1, 2, 3]
			}, {
				value: "Tomorrow",
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.DATE.TOMORROW",
				dateTypes: [3]
			}, {
				value: "NextMonth",
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.DATE.NEXT_MONTH",
				dateTypes: [3]
			}, {
				value: "Next30Days",
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.DATE.NEXT_30_DAYS",
				dateTypes: [3]
			}];

			var dateTypesOptions = [{ value: 1, label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.DATE.TYPES.CREATED" }, { value: 2, label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.DATE.TYPES.ISSUED" }, { value: 3, label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.DATE.TYPES.DELIVERY" }];

			var sortOptions = [{
				rights: ["User"],
				value: 1,
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.SORT.GRN_NUMBER_ASC"
			}, {
				rights: ["User"],
				value: 2,
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.SORT.GRN_NUMBER_DESC"
			}, {
				rights: ["User"],
				value: 3,
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.SORT.ORDER_NUMBER_ASC"
			}, {
				rights: ["User"],
				value: 4,
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.SORT.ORDER_NUMBER_DESC"
			}, {
				rights: ["User"],
				value: 5,
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.SORT.CREATED_DATE_ASC"
			}, {
				rights: ["User"],
				value: 6,
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.SORT.CREATED_DATE_DESC"
			}, {
				rights: ["User"],
				value: 7,
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.SORT.ISSUE_DATE_ASC"
			}, {
				rights: ["User"],
				value: 8,
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.SORT.ISSUE_DATE_DESC"
			}, {
				rights: ["User"],
				value: 9,
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.SORT.DELIVERY_DATE_ASC"
			}, {
				rights: ["User"],
				value: 10,
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.SORT.DELIVERY_DATE_DESC"
			}, {
				rights: ["Supplier"],
				value: 13,
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.SORT.BUYER_ASC"
			}, {
				rights: ["Supplier"],
				value: 14,
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.SORT.BUYER_DESC"
			}, {
				rights: ["Buyer"],
				value: 15,
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.SORT.SUPPLIER_ASC"
			}, {
				rights: ["Buyer"],
				value: 16,
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.SORT.SUPPLIER_DESC"
			}, {
				rights: ["User"],
				value: 17,
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.SORT.LINES_ASC"
			}, {
				rights: ["User"],
				value: 18,
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.SORT.LINES_DESC"
			}, {
				rights: ["User"],
				value: 19,
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.SORT.STATUS_ASC"
			}, {
				rights: ["User"],
				value: 20,
				label: "EINVOICING.PORTAL.GRN.LISTS.FILTERS.SORT.STATUS_DESC"
			}];

			var initialStatusFilter = getOptionByValue(statusFilters, 1);
			var initialDateTimeFilter = getOptionByValue(dateTimeDefaultFilters, "Last30Days");
			var initialDateType = getOptionByValue(dateTypesOptions, 1);
			var initialSortOption = getOptionByValue(sortOptions, 6);

			// Provider definition
			var provider = {
				configure: configure,
				$get: $get
			};

			provider.$get.$inject = ["authorizedObjectsFilter", 'CLIENT_ENUMS'];

			return provider;

			function getOptionByValue(filterItems, value) {
				var filterItem = _.find(filterItems, function (obj) {
					return obj.value === value;
				});

				return filterItem;
			}

			/**
    * Configure the service
    * @param cfg
    */
			function configure(cfg) {
				guard.throwIfNotAnObject("EUP2H01E", cfg, "cfg");

				config = cfg;
			}

			/**
    * Gets required configuration for the grid.
    */
			function $get(authorizedObjectsFilter, clientEnums) {
				buttonsConfiguration = {
					type: "Grn",
					visibleButtons: [],
					buttonsSetOne: [{
						rights: ["User"],
						name: "view",
						action: clientEnums.userActions.viewGoodsReceiptNote,
						singleAction: true
					}],
					buttonsSetTwo: [{
						rights: ["Foo"],
						name: "render",
						action: clientEnums.userActions.downloadGoodsReceiptNote,
						singleAction: true
					}, {
						rights: ["User"],
						name: "related",
						action: clientEnums.userActions.viewRelatedDocumentsGoodsReceiptNote,
						singleAction: true
					}]
				};

				return {
					getTableConfiguration: getTableConfiguration,
					getStatusFilters: getStatusFilters,
					getDateTimeFilters: getDateTimeFilters,
					getDateTypesOptions: getDateTypesOptions,
					getSortableColumns: getSortableColumns,
					getButtonsSetOneConfiguration: getButtonsSetOneConfiguration,
					getButtonsSetTwoConfiguration: getButtonsSetTwoConfiguration,
					getInitialFilter: getInitialFilter,
					getInitialDateTimeFilter: getInitialDateTimeFilter,
					getInitialDateType: getInitialDateType,
					getInitialSortOption: getInitialSortOption,
					getInitialStatusFilter: getInitialStatusFilter,
					getFreeformSearchDefaultFilter: getFreeformSearchDefaultFilter
				};

				/**
     * Gets initial set of all filters.
     */
				function getInitialFilter() {
					var initialFilters = [];

					initialFilters.push(initialStatusFilter);

					initialFilters.push(initialDateTimeFilter);

					return initialFilters;
				}

				/**
     * Gets initial set of status filters.
     */
				function getInitialStatusFilter() {
					return initialStatusFilter;
				}

				/**
     * Gets initial set of date time filters.
     */
				function getInitialDateTimeFilter(dateTypeId) {
					if (util.isDefined(dateTypeId) && dateTypeId === 3) {
						initialDateTimeFilter = getOptionByValue(dateTimeDefaultFilters, "Next30Days");
					} else {
						initialDateTimeFilter = getOptionByValue(dateTimeDefaultFilters, 'Last30Days');
					}
					return initialDateTimeFilter;
				}

				/**
     * gets initial date type option
     */
				function getInitialDateType() {
					return initialDateType;
				}

				/**
     * Gets grid configuration options.
     */
				function getTableConfiguration() {
					var columns = authorizedObjectsFilter.getAuthorizedObjects(columnDefinitions, false);

					config.columns = _.sortBy(columns, function (column) {
						return column.order;
					});

					return config;
				}

				/**
     * Returns buttons set one configuration				 
     */
				function getButtonsSetOneConfiguration() {
					return getConfiguration(buttonsConfiguration.buttonsSetOne);
				}

				/**
     * Returns buttons set two configuration				 
     */
				function getButtonsSetTwoConfiguration() {
					return getConfiguration(buttonsConfiguration.buttonsSetTwo);
				}

				/**
     * Returns buttons configuration				 
     */
				function getConfiguration(array) {
					authorizedObjectsFilter.requireRights(true);

					var configuration = {
						type: "Grn",
						visibleButtons: []
					};
					configuration.visibleButtons.fill(authorizedObjectsFilter.getAuthorizedObjects(array, true));
					return configuration;
				}

				/**
     * Gets status filters
     */
				function getStatusFilters() {
					authorizedObjectsFilter.requireRights(false);
					var options = authorizedObjectsFilter.getAuthorizedObjects(statusFilters, false);
					return options;
				}

				/**
     * Gets date time default filters for the grid.
     */
				function getDateTimeFilters(dateTypeId) {
					var filters = dateTimeDefaultFilters;

					if (util.isDefined(dateTypeId)) {

						filters = _.filter(dateTimeDefaultFilters, function (filter) {
							return _.contains(filter.dateTypes, dateTypeId);
						});
					}

					return filters;
				}

				/**
     * gets list of available date types                     
     */
				function getDateTypesOptions() {
					return dateTypesOptions;
				}

				/**
     * Gets the column intially used to sort the grid results
     */
				function getInitialSortOption() {
					return initialSortOption;
				}

				/**
     * Gets the columns which can be used to sort the grid
     */
				function getSortableColumns() {
					authorizedObjectsFilter.requireRights(true);
					var options = authorizedObjectsFilter.getAuthorizedObjects(sortOptions, true);
					return options;
				}

				/**
     * Gets the filter to use when filtering triggered by freeform search box
     */
				function getFreeformSearchDefaultFilter() {
					return {
						statusFilter: getOptionByValue(getStatusFilters(), 1).value, //all
						sortOption: getOptionByValue(getSortableColumns(), 1).value, //grn number asc
						dateType: getOptionByValue(getDateTypesOptions(), 1).value, //created
						dateTimeFilter: getOptionByValue(getDateTimeFilters(), "Custom").value,
						fromDate: moment.utc([1900, 0, 1]).format(), // months, hours, minutes, seconds, and milliseconds are all zero indexed
						toDate: moment.utc().format()
					};
				}
			}
		}

		return GrnListConfiguratorProvider;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP78}
// di.einvoicing.ui.portal.portal.grn.lists
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.controller('GrnListController', GrnListController);

		GrnListController.$inject = ['diState', 'translator', 'enumTranslator', 'grnRepository', 'grnListConfigurator', '$scope', 'elementNotifier', 'authorizedObjectsFilter', 'CLIENT_ENUMS', 'authenticationData', 'documentStateResolver', 'documentAttributeResolver', 'userRightsRepository', 'userActionsResolver', 'modalSpinner', 'vmFiltersListConfigurator', 'dateFormatter', '$stateParams', 'listsParamsStore'];

		/**
   * Manages and configure goods receipt note list table.		
   */
		function GrnListController(diState, translator, enumTranslator, grnRepository, grnListConfigurator, scope, elementNotifier, authorizedObjectsFilter, clientEnums, authenticationData, documentStateResolver, documentAttributeResolver, userRightsRepository, userActionsResolver, modalSpinner, vmFiltersListConfigurator, dateFormatter, stateParams, listsParamsStore) {
			var vm = this;
			vm.loading = true;
			var resultsReachedNotification;

			vm.grns = [];
			vm.tableOptions = {};
			vm.buttonsSetOneOptions = {};
			vm.buttonsSetTwoOptions = {};
			vm.selectedStates = [];
			vm.selectedAttributes = [];
			vm.selectedActions = [];
			vm.selectedItemsCount = 0;
			vm.selectedFilters = {
				searchText: ""
			};
			vm.labels = {};
			vm.sortOptions = [];
			vm.statusOptions = [];
			vm.dateOptions = [];
			vm.dateTypes = [];

			vm.initialiseTable = initialiseTable;
			vm.filterGrns = filterGrns;
			vm.searchGrns = searchGrns;
			vm.goToRelated = goToRelated;

			vm.getCurrentlySelectedItems = getCurrentlySelectedItems;
			vm.orderChanged = orderChanged;
			vm.dateChanged = dateChanged;
			vm.dateTypeChanged = dateTypeChanged;
			vm.onSelectedChanged = onSelectedChanged;
			vm.statusChanged = statusChanged;
			vm.onPageSizeChanged = onPageSizeChanged;
			vm.onPageNumberChanged = onPageNumberChanged;
			vm.viewGrn = viewGrn;
			vm.clearFilters = clearFilters;
			var spinner;

			initialiseTable();

			return;

			/**
    * Initialises the table by configuring it and getting initial set of data.
    */
			function initialiseTable() {

				setLabels();

				vmFiltersListConfigurator.configure(stateParams, vm, grnListConfigurator);

				getGrns();

				return;

				/**
     * Sets labels values depending on user rights           
     */
				function setLabels() {
					var data = [{
						rights: ["Supplier"],
						key: "title",
						label: "EINVOICING.PORTAL.GRN.LISTS.HEADER.TITLE_SUPPLIER"
					}, {
						key: "title",
						rights: ["Buyer"],
						label: "EINVOICING.PORTAL.GRN.LISTS.HEADER.TITLE_BUYER"
					}];

					vm.labels = authorizedObjectsFilter.getAuthorizedObjectsAsAssociative(data, 'key', 'label');
				}
			}

			/*
    * Triggers the navigation to a new state with free form search applied
    * Filtering using the text search should ignore the set filters and use less restrictive filters
    */
			function searchGrns() {
				var filters = _.extend({}, vm.searchDefaultFilter || {}, { searchText: vm.selectedFilters.searchText });
				filterGrns(filters);
			}

			/**
    * Triggers the navigation to a new state with applied filters
    */
			function filterGrns(filterOptions) {
				vm.loading = true;
				var params = util.isRealObject(filterOptions) ? filterOptions : {
					dateType: vm.selectedFilters.dateType.value,
					dateTimeFilter: vm.selectedFilters.dateTimeFilter.value,
					statusFilter: vm.selectedFilters.statusFilter.value,
					sortOption: vm.selectedFilters.sortOption.value,
					fromDate: dateFormatter.toServerDate(vm.selectedFilters.customDateTimeFilter.fromDate),
					toDate: dateFormatter.toServerDate(vm.selectedFilters.customDateTimeFilter.toDate),
					searchText: vm.selectedFilters.searchText
				};
				//reset page number for each filtering
				params = setInitialPaginationDetails(params);

				//save current filters to local storage before navigating away
				storeParams(params);
				diState.go('.', params, { reload: true });
			}

			/**
    * Starts the loading spinner and calls the GRN repository to retrieve the goods receipt notes
    */
			function getGrns() {
				if (util.isDefined(resultsReachedNotification)) {
					resultsReachedNotification.hide();
				}
				showSpinner();

				var attributes = vm.selectedFilters.attributesFilter;
				var customDateTimeFilter = null;

				if (vm.selectedFilters.customDateTimeFilter.fromDate !== "" && vm.selectedFilters.customDateTimeFilter.toDate !== "") {
					customDateTimeFilter = {
						fromDate: dateFormatter.toServerDate(vm.selectedFilters.customDateTimeFilter.fromDate),
						toDate: dateFormatter.toServerDate(vm.selectedFilters.customDateTimeFilter.toDate)
					};
				}

				grnRepository.getGrns(vm.selectedFilters.searchText, vm.tableOptions.maxItemsToShow, vm.selectedFilters.dateType.value, vm.selectedFilters.dateTimeFilter.value, customDateTimeFilter, vm.selectedFilters.sortOption.value, vm.selectedFilters.statusFilter.value, attributes).then(resolved, rejected).finally(function () {
					vm.loading = false;
				});

				return;

				/**
     * Callback after promise resolved                
     */
				function resolved(data) {
					if (util.isUndefined(data)) {
						data = [];
					}

					if (data.length >= vm.tableOptions.maxItemsToShow) {
						translator.translate("EINVOICING.PORTAL.GRN.LISTS.MAXIMUM_GRNS_REACHED").then(function (translated) {
							resultsReachedNotification = elementNotifier.warning(translated, findElement('#grnList'), { clickToHide: true });
							resultsReachedNotification.show();
						});
					}

					translateDocumentStates(data);

					vm.grns.fill(data);

					resetAllowedActions();

					removeSpinner();
					return;

					function translateDocumentStates(array) {
						documentStateResolver.resolveDocumentStates("grn", array);

						_.each(array, function (grn) {

							getCalculatedState(grn.clientEInvoicingStateId).then(function (state) {
								grn.calculatedState = state;
							});

							grn.attributes = setAttributes(grn);
						});
					}

					function setAttributes(grn) {
						var array = documentAttributeResolver.resolveAttributeKeys(grn.attributes);

						if (isUserSupplier()) {
							documentAttributeResolver.removeAttribute(array, clientEnums.documentAttribute.notScheduledForPayment);
							documentAttributeResolver.removeAttribute(array, clientEnums.documentAttribute.scheduledForPayment);
						}

						return array;
					}

					/**
      * Finds element in DOM					             
      */
					function findElement(key) {
						if (util.isFunction(scope.findElement)) {
							var element = scope.findElement(key);

							return element;
						}

						return null;
					}
				}

				function rejected() {
					removeSpinner();
				}
			}

			function goToRelated() {
				var selected = getSelectedGrn();

				if (util.isDefined(selected.documentId)) {
					diState.go('portal.related.list', { id: selected.documentId });
				}
			}

			/**
    * Gets calculated document state			
    */
			function getCalculatedState(stateId) {
				return documentStateResolver.calculateCurrentState('grn', stateId, true);
			}

			/**
    * Event when order filter has changed            
    */
			function orderChanged(value) {
				var item = _.find(vm.sortOptions, function (option) {
					return option.value === value;
				});

				if (util.isUndefined(item)) {
					return;
				}

				vm.selectedFilters.sortOption = item;
			}

			/**
    * Event when date filter has changed           
    */
			function dateChanged(value, customDate) {
				var item = _.find(vm.dateOptions, function (option) {
					return option.value === value;
				});

				if (util.isUndefined(item)) {
					return;
				}

				vm.selectedFilters.dateTimeFilter = item;

				if (customDate) {
					vm.selectedFilters.customDateTimeFilter = customDate;
				} else {
					vm.selectedFilters.customDateTimeFilter.fromDate = '';
					vm.selectedFilters.customDateTimeFilter.toDate = '';
				}
			}

			/**
    * Event when date type changed			
    */
			function dateTypeChanged(value) {
				var item = _.find(vm.dateTypes, function (option) {
					return option.value === value;
				});

				if (util.isUndefined(item)) {
					return;
				}

				vm.selectedFilters.dateType = item;

				vm.dateOptions = grnListConfigurator.getDateTimeFilters(vm.selectedFilters.dateType.value);
				vm.selectedFilters.dateTimeFilter = grnListConfigurator.getInitialDateTimeFilter(vm.selectedFilters.dateType.value);
			}

			/**
    * Event handler when selection changed             
    */
			function onSelectedChanged(items) {
				vm.selectedItemsCount = items.length;

				var arrayStates = [];
				var arrayAttributes = [];
				var arrayActions = [];

				_.each(items, function (item) {
					arrayStates.push(item.documentStateKey);

					var array = [];

					array.fill(item.attributes);

					arrayActions.push(item.actions);

					_.each(array, function (attribute) {
						arrayAttributes.push(attribute);
					});
				});

				var resolvedActions = userActionsResolver.resolveActions(arrayActions, true);

				vm.selectedAttributes.fill(arrayAttributes);
				vm.selectedStates.fill(arrayStates);
				vm.selectedActions.fill(resolvedActions);
			}

			/**
    * Event handler when status filter has changed           
    */
			function statusChanged(value) {
				var item = _.find(vm.statusOptions, function (option) {
					return option.value === value;
				});

				if (util.isUndefined(item)) {
					return;
				}

				vm.selectedFilters.statusFilter = item;
			}

			function getSelectedGrn() {
				var selectedRows = getCurrentlySelectedItems();

				if (selectedRows.length === 1) {
					return selectedRows[0];
				}
				return {};
			}

			/*
    * Event handler when the size of the page changes
    */
			function onPageSizeChanged(newSize) {
				updateStoredParams({ pageSize: newSize, pageNumber: 1 });
			}

			/*
    * Event handler when the page changes
    */
			function onPageNumberChanged(newPageNumber) {
				updateStoredParams({ pageNumber: newPageNumber });
			}

			/**
    * resets the search filters on the page back to the default values
    */
			function clearFilters() {
				var initialFilters = {
					dateType: grnListConfigurator.getInitialDateType().value,
					dateTimeFilter: grnListConfigurator.getInitialDateTimeFilter().value,
					statusFilter: grnListConfigurator.getInitialStatusFilter().value,
					sortOption: grnListConfigurator.getInitialSortOption().value,
					fromDate: undefined,
					toDate: undefined,
					searchText: ""
				};

				filterGrns(initialFilters);
			}

			/**
    * Get currently selected items from the table.
    */
			function getCurrentlySelectedItems() {
				var selectedRows = [];

				vm.grns.forEach(function addToSelected(item) {
					if (item.isSelected === true) {
						selectedRows.push(item);
					}
				});

				return selectedRows;
			}

			function isUserSupplier() {
				return userRightsRepository.userHasRight("Supplier");
			}

			function viewGrn() {
				var selected = getSelectedGrn();

				if (util.isDefined(selected.id)) {
					diState.go('portal.grn.viewById', { id: selected.id });
				}
			}

			/**
    * resets allowed actions             
    */
			function resetAllowedActions() {
				vm.selectedItemsCount = 0;
				vm.selectedActions.clear();
			}

			/**
     * Adds spinner to the page			 
     */
			function showSpinner() {
				spinner = modalSpinner.showModalSpinner("#spinnerHolder");
			}

			/**
    * Removes spinner from the page
   */
			function removeSpinner() {
				if (spinner) {
					spinner.remove();
				}
			}

			/*
   * Stores the params in the local storage
   */
			function storeParams(params) {
				listsParamsStore.set("grns", params);
			}

			/*
    * Updates the params in the local storage
    */
			function updateStoredParams(params) {
				listsParamsStore.update("grns", params);
			}

			/*
    * Extends the source object with pageSize set to the current paginationPageSize and pageNumber set to 1
    */
			function setInitialPaginationDetails(source) {
				return _.extend(source, {
					pageSize: vm.tableOptions.paginationPageSize,
					pageNumber: 1
				});
			}
		}

		return GrnListController;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP79}
// di.einvoicing.ui.portal.portal.grn.lists
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ng) {
	'use strict';

	return function (module) {
		module.directive('diGrnList', diGrnList);

		function diGrnList() {
			return {
				restrict: 'E',
				replace: true,
				scope: {},
				controller: "GrnListController",
				controllerAs: "grnListCtrl",
				templateUrl: 'src/app/portal/grn/grn-list/grn-list.html',
				link: link
			};

			function link(scope) {
				scope.findElement = findElement;

				return;

				function findElement(name) {
					return ng.element(name);
				}
			}
		}

		return diGrnList;
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(351)], __WEBPACK_AMD_DEFINE_RESULT__ = function (grnSearch) {
	'use strict';

	return function (module) {
		module.component(grnSearch.GrnSearchComponent.selector, grnSearch.GrnSearchComponent);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var GrnSearchComponent = exports.GrnSearchComponent = {
    selector: 'diGrnSearch',
    bindings: {},
    templateUrl: 'src/app/portal/grn/grn-list/grn-search/grn-search.component.html',
    controller: function controller() {
        _classCallCheck(this, controller);
    }
};

/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP76}
// di.einvoicing.ui.portal.proxies
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;
        var util = $di.utility.util;

        module.factory('grnProxy', grnProxy);

        grnProxy.$inject = ['webApiHttp', '$q', 'CLIENT_ENUMS', 'enumTranslator', 'urlHelper', 'grnFormatter'];

        function grnProxy(http, $q, clientEnums, enumTranslator, urlHelper, grnFormatter) {
            var defaultFailureReason = 'EINVOICING.PORTAL.PROXIES.GRN.DEFAULT_ERROR';

            return {
                getGrns: getGrns,
                getById: getById
            };

            function getById(id) {
                var requestUrl = 'GoodsReceiptNote/GetById/' + id;

                var promise = http.get(requestUrl);

                var newPromise = promise.then(grnFormatter.reformatServerGrnDetailsForClient, errorReceivingGrn);

                return newPromise;
            }

            /**
             * calls web api for a list of goods receipt notes			
             */
            function getGrns(searchText, lastNRows, dateType, dateTimeFilters, customDateTimeFilter, sortOption, statusOption) {
                guard.throwIfNotANumber("EUP5L01E", lastNRows, "lastNRows");
                guard.throwIfInvalidId("EUP7601E", dateType, "dateType");
                guard.throwIfNullOrUndefined("EUP7602E", dateTimeFilters, "dateTimeFilters");
                guard.throwIfInvalidId("EUP7603E", sortOption, "sortOption");
                guard.throwIfInvalidId("EUP7604E", statusOption, "statusOption");

                if (!customDateTimeFilter) {
                    customDateTimeFilter = {
                        fromDate: new Date(),
                        toDate: new Date()
                    };
                }

                var requestedParams = {
                    lastNRows: lastNRows,
                    dateType: dateType,
                    dateTimeFilterOption: dateTimeFilters.toString(),
                    fromDate: JSON.stringify(customDateTimeFilter.fromDate).replace(/"/g, ""),
                    toDate: JSON.stringify(customDateTimeFilter.toDate).replace(/"/g, ""),
                    sortOption: sortOption,
                    statusOption: statusOption
                };

                if (util.isNonEmptyString(searchText)) {
                    requestedParams.searchText = searchText;
                }

                var requestedUrl = urlHelper.setParameters('GoodsReceiptNote/GetGoodsReceiptNoteSearchResults', requestedParams);

                var promise = http.get(requestedUrl).then(resolve, errorReceivingGrn);

                return promise;

                function resolve(data) {
                    return data;
                }
            }

            function errorReceivingGrn(error) {
                return errorProcessingGrn(error, 'EINVOICING.PORTAL.PROXIES.GRN.RECEIVE_ERROR');
            }

            function errorProcessingGrn(error, failureReason) {
                error.failureReason = failureReason || defaultFailureReason;
                return $q.reject(error);
            }
        }

        return grnProxy;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP75}
// di.einvoicing.ui.portal.portal.grn
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.factory('grnRepository', grnRepository);

		grnRepository.$inject = ['grnProxy', '$q', 'notificationHandler'];

		/**
   * Repository for methods on goods receipt note		
   */
		function grnRepository(grnProxy, $q, notificationHandler) {
			return {
				getGrns: getGrns
			};

			/**
    * Loads list of grns from database			 
    */
			function getGrns(searchText, lastNRows, dateType, dateTimeFilters, customDateTimeFilter, sortOption, statusOption) {
				var promise = grnProxy.getGrns(searchText, lastNRows, dateType, dateTimeFilters, customDateTimeFilter, sortOption, statusOption).then(resolved, rejected);

				return promise;

				function resolved(data) {
					return data;
				}

				function rejected(error) {
					error.failureReason = "EINVOICING.PORTAL.GRN.ACTIONS.NOTIFICATION.ERROR.RECEIVE_ERROR";
					return rejectWithErrorNotification(error, '');
				}
			}

			/**
    * rejects promise and displays error notification			
    */
			function rejectWithErrorNotification(error, reference) {
				notificationHandler.showError(error.failureReason, reference);

				return $q.reject(error).catch(function () {});
			}
		}

		return grnRepository;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(356), __webpack_require__(357), __webpack_require__(355)], __WEBPACK_AMD_DEFINE_RESULT__ = function (invoiceLinesColumnSettingsLoader, scrollbarResizerLoader, invoiceActionVerifierLoader) {

	'use strict';

	return function (module) {
		invoiceLinesColumnSettingsLoader(module);
		scrollbarResizerLoader(module);
		invoiceActionVerifierLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP93}
// di.einvoicing.ui.portal.portal.invoices._components
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.factory('invoiceActionVerifier', invoiceActionVerifier);

		invoiceActionVerifier.$inject = ['CLIENT_ENUMS'];

		function invoiceActionVerifier(clientEnums) {
			return {
				canBeEdited: canBeEdited,
				canBeSubmitted: canBeSubmitted
			};

			/**
    * Tests if invoice can be edited			
    */
			function canBeEdited(invoice) {
				var editAction = _.find(invoice.actions, function (action) {
					return action === clientEnums.userActions.editInvoice;
				});

				return typeof editAction === "undefined" ? false : true;
			}

			/**
    * Tests if invoice can be submitted             
    */
			function canBeSubmitted(invoice) {
				var submitAction = _.find(invoice.actions, function (action) {
					return action === clientEnums.userActions.submit;
				});

				return typeof submitAction === "undefined" ? false : true;
			}
		}

		return invoiceActionVerifier;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP3X}
// di.einvoicing.ui.portal.invoices.editor.components
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;

        guard.throwIfNotAnObject("EUP3X01E", module, "module");

        module.factory('invoiceLinesColumnSettings', invoiceLinesColumnSettings);

        function invoiceLinesColumnSettings() {
            var settings = getColumnSettings();

            return settings;

            /**
             * Returns a collection of settings for the invoice table columns.
             */
            function getColumnSettings() {
                return {
                    columns: [{
                        heading: '#',
                        headerClass: 'has-ordinal',
                        cellClass: 'centeredcell',
                        model: 'line.lineNumber',
                        template: '<p ' + 'class="centeredcell readonly" ' + 'ng-bind="binding.lineNumber">' + '</p>',
                        readonlyTemplate: '<p ' + 'class="centeredcell readonly" ' + 'ng-bind="binding.lineNumber">' + '</p>',
                        visible: true,
                        hideable: false,
                        editable: false,
                        tiny: true,
                        isColumn: true,
                        mandatory: true
                    }, {
                        heading: 'EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.SUPPLIER_CODE',
                        model: 'line.code',
                        headerClass: 'centeredcellMinWidth',
                        template: '<di-product-selector ' + 'subscribe-to-invoice-details-change="controller.subscribeToInvoiceDetailsChange" ' + 'scope-cache="controller.scopeCache" ' + 'bind-to-object="binding" ' + 'bind-to-property="code" ' + 'validation-name="suppliersProductCode" ' + 'validation-model-display-name="EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.SUPPLIER_CODE" ' + 'property-control="code" ' + 'on-change-accessor="controller.productCodeChanged">' + '</di-product-selector>',
                        readonlyTemplate: '<p class="readonly">' + '{{binding.code}}' + '</p>' + '<input ' + 'type="hidden" ' + 'ng-model="binding.code" ' + 'di-validate="suppliersProductCode"/>',
                        visible: true,
                        hideable: true,
                        editable: true,
                        isVisible: false,
                        isHidden: false,
                        isColumn: true,
                        mandatory: true
                    }, {
                        heading: 'EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.TYPE',
                        model: '(productLinesCtrl.productTypes[line.productType] || {}).name',
                        headerClass: 'centeredcellMinWidth',
                        template: '<di-product-type-selector ' + 'scope-cache="controller.scopeCache" ' + 'bind-to-object="binding" ' + 'bind-to-property="productType" ' + 'validation-property-name="productType" ' + 'bind-to-second-property="productTypeName" ' + 'validation-name="productType" ' + 'on-change-accessor="controller.productTypeChanged" ' + 'validation-model-display-name="EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.TYPE">' + '</di-product-type-selector>',
                        readonlyTemplate: '<p ' + 'class="readonly">' + '{{binding.productTypeName}}' + '</p>' + '<input ' + 'type="hidden" ' + 'ng-model="binding.productType" ' + 'di-validate="productType"/>',
                        visible: true,
                        hideable: true,
                        editable: true,
                        isVisible: false,
                        isHidden: false,
                        isColumn: true,
                        mandatory: true
                    }, {
                        heading: 'EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.ITEM_NAME',
                        model: 'line.itemName',
                        headerClass: 'centeredcellMinWidth',
                        template: "<di-input\n                                    ng-change=\"controller.lineChanged()\"\n                                    ng-model=\"binding\"\n                                    ng-model-property=\"itemName\"\n                                    validation-property-name=\"itemName\"\n                                    validation-model-display-name=\"EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.ITEM_NAME\"\n                                    di-input-type=\"text\">\n                                </di-input>",
                        readonlyTemplate: '<div ' + 'class="tooltip-wrap">' + '<p ' + 'class="readonly text-ellipsis">' + '{{binding.itemName}}' + '</p>' + '<input ' + 'type="hidden" ' + 'ng-model="binding.itemName" ' + 'di-validate="itemName"/>' + '<div ' + 'ng-if="(binding.itemName || \'\').length >= 35" ' + 'ng-class="((binding.itemName || \'\').length > 70) ? [\'tooltip\', \'tooltip-multiline\'] : \'tooltip\'">' + '<span>' + '{{binding.itemName}}' + '</span>' + '</div>' + '</div>',
                        visible: true,
                        hideable: false,
                        editable: true,
                        isVisible: false,
                        isHidden: false,
                        isColumn: true,
                        mandatory: true
                    }, {
                        heading: 'EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.DESCRIPTION',
                        model: 'line.description',
                        headerClass: 'centeredcellDesc',
                        template: "<di-input\n                                    ng-change=\"controller.lineChanged()\"\n                                    ng-model=\"binding\"\n                                    ng-model-property=\"itemDescription\"\n                                    validation-property-name=\"itemDescription\"\n                                    validation-model-display-name=\"EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.DESCRIPTION\"\n                                    di-input-type=\"text\">\n                                </di-input>",
                        readonlyTemplate: '<p ' + 'class="readonly">' + '{{binding.itemDescription}}' + '</p>' + '<input ' + 'type="hidden" ' + 'ng-model="binding.itemDescription" ' + 'di-validate="itemDescription"/>',
                        visible: true,
                        hideable: true,
                        editable: true,
                        isVisible: false,
                        isHidden: false,
                        isColumn: true,
                        mandatory: true
                    }, {
                        heading: 'EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.UNIT_PRICE',
                        headerClass: "centeredcell",
                        cellClass: "numericcell",
                        model: 'line.unitPrice',
                        dataType: 'number',
                        template: "<di-input                                     \n                                    ng-model=\"binding\"\n                                    ng-model-property=\"unitPrice\"\n                                    validation-property-name=\"unitPrice\"\n                                    ng-change=\"controller.lineChanged()\"\n                                    validation-model-display-name=\"EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.UNIT_PRICE\"\n                                    di-input-type=\"text\">\n                                </di-input>",
                        readonlyTemplate: '<p ' + 'class="readonly numericcell">{{binding.unitPrice | diCurrency:controller.currencyId}}' + '</p>' + '<input ' + 'type="hidden" ' + 'ng-model="binding.unitPrice" ' + 'di-validate="unitPrice"/>',
                        visible: true,
                        hideable: false,
                        editable: true,
                        isVisible: false,
                        isHidden: false,
                        isColumn: true,
                        mandatory: true
                    }, {
                        heading: 'EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.QUANTITY',
                        headerClass: "centeredcell",
                        cellClass: "numericcell",
                        model: 'line.quantity',
                        dataType: 'number',
                        template: "<di-input\n                                    class=\"numericcell\"\n                                    ng-model=\"binding\"\n                                    ng-model-property=\"quantity\"\n                                    ng-change=\"controller.lineChanged()\"\n                                    validation-property-name=\"quantity\"\n                                    validation-model-display-name=\"EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.QUANTITY\"\n                                    di-input-type=\"text\">\n                                </di-input>",
                        readonlyTemplate: '<p ' + 'class="readonly numericcell">' + '{{binding.quantity}}' + '</p>' + '<input ' + 'type="hidden" ' + 'ng-model="binding.quantity" ' + 'di-validate="quantity"/>',
                        visible: true,
                        hideable: false,
                        editable: true,
                        isVisible: false,
                        isHidden: false,
                        isColumn: true,
                        mandatory: true
                    }, {
                        heading: 'EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.QUANTITY_UNIT',
                        model: 'line.unitOfMeasureId ? (productLinesCtrl.unitsOfMeasure[line.unitOfMeasureId] || {}).name : ""',
                        headerClass: 'centeredcellMinWidth',
                        template: '<di-unit-of-measure-selector ' + 'scope-cache="controller.scopeCache" ' + 'bind-to-object="binding" ' + 'bind-to-property="unitOfMeasureId" ' + 'bind-to-second-property="quantityUnit" ' + 'validation-name="unitOfMeasureId" ' + 'validation-message="EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.ERRORS.QUANTITY_UNIT" ' + 'validation-model-display-name="EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.QUANTITY_UNIT" ' + 'di-validate-model="invoiceLine" ' + 'validation-property-name="unitOfMeasureId" ' + 'on-change-accessor="controller.productUnitOfMeasureChanged">' + '</di-unit-of-measure-selector>',
                        readonlyTemplate: '<p ' + 'class="readonly">' + '{{controller.getUnitOfmeasureLabel(binding)}}' + '</p>' + '<input ' + 'type="hidden" ' + 'ng-model="binding.quantityUnit"/>',
                        visible: true,
                        hideable: true,
                        editable: true,
                        isVisible: false,
                        isHidden: false,
                        isColumn: true,
                        mandatory: true
                    }, {
                        heading: 'EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.TAX_CODE',
                        model: 'line.taxCodeId ? line.taxCode + \': \' + line.taxRate + \'%\' : ""',
                        headerClass: 'centeredcellMinWidth',
                        template: '<di-tax-code-selector ' + 'subscribe-to-invoice-details-change="controller.subscribeToInvoiceDetailsChange" ' + 'scope-cache="controller.scopeCache" ' + 'bind-to-object="binding" ' + 'bind-to-property="taxCodeId" ' + 'validation-name="taxCodeId" ' + 'validation-model-display-name="EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.TAX_CODE" ' + 'di-validate-model="invoiceLine" ' + 'validation-property-name="taxCodeId" ' + 'on-change-accessor="controller.taxCodeChanged">' + '</di-tax-code-selector>',
                        readonlyTemplate: '<p ' + 'class="readonly">{{binding.taxCode ? binding.taxCode + \' (\' + binding.taxCategory + \'): \' + binding.taxRate + \'%\' : ""}}</p>' + '<input ' + 'type="hidden" ' + 'ng-model="binding.taxCodeId" ' + 'di-validate="taxCodeId"/>',
                        visible: true,
                        hideable: true,
                        editable: true,
                        isVisible: false,
                        isHidden: false,
                        isColumn: true,
                        mandatory: true
                    }, {
                        heading: 'EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.TAX_AMOUNT',
                        headerClass: "centeredcell",
                        cellClass: "numericcell",
                        model: 'line.taxAmount | diCurrency:productLinesCtrl.currencyId',
                        dataType: 'number',
                        template: '<p ' + 'class="readonly numericcell">' + '{{binding.taxAmount | diCurrency:controller.currencyId}}' + '</p>',
                        visible: true,
                        hideable: true,
                        editable: false,
                        isVisible: false,
                        isHidden: false,
                        isColumn: true,
                        mandatory: true
                    }, {
                        heading: 'EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.NET_AMOUNT',
                        headerClass: "centeredcell",
                        cellClass: "numericcell",
                        model: 'line.netAmount | diCurrency:productLinesCtrl.currencyId',
                        dataType: 'number',
                        template: '<p ' + 'class="readonly numericcell">' + '{{binding.netAmount | diCurrency:controller.currencyId}}' + '</p>',
                        visible: true,
                        hideable: false,
                        editable: false,
                        isVisible: false,
                        isHidden: false,
                        isColumn: true,
                        mandatory: true
                    }, {
                        heading: 'EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.ECLASS_CODE',
                        model: 'line.eClassCode',
                        headerClass: 'centeredcell',
                        template: "<di-input\n                                    ng-change=\"controller.lineChanged()\"\n                                    ng-model=\"binding\"\n                                    ng-model-property=\"eClassCode\"\n                                    validation-property-name=\"eClassCode\"\n                                    validation-model-display-name=\"EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.ECLASS_CODE\"\n                                    di-input-type=\"text\">\n                                </di-input>",
                        readonlyTemplate: '<p ' + 'class="readonly">' + '{{binding.eClassCode}}' + '</p>' + '<input ' + 'type="hidden" ' + 'ng-model="binding.eClassCode" ' + 'di-validate="eClassCode"/>',
                        visible: false,
                        hideable: true,
                        editable: true,
                        isVisible: true,
                        isHidden: false,
                        isColumn: false,
                        mandatory: false
                    }, {
                        heading: 'EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.PRICE_BASE_QUANTITY',
                        headerClass: "centeredcell",
                        cellClass: "numericcell",
                        model: 'line.priceBaseQuantity',
                        dataType: 'number',
                        template: "<di-input\n                                    class=\"numericcell\"\n                                    ng-model=\"binding\"\n                                    ng-model-property=\"priceBaseQuantity\"\n                                    ng-change=\"controller.lineChanged()\"\n                                    validation-property-name=\"priceBaseQuantity\"\n                                    validation-model-display-name=\"EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.PRICE_BASE_QUANTITY\"\n                                    di-input-type=\"text\">\n                                </di-input>",
                        readonlyTemplate: '<p ' + 'class="readonly numericcell">' + '{{binding.priceBaseQuantity}}' + '</p>' + '<input ' + 'type="hidden" ' + 'ng-model="binding.priceBaseQuantity" ' + 'di-validate="priceBaseQuantity"/>',
                        visible: false,
                        hideable: true,
                        editable: true,
                        isVisible: true,
                        isHidden: false,
                        isColumn: false,
                        mandatory: false
                    }, {
                        heading: 'EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.PERIOD_START_DATE',
                        headerClass: "centeredcell",
                        model: 'line.periodStartDate',
                        dataType: 'date',
                        template: '<di-input ' + 'di-input-type="date" ' + 'ng-model="binding" ' + 'ng-model-property="periodStartDate" ' + 'ng-model-options="{ updateOn: \'default blur\', debounce: {\'default\': 1000, \'blur\': 0} }" ' + 'ng-change="controller.lineChanged()" ' + 'validation-property-name="periodStartDate" ' + 'validation-model-display-name="{LABEL}">' + '</di-input>',
                        readonlyTemplate: '<p ' + 'class="readonly">' + '{{binding.periodStartDate}}' + '</p>',
                        visible: false,
                        hideable: true,
                        editable: true,
                        isVisible: true,
                        isHidden: false,
                        isColumn: false,
                        mandatory: false
                    }, {
                        heading: 'EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.PERIOD_END_DATE',
                        headerClass: "centeredcell",
                        model: 'line.periodEndDate',
                        dataType: 'date',
                        template: '<di-input ' + 'di-input-type="date" ' + 'ng-model="binding" ' + 'ng-model-property="periodEndDate" ' + 'ng-change="controller.lineChanged()" ' + 'ng-model-options="{ updateOn: \'default blur\', debounce: {\'default\': 1000, \'blur\': 0} }" ' + 'validation-property-name="periodEndDate" ' + 'validation-model-display-name="EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.PERIOD_END_DATE">' + '</di-input>',
                        readonlyTemplate: '<p ' + 'class="readonly">' + '{{binding.periodEndDate}}' + '</p>',
                        visible: false,
                        hideable: true,
                        editable: true,
                        isVisible: true,
                        isHidden: false,
                        isColumn: false,
                        mandatory: false
                    }, {
                        heading: 'EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.ORDER_LINE_REFERENCE',
                        model: 'line.orderLineReference',
                        headerClass: 'centeredcell',
                        template: "<di-input\n                                    ng-change=\"controller.lineChanged()\"\n                                    ng-model=\"binding\"\n                                    ng-model-property=\"orderLineReference\"\n                                    validation-property-name=\"orderLineReference\"\n                                    validation-model-display-name=\"EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.ORDER_LINE_REFERENCE\"\n                                    di-input-type=\"text\">\n                                </di-input>",
                        readonlyTemplate: '<p ' + 'class="readonly">' + '{{binding.orderLineReference}}' + '</p>' + '<input ' + 'type="hidden" ' + 'ng-model="binding.orderLineReference" ' + 'di-validate="orderLineReference"/>',
                        visible: false,
                        hideable: true,
                        editable: true,
                        isVisible: true,
                        isHidden: false,
                        isColumn: false,
                        mandatory: false
                    }, {
                        heading: 'EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.ACCOUNTING_COST_REFERENCE',
                        headerClass: "centeredcell",
                        model: 'line.accountingCostReference',
                        template: '<di-input ' + 'di-input-type="text" ' + 'ng-model="binding" ' + 'ng-model-property="accountingCostReference" ' + 'ng-change="controller.lineChanged()" ' + 'validation-property-name="accountingCostReference" ' + 'validation-model-display-name="EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.ACCOUNTING_COST_REFERENCE">' + '</di-input>',
                        readonlyTemplate: '<p ' + 'class="readonly">' + '{{binding.accountingCostReference}}' + '</p>',
                        visible: false,
                        hideable: true,
                        editable: true,
                        isVisible: true,
                        isHidden: false,
                        isColumn: false,
                        mandatory: false
                    }, {
                        heading: 'EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.INVOICE_NOTES',
                        headerClass: "centeredcell",
                        model: 'line.note',
                        template: '<di-input ' + 'di-input-type="text" ' + 'ng-model="binding" ' + 'ng-model-property="note" ' + 'ng-change="controller.lineChanged()" ' + 'validation-property-name="note" ' + 'validation-model-display-name="EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.INVOICE_NOTES">' + '</di-input>',
                        readonlyTemplate: '<p ' + 'class="readonly">' + '{{binding.note}}' + '</p>',
                        visible: false,
                        hideable: false,
                        editable: true,
                        isVisible: true,
                        isHidden: false,
                        isColumn: false,
                        mandatory: false
                    }, {
                        heading: 'EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.STANDARD_PRODUCT_CODE_SCHEME',
                        headerClass: "centeredcell",
                        model: 'line.standardProductCodeScheme',
                        dataType: 'date',
                        template: '<di-input ' + 'di-input-type="text" ' + 'ng-model="binding" ' + 'ng-model-property="standardProductCodeScheme" ' + 'ng-change="controller.lineChanged()" ' + 'validation-property-name="standardProductCodeScheme" ' + 'validation-model-display-name="EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.STANDARD_PRODUCT_CODE_SCHEME">' + '</di-input>',
                        readonlyTemplate: '<p ' + 'class="readonly">' + '{{binding.standardProductCodeScheme}}' + '</p>',
                        visible: false,
                        hideable: true,
                        editable: true,
                        isVisible: true,
                        isHidden: false,
                        isColumn: false,
                        mandatory: false
                    }, {
                        heading: 'EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.CHARGE_REASON',
                        headerClass: "centeredcell",
                        model: 'line.chargeReason',
                        template: '<di-input ' + 'di-input-type="text" ' + 'ng-model="binding" ' + 'ng-model-property="chargeReason" ' + 'ng-change="controller.lineChanged()" ' + 'validation-property-name="chargeReason" ' + 'validation-model-display-name="EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.CHARGE_REASON">' + '</di-input>',
                        readonlyTemplate: '<p ' + 'class="readonly">' + '{{binding.chargeReason}}' + '</p>',
                        visible: false,
                        hideable: true,
                        editable: true,
                        isVisible: true,
                        isHidden: false,
                        isColumn: false,
                        mandatory: false
                    }, {
                        heading: 'EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.CHARGE_AMOUNT',
                        headerClass: "centeredcell",
                        model: 'line.chargeAmount  | diCurrency:controller.currencyId',
                        dataType: 'number',
                        template: '<di-input ' + 'di-input-type="text" ' + 'ng-model="binding" ' + 'ng-model-property="chargeAmount" ' + 'ng-change="controller.lineChanged()" ' + 'validation-property-name="chargeAmount" ' + 'validation-model-display-name="EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.CHARGE_AMOUNT">' + '</di-input>',
                        readonlyTemplate: '<p ' + 'class="readonly">' + '{{binding.chargeAmount | diCurrency:controller.currencyId }}' + '</p>' + '<input ' + 'type="hidden" ' + 'ng-model="binding.chargeAmount" ' + 'di-validate="chargeAmount"/>',
                        visible: false,
                        hideable: true,
                        editable: true,
                        isVisible: true,
                        isHidden: false,
                        isColumn: false,
                        mandatory: false
                    }, {
                        heading: 'EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.ALLOWANCE_REASON',
                        headerClass: "centeredcell",
                        model: 'line.allowanceReason',
                        template: '<di-input ' + 'di-input-type="text" ' + 'ng-model="binding" ' + 'ng-model-property="allowanceReason" ' + 'ng-change="controller.lineChanged()" ' + 'validation-property-name="allowanceReason" ' + 'validation-model-display-name="EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.ALLOWANCE_REASON">' + '</di-input>',
                        readonlyTemplate: '<p ' + 'class="readonly">' + '{{binding.allowanceReason}}' + '</p>',
                        visible: false,
                        hideable: true,
                        editable: true,
                        isVisible: true,
                        isHidden: false,
                        isColumn: false,
                        mandatory: false
                    }, {
                        heading: 'EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.ALLOWANCE_AMOUNT',
                        headerClass: "centeredcell",
                        model: 'line.allowanceAmount  | diCurrency:controller.currencyId',
                        dataType: 'number',
                        template: '<di-input ' + 'di-input-type="text" ' + 'ng-model="binding" ' + 'ng-model-property="allowanceAmount" ' + 'ng-change="controller.lineChanged()" ' + 'validation-property-name="allowanceAmount" ' + 'validation-model-display-name="EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.ALLOWANCE_AMOUNT">' + '</di-input>',
                        readonlyTemplate: '<p ' + 'class="readonly">' + '{{binding.allowanceAmount | diCurrency:controller.currencyId}}' + '</p>' + '<input ' + 'type="hidden" ' + 'ng-model="binding.allowanceAmount" ' + 'di-validate="allowanceAmount/>',
                        visible: false,
                        hideable: true,
                        editable: true,
                        isVisible: true,
                        isHidden: false,
                        isColumn: false,
                        mandatory: false
                    }, {
                        heading: 'EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.CUSTOMER_PRODUCT_CODE',
                        headerClass: "centeredcell",
                        model: 'line.customersProductCode',
                        template: '<di-input ' + 'di-input-type="text" ' + 'ng-model="binding" ' + 'ng-model-property="customersProductCode" ' + 'ng-change="controller.lineChanged()" ' + 'validation-property-name="customersProductCode" ' + 'validation-model-display-name="EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.CUSTOMER_PRODUCT_CODE">' + '</di-input>',
                        readonlyTemplate: '<p ' + 'class="readonly">' + '{{binding.customersProductCode}}' + '</p>',
                        visible: false,
                        hideable: true,
                        editable: true,
                        isVisible: true,
                        isHidden: false,
                        isColumn: false,
                        mandatory: false
                    }, {
                        heading: 'EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.STANDARD_PRODUCT_CODE',
                        headerClass: "centeredcell",
                        model: 'line.standardProductCode',
                        template: '<di-product-selector ' + 'subscribe-to-invoice-details-change="controller.subscribeToInvoiceDetailsChange" ' + 'scope-cache="scopeCache" ' + 'bind-to-object="binding" ' + 'bind-to-property="standardProductCode" ' + 'on-change-accessor="controller.productStandardCodeChanged" ' + 'validation-name="standardProductCode" ' + 'property-control="standardCode" ' + 'validation-model-display-name="EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.STANDARD_PRODUCT_CODE" ' + 'hideable="false" ' + 'visible="true">' + '</di-product-selector>',
                        readonlyTemplate: '<p ' + 'class="readonly">' + '{{binding.standardProductCode}}' + '</p>' + '<input ' + 'type="hidden" ' + 'ng-model="binding.standardProductCode" ' + 'di-validate="standardProductCode" />',
                        visible: true,
                        hideable: true,
                        editable: true,
                        isVisible: true,
                        isHidden: false,
                        isColumn: false,
                        mandatory: true
                    }, {
                        heading: 'EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.ORIGIN_COUNTRY',
                        headerClass: "centeredcell",
                        model: 'line.originCountry',
                        template: '<di-dropdown-selector ' + 'items="controller.countries"\ ' + 'bind-to-object="binding" ' + 'bind-to-property="originCountryId" ' + 'on-change-accessor="controller.onOriginCountryChanged">' + '</di-dropdown-selector>',
                        readonlyTemplate: '<p ' + 'class="readonly">' + '{{binding.originCountryName}}' + '</p>',
                        visible: false,
                        hideable: true,
                        editable: true,
                        isVisible: true,
                        isHidden: false,
                        isColumn: false,
                        mandatory: false
                    }]
                };
            }
        }

        return invoiceLinesColumnSettings;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($, _) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP91}
// di.einvoicing.ui.portal.portal.invoices._components
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.factory('scrollbarResizer', scrollbarResizer);

        scrollbarResizer.$inject = ['$window'];

        function scrollbarResizer($window) {
            return {
                monitorHorizontalBrowserScrollbar: monitorHorizontalBrowserScrollbar,
                resizeHorizontalScrollbar: resizeHorizontalScrollbar
            };

            function monitorHorizontalBrowserScrollbar() {
                $(window).on("resize.doResize", _.debounce(function () {
                    resizeHorizontalScrollbar();
                }, 100));
            }

            function resizeHorizontalScrollbar() {
                var productTableWidth = $("#productLines").width();
                var leftToProductTableWidth = 340;
                var innerWidth = $window.innerWidth + 15;

                if (innerWidth <= leftToProductTableWidth + productTableWidth) {
                    $("body").css("width", leftToProductTableWidth + productTableWidth);
                } else {
                    $("body").css("width", "100%");
                }
            }
        }
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4), __webpack_require__(0)))

/***/ }),
/* 358 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(359), __webpack_require__(354), __webpack_require__(422), __webpack_require__(379), __webpack_require__(405), __webpack_require__(436), __webpack_require__(401), __webpack_require__(429), __webpack_require__(360), __webpack_require__(370), __webpack_require__(367), __webpack_require__(416), __webpack_require__(419), __webpack_require__(425), __webpack_require__(408), __webpack_require__(400), __webpack_require__(415), __webpack_require__(428)], __WEBPACK_AMD_DEFINE_RESULT__ = function (statesLoader, componentsLoader, sharedLoader, editorLoader, listsLoader, viewerLoader, invoiceRepositoryLoader, unitOfMeasureSelectorLoader, allowancesChargesLoader, documentIssuesLoader, attachmentsLoader, productSelectorLoader, productTypeSelectorLoader, taxCodeSelectorLoader, productLinesLoader, invoiceProxyLoader, productProxyLoader, taxProxyLoader) {
			'use strict';

			return function (module) {
						invoiceProxyLoader(module);
						productProxyLoader(module);
						taxProxyLoader(module);
						statesLoader(module);
						componentsLoader(module);
						sharedLoader(module);
						editorLoader(module);
						listsLoader(module);
						viewerLoader(module);
						invoiceRepositoryLoader(module);
						unitOfMeasureSelectorLoader(module);
						allowancesChargesLoader(module);
						documentIssuesLoader(module);
						attachmentsLoader(module);
						productSelectorLoader(module);
						productTypeSelectorLoader(module);
						taxCodeSelectorLoader(module);
						productLinesLoader(module);
			};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.config(configureInvoiceStates);

		configureInvoiceStates.$inject = ['stateHelperProvider'];
		function configureInvoiceStates(stateHelperProvider) {
			stateHelperProvider.addStates({
				templateBaseUrl: "src/app/portal/invoices/_states",
				parentStateName: 'portal.invoices',
				states: [{
					stateName: "list",
					data: {
						header: { title: "EINVOICING.PORTAL.INVOICES.LISTS.HEADER.TITLE" }
					},
					url: 'list?{dateType:int}&{dateTimeFilter}&{statusFilter:int}&{sortOption:int}&{fromDate:date}&{toDate:date}&{searchText}',
					params: {
						dateType: undefined,
						dateTimeFilter: undefined,
						statusFilter: undefined,
						sortOption: undefined,
						fromDate: undefined,
						toDate: undefined,
						searchText: undefined,
						pageSize: undefined,
						pageNumber: undefined
					}
				}, {
					stateName: "editor",
					rights: ["InvoiceWriter"],
					onlyCreateStateCollection: true,
					stateCollection: [{
						stateName: "new",
						rights: ["InvoiceCreator"],
						data: {
							header: { title: "EINVOICING.PORTAL.INVOICES.EDITOR.NEW.HEADER.TITLE" }
						}
					}, {
						stateName: "editByInvoiceNumber",
						url: '{invoiceNumber}',
						data: {
							header: { title: "EINVOICING.PORTAL.INVOICES.EDITOR.EDIT.HEADER.TITLE" }
						}
					}, {
						stateName: "editById",
						url: 'id/{id:int}',
						data: {
							header: { title: "EINVOICING.PORTAL.INVOICES.EDITOR.EDIT.HEADER.TITLE" }
						},
						params: {
							id: 0
						}
					}]
				}, {
					stateName: "viewer",
					rights: ["InvoiceReader"],
					onlyCreateStateCollection: true,
					stateCollection: [{
						stateName: "viewByInvoiceNumber",
						url: 'view/{invoiceNumber}',
						data: {
							header: { title: "EINVOICING.PORTAL.INVOICES.VIEWER.VIEW.HEADER.TITLE" }
						}
					}, {
						stateName: "viewById",
						url: 'view/id/{id:int}',
						data: {
							header: { title: "EINVOICING.PORTAL.INVOICES.VIEWER.VIEW.HEADER.TITLE" }
						},
						params: {
							id: 0
						}
					}, {
						stateName: "viewByAuditId",
						url: 'view/id/{id:int}-v{aid:int}',
						data: {
							header: { title: "EINVOICING.PORTAL.INVOICES.VIEWER.VIEW.HEADER.TITLE" }
						},
						params: {
							id: 0,
							aid: 0
						}
					}]
				}]
			});
		}
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(362), __webpack_require__(361), __webpack_require__(363)], __WEBPACK_AMD_DEFINE_RESULT__ = function (diAllowanceChargeDirectiveLoader, allowanceChargeControllerLoader, reasonSelectorLoader) {
    'use strict';

    return function (module) {
        diAllowanceChargeDirectiveLoader(module);
        allowanceChargeControllerLoader(module);
        reasonSelectorLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP8X}
// di.einvoicing.ui.portal.components.allowancesCharges.components
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.controller('AllowanceChargeController', AllowanceChargeController);

		AllowanceChargeController.$inject = ['$scope', 'taxProxy', 'filterFilter', 'invoiceProxy', 'staticLookupProxy', 'notificationHandler', 'associativeArrayConvertor', 'scopeCacheFactory', 'debounce', 'controlsRestrictionManager'];

		function AllowanceChargeController(scope, taxProxy, filterFilter, invoiceProxy, staticLookupProxy, notificationHandler, associativeArrayConvertor, scopeCacheFactory, debounce, controlsRestrictionManager) {

			var guard = $di.exception.guard;
			var util = $di.utility.util;
			var currentEditAllowanceCharge = {};
			var unWatchAllowanceCharge = null;

			var vm = this;
			vm.scopeCache = util.isDefined(scope.scopeCache) ? scope.scopeCache : scopeCacheFactory.create(scope);
			vm.readonly = util.isDefined(scope.readonly) ? scope.readonly : false;
			vm.allowancesCharges = scope.allowancesCharges;
			vm.subscribeToInvoiceDetailsChange = scope.subscribeToInvoiceDetailsChange;
			vm.allowanceChargeReasonChanged = allowanceChargeReasonChanged;
			vm.allowanceChargeChange = allowanceChargeChange;
			vm.taxCodeChanged = taxCodeChanged;
			vm.onChange = onChange;
			vm.isCharge = scope.isCharge;
			vm.currencyId = -1;
			vm.addAllowanceCharge = addAllowanceCharge;
			vm.removeAllowanceCharge = removeAllowanceCharge;
			vm.filteredItemsCount = 0;
			vm.toggleEdit = toggleEdit;
			vm.allowAddAllowanceCharge = true;

			if (scope.subscribeToInvoiceDetailsChange) {
				scope.subscribeToInvoiceDetailsChange(setChangedInvoiceDetails);
			}

			controlsRestrictionManager.addOptionsSubscription(function (options) {
				vm.allowAddAllowanceCharge = options.allowAddAllowanceCharge;
			});

			/**
   * Processed the changed invoice details
   * @param invoiceDetails
   */
			function setChangedInvoiceDetails(invoiceDetails) {
				if (util.isDefined(invoiceDetails.supplierPartyId)) {
					setPartyId(invoiceDetails.supplierPartyId);
				}

				if (util.isDefined(invoiceDetails.currencyId)) {
					vm.currencyId = invoiceDetails.currencyId;
				}

				setFilteredItemsCount();
			}

			function setFilteredItemsCount() {
				var filteredAllowancesAndChagers = _.filter(vm.allowancesCharges, function (item) {
					return item.isCharge === vm.isCharge;
				});

				if (filteredAllowancesAndChagers) {
					vm.filteredItemsCount = _.size(filteredAllowancesAndChagers);
				}
			}

			function setPartyId(partyId) {
				var taxPromise;

				vm.taxData = { taxes: {} };

				if (util.isUndefined(partyId) || partyId <= 0) {
					return;
				}

				if (util.isDefined(scope.scopeCache)) {
					taxPromise = scope.scopeCache.get('taxProxy.getTaxesByPartyId', taxProxy.getTaxesByPartyId, [partyId]);
				} else {
					taxPromise = taxProxy.getTaxesByPartyId(partyId);
				}

				taxPromise.then(taxesResolved, taxesRejected);

				function taxesResolved(data) {
					vm.taxData.taxes = associativeArrayConvertor.convert(data, function (tax) {
						return tax.id;
					});
				}

				function taxesRejected(error) {
					notificationHandler.showError(error.failureReason);
				}
			}

			function allowanceChargeReasonChanged(item, reason) {
				if (util.isDefined(reason.value)) {
					item.reasonCode = reason.code;
					item.reasonCodeId = reason.id;
					item.reason = reason.value;
				} else {
					item.reasonCode = null;
					item.reasonCodeId = 0;
					item.reason = reason.code;
				}
				allowanceChargeChange();
			}

			function taxCodeChanged(item, tax) {
				if (util.isDefined(tax)) {
					item.taxCode = tax.code;
					item.taxRate = tax.rate;
					item.taxCodeId = tax.id;
					item.taxCategory = tax.taxCategory;
				}
				allowanceChargeChange();
			}

			function allowanceChargeChange() {
				if (scope.onAllowanceChargeChange) {
					scope.onAllowanceChargeChange();
				}
			}

			function addAllowanceCharge() {
				vm.allowancesCharges.push({
					sequenceNumber: getMaxSequenceNumber() + 1,
					isCharge: scope.isCharge,
					taxRate: 0
				});
				if (scope.onChange) {
					scope.onChange();
				}
			}

			function getMaxSequenceNumber() {
				if (vm.allowancesCharges.length < 1) {
					return 0;
				}
				return Math.max.apply(Math, vm.allowancesCharges.map(function (v) {
					return v.sequenceNumber;
				}));
			}

			function removeAllowanceCharge(allowanceCharge) {
				guard.throwIfNullOrUndefined("EUP8E01E", allowanceCharge, "allowanceCharge");
				allowanceCharge.amountPayable = 0;

				vm.allowancesCharges.fill(_.reject(vm.allowancesCharges, function (current) {
					return current.sequenceNumber === allowanceCharge.sequenceNumber;
				}));
				scope.$emit('calculateInvoiceTotals');
				allowanceChargeChange();
			}

			function onChange() {

				var value = scope.bindToObject[scope.bindToProperty];
				if (scope.onChangeAccessor && util.isFunction(scope.onChangeAccessor)) {
					scope.onChangeAccessor(scope.bindToObject, value);
				}
			}

			function toggleEdit(allowanceCharge) {
				if (vm.readonly || allowanceCharge.editing) {
					return;
				}
				currentEditAllowanceCharge.editing = false;
				if (util.isFunction(unWatchAllowanceCharge)) {
					unWatchAllowanceCharge();
				}
				allowanceCharge.editing = true;
				currentEditAllowanceCharge = allowanceCharge;
				unWatchAllowanceCharge = watchAllowanceCharge(allowanceCharge);
			}

			/**
         * Watch a single allowanceCharge and re-calculate totals
         */
			function watchAllowanceCharge(ac) {
				return scope.$watch(function () {
					return ac;
				}, debounce(function () {
					scope.$emit('calculateInvoiceTotals');
				}, 250), true);
			}
		}
		return AllowanceChargeController;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP8F}
// di.einvoicing.ui.portal.invoices.editor.components
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.directive('diAllowancesCharges', diAllowancesCharges);

        function diAllowancesCharges() {
            return {
                restrict: 'E',
                replace: true,
                scope: {
                    subscribeToInvoiceDetailsChange: '=',
                    scopeCache: '=',
                    onChange: '=',
                    onAllowanceChargeChange: '=',
                    allowancesCharges: '=',
                    isCharge: '=',
                    readonly: '='
                },
                controller: 'AllowanceChargeController',
                controllerAs: 'allowanceChargeCtrl',
                templateUrl: 'src/app/portal/invoices/allowances-charges/allowance-charge.html',
                link: link
            };

            function link(scope) {
                scope.findElement = findElement;

                return;

                function findElement(name) {
                    return ng.element(name);
                }
            }
        }

        return diAllowancesCharges;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(365), __webpack_require__(366), __webpack_require__(364)], __WEBPACK_AMD_DEFINE_RESULT__ = function (diAllowanceChargeReasonSelectorDirectiveLoader, allowanceChargeReasonControllerLoader, allowanceChargeReasonRepositoryLoader) {
    'use strict';

    return function (module) {
        diAllowanceChargeReasonSelectorDirectiveLoader(module);
        allowanceChargeReasonControllerLoader(module);
        allowanceChargeReasonRepositoryLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP8R}
// di.einvoicing.ui.portal.components.allowancesCharges
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.factory('allowanceChargeReasonRepository', allowanceChargeReasonRepository);

        allowanceChargeReasonRepository.$inject = ['staticLookupProxy'];

        function allowanceChargeReasonRepository(staticLookupProxy) {
            var reasons = null;

            return {
                getAllowanceChargeReasons: getAllowanceChargeReasons
            };

            function getAllowanceChargeReasons(scopeCache) {
                var promise = scopeCache.get('staticLookupProxy.getAllowanceChargeReasonCodes', staticLookupProxy.get, ['AllowanceChargeReasonCode']).then(success);

                return promise;

                function success(data) {
                    reasons = data;

                    _.each(reasons, function (reason) {

                        reasons.label = reason.code;
                        reasons.value = reason.value;
                    });

                    return reasons;
                }
            }
        }

        return allowanceChargeReasonRepository;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP8W}
// di.einvoicing.ui.portal.components.allowancesCharges
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var util = $di.utility.util;
        module.directive('diAllowanceChargeReasonSelector', diAllowanceChargeReasonSelector);

        function diAllowanceChargeReasonSelector() {
            return {
                restrict: 'E',
                replace: true,
                scope: {
                    tabIndex: '@',
                    items: '=',
                    scopeCache: '=',
                    bindToObject: '=',
                    bindToProperty: '@',
                    bindToSecondProperty: '@',
                    onChangeAccessor: '&',
                    validationMessage: '@',
                    validationName: '@',
                    validationModelDisplayName: '@'
                },
                controller: 'AllowanceChargeReasonController',
                controllerAs: 'allowanceChargeReasonCtrl',
                template: template
            };

            /**
            * Generates html template             
            */
            function template(element, attrs) {
                var html = '<div>\
								<di-select\
									mode="autoComplete"\
									items="allowanceChargeReasonCtrl.items"\
									item-unique-property="id"\
									bind-to-object="allowanceChargeReasonCtrl"\
									bind-to-property="item"\
									display-property="value"\
									searchable-properties="value"';

                html += getValidationHtml(attrs);
                html += 'on-change-accessor="allowanceChargeReasonCtrl.onChangeAccessor"\
									placeholder="EINVOICING.PORTAL.INVOICES.COMPONENTS.ALLOWANCES_CHARGES.REASON_SEARCH">\
									<b ng-if="filteredItem.item.code">{{::filteredItem.item.code}}: {{::filteredItem.item.value}}\
								</di-select></div>';
                return html;

                /**
                * Adds validation attributes                 
                */
                function getValidationHtml(attrs) {
                    var innerHtml = "";

                    if (util.isDefined(attrs.validationName)) {
                        var displayName = attrs.validationName;
                        if (util.isDefined(attrs.validationModelDisplayName)) {
                            displayName = attrs.validationModelDisplayName;
                        }

                        innerHtml += 'di-validate="{{::validationName}}"' + 'validation-model="bindToObject[bindToProperty]"' + 'validation-message="{{::validationMessage}}"' + 'validation-model-display-name="' + displayName + '"';
                    }
                    return innerHtml;
                }
            }
        }
        return diAllowanceChargeReasonSelector;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP8S}
//di.einvoicing.ui.portal.components.allowancesCharges
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var util = $di.utility.util;

        module.controller('AllowanceChargeReasonController', AllowanceChargeReasonController);

        AllowanceChargeReasonController.$inject = ['$scope', 'allowanceChargeReasonRepository'];

        function AllowanceChargeReasonController(scope, allowanceChargeReasonRepository) {
            var vm = this;
            vm.onChangeAccessor = setBoundIdFromSelectedItem;
            vm.item = {};
            vm.items = [];

            init();

            return;

            function init() {
                allowanceChargeReasonRepository.getAllowanceChargeReasons(scope.scopeCache).then(function (data) {
                    vm.items.fill(data);

                    scope.$watch(function () {
                        return scope.bindToObject[scope.bindToProperty];
                    }, setSelectedItemFromBoundId);

                    return;

                    function setSelectedItemFromBoundId() {
                        if (util.isDefined(vm.item.id) && scope.bindToObject[scope.bindToProperty] === vm.item.id) {
                            return;
                        }

                        if (scope.bindToObject[scope.bindToProperty] === -1) {
                            var unknownItem = {
                                id: 0,
                                reason: scope.bindToObject[scope.bindToSecondProperty],
                                reasonCode: scope.bindToObject[scope.bindToSecondProperty]
                            };

                            var exist = _.find(vm.items, function (item) {
                                return item.id === unknownItem.id;
                            });

                            if (util.isUndefined(exist)) {
                                vm.items.push(unknownItem);
                            }
                            scope.bindToObject[scope.bindToProperty] = unknownItem.id;
                        }

                        var item = _.find(vm.items, function (item) {
                            return item.value === scope.bindToObject[scope.bindToProperty];
                        });

                        if (util.isUndefined(item)) {
                            item = {
                                id: 0,
                                value: scope.bindToObject[scope.bindToProperty],
                                code: scope.bindToObject[scope.bindToProperty]
                            };
                        }
                        vm.item = item;
                    }
                });
            }

            function setBoundIdFromSelectedItem() {
                var accessor;

                scope.bindToObject[scope.bindToProperty] = (vm.item || {}).id;

                if (util.isFunction(scope.onChangeAccessor)) {
                    accessor = scope.onChangeAccessor();

                    if (util.isFunction(accessor)) {
                        accessor(scope.bindToObject, vm.item);
                    }
                }
            }
        }

        return AllowanceChargeReasonController;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(369), __webpack_require__(368)], __WEBPACK_AMD_DEFINE_RESULT__ = function (attachmentUploader, attachmentConfiguratorProviderLoader) {
    'use strict';

    return function (module) {
        module.component(attachmentUploader.AttachmentUploaderComponent.selector, attachmentUploader.AttachmentUploaderComponent);

        attachmentConfiguratorProviderLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP6V}
// di.einvoicing.ui.portal.components.attachmentUploader
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var guard = $di.exception.guard;

		module.provider('documentAttachmentConfigurator', documentAttachmentConfiguratorProvider);

		/**
   * Manages configuration of the attachment uploader component
   */
		function documentAttachmentConfiguratorProvider() {
			var maximumAttachmentSize;
			var disallowedFileExtensions;

			var provider = {
				configure: configure,
				$get: $get
			};

			return provider;

			/**
    * Configure the service
    * @param cfg
    */
			function configure(cfg) {
				guard.throwIfNotAnObject("EUP6V01E", cfg, 'cfg');

				maximumAttachmentSize = cfg.maximumAttachmentSize;
				disallowedFileExtensions = cfg.disallowedFileExtensions;
			}

			/**
    * Gets required configuration for the document attachment controller.
    */
			function $get() {
				return {
					getMaximumAttachmentSize: getMaximumAttachmentSize,
					getDisallowedFileExtensions: getDisallowedFileExtensions
				};

				function getMaximumAttachmentSize() {
					return maximumAttachmentSize;
				}

				function getDisallowedFileExtensions() {
					return disallowedFileExtensions;
				}
			}
		}

		return documentAttachmentConfiguratorProvider;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var util = $di.utility.util;

var AttachmentUploaderComponent = exports.AttachmentUploaderComponent = {
    templateUrl: 'src/app/portal/invoices/attachment-uploader/attachment-uploader.component.html',
    selector: 'diAttachmentUploader',
    bindings: {
        tabIndex: '@',
        bindToObject: "<",
        attachmentDataId: "<",
        fileName: "<",
        download: '&',
        onUploadStateChanged: '&'
    },
    controller: function () {
        function controller($scope, $element, documentAttachmentConfigurator, attachmentProxy, notificationHandler, elementNotifier, translator, fileExtensionValidator) {
            _classCallCheck(this, controller);

            this.$scope = $scope;
            this.$element = $element;
            this.documentAttachmentConfigurator = documentAttachmentConfigurator;
            this.attachmentProxy = attachmentProxy;
            this.notificationHandler = notificationHandler;
            this.elementNotifier = elementNotifier;
            this.translator = translator;
            this.fileExtensionValidator = fileExtensionValidator;

            this.showSpinner = false;

            this.onFileSelected = this.onFileSelected.bind(this);
        }

        _createClass(controller, [{
            key: '$onInit',
            value: function $onInit() {
                var _this = this;

                this.removeSpinner();

                this.maxSize = this.documentAttachmentConfigurator.getMaximumAttachmentSize();

                this.$scope.$watch(function () {
                    return _this.invalidFile;
                }, this.setLanguageFailureKey());
            }
        }, {
            key: '$onChanges',
            value: function $onChanges(changes) {
                if (util.isNullOrUndefined(changes.fileName.currentValue) || util.isNullOrUndefined(changes.attachmentDataId.currentValue)) {

                    this.setUploadButtonVisibility(true);
                    this.selectedFileName = undefined;
                    this.selectedAttachmentDataId = undefined;
                } else {
                    this.setUploadButtonVisibility(false);
                    this.selectedFileName = changes.fileName.currentValue;
                    this.selectedAttachmentDataId = changes.attachmentDataId.currentValue;
                }
            }
        }, {
            key: 'onFileSelected',
            value: function onFileSelected() {
                var _this2 = this;

                if (util.isObject(this.file)) {
                    this.showUploadButton = false;
                    this.showFileName = false;

                    if (this.fileExtensionValidator.isFileExtensionValid(this.file.name) === false) {
                        this.notificationHandler.showInfo('EINVOICING.PORTAL.COMPONENTS.ATTACHMENTS.INVALID_FILE_TYPE');
                        this.showUploadButton = true;
                        return;
                    };

                    this.onUploadStarted();

                    this.addSpinner();

                    this.hideUploadErrorNotification();

                    this.attachmentProxy.addAttachmentData(this.file).then(function (data) {
                        _this2.setUploadButtonVisibility(false);

                        _this2.selectedFileName = _this2.file.name;
                        _this2.selectedAttachmentDataId = data;
                        _this2.onUploadSuccessful();
                    }, function () {
                        _this2.setUploadButtonVisibility(true);

                        _this2.ctrl.selectedFileName = undefined;
                        _this2.ctrl.selectedAttachmentDataId = undefined;

                        _this2.onUploadFailed();
                    }).finally(function () {
                        _this2.file = undefined;
                        _this2.removeSpinner();
                    });
                }
            }
        }, {
            key: 'onUploadStarted',
            value: function onUploadStarted() {
                this.handleUploadStateChange({
                    lineIdentifier: this.bindToObject,
                    status: 'started'
                });
            }
        }, {
            key: 'onUploadSuccessful',
            value: function onUploadSuccessful() {
                this.handleUploadStateChange({
                    lineIdentifier: this.bindToObject,
                    status: 'success',
                    attachmentDataId: this.selectedAttachmentDataId,
                    filename: this.selectedFileName
                });
            }
        }, {
            key: 'onUploadFailed',
            value: function onUploadFailed() {
                this.handleUploadStateChange({
                    lineIdentifier: this.bindToObject,
                    status: 'failed'
                });
            }
        }, {
            key: 'handleUploadStateChange',
            value: function handleUploadStateChange(state) {
                if (util.isFunction(this.onUploadStateChanged)) {
                    this.onUploadStateChanged(state);
                }
            }

            /**
             * event handler when file selection fails         
             */

        }, {
            key: 'setLanguageFailureKey',
            value: function setLanguageFailureKey() {
                var _this3 = this;

                return function () {
                    if (util.isObject(_this3.invalidFile)) {
                        var failureReason = _this3.invalidFile.$error.replace(/([A-Z])/g, "_$1").toUpperCase();

                        var errorKey = 'EINVOICING.PORTAL.COMPONENTS.ATTACHMENTS.FILE_ERRORS.' + failureReason;

                        var translationArgs = {
                            maxSize: _this3.maxSize
                        };

                        _this3.translator.translate(errorKey, translationArgs).then(function (translated) {
                            _this3.uploadErrorNotification = _this3.elementNotifier.error(translated, _this3.$element, { clickToHide: true });

                            _this3.uploadErrorNotification.show();
                        });
                    }
                };
            }

            /**
             * hides error notification        
             */

        }, {
            key: 'hideUploadErrorNotification',
            value: function hideUploadErrorNotification() {
                if (util.isDefined(this.uploadErrorNotification)) {
                    this.uploadErrorNotification.destroy();
                    this.uploadErrorNotification = undefined;
                }
            }
        }, {
            key: 'setUploadButtonVisibility',
            value: function setUploadButtonVisibility(visibility) {
                this.showUploadButton = visibility;
                this.showFileName = !visibility;
            }

            /**
             * adds spinner to control         
             */

        }, {
            key: 'addSpinner',
            value: function addSpinner() {
                this.showSpinner = true;
            }

            /**
             * removes spinner         
             */

        }, {
            key: 'removeSpinner',
            value: function removeSpinner() {
                this.showSpinner = false;
            }
        }]);

        return controller;
    }()
};

AttachmentUploaderComponent.controller.prototype.constructor.$inject = ['$scope', '$element', 'documentAttachmentConfigurator', 'attachmentProxy', 'notificationHandler', 'elementNotifier', 'translator', 'fileExtensionValidator'];

/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(373), __webpack_require__(371), __webpack_require__(372)], __WEBPACK_AMD_DEFINE_RESULT__ = function (reconciliationFailureFormatterLoader, businessValidationFailureFormatterLoader, documentIssuesMessageBuilderLoader) {
	'use strict';

	return function (module) {
		reconciliationFailureFormatterLoader(module);
		businessValidationFailureFormatterLoader(module);
		documentIssuesMessageBuilderLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 371 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:ICV01}
// di.einvoicing.ui.portal._components.documentIssues
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.factory('businessValidationFailureFormatter', businessValidationFailureFormatter);

		businessValidationFailureFormatter.$inject = ['translator'];

		function businessValidationFailureFormatter(translator) {
			return {
				format: format
			};

			function format(invoiceValidationType) {
				return translator.instantTranslate('EINVOICING.PORTAL.COMPONENTS.DOCUMENT_ISSUES.VALIDATION.BUSINESS.ERRORS.' + invoiceValidationType);
			}
		}
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:/UP0Z}
// di.einvoicing.ui.portal._components.documentIssues
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.factory('documentIssuesMessageBuilder', documentIssuesMessageBuilder);

		documentIssuesMessageBuilder.$inject = ['reconciliationFailureFormatter', 'businessValidationFailureFormatter', 'translator', '$sce'];

		function documentIssuesMessageBuilder(reconciliationFailureFormatter, businessValidationFailureFormatter, translator, $sce) {
			return {
				buildMessage: buildMessage
			};

			/**
    * Builds a display message for the given document issues
    * @param {} documentIssuesModel 
    * @returns {} 
    */
			function buildMessage(documentIssuesModel, trustAsHtml) {
				var formattedMessages = buildDocumentIssuesDetails();
				var html = buildHtml();

				if (trustAsHtml) {
					return $sce.trustAsHtml(html);
				}

				return html;

				function buildDocumentIssuesDetails() {
					var reconciliationHeaderFailureMessages = [];
					_.each(documentIssuesModel.reconciliationHeaderFailures || [], function (reconciliationResultLine) {
						reconciliationHeaderFailureMessages.push(reconciliationFailureFormatter.format(reconciliationResultLine));
					});

					var reconciliationLineFailureMessages = [];
					_.each(documentIssuesModel.reconciliationLineFailures || [], function (reconciliationResultLine) {
						reconciliationLineFailureMessages.push(reconciliationFailureFormatter.format(reconciliationResultLine));
					});

					var businessValidationFailureMessages = [];

					_.each(documentIssuesModel.businessValidationFailures || [], function (failureType) {
						businessValidationFailureMessages.push(businessValidationFailureFormatter.format(failureType));
					});

					return {
						reconciliationHeaderFailureMessages: reconciliationHeaderFailureMessages,
						reconciliationLineFailureMessages: reconciliationLineFailureMessages,
						businessValidationFailureMessages: businessValidationFailureMessages,
						exportSchemaValidationErrorMessages: documentIssuesModel.exportSchemaValidationErrorMessages || [],
						exportSchemaValidationWarningMessages: documentIssuesModel.exportSchemaValidationWarningMessages || [],
						transmissionEndpointValidationMessages: documentIssuesModel.transmissionEndpointValidationMessages || []
					};
				}

				function buildHtml() {
					return '<div class="reconcilication-failure-details">' + getDetailsHtml() + '</div>';

					function getDetailsHtml() {
						if (formattedMessages.reconciliationHeaderFailureMessages.length === 0 && formattedMessages.reconciliationLineFailureMessages.length === 0 && formattedMessages.businessValidationFailureMessages.length === 0 && formattedMessages.exportSchemaValidationErrorMessages.length === 0 && formattedMessages.exportSchemaValidationWarningMessages.length === 0 && formattedMessages.transmissionEndpointValidationMessages.length === 0) {
							return getTitleHtml(3, 'NO_ERRORS');
						}

						var detailsHtml = '';

						detailsHtml += getSection('VALIDATION.BUSINESS.TITLE', [{
							messages: formattedMessages.businessValidationFailureMessages
						}]);

						detailsHtml += getSection('RECONCILIATION.TITLE', [{
							title: 'RECONCILIATION.HEADER.TITLE',
							messages: formattedMessages.reconciliationHeaderFailureMessages
						}, {
							title: 'RECONCILIATION.LINE.TITLE',
							messages: formattedMessages.reconciliationLineFailureMessages
						}]);

						detailsHtml += getSection('VALIDATION.EXPORT.TITLE', [{
							title: 'VALIDATION.EXPORT.ERRORS.TITLE',
							messages: formattedMessages.exportSchemaValidationErrorMessages
						}, {
							title: 'VALIDATION.EXPORT.WARNINGS.TITLE',
							messages: formattedMessages.exportSchemaValidationWarningMessages
						}]);

						detailsHtml += getSection('VALIDATION.TRANSMISSION.TITLE', [{
							messages: formattedMessages.transmissionEndpointValidationMessages
						}]);

						return detailsHtml;

						function getSection(title, subSections) {
							var sectionHtml = '';
							var totalLength = 0;

							for (var i = 0; i < subSections.length; i++) {
								var subSection = subSections[i];

								if (subSection.messages.length === 0) {
									continue;
								}

								totalLength += subSection.length;

								if (subSection.title) {
									sectionHtml += getTitleHtml(3, subSection.title);
								}

								sectionHtml += getList(subSection.messages);
							}

							if (totalLength === 0) {
								return '';
							}

							return getTitleHtml(2, title) + sectionHtml + '<br/>';
						}

						function getTitleHtml(level, languageKey) {
							return '<h' + level + '>' + translator.instantTranslate('EINVOICING.PORTAL.COMPONENTS.DOCUMENT_ISSUES.' + languageKey) + '</h' + level + '>';
						}

						function getList(messages) {
							var innerList = '';

							for (var i = 0; i < messages.length; i++) {
								innerList += '<li><span>' + messages[i] + '</span></li>';
							}

							return '<ul>' + innerList + '</ul>';
						}
					}
				}
			}
		}

		return documentIssuesMessageBuilder;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 373 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP6F}
// di.einvoicing.ui.portal._components.documentIssues
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.factory('reconciliationFailureFormatter', reconciliationFailureFormatter);

		reconciliationFailureFormatter.$inject = ['translator', 'userRightsRepository'];

		function reconciliationFailureFormatter(translator, userRightsRepository) {
			return {
				format: format
			};

			/**
    * Function
    * @param failures 
    * @returns - The failure list formatted as HTML with 
    */
			function format(failure) {
				var isSupplier = userRightsRepository.userHasRight("Supplier");

				var languageKey = 'EINVOICING.PORTAL.COMPONENTS.DOCUMENT_ISSUES.RECONCILIATION.HEADER.ERRORS.' + failure.documentType + '.' + failure.reconciliationFailureType;

				var productCode;

				if (isSupplier) {
					productCode = failure.supplierProductCode;
				} else {
					productCode = failure.buyerProductCode;
				}

				var message = '';

				if (util.isNonEmptyString(productCode)) {
					message = '<b>' + productCode + '</b> - ';
				}

				message += translator.instantTranslate(languageKey);

				return message;
			}
		}

		return reconciliationFailureFormatter;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP0T}
// di.einvoicing.ui.portal.portal.invoices
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(375), __webpack_require__(377), __webpack_require__(376)], __WEBPACK_AMD_DEFINE_RESULT__ = function (snippetsLoader, optionalFieldsLoader, invoiceDetailsLoader) {
    'use strict';

    return function (module) {
        snippetsLoader(module);
        optionalFieldsLoader(module);
        invoiceDetailsLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP3C}
// di.einvoicing.ui.portal.portal.invoices.components.snippets
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var snippetContext = $di.angular.snippetRegistrar.createContext(module, 'src/app/portal/invoices/editor/_components/_snippets');

        snippetContext.registerSnippet('diInvoiceHeader', 'invoiceHeader.html');
        snippetContext.registerSnippet('diInvoiceFooter', 'invoiceFooter.html');
        snippetContext.registerSnippet('diInvoicePayee', 'invoicePayee.html');
        snippetContext.registerSnippet('diInvoiceTaxRepresentative', 'invoiceTaxRepresentative.html');
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP5B}
// di.einvoicing.ui.portal.portal.invoices.lists
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.directive('diInvoice', diInvoice);

        function diInvoice() {
            return {
                restrict: 'E',
                replace: true,
                scope: {},
                controller: "InvoiceController",
                controllerAs: "invoiceCtrl",
                templateUrl: 'src/app/portal/invoices/editor/_components/invoiceDetails/invoiceDetails.html'
            };
        }

        return diInvoice;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:OFC02}
// di.einvoicing.ui.portal.invoices.editor.components
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(378)], __WEBPACK_AMD_DEFINE_RESULT__ = function (optionalFieldsConfigurationLoader) {
	return function (module) {
		optionalFieldsConfigurationLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:OFC01}
//di.einvoicing.ui.portal.invoices.editor.components
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.constant('OPTIONAL_FIELDS_CONFIGURATION', optionalFieldsConfiguration());

		function optionalFieldsConfiguration() {
			return [{
				header: 'Currency',
				template: '<label\
									class="form-row-label"\
									di-translate="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.CURRENCY">\
								</label>\
								<div\
									class="custom-fields-input">\
									<di-currency-selector\
										bind-to-object="controller.invoice"\
										bind-to-property="currencyId"\
										validation-name="currencyId"\
										validation-message="Currencyisrequired"\
										on-change-accessor="controller.events.onCurrencyChanged"\
                                        validation-property-name="currencyId">\
									</di-currency-selector>\
								</div>',
				clientName: 'CurrencyId',
				visible: false,
				mandatory: false,
				hideable: true,
				typeGroup: 0,
				isVisible: false,
				isHidden: true,
				isColumn: false
			}, {
				header: 'Delivery note number',
				template: '<di-input\
									ng-model="controller.invoice"\
                                    ng-model-property="deliveryNoteNumber"\
									ng-change="controller.events.onInvoiceChanged()"\
									validation-property-name="deliveryNoteNumber"\
									validation-model-display-name="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.DELIVERY_NOTE_NUMBER"\
									validation-message-position="topright"\
									di-input-type="text"\
					                di-input-label="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.DELIVERY_NOTE_NUMBER">\
                                </di-input>',
				clientName: 'DeliveryNoteNumber',
				visible: false,
				mandatory: false,
				hideable: true,
				typeGroup: 0,
				isVisible: false,
				isHidden: true,
				isColumn: false
			}, {
				header: 'EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.PERIOD_START_DATE',
				template: '<di-input\
									ng-model="controller.invoice"\
                                    ng-model-property="periodStartDate"\
									ng-model-options="{ updateOn: \'default blur\', debounce: {\'default\': 1000, \'blur\': 0} }"\
									ng-change="controller.events.onInvoiceChanged()"\
									validation-property-name="periodStartDate"\
									validation-model-display-name="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.PERIOD_START_DATE"\
									validation-message-position="topright"\
									di-input-type="date"\
									di-input-label="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.PERIOD_START_DATE">\
                              </di-input>',
				clientName: 'PeriodStartDate',
				visible: false,
				mandatory: false,
				hideable: true,
				typeGroup: 0,
				isVisible: false,
				isHidden: true,
				isColumn: false
			}, {
				header: 'EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.PERIOD_END_DATE',
				template: '<di-input\
									ng-model="controller.invoice"\
                                    ng-model-property="periodEndDate"\
									ng-model-options="{ updateOn: \'default blur\', debounce: {\'default\': 1000, \'blur\': 0} }"\
									ng-change="controller.events.onInvoiceChanged()"\
									validation-property-name="periodEndDate"\
									validation-model-display-name="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.PERIOD_END_DATE"\
									validation-message-position="topright"\
									di-input-type="date"\
									di-input-label="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.PERIOD_END_DATE"></di-input>',
				clientName: 'PeriodEndDate',
				visible: false,
				mandatory: false,
				hideable: true,
				typeGroup: 0,
				isVisible: false,
				isHidden: true,
				isColumn: false
			}, {
				header: 'Accounting cost reference',
				template: '	<di-input\
									ng-model="controller.invoice"\
                                    ng-model-property="accountingCostReference"\
									ng-change="controller.events.onInvoiceChanged()"\
									validation-property-name="accountingCostReference"\
									validation-model-display-name="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.ACCOUNTING_COST_REFERENCE"\
									validation-message-position="topright"\
									di-input-type="text"\
									di-input-label="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.ACCOUNTING_COST_REFERENCE"></di-input>',
				clientName: 'AccountingCostReference',
				visible: false,
				mandatory: false,
				hideable: true,
				typeGroup: 0,
				isVisible: false,
				isHidden: true,
				isColumn: false
			}, {
				header: 'Delivery date',
				template: '<di-input\
									ng-model="controller.invoice"\
                                    ng-model-property="deliveryDate"\
									ng-model-options="{ updateOn: \'default blur\', debounce: {\'default\': 1000, \'blur\': 0} }"\
									ng-change="controller.events.onInvoiceChanged()"\
									validation-property-name="deliveryDate"\
									validation-model-display-name="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.DELIVERY_DATE"\
									validation-message-position="topright"\
									di-input-type="date"\
									di-input-label="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.DELIVERY_DATE"></di-input>',
				clientName: 'DeliveryDate',
				visible: false,
				mandatory: false,
				hideable: true,
				typeGroup: 0,
				isVisible: false,
				isHidden: true,
				isColumn: false
			}, {
				header: 'Payment terms',
				template: '<label\
									class="form-row-label"\
									di-translate="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.PAYMENT_TERMS">\
								</label>\
								<di-input di-input-type="textarea" di-class="invoice-summary-textfield textarea"\
									ng-model="controller.invoice"\
                                    ng-model-property="paymentTerms"\
									ng-change="controller.events.onInvoiceChanged()"\
									validation-property-name="paymentTerms"\
									validation-model-display-name="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.PAYMENT_TERMS"/>',
				clientName: 'PaymentTerms',
				visible: false,
				mandatory: false,
				hideable: true,
				typeGroup: 0,
				isVisible: false,
				isHidden: true,
				isColumn: false
			}, {
				header: 'Contract reference',
				template: '<di-input\
									ng-model="controller.invoice"\
                                    ng-model-property="contractReference"\
									ng-change="controller.events.onInvoiceChanged()"\
									validation-property-name="contractReference"\
									validation-model-display-name="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.CONTRACT_REFERENCE"\
									validation-message-position="topright"\
									di-input-type="text"\
									di-input-label="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.CONTRACT_REFERENCE"></di-input>',
				clientName: 'ContractReference',
				visible: false,
				mandatory: false,
				hideable: true,
				typeGroup: 0,
				isVisible: false,
				isHidden: true,
				isColumn: false
			}, {
				header: 'Contract type code',
				template: '<label\
									class="form-row-label"\
									di-translate="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.CONTRACT_TYPE_CODE">\
								</label>\
								<di-contract-type-code-selector\
									scope-cache="controller.scopeCache"\
									bind-to-object="controller.invoice"\
									bind-to-property="contractTypeCodeId"\
									on-change-accessor="controller.events.onContractTypeCodeChanged()"\
									validation-name="contractTypeCode"\
									validation-message=""\
									validation-model-display-name="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.CONTRACT_TYPE_CODE">\
								</di-contract-type-code-selector>',
				clientName: 'ContractTypeCode',
				visible: false,
				mandatory: false,
				hideable: true,
				typeGroup: 0,
				isVisible: false,
				isHidden: true,
				isColumn: false
			}, {
				header: 'Supplier endpoint identifier',
				template: '<label class ="form-row-label ng-scope" di-translate="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.SUPPLIER_ENDPOINTID">Supplier endpoint identifier</label>\
                        <div>\
                        <di-select\
                            mode="dropdown"\
                            items="controller.supplierEndpoints"\
                            item-unique-property="identifier"\
                            watch-items="true"\
                            watch-binding="true"\
                            watch-include-default-obj="true"\
                            bind-to-object="controller"\
                            bind-to-property="supplierEndpointIdentifier"\
                            display-property="displayValue"\
                            allow-empty-display="true"\
                            on-item-select-function="addNew"\
                            di-validate="supplierEndpointIdentifier"\
                            validation-model="controller.invoice.supplierEndpointIdentifier"\
                            item-compare="controller.actions.matchSelectedEndpoint"\
                            on-change-accessor="controller.events.onSupplierEndpointIdentifierChanged">\
                            <div ng-if="!filteredItem.item.code">{{::filteredItem.item.label}}</div>\
                            <div ng-if="filteredItem.item.code">\
                                <strong>{{::filteredItem.item.schemeDescription}}</strong> : <span>{{::filteredItem.item.code}}</span> <span ng-if="filteredItem.item.codeDescription">{{::filteredItem.item.codeDescription}}</span>\
                            </div>\
                        </di-select>\
                        </div>',
				clientName: 'SupplierEndpointIdentifier',
				visible: false,
				mandatory: false,
				hideable: true,
				typeGroup: 0,
				isVisible: false,
				isHidden: true,
				isColumn: false
			}, {
				header: 'Buyer endpoint identifier',
				template: '<label class ="form-row-label ng-scope" di-translate="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.BUYER_ENDPOINTID">Buyer endpoint identifier</label>\
                        <div>\
                        <di-select\
							mode="dropdown"\
							ng-if="!controller.usingAccounting"\
							items="controller.buyerEndpoints"\
							item-unique-property="identifier"\
							watch-items="true"\
							watch-binding="true"\
							watch-include-default-obj="true"\
							bind-to-object="controller"\
							bind-to-property="buyerEndpointIdentifier"\
							display-property="displayValue"\
							allow-empty-display="true"\
							on-item-select-function="addNew"\
                            item-compare="controller.actions.matchSelectedEndpoint"\
							on-change-accessor="controller.events.onBuyerEndpointIdentifierChanged">\
							<div ng-if="!filteredItem.item.code">{{::filteredItem.item.label}}</div>\
							<div ng-if="filteredItem.item.code">\
								<strong>{{::filteredItem.item.schemeDescription}}</strong> : <span>{{::filteredItem.item.code}}</span> <span ng-if="filteredItem.item.codeDescription">{{::filteredItem.item.codeDescription}}</span>\
							</div>\
						</di-select>\
                        <di-select\
							mode="dropdown"\
							ng-if="controller.usingAccounting"\
							items="controller.accountingCustomerEndpoints"\
							item-unique-property="identifier"\
							watch-items="true"\
							watch-binding="true"\
							watch-include-default-obj="true"\
							bind-to-object="controller"\
							bind-to-property="accountingCustomerEndpointIdentifier"\
							display-property="displayValue"\
							allow-empty-display="true"\
							on-item-select-function="addNew"\
                            item-compare="controller.actions.matchSelectedEndpoint"\
							on-change-accessor="controller.events.onAccountingCustomerEndpointIdentifierChanged">\
							<div ng-if="!filteredItem.item.code">{{::filteredItem.item.label}}</div>\
							<div ng-if="filteredItem.item.code">\
								<strong>{{::filteredItem.item.schemeDescription}}</strong> : <span>{{::filteredItem.item.code}}</span> <span ng-if="filteredItem.item.codeDescription">{{::filteredItem.item.codeDescription}}</span>\
							</div>\
						</di-select>\
						</div>',
				clientName: 'BuyerEndpointIdentifier',
				visible: false,
				mandatory: false,
				hideable: true,
				typeGroup: 0,
				isVisible: false,
				isHidden: true,
				isColumn: false
			}, {
				header: 'EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.SUPPLIER_VAT_NUMBER',
				template: '<label class ="form-row-label ng-scope" di-translate="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.SUPPLIER_VAT_NUMBER">Supplier VAT number</label>\
                            <div>\
                                <di-select\
                                    mode="dropdown"\
                                    items="controller.supplierVatNumbers"\
                                    item-unique-property="identifier"\
                                    watch-items="true"\
                                    watch-binding="true"\
                                    watch-include-default-obj="true"\
                                    bind-to-object="controller"\
                                    bind-to-property="supplierVatNumber"\
                                    display-property="displayValue"\
                                    allow-empty-display="true"\
                                    on-item-select-function="addNew"\
                                    on-change-accessor="controller.events.onSupplierVatNumberChanged">\
                                    <div ng-if="!filteredItem.item.code">{{::filteredItem.item.label}}</div>\
                                    <div ng-if="filteredItem.item.code">\
                                        <span ng-if="filteredItem.item.schemeDescription"><strong>{{::filteredItem.item.schemeDescription}}</strong> : </span><span>{{::filteredItem.item.code}}</span>\
                                    </div>\
                                </di-select>\
                        </div>',
				clientName: 'SupplierVatNumber',
				visible: false,
				mandatory: false,
				hideable: true,
				typeGroup: 0,
				isVisible: false,
				isHidden: true,
				isColumn: false
			}, {
				header: 'EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.BUYER_VAT_NUMBER',
				template: '<label class ="form-row-label ng-scope" di-translate="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.BUYER_VAT_NUMBER">Supplier VAT number</label>\
                        <div>\
                        <di-select\
                            mode="dropdown"\
                            ng-if="!controller.usingAccounting"\
                            items="controller.buyerVatNumbers"\
                            item-unique-property="identifier"\
                            watch-items="true"\
                            watch-binding="true"\
                            watch-include-default-obj="true"\
                            bind-to-object="controller"\
                            bind-to-property="customerVatNumber"\
                            display-property="displayValue"\
                            allow-empty-display="true"\
                            on-item-select-function="addNew"\
                            on-change-accessor="controller.events.onBuyerVatNumberChanged">\
                            <div ng-if="!filteredItem.item.code">{{::filteredItem.item.label}}</div>\
                            <div ng-if="filteredItem.item.code">\
                                <span ng-if="filteredItem.item.schemeDescription"><strong>{{::filteredItem.item.schemeDescription}}</strong> : </span><span>{{::filteredItem.item.code}}</span>\
                            </div>\
                        </di-select>\
                        <di-select\
                            mode="dropdown"\
                            ng-if="controller.usingAccounting"\
                            items="controller.accountingCustomerVatNumbers"\
                            item-unique-property="identifier"\
                            watch-items="true"\
                            watch-binding="true"\
                            watch-include-default-obj="true"\
                            bind-to-object="controller"\
                            bind-to-property="accountingCustomerVatNumber"\
                            display-property="displayValue"\
                            allow-empty-display="true"\
                            on-item-select-function="addNew"\
                            on-change-accessor="controller.events.onAccountingCustomerVatNumberChanged">\
                            <div ng-if="!filteredItem.item.code">{{::filteredItem.item.label}}</div>\
                            <div ng-if="filteredItem.item.code">\
                                <span ng-if="filteredItem.item.schemeDescription"><strong>{{::filteredItem.item.schemeDescription}}</strong> : </span><span>{{::filteredItem.item.code}}</span>\
                            </div>\
                        </di-select>\
                        </div>',
				clientName: 'CustomerVatNumber',
				visible: false,
				mandatory: false,
				hideable: true,
				typeGroup: 0,
				isVisible: false,
				isHidden: true,
				isColumn: false
			}, {
				header: 'EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.BUYER_LEGAL_REGISTRATION_NAME',
				template: '<di-input\
									ng-model="controller.invoice"\
									ng-if="!controller.usingAccounting"\
									ng-model-property="buyerCustomerLegalRegistrationName"\
									ng-change="controller.events.onInvoiceChanged()"\
									validation-property-name="buyerCustomerLegalRegistrationName"\
									validation-model-display-name="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.BUYER_LEGAL_REGISTRATION_NAME"\
									validation-message-position="topright"\
									di-input-type="text"\
									di-input-label="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.BUYER_LEGAL_REGISTRATION_NAME"></di-input>\
                             <di-input\
									ng-model="controller.invoice"\
									ng-if="controller.usingAccounting"\
									ng-model-property="accountingCustomerLegalName"\
                                    ng-change="controller.events.onInvoiceChanged()"\
                                    validation-property-name="accountingCustomerLegalName"\
                                    validation-model-display-name="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.BUYER_LEGAL_REGISTRATION_NAME"\
                                    validation-message-position="topright"\
                                    di-input-type="text"\
                                    di-input-label="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.BUYER_LEGAL_REGISTRATION_NAME"></di-input>',
				clientName: 'BuyerCustomerLegalRegistrationName',
				visible: false,
				mandatory: false,
				hideable: true,
				typeGroup: 0,
				isVisible: false,
				isHidden: true,
				isColumn: false
			}, {
				header: 'EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.BUYER_LEGAL_REGISTRATION_IDENTIFIER',
				template: '<label class ="form-row-label ng-scope" di-translate="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.BUYER_LEGAL_REGISTRATION_IDENTIFIER">Buyer legal registration identifier</label>\
                            <div>\
                                <di-select\
                                    mode="dropdown"\
                                    ng-if="!controller.usingAccounting"\
                                    items="controller.buyerCustomerLegalCompanyReferences"\
                                    item-unique-property="identifier"\
                                    watch-items="true"\
                                    watch-binding="true"\
                                    watch-include-default-obj="true"\
                                    bind-to-object="controller"\
                                    bind-to-property="buyerCustomerLegalCompanyReference"\
                                    display-property="displayValue"\
                                    validation-property-name="buyerCustomerLegalCompanyReference"\
				                    validation-model-display-name="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.BUYER_LEGAL_REGISTRATION_IDENTIFIER"\
				                    validation-message-position="topright"\
                                    allow-empty-display="true"\
                                    on-item-select-function="addNew"\
                                    on-change-accessor="controller.events.onBuyerCustomerLegalCompanyReferenceChanged">\
                                    <div ng-if="!filteredItem.item.code">{{::filteredItem.item.label}}</div>\
                                    <div ng-if="filteredItem.item.code">\
                                        <span ng-if="filteredItem.item.schemeDescription"><strong>{{::filteredItem.item.schemeDescription}}</strong> : </span><span>{{::filteredItem.item.code}}</span>\
                                    </div>\
                             </di-select>\
                             <di-select\
                                    mode="dropdown"\
                                    ng-if="controller.usingAccounting"\
                                    items="controller.accountingCustomerLegalCompanyReferences"\
                                    item-unique-property="identifier"\
                                    watch-items="true"\
                                    watch-binding="true"\
                                    watch-include-default-obj="true"\
                                    bind-to-object="controller"\
                                    bind-to-property="accountingCustomerLegalCompanyReference"\
                                    display-property="displayValue"\
                                    validation-property-name="buyerCustomerLegalCompanyReference"\
				                    validation-model-display-name="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.BUYER_LEGAL_REGISTRATION_IDENTIFIER"\
				                    validation-message-position="topright"\
                                    allow-empty-display="true"\
                                    on-item-select-function="addNew"\
                                    on-change-accessor="controller.events.onAccountingCustomerLegalCompanyReferenceChanged">\
                                    <div ng-if="!filteredItem.item.code">{{::filteredItem.item.label}}</div>\
                                    <div ng-if="filteredItem.item.code">\
                                        <span ng-if="filteredItem.item.schemeDescription"><strong>{{::filteredItem.item.schemeDescription}}</strong> : </span><span>{{::filteredItem.item.code}}</span>\
                                    </div>\
                             </di-select>\
                        </div>',
				clientName: 'BuyerCustomerLegalCompanyReference',
				visible: false,
				mandatory: false,
				hideable: true,
				typeGroup: 0,
				isVisible: false,
				isHidden: true,
				isColumn: false
			}, {
				header: 'EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.TAX_EXEMPTION_REASON',
				template: '<di-input\
									ng-model="controller.invoice"\
                                    ng-model-property="taxExemptionReason"\
									ng-change="controller.events.onInvoiceChanged()"\
									validation-property-name="taxExemptionReason"\
									validation-model-display-name="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.TAX_EXEMPTION_REASON"\
									validation-message-position="topright"\
									di-input-type="text"\
									di-input-label="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.TAX_EXEMPTION_REASON"></di-input>',
				clientName: 'TaxExemptionReason',
				visible: false,
				mandatory: false,
				hideable: true,
				typeGroup: 0,
				isVisible: false,
				isHidden: true,
				isColumn: false
			}, {
				header: 'EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.SUPPLIER_LEGAL_REGISTRATION_NAME',
				template: '<di-input\
									ng-model="controller.invoice"\
                                    ng-model-property="supplierLegalRegistrationName"\
									ng-change="controller.events.onInvoiceChanged()"\
									validation-property-name="supplierLegalRegistrationName"\
									validation-model-display-name="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.SUPPLIER_LEGAL_REGISTRATION_NAME"\
									validation-message-position="topright"\
									di-input-type="text"\
									di-input-label="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.SUPPLIER_LEGAL_REGISTRATION_NAME"></di-input>',
				clientName: 'SupplierLegalRegistrationName',
				visible: false,
				mandatory: false,
				hideable: true,
				typeGroup: 0,
				isVisible: false,
				isHidden: true,
				isColumn: false
			}, {
				header: 'EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.SUPPLIER_LEGAL_REGISTRATION_IDENTIFIER',
				template: '<label class ="form-row-label ng-scope" di-translate="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.SUPPLIER_LEGAL_REGISTRATION_IDENTIFIER">Supplier legal registration identifier</label>\
                            <div>\
                                <di-select\
                                    mode="dropdown"\
                                    items="controller.supplierLegalCompanyReferences"\
                                    item-unique-property="identifier"\
                                    watch-items="true"\
                                    watch-binding="true"\
                                    watch-include-default-obj="true"\
                                    bind-to-object="controller"\
                                    bind-to-property="supplierLegalCompanyReference"\
                                    display-property="displayValue"\
                                    validation-property-name="supplierLegalCompanyReference"\
				                    validation-model-display-name="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.SUPPLIER_LEGAL_REGISTRATION_IDENTIFIER"\
				                    validation-message-position="topright"\
                                    allow-empty-display="true"\
                                    on-item-select-function="addNew"\
                                    on-change-accessor="controller.events.onSupplierLegalCompanyReferenceChanged">\
                                    <div ng-if="!filteredItem.item.code">{{::filteredItem.item.label}}</div>\
                                    <div ng-if="filteredItem.item.code">\
                                        <span ng-if="filteredItem.item.schemeDescription"><strong>{{::filteredItem.item.schemeDescription}}</strong> : </span><span>{{::filteredItem.item.code}}</span>\
                                    </div>\
                             </di-select>\
                        </div>',
				clientName: 'SupplierLegalCompanyReference',
				visible: false,
				mandatory: false,
				hideable: true,
				typeGroup: 0,
				isVisible: false,
				isHidden: true,
				isColumn: false
			}, {
				header: 'EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.SUPPLIER_LEGAL_REGISTRATION_TOWN',
				template: '<di-input\
									ng-model="controller.invoice"\
									ng-model-property="supplierLegalTown"\
									ng-change="controller.events.onInvoiceChanged()"\
									validation-property-name="supplierLegalTown"\
									validation-model-display-name="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.SUPPLIER_LEGAL_REGISTRATION_TOWN"\
									validation-message-position="topright"\
									di-input-type="text"\
									di-input-label="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.SUPPLIER_LEGAL_REGISTRATION_TOWN"></di-input>',
				clientName: 'SupplierLegalTown',
				visible: false,
				mandatory: false,
				hideable: true,
				typeGroup: 0,
				isVisible: false,
				isHidden: true,
				isColumn: false
			}, {
				header: 'EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.SUPPLIER_LEGAL_REGISTRATION_COUNTRY',
				template: '<label\
									class="form-row-label"\
									di-translate="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.SUPPLIER_LEGAL_REGISTRATION_COUNTRY">\
								</label>\
								<di-dropdown-selector\
									items="controller.countries"\
									bind-to-object="controller"\
									bind-to-property="supplierLegalCountryId"\
									on-change-accessor="controller.events.onSupplierLegalCountryChanged">\
								</di-dropdown-selector>',
				clientName: 'SupplierLegalCountry',
				visible: false,
				mandatory: false,
				hideable: true,
				typeGroup: 0,
				isVisible: false,
				isHidden: true,
				isColumn: false
			}, {
				header: 'EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.PREPAID_AMOUNT',
				template: '<di-input\
									di-input-type="decimal"\
									ng-change="controller.events.onPrepaidAmountChanged()"\
									ng-model="controller.invoice"\
									ng-model-property="prepaidAmount"\
									validation-property-name="prepaidAmount"\
									validation-model-display-name="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.PREPAID_AMOUNT"\
									validation-message-position="topright"\
									di-input-label="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.PREPAID_AMOUNT">\
								</di-input>',
				clientName: 'PrepaidAmount',
				visible: false,
				mandatory: false,
				hideable: true,
				typeGroup: 0,
				isVisible: false,
				isHidden: true,
				isColumn: false
			}, {
				header: 'Generic text box',
				template: '<di-input\
									ng-model="{MODEL}"\
                                    ng-model-property="{FIELD}"\
									ng-change="{CHANGED}"\
									validation-property-name="{FIELD}"\
									validation-message-position="top right"\
									di-input-type="text"\
                                    di-input-label="{LABEL}"></di-input>',
				clientName: 'GenericTextBox',
				visible: false,
				mandatory: false,
				hideable: true,
				typeGroup: 1,
				isVisible: false,
				isHidden: true,
				isColumn: false
			}, {
				headerClass: 'centeredcell',
				header: 'Generic product line text box',
				model: 'line.{FIELD}',
				template: '<div\
									class="full">\
									<di-input\
                                        di-input-type="text"\
										ng-model="binding"\
										ng-model-property="{FIELD}"\
										ng-change="controller.lineChanged"\
										validation-property-name="{FIELD}"\
										validation-model-display-name="{LABEL}>"\
                                     </di-input>\
								</div>',
				clientName: 'GenericTextBox',
				visible: false,
				mandatory: false,
				hideable: true,
				typeGroup: 1,
				isVisible: false,
				isHidden: true,
				isColumn: false
			}, {
				header: 'Generic number box',
				template: '<div\
									class="custom-fields-col full">\
									<label\
										class="custom-fields-label"\
										di-translate="{LABEL}">\
									</label>\
									<input\
										ng-model="{MODEL}"\
										ng-change="{CHANGED}"\
										type="number"/>\
								</div>',
				clientName: 'GenericTextBox',
				visible: false,
				mandatory: false,
				hideable: true,
				typeGroup: 2,
				isVisible: false,
				isHidden: true,
				isColumn: false
			}, {
				headerClass: 'centeredcell',
				header: 'Generic product line number box',
				model: 'line.{FIELD}',
				template: '<div\
									class="full">\
									<di-input\
                                        di-input-type="number"\
										ng-model="binding"\
										ng-model-property="{FIELD}"\
										validation-property-name="{FIELD}"\
										validation-model-display-name="{LABEL}"\
										ng-change="controller.lineChanged">\
									</di-input>\
								</div>',
				clientName: 'GenericTextBox',
				visible: false,
				mandatory: false,
				hideable: true,
				typeGroup: 2,
				isVisible: false,
				isHidden: true,
				isColumn: false
			}, {
				header: 'Generic decimal box',
				template: '<div\
									class="custom-fields-col full">\
									<label\
										class="custom-fields-label"\
										di-translate="{LABEL}">\
									</label>\
									<di-input\
                                            di-input-type="text"\
											class="numericcell"\
											ng-model="binding"\
											ng-model-property="{FIELD}}"\
											validation-property-name="{FIELD}"\
											ng-change="controller.lineChanged"\
											validation-model-display-name="{LABEL}">\
									</di-input>\
									<input\
										ng-model="{MODEL}"\
										ng-change="{CHANGED}"\
										di-input\
										di-input-type="number"/>\
								</div>',
				clientName: 'GenericDecimalBox',
				visible: false,
				mandatory: false,
				hideable: true,
				typeGroup: 3,
				isVisible: false,
				isHidden: true,
				isColumn: false
			}];
		}
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(374), __webpack_require__(388), __webpack_require__(392), __webpack_require__(398), __webpack_require__(395), __webpack_require__(397), __webpack_require__(396), __webpack_require__(382), __webpack_require__(385), __webpack_require__(380)], __WEBPACK_AMD_DEFINE_RESULT__ = function (componentsLoader, contractTypeCodeSelectorLoader, currencySelectorLoader, locationSelectorLoader, invoiceControllerLoader, invoiceTotalsCalculatorLoader, invoiceDetailsButtonsConfiguratorLoader, contactDetailsLoader, contactSelectorLoader, companiesSelectorLoader) {
    'use strict';

    return function (module) {
        componentsLoader(module);
        contractTypeCodeSelectorLoader(module);
        currencySelectorLoader(module);
        locationSelectorLoader(module);
        invoiceControllerLoader(module);
        invoiceTotalsCalculatorLoader(module);
        invoiceDetailsButtonsConfiguratorLoader(module);
        contactDetailsLoader(module);
        contactSelectorLoader(module);
        companiesSelectorLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(381)], __WEBPACK_AMD_DEFINE_RESULT__ = function (companiesSelectorComponentModule) {
    'use strict';

    return function (module) {
        module.component(companiesSelectorComponentModule.CompaniesSelectorComponent.selector, companiesSelectorComponentModule.CompaniesSelectorComponent);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 381 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CompaniesSelectorComponent = exports.CompaniesSelectorComponent = {
    templateUrl: 'src/app/portal/invoices/editor/companies-selector/companies-selector.component.html',
    selector: 'diCompaniesSelector',
    bindings: {
        billFromCompanies: '<',
        selectedBillFromCompanyId: '<',
        selectedBillToCompanyId: '<',
        onBillFromSelected: '&',
        onBillToSelected: '&'
    },
    controllerAs: 'companiesSelectorCtrl',
    controller: function () {
        function CompaniesSelectorController(partyProxy, authenticationData) {
            _classCallCheck(this, CompaniesSelectorController);

            this.partyProxy = partyProxy;
            this.authenticationData = authenticationData;

            this.setBillFrom = this.setBillFrom.bind(this);
            this.setBillTo = this.setBillTo.bind(this);
            this.billFromSelected = this.billFromSelected.bind(this);
            this.billToSelected = this.billToSelected.bind(this);
        }

        _createClass(CompaniesSelectorController, [{
            key: '$onInit',
            value: function $onInit() {
                this.selectedBillFrom = { partyId: 0 };
                this.selectedBillTo = { partyId: 0 };
                this.setBillFrom();
            }
        }, {
            key: '$onChanges',
            value: function $onChanges(changes) {
                this.setBillFrom();
            }
        }, {
            key: 'setBillFrom',
            value: function setBillFrom() {
                var _this = this;

                this.billFrom = this.billFromCompanies;

                if (this.billFromCompanies.length > 0) {
                    if (this.selectedBillFromCompanyId > 0) {
                        this.selectedBillFrom = _.find(this.billFrom, function (company) {
                            return company.party.id === _this.selectedBillFromCompanyId;
                        });
                    } else if (this.billFrom.length === 1) {
                        this.selectedBillFrom = this.billFrom[0];
                        this.onBillFromSelected({ company: this.selectedBillFrom });
                    }

                    this.setBillTo();
                }
            }
        }, {
            key: 'setBillTo',
            value: function setBillTo() {
                var _this2 = this;

                var billFromId = this.selectedBillFrom.partyId;
                this.partyProxy.getAllUserWorkingForRelatedAllocatedToParties(this.authenticationData.userData.userId, [billFromId]).then(function (data) {
                    _this2.billTo = data;
                    if (_this2.selectedBillToCompanyId > 0) {
                        _this2.selectedBillTo = _.find(_this2.billTo, function (company) {
                            return company.party.id === _this2.selectedBillToCompanyId;
                        });
                    }
                });
            }
        }, {
            key: 'billFromSelected',
            value: function billFromSelected(company) {
                this.selectedBillFrom = company;
                this.setBillFrom();
                this.onBillFromSelected({ company: company });
            }
        }, {
            key: 'billToSelected',
            value: function billToSelected(company) {
                this.selectedBillTo = company;
                this.onBillToSelected({ company: company });
            }
        }]);

        return CompaniesSelectorController;
    }()
};

CompaniesSelectorComponent.controller.prototype.constructor.$inject = ['partyProxy', 'authenticationData'];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(384), __webpack_require__(383)], __WEBPACK_AMD_DEFINE_RESULT__ = function (contactDetailsDirectiveLoader, contactDetailsControllerLoader) {
    'use strict';

    return function (module) {
        contactDetailsDirectiveLoader(module);
        contactDetailsControllerLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP8V}
// di.einvoicing.ui.portal.contactDetails
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;
        var util = $di.utility.util;
        var ngUtil = $di.angular.util;

        module.controller('ContactDetailsController', ContactDetailsController);

        ContactDetailsController.$inject = ['$scope'];

        function ContactDetailsController(scope) {
            var vm = this;
            vm.onDataChanged = onDataChanged;

            function onDataChanged() {
                if (scope.onDataChanged) {
                    scope.onDataChanged();
                }
            }
        }

        return ContactDetailsController;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.directive('diContactDetails', diContactDetails);

        function diContactDetails() {
            return {
                restrict: 'E',
                scope: {
                    bindToObject: "=",
                    onDataChanged: "="
                },
                templateUrl: 'src/app/portal/invoices/editor/contact-details/contact-details.html'
            };
        }

        return diContactDetails;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(387), __webpack_require__(386)], __WEBPACK_AMD_DEFINE_RESULT__ = function (contactSelectorDirectiveLoader, contactSelectorControllerLoader) {
    'use strict';

    return function (module) {
        contactSelectorDirectiveLoader(module);
        contactSelectorControllerLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP8H}
// di.einvoicing.ui.portal.contactSelector
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;
        var util = $di.utility.util;

        module.controller('ContactSelectorController', ContactSelectorController);

        ContactSelectorController.$inject = ['$scope', 'partyProxy', 'promptWindow', 'notificationHandler', 'translator', 'CLIENT_ENUMS'];

        function ContactSelectorController(scope, partyProxy, promptWindow, notificationHandler, translator, clientEnums) {
            var vm = this;
            vm.contacts = [];
            vm.contact = {};
            vm.onChangeAccessor = onChangeAccessor;

            if (scope.subscribeToEvents) {
                scope.subscribeToEvents(reloadContactsForParty);
            }

            scope.$watch(function () {
                return scope.referencedId;
            }, function () {
                if (util.isDefined(scope.referencedId)) {
                    setChangedInvoiceDetails();
                }
            });

            function setChangedInvoiceDetails() {
                if (scope.contactType === 'supplier') {
                    getContactsForParty(scope.referencedId);
                } else if (scope.contactType === 'customer') {
                    getContactsForParty(scope.referencedId);
                }
            }

            function reloadContactsForParty(event) {
                if (event === clientEnums.eventType.invoiceChanged) {
                    getContactsForParty(scope.referencedId);
                }
            }

            function getContactsForParty(partyId) {
                partyProxy.getPartyContacts(partyId).then(success, failure);
            }

            function success(data) {
                guard.throwIfNotArray("EUP8H01E", data, "data");

                vm.contacts.clear();

                translator.whenReady().then(function () {
                    vm.contacts.push({
                        id: 0,
                        name: translator.instantTranslate('EINVOICING.PORTAL.COMPONENTS.CONTACTS.NEW'),
                        displayName: translator.instantTranslate('EINVOICING.PORTAL.COMPONENTS.CONTACTS.NEW')
                    });

                    var fromInvoice = undefined;

                    if (scope.selectedContact) {
                        fromInvoice = {
                            email: scope.selectedContact.billContactEmail,
                            fax: scope.selectedContact.billContactFax,
                            id: scope.selectedContact.billContactId,
                            originalId: scope.selectedContact.originalBillContactId,
                            name: scope.selectedContact.billContactName,
                            partyId: scope.referencedId,
                            reference: scope.selectedContact.billContactReference,
                            telephoneNumber: scope.selectedContact.billContactTelephone,
                            modified: translator.instantTranslate('EINVOICING.PORTAL.COMPONENTS.CONTACTS.MODIFIED')
                        };

                        fromInvoice.displayName = fromInvoice.name + fromInvoice.modified;
                    }
                    var addFromInvoice = true;

                    var fromInvoiceAdded = false;
                    _.each(data, function (dataItem) {
                        dataItem.displayName = formatDisplayName(dataItem, false);

                        if (fromInvoice && fromInvoice.originalId === dataItem.id) {
                            var compare1 = _.pick(fromInvoice, 'name', 'email', 'telephoneNumber', 'fax', 'reference');
                            var compare2 = _.pick(dataItem, 'name', 'email', 'telephoneNumber', 'fax', 'reference');

                            if (_.isMatch(compare1, compare2) === true) {
                                vm.contacts.push(dataItem);
                                addFromInvoice = false;
                                return;
                            } else {
                                fromInvoice.modified = translator.instantTranslate('EINVOICING.PORTAL.COMPONENTS.CONTACTS.MODIFIED');
                                vm.contacts.push(fromInvoice);
                                addFromInvoice = false;
                                vm.contacts.push(dataItem);
                                scope.bindToObject[scope.bindToProperty] = fromInvoice.id;
                            }
                        } else {
                            vm.contacts.push(dataItem);
                        }
                    });

                    if (fromInvoice !== undefined && fromInvoice.name && addFromInvoice) {
                        vm.contacts.push(fromInvoice);
                    }

                    if (newEntity()) {
                        selectDummyContact();
                    } else {
                        setSelectedContactFromBoundId();
                    }

                    if (!selectedContactBelongsToCompany()) {
                        selectDummyContact();
                    }

                    onChangeAccessor();
                });
            }

            function isValidContact(contact) {
                return util.isDefined(contact) && (util.isNonEmptyString(contact.name) || util.isNonEmptyString(contact.email) || util.isNonEmptyString(contact.telephoneNumber) || util.isNonEmptyString(contact.fax) || util.isNonEmptyString(contact.reference));
            }

            function formatDisplayName(contact, addModifiedSuffix) {
                var output = '';
                var hasName = false;
                if (util.isNonEmptyString(contact.name)) {
                    hasName = true;
                    output += contact.name + ' ';
                }

                var s = '[';
                var e = ']';

                if (util.isNonEmptyString(contact.email)) {
                    if (!hasName) {
                        s = '';
                        e = '';
                    }
                    output += '' + s + contact.email + e + ' ';
                }

                if (addModifiedSuffix) {
                    output += contact.modified + ' ';
                }

                return output;
            }

            function newEntity() {
                return !scope.bindToObject['id'] || scope.bindToObject['id'] <= 0;
            }

            function selectDummyContact() {
                vm.contact = _.find(vm.contacts, function (contact) {
                    return contact.id === 0;
                });
            }

            function selectedContactBelongsToCompany() {
                var contactToUpdate = _.find(vm.contacts, function (contact) {
                    return contact.id === vm.contact.id;
                });

                return contactToUpdate != undefined;
            }

            function failure(error) {
                notificationHandler.showError(error.failureReason);
            }

            function setSelectedContactFromBoundId() {
                if (!util.isDefined(vm.contact)) {
                    return;
                }

                var contact = _.find(vm.contacts, function (contact) {
                    return contact.id === scope.bindToObject[scope.bindToProperty];
                });

                if (util.isUndefined(contact)) {
                    return;
                }

                vm.contact = contact;
            }

            function onChangeAccessor() {
                setBoundIdFromSelectedContact();
            }

            function setBoundIdFromSelectedContact() {
                var accessor;

                scope.bindToObject[scope.bindToProperty] = (vm.contact || {}).id;

                if (util.isFunction(scope.onChangeAccessor)) {
                    accessor = scope.onChangeAccessor();

                    if (util.isFunction(accessor)) {
                        accessor(vm.contact);
                    }
                }
            }
        }

        return ContactSelectorController;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP8I}
// di.einvoicing.ui.portal.contactSelector
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.directive('diContactSelector', diContactSelector);

        function diContactSelector() {
            return {
                restrict: 'E',
                scope: {
                    bindToObject: '=',
                    bindToProperty: '@',
                    referencedId: '=',
                    selectedContact: "=",
                    contactType: '@',
                    onChangeAccessor: '&',
                    subscribeToEvents: '=',
                    validationPropertyName: '@'
                },
                controller: 'ContactSelectorController',
                controllerAs: 'contactSelectorCtrl',
                templateUrl: 'src/app/portal/invoices/editor/contact-selector/contact-selector.html'
            };
        }

        return diContactSelector;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP88}
// di.einvoicing.ui.portal.components.contractTypeCodeselector
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(390), __webpack_require__(391), __webpack_require__(389)], __WEBPACK_AMD_DEFINE_RESULT__ = function (contractTypeCodeSeclectorDirectiveLoader, contractTypeCodeControllerLoader, contractTypeCodeRepositoryLoader) {
	'use strict';

	return function (module) {
		contractTypeCodeSeclectorDirectiveLoader(module);
		contractTypeCodeControllerLoader(module);
		contractTypeCodeRepositoryLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 389 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP8A}
// di.einvoicing.ui.portal.components.contractTypeCodeSelector
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_) {
	'use strict';

	return function (module) {
		module.factory('contractTypeCodeRepository', contractTypeCodeRepository);

		contractTypeCodeRepository.$inject = ['staticLookupProxy'];

		function contractTypeCodeRepository(staticLookupProxy) {
			var codes = null;

			return {
				getContractTypeCodes: getContractTypeCodes
			};

			/**
    * Gets all available contract type codes defined in the system.
    */
			function getContractTypeCodes() {
				var promise = staticLookupProxy.get('ContractTypeCode').then(success);

				return promise;

				function success(data) {
					codes = data;

					_.each(codes, function (code) {
						codes.id = code.id;
						codes.label = code.code;
						codes.value = code.value;
					});

					codes = _.sortBy(codes, function (code) {
						return code.code;
					});

					return codes;
				}
			}
		}

		return contractTypeCodeRepository;
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 390 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP89}
// di.einvoicing.ui.portal.components.contractTypeCodeSelector
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;
		module.directive('diContractTypeCodeSelector', diContractTypeCodeSelector);

		function diContractTypeCodeSelector() {
			return {
				restrict: 'E',
				replace: true,
				template: template,
				controller: 'ContractTypeCodeController',
				controllerAs: 'contractTypeCodeCtrl',
				scope: {
					tabIndex: '@',
					items: '=',
					bindToObject: '=',
					bindToProperty: '@',
					bindToSecondProperty: '@',
					onChangeAccessor: '&',
					validationMessage: '@',
					validationName: '@',
					validationModelDisplayName: '@'
				}
			};

			/**
    * Generates html template             
    */
			function template(element, attrs) {
				var html = '<div>\
								<di-select\
									tab-index="{{::tabIndex}}"\
									mode="dropdownSearch"\
									watch-items="true"\
									items="contractTypeCodeCtrl.items"\
									item-unique-property="id"\
									bind-to-object="contractTypeCodeCtrl"\
									bind-to-property="item"\
									display-property="value"\
									searchable-properties="value"';

				html += getValidationHtml(attrs);
				html += '           on-change-accessor="contractTypeCodeCtrl.onChangeAccessor"\
									placeholder="EINVOICING.COMPONENTS.CONTRACT_TYPE_CODE.SEARCH">\
									{{::filteredItem.item.code}}: {{::filteredItem.item.value}}\
								</di-select></div>';
				return html;

				/**
     * Adds validation attributes                 
     */
				function getValidationHtml(attrs) {
					var innerHtml = "";

					if (util.isDefined(attrs.validationName)) {
						var displayName = attrs.validationName;
						if (util.isDefined(attrs.validationModelDisplayName)) {
							displayName = attrs.validationModelDisplayName;
						}

						innerHtml += 'di-validate="{{::validationName}}"' + 'validation-model="bindToObject[bindToProperty]"' + 'validation-message="{{::validationMessage}}"' + 'validation-model-display-name="' + displayName + '"';
					}

					return innerHtml;
				}
			}
		}

		return diContractTypeCodeSelector;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 391 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP8B}
// di.einvoicing.ui.portal.components.contractTypeCodeSelector
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.controller('ContractTypeCodeController', ContractTypeCodeController);

		ContractTypeCodeController.$inject = ['$scope', 'contractTypeCodeRepository'];

		function ContractTypeCodeController(scope, contractTypeCodeRepository) {
			var vm = this;

			vm.items = [];
			vm.item = {};
			vm.onChangeAccessor = setBoundIdFromSelectedItem;

			init();

			return;

			//initialise and populate the contract type code control from the repository
			function init() {
				contractTypeCodeRepository.getContractTypeCodes().then(function (data) {
					vm.items.fill(data);

					scope.$watch(function () {
						return scope.bindToObject[scope.bindToProperty];
					}, setSelectedItemFromBoundId);

					return;

					function setSelectedItemFromBoundId() {
						if (util.isDefined(vm.item.id) && scope.bindToObject[scope.bindToProperty] === vm.item.id) {
							return;
						}

						if (scope.bindToObject[scope.bindToProperty] === -1) {
							var unknownItem = {
								id: 0,
								code: scope.bindToObject[scope.bindToSecondProperty],
								value: scope.bindToObject[scope.bindToSecondProperty]
							};

							var exist = _.find(vm.items, function (item) {
								return item.id === unknownItem.id;
							});

							if (util.isUndefined(exist)) {
								vm.items.push(unknownItem);
							}
							scope.bindToObject[scope.bindToProperty] = unknownItem.id;
						}

						var item = _.find(vm.items, function (item) {
							return item.id === scope.bindToObject[scope.bindToProperty];
						});

						if (util.isUndefined(item)) {
							return;
						}

						vm.item = item;
					}
				});
			}

			function setBoundIdFromSelectedItem() {
				var accessor;

				scope.bindToObject[scope.bindToProperty] = (vm.item || {}).id;

				if (util.isFunction(scope.onChangeAccessor)) {
					accessor = scope.onChangeAccessor();

					if (util.isFunction(accessor)) {
						accessor(vm.item);
					}
				}
			}
		}

		return ContractTypeCodeController;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 392 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP1U}
// di.einvoicing.ui.portal.components
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(394), __webpack_require__(393)], __WEBPACK_AMD_DEFINE_RESULT__ = function (currencySelectorDirectiveLoader, currencySelectorControllerLoader) {
    'use strict';

    return function (module) {
        currencySelectorDirectiveLoader(module);
        currencySelectorControllerLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 393 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP1V}
// di.einvoicing.ui.portal.components
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var util = $di.utility.util;

        module.controller('CurrencySelectorController', CurrencySelectorController);

        CurrencySelectorController.$inject = ['$scope', 'currencyCache'];

        function CurrencySelectorController(scope, currencyCache) {
            var vm = this;

            vm.items = [];
            vm.item = {};
            vm.onChangeAccessor = setBoundIdFromSelectedItem;

            init();

            return;

            function init() {
                currencyCache.getCurrencies().then(function (data) {
                    vm.items.fill(data);

                    scope.$watch(function () {
                        return scope.bindToObject[scope.bindToProperty];
                    }, setSelectedItemFromBoundId);

                    return;

                    function setSelectedItemFromBoundId() {
                        if (util.isDefined(vm.item) && scope.bindToObject[scope.bindToProperty] === vm.item.id) {
                            return;
                        }

                        var item = _.find(vm.items, function (item) {
                            return item.id === scope.bindToObject[scope.bindToProperty];
                        });

                        if (util.isUndefined(item)) {
                            return;
                        }

                        vm.item = item;
                    }
                });
            }

            function setBoundIdFromSelectedItem() {
                var accessor;

                scope.bindToObject[scope.bindToProperty] = (vm.item || {}).id;

                if (util.isFunction(scope.onChangeAccessor)) {
                    accessor = scope.onChangeAccessor();

                    if (util.isFunction(accessor)) {
                        accessor(vm.item);
                    }
                }
            }
        }

        return CurrencySelectorController;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 394 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP1W}
// di.einvoicing.ui.portal.components
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var util = $di.utility.util;
        module.directive('diCurrencySelector', diCurrencySelector);

        function diCurrencySelector() {
            return {
                restrict: 'E',
                replace: true,
                scope: {
                    bindToObject: '=',
                    bindToProperty: '@',
                    validationName: "@",
                    validationMessage: '@',
                    onChangeAccessor: '&',
                    validationPropertyName: '@'
                },
                controller: 'CurrencySelectorController',
                controllerAs: 'currencySelectorCtrl',
                template: template
            };

            function template(element, attrs) {
                var html = '<div>\
                                <di-select\
                                    mode="dropdown"\
                                    items="currencySelectorCtrl.items"\
                                    item-unique-property="id"\
                                    bind-to-object="currencySelectorCtrl"\
                                    bind-to-property="item"\
                                    display-property="name"\
                                    on-change-accessor="currencySelectorCtrl.onChangeAccessor"\
                                    watch-binding="true"\
                                    di-validate-model="invoice"\
                                    validation-property-name="{{::validationPropertyName}}"\
                                    placeholder="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.CURRENCY"';
                html += getValidationHtml(attrs);
                html += '><strong>{{::filteredItem.item.symbol}}</strong>: {{::filteredItem.item.name}} ({{::filteredItem.item.code}})\
                                </di-select>\
                            </div>';

                return html;

                function getValidationHtml(attrs) {
                    var innerHtml = "";

                    if (util.isDefined(attrs.validationName)) {
                        var displayName = attrs.validationName;
                        if (util.isDefined(attrs.validationModelDisplayName)) {
                            displayName = attrs.validationModelDisplayName;
                        }

                        innerHtml += 'di-validate="{{::validationName}}"\
                                      validation-message="{{::validationMessage}}"\
                                      validation-model="bindToObject[bindToProperty]"\
                                      validation-model-display-name="' + displayName + '"';
                    }

                    return innerHtml;
                }
            }
        }

        return diCurrencySelector;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

//{CODE:EUP08}
// di.einvoicing.ui.portal.portal.invoices.editor
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;
        var util = $di.utility.util;

        module.controller('InvoiceController', InvoiceController);

        InvoiceController.$inject = ['$scope', 'headerData', 'invoiceTotalsCalculator', 'invoiceLinesColumnSettings', 'OPTIONAL_FIELDS_CONFIGURATION', '$stateParams', 'invoiceProxy', 'partyProxy', 'taxProxy', 'diState', 'authenticationData', 'translator', 'enumTranslator', 'promptWindow', 'associativeArrayConvertor', 'modalSpinner', 'scopeCacheFactory', 'CLIENT_ENUMS', 'authorizedObjectsFilter', 'invoiceDetailsButtonsConfigurator', 'valdr', 'documentStateResolver', 'documentAttributeResolver', 'invoiceRepository', 'staticLookupProxy', 'notificationHandler', '$q', 'userActionsResolver', 'documentDownloader', 'debounce', 'currencyCache', 'scrollbarResizer', 'documentIssuesMessageBuilder', 'validationRulesSetter', 'attachmentProxy', 'INVOICE_ADDITIONAL_DOCUMENT_REFERENCES_CONFIGURATION', 'attachmentDownloadValidator', 'randomStringGenerator', 'modalWindow', 'identifierFactory', 'controlsRestrictionManager', 'formAnalyser', 'locationProxy', 'contactProxy'];

        function InvoiceController(scope, headerData, invoiceTotalsCalculator, invoiceLinesColumnSettings, optionalFieldsConfiguration, stateParams, invoiceProxy, partyProxy, taxProxy, diState, authenticationData, translator, enumTranslator, promptWindow, associativeArrayConvertor, modalSpinner, scopeCacheFactory, CLIENT_ENUMS, authorizedObjectsFilter, invoiceDetailsButtonsConfigurator, valdr, documentStateResolver, documentAttributeResolver, invoiceRepository, staticLookupProxy, notificationHandler, $q, userActionsResolver, documentDownloader, debounce, currencyCache, scrollbarResizer, documentIssuesMessageBuilder, validationRulesSetter, attachmentProxy, additionalDocumentReferencesTableConfiguration, attachmentDownloadValidator, randomStringGenerator, modalWindow, identifierFactory, controlsRestrictionManager, formAnalyser, locationProxy, contactProxy) {
            var vm = this;

            var spinner;

            var unRegCalculateInvoiceTotals = function unRegCalculateInvoiceTotals() {};

            setUp();

            init();

            tearDown();

            return;

            function setUp() {
                vm.scopeCache = scopeCacheFactory.create(scope);

                scope.loaded = false;
                scope.constraints = valdr.getConstraints();
                scope.invoiceLine = {};

                vm.mode = 'edit';
                vm.usingAccounting = false;
                vm.currentState = '...';
                vm.invoice = {
                    lines: [],
                    attributes: [],
                    actions: [],
                    allowancesCharges: [],
                    invoiceTypeId: 1
                };

                vm.invoiceDocumentIssuesDetails = {
                    visible: false,
                    loaded: false,
                    message: ''
                };

                vm.totals = {};

                vm.invoiceDetailsChangeSubscriptions = [];
                vm.eventsSubscriptions = [];
                vm.selectedAttributes = [];
                vm.selectedActions = [];
                vm.selectedStates = [];
                vm.uploadsInProgress = [];

                vm.settings = invoiceLinesColumnSettings;
                vm.languageKey = "EINVOICING.PORTAL.INVOICES.COMPONENTS.PRODUCT_LINES";
                vm.optionalFieldsSettings = optionalFieldsConfiguration;
                vm.additionalDocumentReferencesConfiguration = additionalDocumentReferencesTableConfiguration;

                vm.countOfAttachments = 0;
                vm.calculateLineNet = calculateLineNet;
                vm.calculateLineTax = calculateLineTax;

                vm.events = getEvents();
                vm.actions = getActions();

                vm.revealPayeeDetails = {
                    show: function show() {},
                    hide: function hide() {}
                };

                vm.revealTaxRepresentativeDetails = {
                    show: function show() {},
                    hide: function hide() {}
                };
            }

            function getActions() {
                return {
                    subscribeToInvoiceDetailsChange: subscribeToInvoiceDetailsChange,
                    subscribeToEvents: subscribeToEvents,
                    resizeHorizontalScrollbar: scrollbarResizer.resizeHorizontalScrollbar,
                    showBillFromChangePopup: showBillFromChangePopup,
                    showBillToChangePopup: showBillToChangePopup,
                    showBillToLocationChangePopup: showBillToLocationChangePopup,
                    preSaveAction: preSaveAction,
                    saveInvoice: saveInvoice,
                    submitInvoice: submitInvoice,
                    voidInvoice: voidInvoice,
                    viewInvoice: viewInvoice,
                    viewHistory: viewHistory,
                    getRelatedDocuments: getRelatedDocuments,
                    deleteInvoice: deleteInvoice,
                    viewInvoiceDocumentIssues: viewInvoiceDocumentIssues,
                    getRenderedInvoice: getRenderedInvoice,
                    cancelChanges: cancelChanges,
                    viewDocumentAttachments: viewDocumentAttachments,
                    downloadAttachment: downloadAttachment,
                    downloadAllAttachments: downloadAllAttachments,
                    addAdditionalDocumentReference: addAdditionalDocumentReference,
                    removeAdditionalDocumentReference: removeAdditionalDocumentReference,
                    matchSelectedEndpoint: matchSelectedEndpoint,
                    matchPartyId: matchPartyId,
                    matchContactId: matchContactId,
                    matchAddressId: matchAddressId
                };

                function subscribeToInvoiceDetailsChange(subscription) {
                    vm.invoiceDetailsChangeSubscriptions.push(subscription);
                    subscription({
                        supplierPartyId: vm.invoice.supplierPartyId,
                        customerPartyId: vm.invoice.customerPartyId,
                        currencyId: vm.invoice.currencyId
                    });
                }

                function subscribeToEvents(subscription) {
                    vm.eventsSubscriptions.push(subscription);
                }

                function showBillFromChangePopup(item) {
                    return scope.loaded && item.partyId !== vm.supplier.partyId && (vm.mode === 'edit' || vm.invoice.lines.length > 0 || util.isDefined(vm.customer));
                }

                function showBillToChangePopup(item) {
                    return util.isDefined(vm.customer) && item.partyId !== vm.customer.partyId;
                }

                function showBillToLocationChangePopup(item) {
                    return util.isDefined(vm.customerBillToLocationSelected) && item.party.id !== vm.customerBillToLocationSelected.party.id;
                }

                function preSaveAction() {
                    if (vm.uploadsInProgress.length > 0) {
                        notificationHandler.showWarning('EINVOICING.PORTAL.INVOICES.EDITOR.ERROR_UPLOAD_IN_PROGRESS');

                        return false;
                    }

                    if (vm.invoice.lines.length <= 0) {
                        notificationHandler.showWarning('EINVOICING.PORTAL.INVOICES.EDITOR.ERROR_NO_INVOICE_LINES');

                        return false;
                    }

                    var invalidLineNumbers = [];

                    //Validation that allowance and charge on lines must have both an amount and a reason
                    _.each(vm.invoice.lines, function (line) {
                        if (util.isNonEmptyString(line.allowanceReason) && isNaN(parseFloat(line.allowanceAmount))) {
                            invalidLineNumbers.push(line.lineNumber);
                            return;
                        }

                        if (!isNaN(parseFloat(line.allowanceAmount)) && (!util.isString(line.allowanceReason) || line.allowanceReason === '')) {
                            invalidLineNumbers.push(line.lineNumber);
                            return;
                        }

                        if (util.isNonEmptyString(line.chargeReason) && isNaN(parseFloat(line.chargeAmount))) {
                            invalidLineNumbers.push(line.lineNumber);
                            return;
                        }

                        if (!isNaN(parseFloat(line.chargeAmount)) && (!util.isString(line.chargeReason) || line.chargeReason === '')) {
                            invalidLineNumbers.push(line.lineNumber);
                            return;
                        }
                    });

                    if (invalidLineNumbers.length > 0) {
                        notificationHandler.showError(translator.instantTranslate('EINVOICING.PORTAL.INVOICES.EDITOR.ERROR_INVALID_ALLOWANCE_CHARGES', {
                            invalidLines: invalidLineNumbers.join()
                        }));

                        return false;
                    }

                    updateModelReadyForServer();

                    showSpinner();

                    var testForDocumentIssuesPromise = invoiceProxy.testForInvoiceDocumentIssues(vm.invoice);

                    return testForDocumentIssuesPromise.then(resolve, reject);

                    function resolve(documentIssuesModel) {
                        removeSpinner();

                        if (documentIssuesModel.issuesLevel !== 1) {
                            var message = documentIssuesMessageBuilder.buildMessage(documentIssuesModel, false);

                            return {
                                title: 'EINVOICING.PORTAL.INVOICES.EDITOR.DOCUMENT_ISSUES_ON_SAVE.' + documentIssuesModel.issuesLevel,
                                promptCondition: true,
                                message: message
                            };
                        }

                        return {};
                    }

                    function reject() {
                        removeSpinner();
                        notificationHandler.showError('EINVOICING.PORTAL.INVOICES.EDITOR.ERROR_WHEN_TESTING_DOCUMENT_ISSUES');
                    }
                }

                function saveInvoice(goToInvoiceLinesScreen) {
                    updateModelReadyForServer();

                    invoiceProxy.commitInvoice(vm.invoice).then(commitResolved, commitRejected);

                    return;

                    function commitResolved(data) {
                        if (data.success === true) {
                            vm.scopeCache.clear();
                            notificationHandler.showSuccess('EINVOICING.PORTAL.INVOICES.EDITOR.SAVED_INVOICE', vm.invoice.number);
                            scope.invoiceForm.$setPristine();

                            vm.invoice.id = data.resultData;
                            if (goToInvoiceLinesScreen) {
                                diState.go('portal.invoices.list');
                            } else {
                                if (vm.mode === 'new') {
                                    diState.go('portal.invoices.editById', { id: data.resultData });
                                } else {
                                    loadInvoice(data.resultData);
                                    setState(CLIENT_ENUMS.documentStateKey.pending);
                                    setClean();
                                }
                            }

                            notifyEventsSubscribers(CLIENT_ENUMS.eventType.invoiceChanged);
                        } else {
                            enumTranslator.translate(CLIENT_ENUMS.documentCreationFailureReason, data.failureReason).then(function (translated) {
                                notificationHandler.showError('EINVOICING.PORTAL.INVOICES.EDITOR.COMMIT_REJECTED', translated);
                            });
                        }
                    }

                    function commitRejected(error) {
                        notificationHandler.showError(error.failureReason);
                    }
                }

                function submitInvoice() {
                    invoiceRepository.submitInvoiceByDocumentId(vm.invoice.documentId, vm.invoice.number).then(function () {
                        viewInvoice();
                    });
                }

                function voidInvoice() {
                    invoiceRepository.voidInvoice(vm.invoice.documentId, vm.invoice.number).then(function () {
                        viewInvoice();
                    });
                }

                function viewInvoice(id) {
                    diState.go('portal.invoices.viewById', { id: util.isDefined(id) ? id : vm.invoice.id });
                }

                function viewHistory() {
                    diState.go('portal.audit.list', { id: vm.invoice.documentId });
                }

                function getRelatedDocuments() {
                    diState.go('portal.related.list', { id: vm.invoice.documentId });
                }

                function deleteInvoice() {
                    invoiceRepository.deleteInvoice(vm.invoice.documentId, vm.invoice.number).then(function () {
                        if (scope.invoiceForm) {
                            scope.invoiceForm.$setPristine();
                        }
                        //do not goBack as this will trigger an infinite loop when navigation to edit screen was from view screen
                        //limitation: does not preserve the filters
                        diState.go('portal.invoices.list');
                    });
                }

                function viewInvoiceDocumentIssues(visible) {
                    vm.invoiceDocumentIssuesDetails.visible = visible;

                    if (visible && vm.invoiceDocumentIssuesDetails.loaded === false) {
                        invoiceProxy.getInvoiceDocumentIssues(vm.invoice.id).then(function (documentIssuesModel) {
                            vm.invoiceDocumentIssuesDetails.loaded = true;

                            vm.invoiceDocumentIssuesDetails.message = documentIssuesMessageBuilder.buildMessage(documentIssuesModel, true);
                        }, function () {
                            notificationHandler.showError('EINVOICING.PORTAL.COMPONENTS.DOCUMENT_ISSUES.COULD_NOT_LOAD_ERROR_DETAILS');
                        });
                    }

                    vm.invoiceDocumentIssuesDetails.visible = visible;
                }

                function getRenderedInvoice() {
                    documentDownloader.downloadRenderedInvoice(vm.invoice.documentId);
                }

                function cancelChanges() {
                    goBack();
                }

                function viewDocumentAttachments() {
                    diState.go('portal.attachments.viewByDocumentId', {
                        documentId: vm.invoice.documentId,
                        invoiceId: vm.invoice.id
                    });
                }

                function downloadAttachment(attachmentDataId, filename) {
                    if (attachmentDownloadValidator.allowDownloadSingleFile(filename)) {
                        attachmentProxy.downloadFile(attachmentDataId);
                    }
                }

                function addAdditionalDocumentReference() {
                    var line = {
                        lineIdentifier: randomStringGenerator.generate()
                    };

                    vm.invoice.additionalDocumentReferences = util.isArray(vm.invoice.additionalDocumentReferences) ? vm.invoice.additionalDocumentReferences.concat([line]) : [line];
                    vm.events.onInvoiceChanged();
                }

                function removeAdditionalDocumentReference(line) {
                    var beingUploaded = _.find(vm.uploadsInProgress, function (item) {
                        return item.lineIdentifier === line.lineIdentifier;
                    });

                    if (util.isDefined(beingUploaded)) {
                        translator.whenReady().then(function () {
                            promptWindow.confirm({
                                title: translator.instantTranslate('EINVOICING.PORTAL.INVOICES.EDITOR.REMOVE_LINE.CONFIRM_TITLE'),
                                message: translator.instantTranslate('EINVOICING.PORTAL.INVOICES.EDITOR.REMOVE_LINE.REMOVE_MESSAGE'),
                                okBtnText: translator.instantTranslate('CORE.PROMPT.YES'),
                                cancelBtnText: translator.instantTranslate('CORE.PROMPT.NO'),
                                callback: function callback(result) {
                                    if (result) {
                                        removeSingleLine();
                                    }
                                }
                            });
                        });
                    } else {
                        removeSingleLine();
                    }

                    return;

                    function removeSingleLine() {
                        vm.invoice.additionalDocumentReferences = _.without(vm.invoice.additionalDocumentReferences, line);

                        vm.uploadsInProgress = _.without(vm.uploadsInProgress, line);

                        vm.events.onInvoiceChanged();
                    }
                }

                function matchSelectedEndpoint(item1, item2, display) {
                    var compare1 = _.pick(item1, 'scheme', 'code', 'identifier');
                    var compare2 = _.pick(item2, 'scheme', 'code', 'identifier');

                    var isMatch = _.isMatch(compare1, compare2);
                    if (isMatch && item2.identifier !== '') {
                        item2.codeDescription = item1.codeDescription;
                        item2.displayValue = item1.displayValue;
                        item2.label = item1.label;
                        if (util.isFunction(display)) {
                            display();
                        }
                    }

                    return isMatch;
                }

                function matchPartyId(party1, party2) {
                    return _compareItems(party1, party2, 'partyId');
                }

                function matchContactId(contact1, contact2) {
                    return _compareItems(contact1, contact2);
                }

                function matchAddressId(address1, address2) {
                    return _compareItems(address1, address2);
                }

                function _compareItems(item1, item2, propertyName1, propertyName2) {
                    if (util.isUndefined(propertyName1)) {
                        propertyName1 = 'id';
                    }

                    if (util.isUndefined(propertyName2)) {
                        propertyName2 = propertyName1;
                    }

                    return item1[propertyName1] === item2[propertyName2];
                }
            }

            function getEvents() {
                return {
                    onInvoiceChanged: onInvoiceChanged,
                    onContractTypeCodeChanged: onContractTypeCodeChanged,
                    onFromCompanyChanged: onFromCompanyChanged,
                    onBillToChanged: onBillToChanged,
                    onBillToCountryChanged: onBillToCountryChanged,
                    onDeliveryCountryChanged: onDeliveryCountryChanged,
                    onSupplierLegalCountryChanged: onSupplierLegalCountryChanged,
                    onBillToLocationChanged: onBillToLocationChanged,
                    onDeliveryLocationChanged: onDeliveryLocationChanged,
                    onCurrencyChanged: onCurrencyChanged,
                    onToContactChanged: onToContactChanged,
                    onFromContactChanged: onFromContactChanged,
                    onPrepaidAmountChanged: onPrepaidAmountChanged,
                    onInvoiceTypeChanged: onInvoiceTypeChanged,
                    onAttachmentUploaded: onAttachmentUploaded,
                    onAttachmentUploadStarted: onAttachmentUploadStarted,
                    onAttachmentUploadFailed: onAttachmentUploadFailed,
                    onSupplierCodeChanged: onSupplierCodeChanged,
                    onSupplierEndpointIdentifierChanged: onSupplierEndpointIdentifierChanged,
                    onCustomerCodeChanged: onCustomerCodeChanged,
                    onBuyerEndpointIdentifierChanged: onBuyerEndpointIdentifierChanged,
                    onAccountingCustomerEndpointIdentifierChanged: onAccountingCustomerEndpointIdentifierChanged,
                    onSupplierVatNumberChanged: onSupplierVatNumberChanged,
                    onBuyerVatNumberChanged: onBuyerVatNumberChanged,
                    onAccountingCustomerVatNumberChanged: onAccountingCustomerVatNumberChanged,
                    onPayeeVatNumberChanged: onPayeeVatNumberChanged,
                    onTaxRepresentativePartyVatNumberChanged: onTaxRepresentativePartyVatNumberChanged,
                    onPayeePartyIdentifierChanged: onPayeePartyIdentifierChanged,
                    onBuyerCustomerLegalCompanyReferenceChanged: onBuyerCustomerLegalCompanyReferenceChanged,
                    onAccountingCustomerLegalCompanyReferenceChanged: onAccountingCustomerLegalCompanyReferenceChanged,
                    onSupplierLegalCompanyReferenceChanged: onSupplierLegalCompanyReferenceChanged
                };

                function onInvoiceChanged() {
                    if (vm.mode === 'edit' && scope.loaded === true || vm.mode === 'new') {
                        setDirty();
                    }
                }

                function onContractTypeCodeChanged() {
                    var selectedContractTypeCode = _.find(vm.contractTypeCodes, function (contractTypeCode) {
                        return contractTypeCode.id === vm.invoice.contractTypeCodeId;
                    });

                    vm.invoice.contractTypeCode = selectedContractTypeCode.code;
                    vm.invoice.contractType = selectedContractTypeCode.value;

                    onInvoiceChanged();
                }

                function onFromCompanyChanged(company) {
                    if (vm.invoice.supplierPartyId === company.partyId) {
                        return;
                    }

                    company.party.partyId = company.partyId;

                    vm.invoice.lines.clear();
                    vm.customer = undefined;
                    vm.customerBillToLocationSelected = undefined;
                    vm.selectedCustomerContact = undefined;

                    _onSupplierSelected(company.party);

                    notifyInvoiceDetailsChangeSubscribers({
                        supplierPartyId: company.partyId
                    });

                    onInvoiceChanged();
                }

                function onBillToChanged(company) {
                    if (vm.invoice.customerPartyId === company.partyId) {
                        return;
                    }

                    onCustomerSelected(company);

                    notifyInvoiceDetailsChangeSubscribers({
                        customerPartyId: company.id
                    });

                    onInvoiceChanged();
                }

                function onBillToCountryChanged(country) {
                    vm.customerBillToLocationSelected.country = country;
                    notifyInvoiceDetailsChangeSubscribers({
                        countryCode: country.code
                    });

                    setCurrencyFromBusinessAddress();

                    onInvoiceChanged();
                }

                function onDeliveryCountryChanged(country) {
                    vm.customerDeliveryLocationSelected.country = country;

                    onInvoiceChanged();
                }

                function onSupplierLegalCountryChanged(country) {
                    if (vm.invoice.supplierLegalCountry === country.code) {
                        return;
                    }

                    vm.invoice.supplierLegalCountry = country.code;
                    onInvoiceChanged();
                }

                function onBillToLocationChanged(location) {
                    if (location.id < 0) {
                        vm.customerBillToLocationSelected.country = { id: -1 };
                    } else {
                        setCustomerDetails();
                    }

                    onInvoiceChanged();
                }

                function onDeliveryLocationChanged(location) {
                    if (location.id < 0) {
                        vm.customerDeliveryLocationSelected.locationIdentifier = {
                            identifier: "",
                            code: "",
                            scheme: "",
                            schemeDescription: "",
                            displayValue: "",
                            showLabel: true,
                            label: "[None]"
                        };;
                        vm.customerDeliveryLocationSelected.country = {};
                    }

                    onInvoiceChanged();
                }

                function onCurrencyChanged(currency) {
                    setCurrency(currency.id);

                    onInvoiceChanged();
                }

                function onToContactChanged() {
                    onInvoiceChanged();
                }

                function onFromContactChanged() {
                    onInvoiceChanged();
                }

                function onPrepaidAmountChanged() {
                    invoiceTotalsCalculator.calculate(vm.invoice, vm.totals);

                    onInvoiceChanged();
                }

                function onInvoiceTypeChanged(selectedId) {
                    vm.invoice.invoiceTypeId = selectedId;
                    onInvoiceChanged();
                }

                function onAttachmentUploaded(lineIdentifier, attachmentDataId, filename) {
                    var line = _.find(vm.invoice.additionalDocumentReferences, function (item) {
                        return item.lineIdentifier === lineIdentifier;
                    });

                    if (util.isDefined(line)) {
                        line.attachmentDataId = attachmentDataId;
                        line.fileName = filename;

                        vm.uploadsInProgress = _.without(vm.uploadsInProgress, line);

                        notificationHandler.showSuccess('EINVOICING.PORTAL.COMPONENTS.ATTACHMENTS.UPLOAD_SUCCESSFUL');

                        onInvoiceChanged();
                    }
                }

                function onAttachmentUploadStarted(lineIdentifier) {
                    var line = _.find(vm.invoice.additionalDocumentReferences, function (item) {
                        return item.lineIdentifier === lineIdentifier;
                    });

                    if (util.isDefined(line)) {
                        vm.uploadsInProgress.push(line);
                    }
                }

                function onAttachmentUploadFailed(lineIdentifier) {
                    var line = _.find(vm.invoice.additionalDocumentReferences, function (item) {
                        return item.lineIdentifier === lineIdentifier;
                    });

                    if (util.isDefined(line)) {
                        notificationHandler.showError('EINVOICING.PORTAL.COMPONENTS.ATTACHMENTS.UPLOAD_FAILED');

                        vm.uploadsInProgress = _.without(vm.uploadsInProgress, line);
                    }
                }

                function onSupplierCodeChanged(item) {
                    vm.invoice.supplierCode = item.code;
                    vm.invoice.supplierCodeScheme = item.scheme;
                    vm.invoice.supplierCodeSchemeId = item.schemeId;

                    onInvoiceChanged();
                }

                function onSupplierEndpointIdentifierChanged(item) {
                    vm.invoice.supplierEndpointIdentifier = item.code;
                    vm.invoice.supplierEndpointIdentifierScheme = item.scheme;
                    vm.invoice.supplierEndpointIdentifierSchemeId = item.schemeId;

                    onInvoiceChanged();
                }

                function onCustomerCodeChanged(item) {
                    vm.invoice.customerCode = item.code;
                    vm.invoice.customerCodeScheme = item.scheme;
                    vm.invoice.customerCodeSchemeId = item.schemeId;

                    onInvoiceChanged();
                }

                function onBuyerEndpointIdentifierChanged(item) {
                    vm.invoice.buyerEndpointIdentifier = item.code;
                    vm.invoice.buyerEndpointIdentifierScheme = item.scheme;
                    vm.invoice.buyerEndpointIdentifierSchemeId = item.schemeId;

                    onInvoiceChanged();
                }

                function onAccountingCustomerEndpointIdentifierChanged(item) {
                    vm.invoice.accountingCustomerEndpointIdentifier = item.code;
                    vm.invoice.accountingCustomerEndpointIdentifierScheme = item.scheme;
                    vm.invoice.accountingCustomerEndpointIdentifierSchemeId = item.schemeId;

                    onInvoiceChanged();
                }

                function onSupplierVatNumberChanged(item) {
                    vm.invoice.supplierVatNumber = item.code;
                    vm.invoice.supplierVatNumberScheme = item.scheme;
                    vm.invoice.supplierVatNumberSchemeId = item.schemeId;

                    onInvoiceChanged();
                }

                function onBuyerVatNumberChanged(item) {
                    vm.invoice.customerVatNumber = item.code;
                    vm.invoice.customerVatNumberScheme = item.scheme;
                    vm.invoice.customerVatNumberSchemeId = item.schemeId;

                    onInvoiceChanged();
                }

                function onAccountingCustomerVatNumberChanged(item) {
                    vm.invoice.accouningCustomerVatNumber = item.code;
                    vm.invoice.accouningCustomerVatNumberScheme = item.scheme;
                    vm.invoice.accouningCustomerVatNumberSchemeId = item.schemeId;

                    onInvoiceChanged();
                }

                function onPayeeVatNumberChanged(item) {
                    vm.invoice.payeeVatNumber = item.code;
                    vm.invoice.payeeVatNumberScheme = item.scheme;
                    vm.invoice.payeeVatNumberSchemeId = item.schemeId;

                    onInvoiceChanged();
                }

                function onTaxRepresentativePartyVatNumberChanged(item) {
                    vm.invoice.taxRepresentativePartyVatNumber = item.code;
                    vm.invoice.taxRepresentativePartyVatNumberScheme = item.scheme;
                    vm.invoice.taxRepresentativePartyVatNumberSchemeId = item.schemeId;

                    onInvoiceChanged();
                }

                function onPayeePartyIdentifierChanged(item) {
                    vm.invoice.payeePartyIdentifier = item.code;
                    vm.invoice.payeePartyIdentifierScheme = item.scheme;
                    vm.invoice.payeePartyIdentifierSchemeId = item.schemeId;

                    onInvoiceChanged();
                }

                function onBuyerCustomerLegalCompanyReferenceChanged(item) {
                    vm.invoice.buyerCustomerLegalCompanyReference = item.code;
                    vm.invoice.buyerCustomerLegalCompanyReferenceScheme = item.scheme;
                    vm.invoice.buyerCustomerLegalCompanyReferenceSchemeId = item.schemeId;

                    onInvoiceChanged();
                }

                function onAccountingCustomerLegalCompanyReferenceChanged(item) {
                    vm.invoice.accountingCustomerLegalCompanyReference = item.code;
                    vm.invoice.accountingCustomerLegalCompanyReferenceScheme = item.scheme;
                    vm.invoice.accountingCustomerLegalCompanyReferenceSchemeId = item.schemeId;

                    onInvoiceChanged();
                }

                function onSupplierLegalCompanyReferenceChanged(item) {
                    vm.invoice.supplierLegalCompanyReference = item.code;
                    vm.invoice.supplierLegalCompanyReferenceScheme = item.scheme;
                    vm.invoice.supplierLegalCompanyReferenceSchemeId = item.schemeId;

                    onInvoiceChanged();
                }
            }

            /**
            *  Destroy all state, watchers,  any event listeners and subscriptions
            */
            function tearDown() {
                scope.$on('$destroy', function () {
                    unRegCalculateInvoiceTotals();
                });
            }

            /**
            * Initialises UI and loads data
            */
            function init() {
                showSpinner();

                scrollbarResizer.monitorHorizontalBrowserScrollbar();

                vm.buttonsSetOneOptions = invoiceDetailsButtonsConfigurator.getButtonsOneConfiguration();
                vm.buttonsSetTwoOptions = invoiceDetailsButtonsConfigurator.getButtonsTwoConfiguration();
                vm.buttonsSetThreeOptions = invoiceDetailsButtonsConfigurator.getButtonsThreeConfiguration();
                vm.buttonsSetFourOptions = invoiceDetailsButtonsConfigurator.getButtonsFourConfiguration();

                setLabels();

                validationRulesSetter.setValidationRules("Invoice,InvoiceLine,customItem,AdditionalDocumentReference,PartyCode,AllowancesCharges");

                controlsRestrictionManager.initialise(stateParams.id, function (restrictionLevel) {
                    if (restrictionLevel === 'all') {
                        vm.actions.viewInvoice(stateParams.id);
                        notificationHandler.showWarning("EINVOICING.PORTAL.INVOICES.EDITOR.ACTIONS.EDIT_INVOICE_WARNING");
                        return;
                    }
                });

                var promises = [];

                var countriesPromise = staticLookupProxy.get('Country');
                var currenciesPromise = currencyCache.getCurrencies();
                var contractTypesPromise = staticLookupProxy.get('ContractTypeCode');

                var workingForPartiesPromise = partyProxy.getAllPartiesUserCanWorkFor(0);

                promises.push(countriesPromise);
                promises.push(currenciesPromise);
                promises.push(contractTypesPromise);
                promises.push(workingForPartiesPromise);

                $q.all(promises).then(function (_ref) {
                    var _ref2 = _slicedToArray(_ref, 4),
                        countries = _ref2[0],
                        currencies = _ref2[1],
                        contractTypes = _ref2[2],
                        workingForParties = _ref2[3];

                    vm.countries = countries;
                    vm.currencies = currencies;
                    vm.contractTypeCodes = contractTypes;
                    vm.partiesUserWorksFor = workingForParties;

                    loadInvoice(stateParams.id);

                    unRegCalculateInvoiceTotals = scope.$on('calculateInvoiceTotals', function () {
                        invoiceTotalsCalculator.calculate(vm.invoice, vm.totals);
                    });
                });

                return;

                /**
                 * sets labels values depending on user rights
                 */
                function setLabels() {
                    var data = [{
                        rights: ["Supplier"],
                        key: "titleEdit",
                        label: "EINVOICING.PORTAL.INVOICES.EDITOR.EDIT.HEADER.TITLE_SUPPLIER"
                    }, {
                        rights: ["Buyer"],
                        key: "titleEdit",
                        label: "EINVOICING.PORTAL.INVOICES.EDITOR.EDIT.HEADER.TITLE_BUYER"
                    }, {
                        rights: ["Supplier"],
                        key: "titleNew",
                        label: "EINVOICING.PORTAL.INVOICES.EDITOR.NEW.HEADER.TITLE_SUPPLIER"
                    }, {
                        rights: ["Buyer"],
                        key: "titleNew",
                        label: "EINVOICING.PORTAL.INVOICES.EDITOR.NEW.HEADER.TITLE_BUYER"
                    }];

                    vm.labels = authorizedObjectsFilter.getAuthorizedObjectsAsAssociative(data, 'key', 'label');

                    if (vm.mode === 'edit') {
                        vm.labels.title = vm.labels.titleEdit;
                    } else {
                        vm.labels.title = vm.labels.titleNew;
                    }
                }
            }

            /**
             * loads invoice data from db
             */
            function loadInvoice(id) {
                var functionToGetInvoice = function functionToGetInvoice() {};
                var parameterToGetInvoice = {};

                vm.mode = 'edit';
                scope.loaded = false;
                vm.supplier = undefined;
                vm.customer = undefined;
                vm.accountingCustomer = undefined;
                vm.currentBillTo = undefined;

                vm.actions.viewInvoiceDocumentIssues(false);

                if (util.isNumber(id)) {
                    functionToGetInvoice = invoiceProxy.getById;
                    parameterToGetInvoice = id;
                } else if (util.isNonEmptyString(stateParams.invoiceNumber)) {
                    functionToGetInvoice = invoiceProxy.getByInvoiceNumber;
                    parameterToGetInvoice = stateParams.invoiceNumber;
                } else {
                    vm.mode = 'new';
                    setState(CLIENT_ENUMS.documentStateKey.pending);
                    vm.taxPointDateInitialValue = '';
                    // set to empty as causing issues with date format on some machines, will be fixed later
                    vm.selectedActions = [CLIENT_ENUMS.userActions.editInvoice, CLIENT_ENUMS.userActions.commit];
                }

                if (vm.mode === 'edit' && util.isFunction(functionToGetInvoice)) {
                    functionToGetInvoice(parameterToGetInvoice).then(invoiceResolved, invoiceRejected);
                } else {
                    var promise = setIdentifiers(false, false, true);

                    $q.all([promise]).then(function () {
                        removeSpinner();
                    });
                }

                return;

                /**
                *  Loads invoice data
                */
                function invoiceResolved(data) {
                    var editAction = _.find(data.actions, function (action) {
                        return action === CLIENT_ENUMS.userActions.editInvoice;
                    });

                    if (typeof editAction === "undefined") {
                        viewInvoice(data.id);

                        return;
                    }

                    setSupplierLegalCountry(data.supplierLegalCountry);

                    vm.countOfAttachments = data.countOfAttachments;

                    enumTranslator.translateCollection(CLIENT_ENUMS.productType, data.lines, "productType", "productTypeName");

                    _.each(data.attributes, function (attribute) {
                        vm.invoice.attributes.push(attribute);
                    });

                    util.extend(vm.invoice, _.omit(data, 'additionalDocumentReferences'));

                    //components one-way bindings watch reference changes (the default of scope.$watch's third param - objectEquality - is false)
                    vm.invoice.additionalDocumentReferences = randomStringGenerator.reset(data.additionalDocumentReferences, 'lineIdentifier');

                    setTaxExemptionReasonField();

                    validateCurrency(vm.invoice.currencyId);

                    scope.invoiceLine = vm.invoice.lines[0];

                    setAttributes();

                    setActions();

                    setState(vm.invoice.clientEInvoicingState);

                    if (vm.invoice.clientEInvoicingState === CLIENT_ENUMS.documentStateKey.invalid) {
                        setState(CLIENT_ENUMS.documentStateKey.pending);
                        vm.selectedStates.push(documentStateResolver.getDocumentState(2));
                    }

                    setContactDetails();

                    setInvoiceAddressDetails();

                    setDeliveryAddressDetails();

                    vm.actions.viewInvoiceDocumentIssues(_.find(data.attributes, function (attribute) {
                        return attribute === CLIENT_ENUMS.documentAttribute.businessInvalid || attribute === CLIENT_ENUMS.documentAttribute.reconciliationFailed || attribute === CLIENT_ENUMS.documentAttribute.xsltInvalid;
                    }));

                    setSupplier();

                    togglePayeeDetails();
                    toggleTaxRepresentativeDetails();

                    return;

                    /**
                    * Sets invoice address details.
                    */
                    function setInvoiceAddressDetails() {
                        var address = {
                            id: 0,
                            locationId: vm.invoice.invoiceLocationId,
                            name: vm.invoice.addressName,
                            addressLine1: vm.invoice.addressLine1,
                            addressLine2: vm.invoice.addressLine2,
                            town: vm.invoice.addressTown,
                            county: vm.invoice.addressCounty,
                            country: vm.invoice.country,
                            postCode: vm.invoice.postCode
                        };

                        if (address.country) {
                            var country = getCountryByCode(address.country);
                            address.country = country;
                            address.countryId = country.id;
                            address.countryName = country.name;
                        }

                        vm.customerBillToLocationFromInvoice = address;
                    }

                    /**
                     * Sets delivery address details.
                     */
                    function setDeliveryAddressDetails() {
                        var address = {
                            id: 0,
                            locationId: vm.invoice.deliveryLocationId,
                            name: vm.invoice.deliveryAddressName,
                            addressLine1: vm.invoice.deliveryAddressLine1,
                            addressLine2: vm.invoice.deliveryAddressLine2,
                            town: vm.invoice.deliveryAddressTown,
                            county: vm.invoice.deliveryAddressCounty,
                            country: vm.invoice.deliveryCountry,
                            postCode: vm.invoice.deliveryPostCode,
                            locationIdentifier: identifierFactory.create(vm.invoice.deliveryLocationIdentifierScheme, vm.invoice.deliveryLocationIdentifierSchemeId, vm.invoice.deliveryLocationIdentifier)
                        };

                        if (address.country) {
                            var country = getCountryByCode(address.country);
                            address.country = country;
                            address.countryId = country.id;
                            address.countryName = country.name;
                        }

                        vm.customerDeliveryLocationFromInvoice = address;
                    }

                    /**
                     * Sets supplier and customer contact details from header.
                     */
                    function setContactDetails() {
                        var supplierContactFromInvoice = {
                            id: 0,
                            contactId: vm.invoice.billFromContactId,
                            name: vm.invoice.billFromContactName,
                            telephoneNumber: vm.invoice.billFromContactTelephone,
                            fax: vm.invoice.billFromContactFax,
                            email: vm.invoice.billFromContactEmail,
                            reference: vm.invoice.billFromContactReference
                        };

                        vm.supplierContactFromInvoice = supplierContactFromInvoice;

                        var customerContactFromInvoice = {
                            id: 0,
                            contactId: vm.invoice.billToContactId,
                            name: vm.invoice.billToContactName,
                            telephoneNumber: vm.invoice.billToContactTelephone,
                            fax: vm.invoice.billToContactFax,
                            email: vm.invoice.billToContactEmail,
                            reference: vm.invoice.billToContactReference
                        };

                        vm.customerContactFromInvoice = customerContactFromInvoice;
                    }

                    function setSupplier() {
                        var foundSupplier = _.find(vm.partiesUserWorksFor, function (item) {
                            return item.partyId === vm.invoice.supplierPartyId;
                        });

                        if (foundSupplier) {
                            foundSupplier.party.partyId = foundSupplier.partyId;
                            _onSupplierSelected(foundSupplier.party);
                        }
                    }

                    function togglePayeeDetails() {
                        if (util.isNonEmptyString(vm.invoice.payeeName) || util.isNonEmptyString(vm.invoice.payeePartyIdentifier)) {
                            vm.revealPayeeDetails.show();
                        } else {
                            vm.revealPayeeDetails.hide();
                        }
                    }

                    function toggleTaxRepresentativeDetails() {
                        if (util.isNonEmptyString(vm.invoice.taxRepresentativePartyName)) {
                            vm.revealTaxRepresentativeDetails.show();
                        } else {
                            vm.revealTaxRepresentativeDetails.hide();
                        }
                    }

                    function setAttributes() {
                        if (util.isNonEmptyString(vm.invoice.number) === false) {
                            vm.invoice.attributes.push(CLIENT_ENUMS.documentAttribute.justFlipped);
                        }

                        var array = documentAttributeResolver.resolveAttributeKeys(vm.invoice.attributes);
                        documentAttributeResolver.addAttributeById(array, CLIENT_ENUMS.documentAttribute.saved, false);
                        documentAttributeResolver.addAttributeById(array, CLIENT_ENUMS.documentAttribute.hasServerId, false);

                        vm.selectedAttributes.fill(array);
                    }

                    function setActions() {
                        vm.selectedActions.fill(userActionsResolver.resolveActions(vm.invoice.actions, false));
                    }

                    /**
                    * maps the Tax exemption reason from the relevant tax breakdown category
                    */
                    function setTaxExemptionReasonField() {
                        _.each(vm.invoice.taxBreakdown, function (taxItem) {
                            if (taxItem.taxCategory && taxItem.taxCategory.toUpperCase() === "E") {
                                vm.invoice.taxExemptionReason = taxItem.taxExemptionReason;
                            }
                        });
                    }
                }

                /**
                * Notifies about failure while loading invoice data
                */
                function invoiceRejected() {
                    removeSpinner();
                    notificationHandler.showError('EINVOICING.PORTAL.INVOICES.EDITOR.COULD_NOT_LOAD_INVOICE', parameterToGetInvoice);
                    goBack();
                }
            }

            function _onSupplierSelected(selectedSupplier) {
                showSpinner();
                vm.supplier = selectedSupplier;

                vm.invoice.supplierPartyId = selectedSupplier.partyId;

                setIdentifiers(true, false, true);

                var currentUserId = authenticationData.userData.userId;

                var promises = [];

                var allocatedPartiesPromise = partyProxy.getAllUserWorkingForRelatedAllocatedToParties(currentUserId, [vm.supplier.partyId]).then(partiesResolved, partiesRejected);

                var supplierContactsPromise = setSupplierContacts();

                promises.push(allocatedPartiesPromise);
                promises.push(supplierContactsPromise);

                $q.all(promises).then(function () {
                    if (scope.invoiceForm) {
                        scope.invoiceForm.$setPristine();
                    }

                    if (vm.mode === 'new') {
                        removeSpinner();
                    }
                });
            }

            function getContactIdentifier(contact) {
                var identifier = util.isNonEmptyString(contact.email) ? contact.email : contact.name;

                if (util.isUndefined(identifier)) {
                    identifier = '';
                }

                return identifier;
            }

            function validateForm() {
                var form = formAnalyser.getForm(angular.element('#invoiceSaveButton'));

                formAnalyser.dirtyTrackedElements(form, true);

                var formInstance = formAnalyser.getFormInstance(scope);

                if (formInstance) {
                    formInstance.$setSubmitted(true);
                }
            }

            function setResource(propertyName, partyId, getList, getMatch, getIdentifier, getValid, formatItem, formatDisplayName, allowDefaultOptions, proxyParam) {
                var fromInvoice = vm[propertyName + 'FromInvoice'];

                if (util.isUndefined(fromInvoice)) {
                    fromInvoice = {};
                }

                fromInvoice.identifier = getIdentifier(fromInvoice);

                var promise = getList(partyId, proxyParam).then(function (data) {
                    var array = [];

                    var fromInvoiceIsValid = getValid(fromInvoice);
                    var match = 'none';
                    var labelModified = translator.instantTranslate("EINVOICING.PORTAL.INVOICES.EDITOR.MODIFIED");

                    var selectedResource = undefined;
                    vm[propertyName + 's'] = [];
                    vm[propertyName + 'Selected'] = {};

                    _.each(data, function (item) {
                        var formatted = formatItem(item);
                        formatted.displayName = formatDisplayName(formatted, false);

                        if (fromInvoiceIsValid && match === 'none') {
                            match = getMatch(formatted, fromInvoice);

                            switch (match) {
                                case 'partial':
                                    fromInvoice.modified = labelModified;
                                    fromInvoice.displayName = formatDisplayName(fromInvoice, true);
                                    fromInvoice.party = formatted.party;
                                    array.push(fromInvoice);
                                    selectedResource = fromInvoice;
                                    array.push(formatted);
                                    break;
                                case 'exact':
                                    selectedResource = formatted;
                                default:
                                    array.push(formatted);
                                    break;
                            }
                        } else {
                            array.push(formatted);
                        }
                    });

                    if (fromInvoiceIsValid && match === 'none') {
                        fromInvoice.modified = labelModified;
                        fromInvoice.displayName = formatDisplayName(fromInvoice, true);
                        fromInvoice.party = vm.customer;
                        array.unshift(fromInvoice);
                        selectedResource = fromInvoice;
                    }

                    if (allowDefaultOptions) {
                        setDefaultOptions(array);
                    }

                    if (util.isUndefined(selectedResource)) {
                        selectedResource = array[0];
                    }

                    vm[propertyName + 's'] = array;
                    vm[propertyName + 'Selected'] = selectedResource;
                }, function () {});

                return promise;

                function setDefaultOptions(options) {
                    var none = {
                        id: -1,
                        showLabel: true,
                        label: "[None]"
                    };

                    options.unshift(none);
                }
            }

            function getContactMatch(contact1, contact2) {
                var match = 'none';

                contact1.identifier = getContactIdentifier(contact1);
                contact2.identifier = getContactIdentifier(contact2);

                if (contact1.identifier === contact2.identifier) {
                    match = 'partial';

                    var compare1 = _.pick(contact1, 'name', 'email', 'telephoneNumber', 'fax', 'reference');
                    var compare2 = _.pick(contact2, 'name', 'email', 'telephoneNumber', 'fax', 'reference');

                    if (_.isMatch(compare1, compare2) === true) {
                        match = 'exact';
                    }
                }

                return match;
            }

            function isContactValid(contact) {
                return util.isDefined(contact) && (util.isNonEmptyString(contact.name) || util.isNonEmptyString(contact.email) || util.isNonEmptyString(contact.telephoneNumber) || util.isNonEmptyString(contact.fax) || util.isNonEmptyString(contact.reference));
            }

            function formatContact(contact) {
                var formatted = {
                    party: contact.party
                };
                util.extend(formatted, contact.resource);

                return formatted;
            }

            function formatContactDisplayName(contact, addModifiedSuffix) {
                var output = '';
                var hasName = false;
                if (util.isNonEmptyString(contact.name)) {
                    hasName = true;
                    output += contact.name + ' ';
                }

                var s = '[';
                var e = ']';

                if (util.isNonEmptyString(contact.email)) {
                    if (!hasName) {
                        s = '';
                        e = '';
                    }
                    output += '' + s + contact.email + e + ' ';
                }

                if (addModifiedSuffix) {
                    output += contact.modified;
                }

                return output;
            }

            function setSupplierContacts() {
                return setResource('supplierContact', vm.supplier.partyId, getContacts, getContactMatch, getContactIdentifier, isContactValid, formatContact, formatContactDisplayName, true, {
                    forPartyId: vm.supplier.partyId,
                    sortBy: 1
                });
            }

            function setCustomerContacts() {
                return setResource('customerContact', vm.customer.partyId, getContacts, getContactMatch, getContactIdentifier, isContactValid, formatContact, formatContactDisplayName, true, {
                    forPartyId: vm.supplier.partyId,
                    sortBy: 1
                });
            }

            function setCustomerBillToLocations() {
                return setResource('customerBillToLocation', vm.customer.partyId, getAddresses, getAddressMatch, getAddressIdentifier, isAddressIsValid, formatBusinessAddress, formatAddressDisplayName, false, {
                    types: [CLIENT_ENUMS.locationType.Business, CLIENT_ENUMS.locationType.Accounting],
                    forPartyId: vm.supplier.partyId,
                    sortBy: 1
                });
            }

            function getContacts(partyId, options) {
                var promise = contactProxy.getContactBook(partyId, options.forPartyId, (options.sortBy || {}).value || options.sortBy).then(function (data) {
                    return data;
                });

                return promise;
            }

            function getAddresses(partyId, options) {
                var promise = locationProxy.getAddressBook(partyId, options.forPartyId, (options.sortBy || {}).value || options.sortBy).then(function (data) {
                    return _.filter(data, function (item) {
                        return _.contains(options.types, item.resource.locationType);
                    });
                });

                return promise;
            }

            function setCustomerDeliveryLocations() {
                return setResource('customerDeliveryLocation', vm.customer.partyId, getAddresses, getAddressMatch, getAddressIdentifier, isAddressIsValid, formatAddress, formatAddressDisplayName, true, {
                    types: [CLIENT_ENUMS.locationType.Delivery],
                    forPartyId: vm.supplier.partyId,
                    sortBy: 1
                });
            }

            function getAddressMatch(address1, address2) {
                var match = 'none';

                if (util.isUndefined(address1) || util.isUndefined(address2)) {
                    return match;
                }

                address1.identifier = getAddressIdentifier(address1);
                address2.identifier = getAddressIdentifier(address2);

                address1.reference = getAddressReference(address1);
                address2.reference = getAddressReference(address2);

                if (address1.identifier === address2.identifier) {
                    match = 'partial';

                    var compare1 = _.pick(address1, 'addressLine1', 'addressLine2', 'addressTown', 'code', 'county', 'postCode', 'reference');

                    var compare2 = _.pick(address2, 'addressLine1', 'addressLine2', 'addressTown', 'code', 'county', 'postCode', 'reference');

                    if (_.isMatch(compare1, compare2) === true) {
                        match = 'exact';
                    }
                }

                return match;
            }

            function isAddressIsValid(address) {
                return util.isDefined(address) && (util.isNonEmptyString(address.name) || util.isNonEmptyString(address.addressLine1) || util.isNonEmptyString(address.postCode));
            }

            function getAddressIdentifier(address) {
                if (util.isUndefined(address)) {
                    return "";
                }

                var array = [address.name, address.addressLine1, address.postCode];

                var parameters = _.filter(array, function (item) {
                    return util.isNonEmptyString(item);
                });

                var addressDetailsIdentifier = parameters.join(' ');

                if (address.locationType !== CLIENT_ENUMS.locationType.delivery) {
                    return util.isNonEmptyString(address.locationIdentifier) ? address.locationIdentifier : addressDetailsIdentifier;
                }

                return addressDetailsIdentifier;
            }

            function getAddressReference(address) {
                if (!util.isNullOrUndefined(address.locationIdentifier)) {
                    return address.locationIdentifier.identifier;
                }

                return '';
            }

            function formatBusinessAddress(address) {
                var formatted = formatAddress(address);
                formatted.locationIdentifier = null;

                return formatted;
            }

            function formatAddress(address) {
                var formatted = {
                    id: address.resource.id,
                    locationId: address.resource.id,
                    name: address.resource.name,
                    addressLine1: address.resource.line1,
                    addressLine2: address.resource.line2,
                    town: address.resource.town,
                    county: address.resource.county,
                    postCode: address.resource.postCode
                };

                if (address.resource.locationType === CLIENT_ENUMS.locationType.Delivery) {
                    formatted.locationIdentifier = identifierFactory.create(address.resource.locationIdentifierScheme, address.resource.locationIdentifierSchemeId, address.resource.locationIdentifier);
                }

                if (util.isDefined(address.resource.countryId)) {
                    var country = getCountryById(address.resource.countryId);

                    if (util.isDefined(country)) {
                        formatted.country = country;
                        formatted.countryName = country.name;
                    }
                }

                formatted.party = address.party;

                return formatted;
            }

            function formatAddressDisplayName(address, addModifiedSuffix) {
                if (util.isUndefined(address)) {
                    return "";
                }

                var output = '';
                var hasName = false;
                if (util.isNonEmptyString(address.name)) {
                    hasName = true;
                    output += address.name;
                }

                var s = hasName ? ' - ' : '';

                if (util.isObject(address.locationIdentifier)) {

                    output += '' + s + address.locationIdentifier.displayValue;
                } else if (util.isNonEmptyString(address.locationIdentifier)) {
                    output += '' + s + address.locationIdentifier;
                }

                var countryName = '';

                if (util.isNonEmptyString(address.countryName)) {
                    countryName = address.countryName;
                } else {
                    var country = getCountryById(address.countryId);
                    if (util.isDefined(country)) {
                        countryName = country.name;
                    }
                }

                var array = [output, address.addressLine1, address.town, address.postCode, address.county, countryName];

                var parameters = _.filter(array, function (item) {
                    return util.isNonEmptyString(item);
                });

                var addressDetails = parameters.join(', ');

                if (addModifiedSuffix) {
                    addressDetails += address.modified + ' ';
                }

                return addressDetails;
            }

            function partiesResolved(data) {
                guard.throwIfNotArray("EUP0801E", data, "data");

                var companies = [];

                _.each(data, function (item) {
                    item.party.partyId = item.partyId;
                    companies.push(item.party);
                });

                vm.allocatedCompanies = companies;

                var foundCustomer = _.find(vm.allocatedCompanies, function (item) {
                    return item.id === vm.invoice.customerPartyId;
                });

                if (util.isDefined(foundCustomer)) {
                    onCustomerSelected(foundCustomer);
                }
                if (vm.mode === 'new') {
                    removeSpinner();
                }
            }

            function partiesRejected(error) {
                removeSpinner();
                notificationHandler.showError(error.failureReason);
            }

            function onCustomerSelected(selectedCustomer) {
                if (util.isDefined(vm.currentBillTo) && vm.currentBillTo.partyId === selectedCustomer.partyId) {
                    return;
                }

                if (util.isDefined(vm.currentBillTo)) {
                    resetCustomerSpecificDetails();
                }

                showSpinner();
                vm.customer = selectedCustomer;
                vm.currentBillTo = selectedCustomer;

                vm.invoice.customerPartyId = selectedCustomer.partyId;

                var contactsPromise = setCustomerContacts();
                var billToLocationsPromise = setCustomerBillToLocations();
                var deliveryLocationsPromise = setCustomerDeliveryLocations();

                $q.all([contactsPromise, billToLocationsPromise, deliveryLocationsPromise]).then(function () {
                    setCustomerDetails();
                }).finally(function () {
                    scope.loaded = true;
                });
            }

            function resetCustomerSpecificDetails() {
                vm.customerBillToLocationSelected = undefined;
                vm.customerBillToLocationFromInvoice = undefined;
                vm.buyerEndpointIdentifier = undefined;
                vm.accountingCustomerEndpointIdentifier = undefined;
                vm.buyerCustomerLegalCompanyReference = undefined;
                vm.accountingCustomerLegalCompanyReference = undefined;
                vm.customerVatNumber = undefined;
                vm.accountingCustomerVatNumber = undefined;

                vm.invoice.buyerEndpointIdentifierScheme = undefined;
                vm.invoice.buyerEndpointIdentifierSchemeId = undefined;
                vm.invoice.buyerEndpointIdentifier = undefined;

                vm.invoice.accountingCustomerEndpointIdentifierScheme = undefined;
                vm.invoice.accountingCustomerEndpointIdentifierSchemeId = undefined;
                vm.invoice.accountingCustomerEndpointIdentifier = undefined;

                vm.invoice.customerVatNumberScheme = '';
                vm.invoice.customerVatNumberSchemeId = undefined;
                vm.invoice.customerVatNumber = undefined;

                vm.invoice.accountingCustomerVatNumberScheme = '';
                vm.invoice.accountingCustomerVatNumberSchemeId = undefined;
                vm.invoice.accountingCustomerVatNumber = undefined;

                vm.invoice.buyerCustomerLegalCompanyReferenceScheme = '';
                vm.invoice.buyerCustomerLegalCompanyReferenceSchemeId = undefined;
                vm.invoice.buyerCustomerLegalCompanyReference = undefined;

                vm.invoice.accountingCustomerCustomerLegalCompanyReferenceScheme = '';
                vm.invoice.accountingCustomerCustomerLegalCompanyReferenceSchemeId = undefined;
                vm.invoice.accountingCustomerCustomerLegalCompanyReference = undefined;

                vm.invoice.buyerCustomerLegalRegistrationName = undefined;
                vm.invoice.accountingCustomerLegalRegistrationName = undefined;
            }

            function setCustomerDetails() {
                setCurrencyFromBusinessAddress();

                var setForAccounting = false;
                var setForBuyer = true;

                if (vm.customerBillToLocationSelected && vm.customerBillToLocationSelected.party && vm.customerBillToLocationSelected.party.isAccountingCustomer) {
                    setForAccounting = true;
                    setForBuyer = false;

                    vm.accountingCustomer = vm.customerBillToLocationSelected.party;
                }

                var identifiersPromise = setIdentifiers(false, setForBuyer, false, setForAccounting);

                var propertyFieldsPromise = invoiceProxy.getVisiblePropertyFieldsForBuyer(vm.customer.partyId);

                $q.all([identifiersPromise, propertyFieldsPromise]).then(function (data) {
                    removeSpinner();

                    populateCustomPropertyFields(data[1]);

                    if (vm.invoice.clientEInvoicingState === CLIENT_ENUMS.documentStateKey.invalidDraft || vm.invoice.clientEInvoicingState === CLIENT_ENUMS.documentStateKey.invalid) {
                        validateForm();
                    }
                });
            }

            function setCurrencyFromBusinessAddress() {
                if (vm.customerBillToLocationSelected && vm.customerBillToLocationSelected.country) {
                    vm.invoice.currencyId = vm.customerBillToLocationSelected.country.currencyId;
                    setCurrency(vm.invoice.currencyId);
                }

                validateCurrency(vm.invoice.currencyId);
            }

            function updateModelReadyForServer() {
                if (!util.isDefined(vm.invoice.id) || vm.invoice.id <= 0) {
                    vm.invoice.createdDateTime = new Date();
                    vm.invoice.createdByUserId = authenticationData.userData.userId;
                    vm.invoice.documentType = CLIENT_ENUMS.documentType.invoice;
                    vm.invoice.documentSource = CLIENT_ENUMS.documentSource.websiteUser;

                    vm.invoice.taxCurrencyId = vm.invoice.currencyId;
                }

                vm.invoice.lastDocumentSource = CLIENT_ENUMS.documentSource.websiteUser;
                vm.invoice.lastModifiedDateTime = new Date();
                vm.invoice.lastModifiedByUserId = authenticationData.userData.userId;
                vm.invoice.totalLineAmounts = vm.totals.beforeTax;
                vm.invoice.totalExcludingTax = vm.totals.beforeTax;
                vm.invoice.totalTax = vm.totals.totalTax;
                vm.invoice.totalIncludingTax = vm.totals.total;
                vm.invoice.amountPayable = vm.totals.total;

                updateSupplierCode();

                updateCustomerCode();

                updateAccountingCustomer();

                updateAddressDetails();

                updateContactDetails();

                _.each(vm.invoice.lines, function (line) {
                    line.netAmount = calculateLineNet(line);
                    line.taxAmount = invoiceTotalsCalculator.calculateTaxForLine(line);
                });

                vm.invoice.taxBreakdown = vm.totals.taxBreakdown;

                mapTaxExemptionReason();

                return;

                function updateAccountingCustomer() {
                    if (vm.usingAccounting === true) {
                        updateAccountingAddress();
                        updateAccountingIdentifiers();
                    } else {
                        clearAccountingDetails();
                    }

                    return;

                    function clearAccountingDetails() {
                        vm.invoice.accountingCustomerPartyId = undefined;
                        vm.invoice.accountingCustomerName = undefined;
                        vm.invoice.accountingCustomerLocationId = undefined;
                        vm.invoice.accountingCustomerAddressName = undefined;
                        vm.invoice.accountingCustomerAddressLine1 = undefined;
                        vm.invoice.accountingCustomerAddressLine2 = undefined;
                        vm.invoice.accountingCustomerAddressTown = undefined;
                        vm.invoice.accountingCustomerAddressCounty = undefined;
                        vm.invoice.accountingCustomerPostCode = undefined;
                        vm.invoice.accountingCustomerCountry = undefined;
                        vm.invoice.accountingCustomerLocationIdentifier = undefined;

                        vm.invoice.accountingCustomerCode = undefined;
                        vm.invoice.accountingCustomerCodeScheme = undefined;
                        vm.invoice.accountingCustomerCodeSchemeId = undefined;

                        vm.invoice.accountingCustomerEndpointIdentifier = undefined;
                        vm.invoice.accountingCustomerEndpointIdentifierScheme = undefined;
                        vm.invoice.accountingCustomerEndpointIdentifierSchemeId = undefined;

                        vm.invoice.accountingCustomerVatNumber = undefined;
                        vm.invoice.accountingCustomerVatNumberScheme = undefined;
                        vm.invoice.accountingCustomerVatNumberSchemeId = undefined;

                        vm.invoice.accountingCustomerLegalCompanyReference = undefined;
                        vm.invoice.accountingCustomerLegalCompanyReferenceScheme = undefined;
                        vm.invoice.accountingCustomerLegalCompanyReferenceSchemeId = undefined;

                        vm.invoice.accountingCustomerLegalName = undefined;
                    }

                    function updateAccountingAddress() {
                        vm.invoice.accountingCustomerPartyId = vm.customerBillToLocationSelected.party.id;
                        vm.invoice.accountingCustomerName = vm.customerBillToLocationSelected.party.name;
                        vm.invoice.accountingCustomerLocationId = vm.customerBillToLocationSelected.locationId;
                        vm.invoice.accountingCustomerAddressName = vm.customerBillToLocationSelected.name;
                        vm.invoice.accountingCustomerAddressLine1 = vm.customerBillToLocationSelected.addressLine1;
                        vm.invoice.accountingCustomerAddressLine2 = vm.customerBillToLocationSelected.addressLine2;
                        vm.invoice.accountingCustomerAddressTown = vm.customerBillToLocationSelected.town;
                        vm.invoice.accountingCustomerAddressCounty = vm.customerBillToLocationSelected.county;
                        vm.invoice.accountingCustomerPostCode = vm.customerBillToLocationSelected.postCode;

                        if (util.hasValue(vm.customerBillToLocationSelected.country)) {
                            vm.invoice.accountingCustomerCountry = vm.customerBillToLocationSelected.country.code;
                        }

                        vm.invoice.accountingCustomerLocationIdentifier = vm.customerBillToLocationSelected.locationIdentifier;
                    }

                    function updateAccountingIdentifiers() {
                        updateAccountingCustomerCode();
                        updateAccountingCustomerEndpoint();
                        updateAccountingCustomerVatNumber();

                        return;

                        function updateAccountingCustomerCode() {
                            var item = vm.customerCode;

                            if (util.isDefined(item) && util.isNonEmptyString(item.identifier)) {
                                vm.invoice.accountingCustomerCode = item.code;
                                vm.invoice.accountingCustomerCodeScheme = item.scheme;
                                vm.invoice.accountingCustomerCodeSchemeId = item.schemeId;
                            }
                        }

                        function updateAccountingCustomerEndpoint() {
                            var item = vm.accountingCustomerEndpointIdentifier;

                            if (util.isDefined(item) && util.isNonEmptyString(item.identifier)) {
                                vm.invoice.accountingCustomerEndpointIdentifier = item.code;
                                vm.invoice.accountingCustomerEndpointIdentifierScheme = item.scheme;
                                vm.invoice.accountingCustomerEndpointIdentifierSchemeId = item.schemeId;
                            }
                        }

                        function updateAccountingCustomerVatNumber() {
                            var item = vm.accountingCustomerVatNumber;

                            if (util.isDefined(item) && util.isNonEmptyString(item.identifier)) {
                                vm.invoice.accountingCustomerVatNumber = item.code;
                                vm.invoice.accountingCustomerVatNumberScheme = item.scheme;
                                vm.invoice.accountingCustomerVatNumberSchemeId = item.schemeId;
                            }
                        }
                    }
                }

                function updateSupplierCode() {
                    var item = vm.supplierCode;

                    if (util.isDefined(item) && util.isNonEmptyString(item.identifier)) {
                        vm.invoice.supplierCode = item.code;
                        vm.invoice.supplierCodeScheme = item.scheme;
                        vm.invoice.supplierCodeSchemeId = item.schemeId;
                    }
                }

                function updateCustomerCode() {
                    var item = vm.customerCode;

                    if (util.isDefined(item) && util.isNonEmptyString(item.identifier)) {
                        vm.invoice.customerCode = item.code;
                        vm.invoice.customerCodeScheme = item.scheme;
                        vm.invoice.customerCodeSchemeId = item.schemeId;
                    }
                }

                function updateAddressDetails() {
                    if (util.isDefined(vm.customerBillToLocationSelected)) {
                        vm.invoice.invoiceLocationId = vm.customerBillToLocationSelected.locationId;
                        vm.invoice.addressName = vm.customerBillToLocationSelected.name;
                        vm.invoice.addressLine1 = vm.customerBillToLocationSelected.addressLine1;
                        vm.invoice.addressLine2 = vm.customerBillToLocationSelected.addressLine2;
                        vm.invoice.addressTown = vm.customerBillToLocationSelected.town;
                        vm.invoice.addressCounty = vm.customerBillToLocationSelected.county;
                        vm.invoice.postCode = vm.customerBillToLocationSelected.postCode;

                        if (util.hasValue(vm.customerBillToLocationSelected.country)) {
                            vm.invoice.country = vm.customerBillToLocationSelected.country.code;
                        }
                        vm.invoice.locationIdentifier = vm.customerBillToLocationSelected.locationIdentifier;
                    }

                    if (util.isDefined(vm.customerDeliveryLocationSelected)) {
                        vm.invoice.deliveryLocationId = vm.customerDeliveryLocationSelected.locationId;
                        vm.invoice.deliveryAddressName = vm.customerDeliveryLocationSelected.name;
                        vm.invoice.deliveryAddressLine1 = vm.customerDeliveryLocationSelected.addressLine1;
                        vm.invoice.deliveryAddressLine2 = vm.customerDeliveryLocationSelected.addressLine2;
                        vm.invoice.deliveryAddressTown = vm.customerDeliveryLocationSelected.town;
                        vm.invoice.deliveryAddressCounty = vm.customerDeliveryLocationSelected.county;
                        if (util.hasValue(vm.customerDeliveryLocationSelected.country)) {
                            vm.invoice.deliveryCountry = vm.customerDeliveryLocationSelected.country.code;
                        }
                        vm.invoice.deliveryPostCode = vm.customerDeliveryLocationSelected.postCode;

                        if (util.isDefined(vm.customerDeliveryLocationSelected.locationIdentifier)) {
                            vm.invoice.deliveryLocationIdentifier = vm.customerDeliveryLocationSelected.locationIdentifier.code;
                            vm.invoice.deliveryLocationIdentifierScheme = vm.customerDeliveryLocationSelected.locationIdentifier.scheme;
                            vm.invoice.deliveryLocationIdentifierSchemeId = vm.customerDeliveryLocationSelected.locationIdentifier.schemeId;
                        }
                    }
                }

                function updateContactDetails() {
                    if (util.isDefined(vm.selectedSupplierContact)) {
                        vm.invoice.billFromContactId = vm.selectedSupplierContact.contactId;
                        vm.invoice.billFromContactName = vm.selectedSupplierContact.name;
                        vm.invoice.billFromContactTelephone = vm.selectedSupplierContact.telephoneNumber;
                        vm.invoice.billFromContactFax = vm.selectedSupplierContact.fax;
                        vm.invoice.billFromContactEmail = vm.selectedSupplierContact.email;
                        vm.invoice.billFromContactReference = vm.selectedSupplierContact.reference;
                    }

                    if (util.isDefined(vm.selectedCustomerContact)) {
                        vm.invoice.billToContactId = vm.selectedCustomerContact.contactId;
                        vm.invoice.billToContactName = vm.selectedCustomerContact.name;
                        vm.invoice.billToContactTelephone = vm.selectedCustomerContact.telephoneNumber;
                        vm.invoice.billToContactFax = vm.selectedCustomerContact.fax;
                        vm.invoice.billToContactEmail = vm.selectedCustomerContact.email;
                        vm.invoice.billToContactReference = vm.selectedCustomerContact.reference;
                    }
                }
            }

            function setSupplierLegalCountry(code) {
                var country = getCountryByCode(code, false);

                if (util.hasValue(country)) {
                    vm.supplierLegalCountryId = country.id;
                }
            }

            function getCountryByCode(code, setDefault) {
                var country = _.find(vm.countries, function (country) {
                    return country.code === code;
                });

                if (util.isUndefined(country)) {
                    country = _.find(vm.countries, function (country) {
                        return country.name === code;
                    });
                }

                if (setDefault) {
                    if (util.isUndefined(country)) {
                        country = _.find(vm.countries, function (country) {
                            return country.code === "GB";
                        });
                    }

                    if (util.isUndefined(country)) {
                        country = vm.countries[0];
                    }
                }

                return country;
            }

            function getCountryById(id) {
                var country = _.find(vm.countries, function (country) {
                    return country.id === id;
                });

                return country;
            }

            function setCurrency(currencyId) {
                vm.invoice.currencyId = currencyId;
                vm.invoice.taxCurrencyId = currencyId;

                notifyInvoiceDetailsChangeSubscribers({
                    currencyId: currencyId
                });
            }

            function validateCurrency(currencyId) {
                var enabledCurrency = _.find(vm.currencies, function (item) {
                    return item.id === currencyId;
                });

                if (util.isUndefined(enabledCurrency)) {
                    vm.invoice.currencyId = 157; // DEFAULT 
                }
            }

            function populateCustomPropertyFields(data) {
                vm.propertyFields = [];
                var invoicePropertyKeyValueArray = _.pairs(vm.invoice);
                var invoiceLinesPropertyKeyValueArray = [];
                _.each(vm.invoice.lines, function (line) {
                    invoiceLinesPropertyKeyValueArray.push(_.pairs(line));
                });

                _.each(data, function (item) {
                    var customFieldSetting = _.find(vm.optionalFieldsSettings, function (fieldSetting) {
                        return fieldSetting.clientName === item.entityPropertyClientName;
                    });

                    if (_.isEmpty(customFieldSetting)) {
                        //use generic field
                        if (item.entityTypeClientName === "Invoice") {
                            customFieldSetting = _.find(vm.optionalFieldsSettings, function (fieldSetting) {
                                return fieldSetting.typeGroup === item.entityType;
                            });
                        } else if (item.entityTypeClientName === "InvoiceLine") {
                            customFieldSetting = _.find(vm.optionalFieldsSettings, function (fieldSetting) {
                                return fieldSetting.typeGroup === item.entityType && fieldSetting.header === "Generic product line text box"; //change this
                            });
                        }
                    }

                    if (!_.isEmpty(customFieldSetting)) {

                        customFieldSetting = _.clone(customFieldSetting);

                        if (customFieldSetting.typeGroup > 0) {
                            customFieldSetting.clientName = item.entityPropertyClientName;
                            customFieldSetting.header = item.entityPropertyClientName;
                            var labelValue = util.toSnakeCase(item.entityPropertyClientName).toUpperCase();

                            customFieldSetting.template = customFieldSetting.template.replace("{LABEL}", "EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS." + labelValue);

                            var propertyName = item.entityPropertyClientName.charAt(0).toLowerCase() + item.entityPropertyClientName.slice(1);

                            //this whole section needs revising to make sure the control being populated contains the correct information
                            if (item.entityTypeClientName === "InvoiceLine") {
                                //sets default visible settings (the value visible is handled on the line)
                                customFieldSetting = fieldIsVisible(customFieldSetting, item);
                                customFieldSetting.heading = "EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS." + labelValue;
                                customFieldSetting.model = "line." + propertyName;

                                customFieldSetting.template = customFieldSetting.template.replace("{CHANGED}", "productLinesCtrl.onChanged()").replace("{VISIBLE}", item.isVisible).replace("{HIDDEN}", customFieldSetting.hidden).replace(/{FIELD}/g, propertyName).replace("{MODEL}", "controller.invoice.invoiceLine");
                            } else if (item.entityTypeClientName === "Invoice") {
                                customFieldSetting.template = customFieldSetting.template.replace("{CHANGED}", "controller.onInvoiceChanged()").replace(/{FIELD}/g, propertyName).replace("{MODEL}", "controller.invoice");
                            }
                        }

                        customFieldSetting.entityTypeName = item.entityTypeClientName;

                        if (item.entityTypeClientName === 'Invoice') {
                            customFieldSetting = fieldIsVisible(customFieldSetting, item);

                            //if the item has a value already show it in the optional fields by default

                            var setVisibleWhenPopulated = function setVisibleWhenPopulated(propertyNameAndValuePairs, propertyClientName, fieldSetting) {
                                var propertyValue = getPropertyValue(propertyNameAndValuePairs, propertyClientName);

                                if (!util.isNullOrUndefined(propertyValue) && util.isNonEmptyString(propertyValue)) {
                                    fieldSetting.visible = true;
                                }
                            };

                            setVisibleWhenPopulated(invoicePropertyKeyValueArray, item.entityPropertyClientName, customFieldSetting);
                        } else if (item.entityTypeClientName === 'InvoiceLine') {
                            //check through all the lines for a value similar to the above
                            _.each(invoiceLinesPropertyKeyValueArray, function (lineKeyValueArray) {
                                var invoiceLineProperty = _.find(lineKeyValueArray, function (keyValuePair) {
                                    return keyValuePair[0].toUpperCase() === item.entityPropertyClientName.toUpperCase();
                                });

                                if (invoiceLineProperty) {
                                    if (invoiceLineProperty[1] && invoiceLineProperty[1] !== "") {
                                        customFieldSetting.visible = true;
                                        customFieldSetting.isVisible = true;
                                        customFieldSetting.isColumn = false;
                                        customFieldSetting.isHidden = false;
                                    }
                                }
                            });
                        }

                        vm.propertyFields.push(customFieldSetting);
                    }
                });
            }

            /*
            * Gets the value of the propertyClientName if found in the propertyNameAndValuePairs, otherwise undefined
            */
            function getPropertyValue(propertyNameAndValuePairs, propertyClientName) {
                var propertyNameAndValue = _.find(propertyNameAndValuePairs, function (keyValuePair) {
                    var propertyName = keyValuePair[0];
                    return propertyName.toUpperCase() === propertyClientName.toUpperCase();
                });

                if (!util.isNullOrUndefined(propertyNameAndValue)) {
                    return propertyNameAndValue[1];
                }

                return undefined;
            }

            /**
             * states if the field should be visible mandatory, or it can be hidden
             * All fields should be visible             
             */
            function fieldIsVisible(customFieldSetting, item) {
                customFieldSetting.visible = item.isVisible;
                if (item.isVisible) {
                    customFieldSetting.mandatory = true;
                    customFieldSetting.isHidden = false;
                    customFieldSetting.isColumn = true;
                } else {
                    customFieldSetting.mandatory = false;
                }

                return customFieldSetting;
            }

            function setFormDirty() {
                if (scope.invoiceForm) {
                    scope.invoiceForm.$setDirty();
                }
            }

            /**
             * Uses the totals calculator to get the total net amount of an individual line.
             */
            function calculateLineNet(line) {
                return invoiceTotalsCalculator.calculateLineNet(line);
            }

            /**
             * Uses the totals calculator to get the total tax of an individual line.
             */
            function calculateLineTax(line) {
                return invoiceTotalsCalculator.calculateLineTax(line);
            }

            /**
             * Calls subscribers to invoice details change
             */
            function notifyInvoiceDetailsChangeSubscribers(notificationObject) {
                for (var i = 0; i < vm.invoiceDetailsChangeSubscriptions.length; i++) {
                    vm.invoiceDetailsChangeSubscriptions[i](notificationObject);
                }
            }

            /**
             * Calls subscribers to events
             */
            function notifyEventsSubscribers(notificationObject) {
                for (var i = 0; i < vm.eventsSubscriptions.length; i++) {
                    vm.eventsSubscriptions[i](notificationObject);
                }
            }

            /**
             * Sets invoice state atributes
             */
            function setState(stateId) {
                var state = documentStateResolver.getDocumentState(stateId);
                vm.invoice.clientEInvoicingState = stateId;
                vm.selectedStates.fill(state);

                updateCurrentState(stateId);
            }

            /**
            * map the Tax exemption reason against the relevant tax breakdown category
            */
            function mapTaxExemptionReason() {
                _.each(vm.invoice.taxBreakdown, function (taxItem) {
                    if (taxItem.taxCategory && taxItem.taxCategory.toUpperCase() === "E") {
                        taxItem.taxExemptionReason = vm.invoice.taxExemptionReason;
                    }
                });
            }

            /**
             * sets page to dirty
             */
            function setDirty() {
                setFormDirty();

                documentAttributeResolver.removeAttribute(vm.selectedAttributes, CLIENT_ENUMS.documentAttribute.saved);
                documentAttributeResolver.addAttributeById(vm.selectedAttributes, CLIENT_ENUMS.documentAttribute.notSaved, false);

                updateCurrentState();
            }

            /**
             * sets page to clean
             */
            function setClean() {
                documentAttributeResolver.removeAttribute(vm.selectedAttributes, CLIENT_ENUMS.documentAttribute.notSaved);
                documentAttributeResolver.addAttributeById(vm.selectedAttributes, CLIENT_ENUMS.documentAttribute.saved, false);
                updateCurrentState();
            }

            /**
             * sets calculated state of invoice in edit mode
             */
            function updateCurrentState() {
                if (vm.mode !== 'new') {
                    documentStateResolver.calculateCurrentState('invoice', vm.invoice.clientEInvoicingState, true).then(function (state) {
                        vm.currentState = state;
                    });
                }
            }

            /**
             * Adds spinner to the page
             */
            function showSpinner() {
                if (util.isUndefined(spinner)) {
                    spinner = modalSpinner.showModalSpinner("#spinnerHolder");
                }
            }

            /**
             * Removes spinner from the page
            */
            function removeSpinner() {
                if (spinner) {
                    spinner.remove();
                    spinner = undefined;
                }
            }

            /*
             * Navigates back if possible otherwise to the invoice list
             */
            function goBack() {
                diState.goBack().catch(function () {
                    return diState.go('portal.invoices.list');
                });
            }

            /**
             * Downloads all the allowed attachments
             */
            function downloadAllAttachments() {
                var attachmentDataIds = [];

                if (attachmentDownloadValidator.allowDownloadMultipleFiles(vm.invoice.additionalDocumentReferences, attachmentDataIds)) {
                    attachmentProxy.downloadZipFile(attachmentDataIds);
                }
            }

            function setIdentifiers(forSupplier, forBuyer, forOthers, forAccounting) {
                return partyProxy.getEnabledSchemes().then(function (schemes) {
                    var identifiers = [];
                    if (forSupplier && util.isDefined(vm.supplier)) {
                        identifiers = setSupplierCodes();

                        var supplierEndpoints = identifiers[CLIENT_ENUMS.partyCodeType.endpoint] || [];

                        var schemeOptions1 = _.clone(schemes[CLIENT_ENUMS.partyCodeType.endpoint]);

                        var defaultOptions1 = getDefaultOptions(schemeOptions1, 'supplierEndpoints', 'supplierEndpointIdentifier');

                        vm.supplierEndpoints = defaultOptions1.concat(createIdentifiersForClient(supplierEndpoints));

                        setIdentifier('supplierEndpointIdentifier', vm.supplierEndpoints, vm.invoice.supplierEndpointIdentifierScheme || 'GLN', vm.invoice.supplierEndpointIdentifierSchemeId || 6, vm.invoice.supplierEndpointIdentifier, true, vm.invoice.supplierEndpointIdentifierDescription);

                        var supplierVatNumbers = identifiers[CLIENT_ENUMS.partyCodeType.taxReference] || [];

                        var schemeOptions2 = _.clone(schemes[CLIENT_ENUMS.partyCodeType.taxReference]);

                        var defaultOptions2 = getDefaultOptions(schemeOptions2, 'supplierVatNumbers', 'supplierVatNumber');

                        vm.supplierVatNumbers = defaultOptions2.concat(createIdentifiersForClient(supplierVatNumbers));

                        setIdentifier('supplierVatNumber', vm.supplierVatNumbers, vm.invoice.supplierVatNumberScheme || 'GB:VAT', vm.invoice.supplierVatNumberSchemeId || 38, vm.invoice.supplierVatNumber);

                        var schemeOptions3 = _.clone(schemes[CLIENT_ENUMS.partyCodeType.default]);

                        vm.supplierLegalCompanyReferences = getDefaultOptions(schemeOptions3, 'supplierLegalCompanyReferences', 'supplierLegalCompanyReference');

                        setIdentifier('supplierLegalCompanyReference', vm.supplierLegalCompanyReferences, vm.invoice.supplierLegalCompanyReferenceScheme || 'GLN', vm.invoice.supplierLegalCompanyReferenceSchemeId || 6, vm.invoice.supplierLegalCompanyReference);
                    }

                    if (forBuyer && util.isDefined(vm.customer)) {
                        setSupplierCodes(vm.customer);
                        vm.usingAccounting = false;

                        var justCustomerCodes = _.map(vm.customer.partyCodes, function (item) {
                            return item.code;
                        });

                        if (util.isDefined(justCustomerCodes)) {
                            identifiers = _.groupBy(justCustomerCodes, function (item) {
                                return item.partyCodeType;
                            });
                        }

                        var customerCodes = identifiers[CLIENT_ENUMS.partyCodeType.default] || [];

                        vm.customerCodes = createIdentifiersForClient(customerCodes);

                        setIdentifier('customerCode', vm.customerCodes, vm.invoice.customerCodeScheme || 'GLN', vm.invoice.customerCodeSchemeId || 6, vm.invoice.customerCode, false);

                        var buyerEndpoints = identifiers[CLIENT_ENUMS.partyCodeType.endpoint] || [];

                        var schemeOptions4 = _.clone(schemes[CLIENT_ENUMS.partyCodeType.endpoint]);

                        var defaultOptions3 = getDefaultOptions(schemeOptions4, 'buyerEndpoints', 'buyerEndpointIdentifier');

                        vm.buyerEndpoints = defaultOptions3.concat(createIdentifiersForClient(buyerEndpoints));

                        setIdentifier('buyerEndpointIdentifier', vm.buyerEndpoints, vm.invoice.buyerEndpointIdentifierScheme || 'GLN', vm.invoice.buyerEndpointIdentifierSchemeId || 6, vm.invoice.buyerEndpointIdentifier, true, vm.invoice.buyerEndpointIdentifierDescription);

                        var buyerVatNumbers = identifiers[CLIENT_ENUMS.partyCodeType.taxReference] || [];

                        var schemeOptions5 = _.clone(schemes[CLIENT_ENUMS.partyCodeType.taxReference]);

                        var defaultOptions4 = getDefaultOptions(schemeOptions5, 'buyerVatNumbers', 'customerVatNumber');

                        vm.buyerVatNumbers = defaultOptions4.concat(createIdentifiersForClient(buyerVatNumbers));

                        setIdentifier('customerVatNumber', vm.buyerVatNumbers, vm.invoice.customerVatNumberScheme || 'GB:VAT', vm.invoice.customerVatNumberSchemeId || 38, vm.invoice.customerVatNumber);

                        var schemeOptions6 = _.clone(schemes[CLIENT_ENUMS.partyCodeType.default]);

                        var defaultOptions5 = getDefaultOptions(schemeOptions6, 'deliveryLocationIdentifiers', 'deliveryLocationIdentifier');

                        vm.deliveryLocationIdentifiers = defaultOptions5;

                        setIdentifier('deliveryLocationIdentifier', vm.deliveryLocationIdentifiers, vm.invoice.deliveryLocationIdentifierScheme || 'GLN', vm.invoice.deliveryLocationIdentifierSchemeId || 6, vm.invoice.deliveryLocationIdentifier);

                        var schemeOptions7 = _.clone(schemes[CLIENT_ENUMS.partyCodeType.default]);

                        vm.buyerCustomerLegalCompanyReferences = getDefaultOptions(schemeOptions7, 'buyerCustomerLegalCompanyReferences', 'buyerCustomerLegalCompanyReference');

                        setIdentifier('buyerCustomerLegalCompanyReference', vm.buyerCustomerLegalCompanyReferences, vm.invoice.buyerCustomerLegalCompanyReferenceScheme || 'GB:VAT', vm.invoice.buyerCustomerLegalCompanyReferenceSchemeId || 38, vm.invoice.buyerCustomerLegalCompanyReference);
                    }

                    if (forAccounting && util.isDefined(vm.accountingCustomer)) {
                        setSupplierCodes(vm.customer);
                        vm.usingAccounting = true;

                        var justAccountingCustomerCodes = _.map(vm.accountingCustomer.partyCodes, function (item) {
                            return item.code;
                        });

                        if (util.isDefined(justAccountingCustomerCodes)) {
                            identifiers = _.groupBy(justAccountingCustomerCodes, function (item) {
                                return item.partyCodeType;
                            });
                        }

                        var accountingCustomerCodes = identifiers[CLIENT_ENUMS.partyCodeType.default] || [];

                        vm.customerCodes = createIdentifiersForClient(accountingCustomerCodes);

                        setIdentifier('customerCode', vm.customerCodes, vm.invoice.customerCodeScheme || 'GLN', vm.invoice.customerCodeSchemeId || 6, vm.invoice.customerCode, false);

                        var accountingCustomerEndpoints = identifiers[CLIENT_ENUMS.partyCodeType.endpoint] || [];

                        var schemeOptions11 = _.clone(schemes[CLIENT_ENUMS.partyCodeType.endpoint]);

                        var defaultOptions11 = getDefaultOptions(schemeOptions11, 'accountingCustomerEndpoints', 'accountingCustomerEndpointIdentifier');

                        vm.accountingCustomerEndpoints = defaultOptions11.concat(createIdentifiersForClient(accountingCustomerEndpoints));

                        setIdentifier('accountingCustomerEndpointIdentifier', vm.accountingCustomerEndpoints, vm.invoice.accountingCustomerEndpointIdentifierScheme || 'GLN', vm.invoice.accountingCustomerEndpointIdentifierSchemeId || 6, vm.invoice.accountingCustomerEndpointIdentifier, true, vm.invoice.accountingCustomerEndpointIdentifierDescription);

                        var accountingCustomerVatNumbers = identifiers[CLIENT_ENUMS.partyCodeType.taxReference] || [];

                        var schemeOptions12 = _.clone(schemes[CLIENT_ENUMS.partyCodeType.taxReference]);

                        var defaultOptions12 = getDefaultOptions(schemeOptions12, 'accountingCustomerVatNumbers', 'accountingCustomerVatNumber');

                        vm.accountingCustomerVatNumbers = defaultOptions12.concat(createIdentifiersForClient(accountingCustomerVatNumbers));

                        setIdentifier('accountingCustomerVatNumber', vm.accountingCustomerVatNumbers, vm.invoice.accountingCustomerVatNumberScheme || 'GB:VAT', vm.invoice.accountingCustomerVatNumberSchemeId || 38, vm.invoice.accountingCustomerVatNumber);

                        var schemeOptions13 = _.clone(schemes[CLIENT_ENUMS.partyCodeType.default]);

                        vm.accountingCustomerLegalCompanyReferences = getDefaultOptions(schemeOptions13, 'accountingCustomerLegalCompanyReferences', 'accountingCustomerLegalCompanyReference');

                        setIdentifier('accountingCustomerLegalCompanyReference', vm.accountingCustomerLegalCompanyReferences, vm.invoice.accountingCustomerLegalCompanyReferenceScheme || 'GB:VAT', vm.invoice.accountingCustomerLegalCompanyReferenceSchemeId || 38, vm.invoice.accountingCustomerLegalCompanyReference);
                    }

                    if (forOthers) {
                        vm.payeeVatNumbers = getDefaultOptions(schemes[CLIENT_ENUMS.partyCodeType.default], 'payeeVatNumbers', 'payeeVatNumber');

                        setIdentifier('payeeVatNumber', vm.payeeVatNumbers, vm.invoice.payeeVatNumberScheme || 'GLN', vm.invoice.payeeVatNumberSchemeId || 6, vm.invoice.payeeVatNumber);

                        vm.payeePartyIdentifiers = getDefaultOptions(schemes[CLIENT_ENUMS.partyCodeType.default], 'payeePartyIdentifiers', 'payeePartyIdentifier');

                        setIdentifier('payeePartyIdentifier', vm.payeePartyIdentifiers, vm.invoice.payeePartyIdentifierScheme || 'GLN', vm.invoice.payeePartyIdentifierSchemeId || 6, vm.invoice.payeePartyIdentifier);

                        vm.taxRepresentativePartyVatNumbers = getDefaultOptions(schemes[CLIENT_ENUMS.partyCodeType.taxReference], 'taxRepresentativePartyVatNumbers', 'taxRepresentativePartyVatNumber');

                        setIdentifier('taxRepresentativePartyVatNumber', vm.taxRepresentativePartyVatNumbers, vm.invoice.taxRepresentativePartyVatNumberScheme || 'GB:VAT', vm.invoice.taxRepresentativePartyVatNumberSchemeId || 38, vm.invoice.taxRepresentativePartyVatNumber);
                    }
                });

                function getDefaultOptions(schemeOptions, arrayName, validationPropertyname, allowBlank) {
                    return identifierFactory.getDefaultOptions(schemeOptions, arrayName, validationPropertyname, allowBlank, setNewItem);
                }

                function setNewItem(item, arrayName) {
                    vm[arrayName].splice(2, 0, item);
                }
            }

            function createIdentifiersForClient(fromServer) {
                var identifiers = [];

                _.each(fromServer, function (item) {
                    var scheme = partyProxy.resolveSchemeCodeFromId(item.schemeId);

                    var identifier = identifierFactory.create(scheme, item.schemeId, item.codeValue, item.description);

                    identifiers.push(identifier);
                });

                return identifiers;
            }

            function setSupplierCodes(billTo) {
                var justSupplierCodes = _.map(vm.supplier.partyCodes, function (item) {
                    return item.code;
                });

                var partyCodes = _.clone(justSupplierCodes);

                if (util.isDefined(billTo)) {
                    partyCodes = _.filter(justSupplierCodes, function (item) {
                        return item.relatedPartyId === billTo.id || util.isNullOrUndefined(item.relatedPartyId) || item.relatedPartyId <= 0;
                    });
                }

                var identifiers = _.groupBy(partyCodes, function (item) {
                    return item.partyCodeType;
                });

                var supplierCodes = identifiers[CLIENT_ENUMS.partyCodeType.default] || [];

                vm.supplierCodes = createIdentifiersForClient(supplierCodes);

                if (vm.supplierCodes.length === 0) {
                    vm.invoice.supplierCodeScheme = "";
                    vm.invoice.supplierCodeSchemeId = -1;
                    vm.invoice.supplierCode = "";
                }

                setIdentifier('supplierCode', vm.supplierCodes, vm.invoice.supplierCodeScheme || 'GLN', vm.invoice.supplierCodeSchemeId || 6, vm.invoice.supplierCode, false);

                return identifiers;
            }

            function setIdentifier(propertyName, array, scheme, schemeId, code, addToListIfNotExists, description) {
                var addIfNotExists = true;
                var selected = false;

                if (util.isDefined(addToListIfNotExists) && !addToListIfNotExists) {
                    addIfNotExists = false;
                }

                var temp = identifierFactory.create(scheme, schemeId, code, description);

                if (validateIdentifier(temp)) {
                    var existing = _.find(array, function (item) {
                        return item.identifier === temp['identifier'];
                    });

                    if (util.isDefined(existing)) {
                        setIdentifier(existing);
                        selected = true;
                    } else if (util.isUndefined(existing) && addIfNotExists) {
                        array.splice(2, 0, temp);
                        setIdentifier(temp);
                        selected = true;
                    }
                }

                if (!selected) {
                    var single = _.filter(array, function (item) {
                        return util.isNonEmptyString(item.code);
                    });

                    if (util.isDefined(single) && single.length === 1) {
                        setIdentifier(single[0]);
                        selected = true;
                    }
                }

                if (!selected) {
                    setIdentifier(array[0]);
                }

                return;

                function setIdentifier(item) {
                    if (util.isDefined(item)) {
                        vm[propertyName] = item;

                        if (validateIdentifier(item)) {
                            //vm.invoice[propertyName] = item.code;
                            //vm.invoice[propertyName + 'Scheme'] = item.scheme;
                            //vm.invoice[propertyName + 'SchemeId'] = item.schemeId;
                        }
                    } else {
                        vm[propertyName] = undefined;

                        // vm.invoice[propertyName] = undefined;
                        //vm.invoice[propertyName + 'Scheme'] = undefined;
                        //vm.invoice[propertyName + 'SchemeId'] = undefined;
                    }
                }

                function validateIdentifier(identifier) {
                    return util.isNonEmptyString(identifier.code);
                }
            }
        }

        return InvoiceController;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 396 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP0E}
// di.einvoicing.ui.portal.portal.invoices.editor
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var guard = $di.exception.guard;

		module.provider('invoiceDetailsButtonsConfigurator', InvoiceDetailsButtonsConfiguratorProvider);

		/**
   * Manages invoice editor configuration and set up.
   */
		function InvoiceDetailsButtonsConfiguratorProvider() {
			var config;

			var buttonsConfiguration = {};

			// Provider definition
			var provider = {
				configure: configure,
				$get: $get
			};

			provider.$get.$inject = ['authorizedObjectsFilter', 'CLIENT_ENUMS'];

			return provider;

			/**
    * Configure the service
    * @param cfg
    */
			function configure(cfg) {
				guard.throwIfNotAnObject('EUP2H01E', cfg, 'cfg');

				config = cfg;
			}

			/**
    * Gets required configuration for the grid.
    */
			function $get(authorizedObjectsFilter, clientEnums) {

				buttonsConfiguration = {
					type: 'Invoice',
					visibleButtons: [],
					buttonsSetOne: [{
						rights: ['InvoiceReader'],
						name: 'view',
						action: clientEnums.userActions.viewInvoice,
						attributesRequired: ['saved']
					}, {
						rights: ['Supplier'],
						name: 'cancelInvoice',
						action: clientEnums.userActions.cancelInvoice,
						attributesRequired: ['saved']
					}, {
						rights: ['InvoiceReader'],
						name: 'issues',
						action: clientEnums.userActions.showIssues
					}],
					buttonsSetTwo: [{
						rights: ['InvoiceReader'],
						name: 'render',
						action: clientEnums.userActions.downloadInvoice,
						attributesRequired: ['saved']
					}, {
						rights: ['Supplier'],
						action: clientEnums.userActions.viewHistoryInvoice,
						attributesRequired: ['saved'],
						name: 'viewHistory'
					}, {
						rights: ['User'],
						name: 'related',
						action: clientEnums.userActions.viewRelatedDocumentsInvoice,
						attributesRequired: ['saved']
					}],
					buttonsSetThree: [{
						rights: ['Supplier', 'InvoiceWriter'],
						name: 'deleteInvoice',
						action: clientEnums.userActions.remove,
						attributesRequired: ['hasServerId']
					}, {
						rights: ['InvoiceWriter'],
						name: 'saveInvoice',
						action: clientEnums.userActions.commit,
						attributesRequired: ['notSaved', 'justFlipped'],
						anyAttribute: true
					}, {
						rights: ['InvoiceWriter'],
						name: 'submit',
						action: clientEnums.userActions.submit,
						attributesRequired: ['saved']
					}],
					buttonsSetFour: [{
						rights: ['InvoiceWriter'],
						name: 'saveInvoice',
						action: clientEnums.userActions.commit,
						attributesRequired: ['notSaved', 'justFlipped'],
						anyAttribute: true
					}, {
						rights: ['InvoiceWriter'],
						name: 'submit',
						action: clientEnums.userActions.submit,
						attributesRequired: ['saved']
					}]
				};

				return {
					getButtonsOneConfiguration: getButtonsOneConfiguration,
					getButtonsTwoConfiguration: getButtonsTwoConfiguration,
					getButtonsThreeConfiguration: getButtonsThreeConfiguration,
					getButtonsFourConfiguration: getButtonsFourConfiguration
				};

				function getButtonsOneConfiguration() {
					return getConfiguration(buttonsConfiguration.buttonsSetOne);
				}

				function getButtonsTwoConfiguration() {
					return getConfiguration(buttonsConfiguration.buttonsSetTwo);
				}

				function getButtonsThreeConfiguration() {
					return getConfiguration(buttonsConfiguration.buttonsSetThree);
				}

				function getButtonsFourConfiguration() {
					return getConfiguration(buttonsConfiguration.buttonsSetFour);
				}

				function getConfiguration(array) {
					var configuration = {
						type: 'Invoice',
						visibleButtons: []
					};
					configuration.visibleButtons.fill(authorizedObjectsFilter.getAuthorizedObjects(array, true));

					return configuration;
				}
			}
		}

		return InvoiceDetailsButtonsConfiguratorProvider;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 397 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP1E}
// di.einvoicing.ui.portal.portal.invoices.editor
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_) {
	'use strict';

	return function (module) {
		var guard = $di.exception.guard;
		var util = $di.utility.util;

		module.factory('invoiceTotalsCalculator', invoiceTotalsCalculator);

		function invoiceTotalsCalculator() {
			var taxDetails = [];

			return {
				calculate: calculate,
				calculateLineNet: calculateLineNet,
				calculateTaxForLine: calculateTaxForLine,
				calculateAllowancesCharges: calculateAllowancesCharges
			};

			/**
   * Calculates the totals for the current invoice
   */
			function calculate(invoice, totals) {
				var lines = invoice.lines;

				totals.totalTax = 0;
				totals.totalIncludingTax = 0;
				totals.total = 0;
				totals.payableAmount = 0;
				totals.beforeTax = 0;
				totals.prepaidAmount = invoice.prepaidAmount ? parseFloat(invoice.prepaidAmount) : 0;
				totals.totalLines = 0;
				totals.totalCharges = 0;
				totals.totalAllowances = 0;
				totals.taxBreakdown = {};

				getTaxDataFromLines();

				var linesTaxBreakdown = calculateLinesPerTaxCategory(lines);

				_.each(linesTaxBreakdown, function (taxAmount) {
					totals.beforeTax += taxAmount.taxableAmount;
					totals.totalTax += taxAmount.taxAmount;
				});

				recalculateTax(lines);

				totals.totalLines = totals.beforeTax;

				calculateAllowancesCharges(invoice.allowancesCharges, totals);

				var allowancesChargesTaxBreakdown = calculateAllowancesChargesPerTaxCode(invoice.allowancesCharges);

				totals.totalIncludingTax = totals.beforeTax + totals.totalTax;

				totals.total = totals.beforeTax + totals.totalTax;

				totals.taxBreakdown = combineBreakTaxBreakdowns(linesTaxBreakdown, allowancesChargesTaxBreakdown);
				totals.beforeTax = round(totals.beforeTax, 2);
				totals.payableAmount = totals.total - totals.prepaidAmount;

				if (totals.payableAmount < 0) {
					totals.payableAmount = 0;
				}

				return;

				/**
     * Builds up tax array from lines
     */
				function getTaxDataFromLines() {
					_.each(lines, function (line) {
						line.netAmount = calculateLinePrice(line.unitPrice, line.quantity, line.allowanceAmount, line.chargeAmount, sanitizePriceBaseQuantity(line.priceBaseQuantity));
						if (util.isUndefined(taxDetails[line.taxCode])) {
							taxDetails[line.taxCategory] = {
								taxRate: line.taxRate,
								taxCode: line.taxCode,
								taxCategory: line.taxCategory
							};
						}
					});
				}
			}

			/**
    * Combines the lines and allowancesCharges tax breakdowns:
    * sums all shared tax codes, and assigns and new taxCodes
    * returns a single version
    */
			function combineBreakTaxBreakdowns(linesTaxBreakdown, allowancesChargesTaxBreakdown) {
				for (var lineTaxCategory in linesTaxBreakdown) {
					if (!linesTaxBreakdown.hasOwnProperty(lineTaxCategory)) continue;

					if (lineTaxCategory === 'undefined') {
						delete linesTaxBreakdown.undefined;
						continue;
					}

					for (var acTaxCategory in allowancesChargesTaxBreakdown) {
						if (!allowancesChargesTaxBreakdown.hasOwnProperty(acTaxCategory)) {
							continue;
						}

						if (acTaxCategory === 'undefined') {
							delete allowancesChargesTaxBreakdown.undefined;
							continue;
						}

						if (acTaxCategory === lineTaxCategory) {
							linesTaxBreakdown[lineTaxCategory].taxAmount += allowancesChargesTaxBreakdown[lineTaxCategory].taxAmount;
							linesTaxBreakdown[lineTaxCategory].taxableAmount += allowancesChargesTaxBreakdown[lineTaxCategory].taxableAmount;
						} else if (!linesTaxBreakdown.hasOwnProperty(acTaxCategory)) {
							linesTaxBreakdown[acTaxCategory] = allowancesChargesTaxBreakdown[acTaxCategory];
						}
					}
				}
				return linesTaxBreakdown;
			}

			function calculateAllowancesCharges(allowancesCharges, totals) {
				_.each(allowancesCharges, function (ac) {
					if (util.isUndefined(taxDetails[ac.taxCategory])) {
						taxDetails[ac.taxCategory] = {
							taxRate: ac.taxRate,
							taxCode: ac.taxCode,
							taxCategory: ac.taxCategory
						};
					}
					ac.taxAmount = 0;

					if (isNaN(ac.netAmount)) {
						return;
					}
					ac.taxAmount = round(netAmountChanged(ac, ac.netAmount), 2);

					var roundedAllowanceChargeNetAmount = round(parseFloat(ac.netAmount), 2);
					var roundedAllowanceChargeTotalAmount = roundedAllowanceChargeNetAmount + ac.taxAmount;
					ac.amount = roundedAllowanceChargeTotalAmount;

					if (ac.isCharge === true) {
						totals.totalCharges = parseFloat(totals.totalCharges) + roundedAllowanceChargeNetAmount;
						totals.beforeTax = parseFloat(totals.beforeTax) + roundedAllowanceChargeNetAmount;
						totals.total = parseFloat(totals.total) + roundedAllowanceChargeTotalAmount;
						totals.totalTax = parseFloat(totals.totalTax) + parseFloat(ac.taxAmount);
					} else {
						totals.totalAllowances = parseFloat(totals.totalAllowances) + roundedAllowanceChargeNetAmount;
						totals.beforeTax = parseFloat(totals.beforeTax) - roundedAllowanceChargeNetAmount;
						totals.total = parseFloat(totals.total) - roundedAllowanceChargeTotalAmount;
						totals.totalTax = parseFloat(totals.totalTax) - parseFloat(ac.taxAmount);
					}
				});
				return;
			}

			/**
    * recalculates taxes per line to add missing pennies after rounding
    * @param {} lines
    * @returns {}
    */
			function recalculateTax(lines) {
				var sumExact = 0;
				var sumRounded = 0;

				_.each(lines, function (line) {
					if (line.quantity == undefined || line.taxCodeId == undefined || line.unitPrice == undefined) {
						line.taxAmount = undefined;
						return;
					}
					if (line.quantity > 0) {
						var amount = calculateTaxForLine(line);

						line.taxAmount = round(amount, 2);
						sumExact += amount;
						sumRounded += line.taxAmount;
					} else {
						line.taxAmount = 0;
					}
				});

				var sumExactRounded = round(sumExact, 2);
			}

			/**
    * rounds to specified number of decimal places
    * @param {} value
    * @param {} exp
    * @returns {}
    */
			function round(value, exp) {
				if (typeof exp === 'undefined' || +exp === 0) return Math.round(value);

				value = +value;
				exp = +exp;

				if (isNaN(value) || !(exp % 1 === 0)) return NaN;

				// Shift
				value = value.toString().split('e');
				value = Math.round(+(value[0] + 'e' + (value[1] ? +value[1] + exp : exp)));

				// Shift back
				value = value.toString().split('e');
				return +(value[0] + 'e' + (value[1] ? +value[1] - exp : -exp));
			}

			/**
    * Ensures that the object has all necessary values to perform a calculation
    * @param line
    */
			function isValidLine(line) {
				if (line && line.unitPrice && line.quantity) {
					return true;
				}

				return false;
			}

			/**
    * Reduces an invoice line to a specific value using a provided formula for the running total.
    * @param lines
    * @param formula
    */
			function performCalculation(lines, formula) {
				var result = lines.reduce(function (total, current) {
					if (isValidLine(current)) {
						return total + formula(current.unitPrice, current.quantity, current.taxCategory, current.allowanceAmount, current.chargeAmount);
					} else {
						return total;
					}
				}, 0);

				return result;
			}

			/**
    * Callback function which calculates the tax for the specified price quantity and tax percentage
    * @param price
    * @param quantity
    * @param tax
    */
			function calculateLineTax(price, quantity, taxCategory, allowanceAmount, chargeAmount, priceBaseQuantity) {
				var taxRate = 0;
				if (util.isDefined(taxDetails[taxCategory]) && util.isDefined(taxDetails[taxCategory].taxRate)) {
					taxRate = taxDetails[taxCategory].taxRate;
				} else {
					return 0;
				}

				var taxRatio = taxRate / 100;

				return calculateLinePrice(price, quantity, allowanceAmount, chargeAmount, priceBaseQuantity) * taxRatio;
			}

			/**
    * Calculates the cost of a line with the specified price and quantity
    * @param price
    * @param quantity
    */
			function calculateLinePrice(price, quantity, allowanceAmount, chargeAmount, priceBaseQuantity) {
				var totalPrice = price / sanitizePriceBaseQuantity(priceBaseQuantity) * quantity;

				if (allowanceAmount && allowanceAmount >= 0) {
					totalPrice = parseFloat(totalPrice) - parseFloat(allowanceAmount);
				}

				if (chargeAmount && chargeAmount >= 0) {
					totalPrice = parseFloat(totalPrice) + parseFloat(chargeAmount);
				}

				return totalPrice;
			}

			/**
    * Calculates the net cost of the specified invoice line
    * @param line
    */
			function calculateLineNet(line) {
				if (!isValidLine(line)) {
					return 0;
				}

				return calculateLinePrice(line.unitPrice, line.quantity, line.allowanceAmount, line.chargeAmount, sanitizePriceBaseQuantity(line.priceBaseQuantity));
			}

			/**
    * Calculates the amount of tax payable on the specified line
    * @param line
    */
			function calculateTaxForLine(line) {
				if (!isValidLine(line)) {
					return 0;
				}

				return calculateLineTax(line.unitPrice, line.quantity, line.taxCategory, line.allowanceAmount, line.chargeAmount, sanitizePriceBaseQuantity(line.priceBaseQuantity));
			}

			/**
    * Breaks the invoice lines down by tax category and returns an object with the totals
    * stored with a key of the tax code
    * @param lines
    */
			function calculateLinesPerTaxCategory(lines) {
				var taxCatTotals = {};
				var groupedByTaxCategory = groupByTaxCategory(lines);

				_.each(groupedByTaxCategory, function (lines, taxCategory) {
					var taxCategoryDetails = taxDetails[taxCategory];

					var breakdownForTaxCat = {
						taxCode: taxCategoryDetails.taxCode,
						taxAmount: 0,
						taxableAmount: 0,
						taxCategory: taxCategoryDetails.taxCategory,
						taxRate: taxCategoryDetails.taxRate
					};

					_.each(lines, function (line) {
						if (isValidLine(line)) {
							breakdownForTaxCat.taxAmount += round(calculateLineTax(line.unitPrice, line.quantity, line.taxCategory, line.allowanceAmount, line.chargeAmount, sanitizePriceBaseQuantity(line.priceBaseQuantity)), 2);
							breakdownForTaxCat.taxableAmount += round(calculateLinePrice(line.unitPrice, line.quantity, line.allowanceAmount, line.chargeAmount, sanitizePriceBaseQuantity(line.priceBaseQuantity)), 2);
						}
					});

					taxCatTotals[taxCategory] = breakdownForTaxCat;
				});

				return taxCatTotals;
			}

			/**
    * Breaks the allowances & charges down by tax code and returns an object with the totals
    * stored with a key of the tax code
    * @param allowancesCharges
    */
			function calculateAllowancesChargesPerTaxCode(allowancesCharges) {
				var taxCatTotals = {};

				var groupedByTaxCategory = groupByTaxCategory(allowancesCharges);

				_.each(groupedByTaxCategory, function (allowancesCharges, taxCategory) {
					var taxCatDetails = taxDetails[taxCategory];

					var allowanceChargeBreakdown = {
						taxCode: taxCatDetails.taxCode,
						taxCategory: taxCatDetails.taxCategory,
						taxRate: taxCatDetails.taxRate,
						taxAmount: 0,
						taxableAmount: 0
					};

					_.each(allowancesCharges, function (ac) {
						var roundedNetAmount = round(ac.netAmount, 2);

						if (ac.isCharge === true) {
							allowanceChargeBreakdown.taxAmount += ac.taxAmount;
							allowanceChargeBreakdown.taxableAmount += roundedNetAmount;
						} else {
							allowanceChargeBreakdown.taxAmount -= ac.taxAmount;
							allowanceChargeBreakdown.taxableAmount -= roundedNetAmount;
						}
					});

					taxCatTotals[taxCategory] = allowanceChargeBreakdown;
				});

				return taxCatTotals;
			}

			function groupByTaxCategory(items) {

				return _.groupBy(items, function (item) {
					return item.taxCategory;
				});
			}

			function netAmountChanged(item, amount) {

				var taxAmount = 0;
				if (item.taxRate > 0) {
					var taxRatio = item.taxRate / 100;
					taxAmount = Math.round(amount * taxRatio * 10000) / 10000;
					var result = parseFloat(amount) + parseFloat(taxAmount);
					item.amount = Math.round(result * 10000) / 10000;
				} else {
					item.amount = amount;
				}
				return taxAmount;
			}

			function sanitizePriceBaseQuantity(priceBaseQuantity) {
				var sanitized = priceBaseQuantity > 0 ? priceBaseQuantity : 1.0;
				return sanitized;
			}
		}

		return invoiceTotalsCalculator;
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 398 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP8L}
// di.einvoicing.ui.portal.components.locationselector
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(399)], __WEBPACK_AMD_DEFINE_RESULT__ = function (locationSelectorComponentModule) {
    'use strict';

    return function (module) {
        module.component(locationSelectorComponentModule.LocationSelectorComponent.selector, locationSelectorComponentModule.LocationSelectorComponent);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 399 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LocationSelectorComponent = exports.LocationSelectorComponent = {
  templateUrl: 'src/app/portal/invoices/editor/location-selector/location-selector.component.html',
  selector: 'diLocationSelector',
  bindings: {
    partyId: '<',
    locationType: '@',
    preDeterminedLocation: '<',
    onLocationSelected: '&'
  },
  controller: function () {
    function controller(partyProxy, clientEnums) {
      _classCallCheck(this, controller);

      this.partyProxy = partyProxy;
      this.clientEnums = clientEnums;

      this.selectedPartyLocation = {};
      this.partyLocations = [];
      this.onLocationChanged = this.onLocationChanged.bind(this);
    }

    _createClass(controller, [{
      key: '$onInit',
      value: function $onInit() {
        this.getPartyLocations();
      }
    }, {
      key: '$onChanges',
      value: function $onChanges() {
        this.getPartyLocations();
      }
    }, {
      key: 'getPartyLocations',
      value: function getPartyLocations() {
        var _this = this;

        if (this.partyId === 0 || this.partyId === null || 'undefined' === typeof this.partyId) {
          return;
        }

        this.partyProxy.getLocationsForParty(this.partyId, this.locationType).then(function (data) {
          var locationsData = data;

          if ("undefined" !== typeof locationsData) {
            _this.partyLocations = locationsData;
          } else {
            return;
          }

          if (_this.preDeterminedLocation !== null && 'undefined' !== typeof _this.preDeterminedLocation) {

            var preDeterminedFound = getPredeterminedLocationFromList(_this.partyLocations, _this.preDeterminedLocation, _this.selectedPartyLocation);

            _this.selectedPartyLocation = setSelectedLocation(_this.partyLocations, _this.selectedPartyLocation, preDeterminedFound, _this.preDeterminedLocation);
          }
        });

        function getPredeterminedLocationFromList(partyLocations, preDeterminedLocation, selectedPartyLocation) {
          _.each(partyLocations, function (partyLocation) {
            if (partyLocation.addressLine1 === preDeterminedLocation.addressLine1 && partyLocation.addressLine2 === preDeterminedLocation.addressLine2 && partyLocation.town === preDeterminedLocation.addressTown && partyLocation.county === preDeterminedLocation.county && partyLocation.postalCode === preDeterminedLocation.postCode) {

              return partyLocation;
            }
          });
        }

        function setSelectedLocation(partyLocations, selectedPartyLocation, preDeterminedFound, preDeterminedLocation) {
          if ('undefined' !== typeof preDeterminedFound) {
            partyLocations.push(preDeterminedLocation);
            return preDeterminedLocation;
          } else {
            return preDeterminedLocation;
          }
        }
      }
    }, {
      key: 'onLocationChanged',
      value: function onLocationChanged(selectedLocation) {
        this.onLocationSelected({ value: selectedLocation });
      }
    }]);

    return controller;
  }()
};

LocationSelectorComponent.controller.prototype.constructor.$inject = ['partyProxy', 'CLIENT_ENUMS'];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP40}
// di.einvoicing.ui.portal.proxies
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
				'use strict';

				return function (module) {
								var guard = $di.exception.guard;
								var util = $di.utility.util;

								module.factory('invoiceProxy', invoiceProxy);

								invoiceProxy.$inject = ['webApiHttp', '$q', 'invoiceFormatter', 'CLIENT_ENUMS', 'enumTranslator', 'urlHelper', 'proxyErrorInterceptor'];

								function invoiceProxy(http, $q, invoiceFormatter, clientEnums, enumTranslator, urlHelper, proxyErrorInterceptor) {
												var defaultFailureReason = 'EINVOICING.PORTAL.PROXIES.INVOICE.DEFAULT_ERROR';

												return {
																getById: getById,
																getDetailsById: getDetailsById,
																getDetailsByAuditId: getDetailsByAuditId,
																getByInvoiceNumber: getByInvoiceNumber,
																getDetailsByInvoiceNumber: getDetailsByInvoiceNumber,
																commitInvoice: commitInvoice,
																flagInDisputeInvoice: flagInDisputeInvoice,
																voidInvoice: voidInvoice,
																flagPaidInvoice: flagPaidInvoice,
																flagAsScheduledForPayment: flagAsScheduledForPayment,
																getInvoices: getInvoices,
																submitInvoiceByDocumentId: submitInvoiceByDocumentId,
																getInvoiceDocumentIssues: getInvoiceDocumentIssues,
																testForInvoiceDocumentIssues: testForInvoiceDocumentIssues,
																releaseInvoice: releaseInvoice,
																releaseInvoices: releaseInvoices,
																deleteInvoice: deleteInvoice,
																getVisiblePropertyFieldsForBuyer: getVisiblePropertyFieldsForBuyer,
																getAllowedActions: getAllowedActions
												};

												/**
            * Gets the invoice with the specified ID from the web API
            * @param id
            */
												function getById(id) {
																var requestUrl = 'Invoice/GetById/' + id;

																var promise = http.get(requestUrl);

																var newPromise = promise.then(invoiceFormatter.reformatServerInvoiceForClient, errorReceivingInvoice);

																return newPromise;
												}

												function getDetailsById(id) {
																guard.throwIfInvalidId("EUP400HE", id, 'id');

																var requestUrl = 'Invoice/GetDetailsById/' + id;

																var promise = http.get(requestUrl);

																var newPromise = promise.then(invoiceFormatter.reformatServerInvoiceDetailsForClient, errorReceivingInvoice);

																return newPromise;
												}

												function getDetailsByAuditId(id) {
																guard.throwIfInvalidId("EUP4001E", id, 'id');

																var requestUrl = 'Invoice/GetDetailsByAuditId/' + id;

																var promise = http.get(requestUrl);

																var newPromise = promise.then(invoiceFormatter.reformatServerInvoiceDetailsForClient, errorReceivingInvoice);

																return newPromise;
												}

												/**
            * Gets the invoice with the specified invoice number from the web API
            * @param number
            */
												function getDetailsByInvoiceNumber(number) {
																guard.throwIfEmptyString("EUP4003E", number, 'number');

																var requestParams = {
																				invoiceNumber: number
																};

																var requestUrl = urlHelper.setParameters('Invoice/GetDetailsByInvoiceNumber', requestParams);

																var promise = http.get(requestUrl);

																var newPromise = promise.then(invoiceFormatter.reformatServerInvoiceDetailsForClient, errorReceivingInvoice);

																return newPromise;
												}

												/**
            * Gets the invoice with the specified invoice number from the web API
            * @param number
            */
												function getByInvoiceNumber(number) {
																guard.throwIfEmptyString("EUP4003E", number, 'number');

																var requestParams = {
																				invoiceNumber: number
																};

																var requestUrl = urlHelper.setParameters('Invoice/GetByInvoiceNumber', requestParams);

																var promise = http.get(requestUrl);

																var newPromise = promise.then(invoiceFormatter.reformatServerInvoiceForClient, errorReceivingInvoice);

																return newPromise;
												}

												/**
             * Gets a collection of field names and if they are default visible or not based on the buyer 
             * @param {} buyerPartyId 
             * @returns {} 
             */
												function getVisiblePropertyFieldsForBuyer(buyerPartyId) {
																guard.throwIfZeroOrNegative("EUP400IE", buyerPartyId, 'buyerPartyId');
																guard.throwIfNotANumber("EUP400JE", buyerPartyId, 'buyerPartyId');

																var requestParams = {
																				buyerPartyId: buyerPartyId
																};

																var requestUrl = urlHelper.setParameters('Invoice/GetVisiblePropertyFieldsForBuyer', requestParams);

																var promise = http.get(requestUrl);

																var newPromise = promise.then(resolved, error);

																return newPromise;

																function resolved(data) {
																				return data;
																}

																function error(errordata) {
																				return errordata;
																}
												}

												/**
            * Commits the specified invoice to the web API
            * @param invoice
            */
												function commitInvoice(invoice) {
																guard.throwIfNotAnObject("EUP4002E", invoice, 'invoice');

																var reformattedInvoice = invoiceFormatter.reformatClientInvoiceForServer(invoice);

																var promise = http.post('Invoice/CommitInvoice', reformattedInvoice);

																var newPromise = promise.then(resolved, rejected);

																return newPromise;

																function resolved(data) {
																				return data;
																}

																function rejected(error) {
																				return errorProcessingInvoice(error, 'EINVOICING.PORTAL.PROXIES.INVOICE.SAVE_ERROR');
																}
												}

												function flagInDisputeInvoice(id, reason, inDispute) {
																guard.throwIfInvalidId("EUP400DE", id, 'id');

																var requestParams;

																reason = 'not implemented';

																var url = 'Invoice/FlagAsInDisputeInvoice';

																if (util.isDefined(inDispute) && inDispute === false) {
																				url = 'Invoice/FlagAsNotInDisputeInvoice';

																				requestParams = {
																								id: id
																				};
																} else {
																				guard.throwIfEmptyString("EUP400GE", reason, 'reason');

																				requestParams = {
																								id: id,
																								reason: reason
																				};
																}

																var requestUrl = urlHelper.setParameters(url, requestParams);

																var promise = http.post(requestUrl);

																var newPromise = promise.then(resolved, rejected);

																return newPromise;

																function resolved(data) {
																				return data;
																}

																function rejected(error) {
																				var message = 'EINVOICING.PORTAL.PROXIES.INVOICE.END_DISPUTE_ERROR';

																				if (inDispute) {
																								message = 'EINVOICING.PORTAL.PROXIES.INVOICE.START_DISPUTE_ERROR';
																				}

																				return errorProcessingInvoice(error, message);
																}
												}

												function voidInvoice(id) {
																guard.throwIfInvalidId("EUP400DE", id, 'id');

																var requestParams = {
																				id: id
																};

																var requestUrl = urlHelper.setParameters('Invoice/VoidInvoice', requestParams);

																var promise = http.post(requestUrl);

																var newPromise = promise.then(resolved, rejected);

																return newPromise;

																function resolved(data) {
																				return data;
																}

																function rejected(error) {
																				return errorProcessingInvoice(error, 'EINVOICING.PORTAL.PROXIES.INVOICE.VOID_ERROR');
																}
												}

												function flagPaidInvoice(id, isPaid) {
																guard.throwIfInvalidId("EUP400DE", id, 'id');

																var requestParams = {
																				id: id
																};

																var url = 'Invoice/FlagPaidInvoice';
																if (util.isDefined(isPaid) && isPaid === false) {
																				url = 'Invoice/FlagUnPaidInvoice';
																}

																var requestUrl = urlHelper.setParameters(url, requestParams);

																var promise = http.post(requestUrl);

																var newPromise = promise.then(resolved, rejected);

																return newPromise;

																function resolved(data) {
																				return data;
																}

																function rejected(error) {
																				var message = 'EINVOICING.PORTAL.PROXIES.INVOICE.FLAG_PAID_ERROR';

																				if (isPaid === false) {
																								message = 'EINVOICING.PORTAL.PROXIES.INVOICE.FLAG_NOTPAID_ERROR';
																				}

																				return errorProcessingInvoice(error, message);
																}
												}

												function flagAsScheduledForPayment(id, scheduled) {
																guard.throwIfInvalidId("EUP400DE", id, 'id');

																var requestParams = {
																				id: id
																};

																var url = 'Invoice/FlagAsScheduledForPayment';

																if (util.isDefined(scheduled) && scheduled === false) {
																				url = 'Invoice/FlagAsNotScheduledForPayment';
																}

																var requestUrl = urlHelper.setParameters(url, requestParams);

																var promise = http.post(requestUrl);

																var newPromise = promise.then(resolved, rejected);

																return newPromise;

																function resolved(data) {
																				return data;
																}

																function rejected(error) {
																				var message = 'EINVOICING.PORTAL.PROXIES.INVOICE.FLAG_SCHEDULEDPAID_ERROR';

																				if (scheduled === false) {
																								message = 'EINVOICING.PORTAL.PROXIES.INVOICE.FLAG_NOT_SCHEDULEDPAID_ERROR';
																				}
																				return errorProcessingInvoice(error, message);
																}
												}

												/**
             * Get invoices from the database
             */
												function getInvoices(searchText, lastNRows, dateType, dateTimeFilters, customDateTimeFilter, sortOption, statusOption) {
																guard.throwIfNotANumber("EUP4006E", lastNRows, "lastNRows");
																guard.throwIfInvalidId("EUP400AE", dateType, "dateType");
																guard.throwIfNullOrUndefined("EUP4007E", dateTimeFilters, "dateTimeFilters");
																guard.throwIfInvalidId("EUP4008E", sortOption, "sortOption");
																guard.throwIfInvalidId("EUP400BE", statusOption, "statusOption");

																if (!customDateTimeFilter) {
																				customDateTimeFilter = {
																								fromDate: new Date(),
																								toDate: new Date()
																				};
																}

																var requestedParams = {
																				lastNRows: lastNRows,
																				dateType: dateType,
																				dateTimeFilterOption: dateTimeFilters.toString(),
																				fromDate: JSON.stringify(customDateTimeFilter.fromDate).replace(/"/g, ""),
																				toDate: JSON.stringify(customDateTimeFilter.toDate).replace(/"/g, ""),
																				sortOption: sortOption,
																				statusOption: statusOption
																};

																if (util.isNonEmptyString(searchText)) {
																				requestedParams.searchText = searchText;
																}

																var requestedUrl = urlHelper.setParameters('Invoice/GetInvoiceSearchResults', requestedParams);

																var promise = http.get(requestedUrl).then(resolve, reject);

																return promise;

																function resolve(data) {
																				return data;
																}

																function reject(error) {
																				return errorProcessingInvoice(error, 'EINVOICING.PORTAL.PROXIES.INVOICE.RECEIVE_ERROR');
																}
												}

												/**
             * Function which gets the failure details for an invoice
             * 
             * @param invoiceId - The ID of the invoice to retrieve failure details for
             * @returns - Promise which resolves to the failure details for the invoice 
             */
												function getInvoiceDocumentIssues(invoiceId) {
																var requestParams = {
																				invoiceId: invoiceId
																};

																var requestedUrl = urlHelper.setParameters('Invoice/GetInvoiceDocumentIssues/', requestParams);

																var promise = http.get(requestedUrl);

																return promise;
												}

												/**
            * tests the invoice for any issues
            * @param invoice
            */
												function testForInvoiceDocumentIssues(invoice) {
																guard.throwIfNotAnObject("EUP4002E", invoice, 'invoice');

																var reformattedInvoice = invoiceFormatter.reformatClientInvoiceForServer(invoice);

																var promise = http.post('Invoice/TestForInvoiceDocumentIssues', reformattedInvoice);

																return promise;
												}

												/**
             * Submits the invoice with the given document id (flag for export and sending)
             * @param id
             */
												function submitInvoiceByDocumentId(id) {
																guard.throwIfInvalidId("EUP4009E", id, 'id');

																var promise = http.post('Invoice/SubmitInvoiceByDocumentId', id);

																var newPromise = promise.then(resolved, rejected);

																return newPromise;

																function resolved(data) {
																				return data;
																}

																function rejected(error) {
																				return errorProcessingInvoice(error, 'EINVOICING.PORTAL.PROXIES.INVOICE.SUBMIT_ERROR');
																}
												}

												/**
             * Calls web api to release mismatched single invoice			
             */
												function releaseInvoice(id, reference) {
																guard.throwIfInvalidId("EUP400KE", id, 'id');

																var ids = [];

																ids.push(id);

																return releaseInvoices(ids, reference);
												}

												/**
             * Calls web api to release mismatched invoices			
             */
												function releaseInvoices(ids, reference) {
																guard.throwIfEmptyArray("EUP400EE", ids, 'ids');

																var requestParams = {
																				ids: ids
																};

																var requestUrl = urlHelper.setParameters('Invoice/ReleaseInvoices', requestParams);

																var promise = http.post(requestUrl);

																var newPromise = promise.then(releaseResolved, releaseRejected);

																return newPromise;

																function releaseResolved(data) {
																				return data;
																}

																function releaseRejected(error) {
																				var errorMsg = 'EINVOICING.PORTAL.PROXIES.INVOICE.RELEASE_MULTI_ERROR';
																				if (util.isNonEmptyString(reference)) {
																								errorMsg = 'EINVOICING.PORTAL.PROXIES.INVOICE.RELEASE_ERROR';
																				}

																				return errorProcessingInvoice(error, errorMsg);
																}
												}

												/**
             * Marks invoice as deleted			 
             */
												function deleteInvoice(id) {
																guard.throwIfInvalidId("EUP400FE", id, 'id');

																var requestParams = {
																				id: id
																};

																var requestUrl = urlHelper.setParameters('Invoice/RemoveInvoice', requestParams);

																var promise = http.post(requestUrl);

																var newPromise = promise.then(resolved, rejected);

																return newPromise;

																function resolved(data) {
																				return data;
																}

																function rejected(error) {
																				return errorProcessingInvoice(error, 'EINVOICING.PORTAL.PROXIES.INVOICE.DELETE_ERROR');
																}
												}

												/**
             * Loads allowed actions for invoice
             */
												function getAllowedActions(id) {
																guard.throwIfInvalidId("EUP4009E", id, 'id');

																var requestUrl = 'Invoice/GetActionsAllowed/' + id;

																var promise = http.get(requestUrl);

																var newPromise = promise.then(resolved, rejected);

																return newPromise;

																function resolved(data) {
																				return data;
																}

																function rejected(error) {
																				return errorProcessingInvoice(error, 'EINVOICING.PORTAL.PROXIES.INVOICE.ACTIONS_ERROR');
																}
												}

												/**
            * Callback function executed when an error occurs whilst receiving invoice(s)			
            */
												function errorReceivingInvoice(error) {
																return errorProcessingInvoice(error, 'EINVOICING.PORTAL.PROXIES.INVOICE.RECEIVE_ERROR');
												}

												/**
            * Callback function executed when an error occurs processing the invoice			
            */
												function errorProcessingInvoice(error, failureReason) {
																proxyErrorInterceptor.handleError(error, failureReason, defaultFailureReason);
																return $q.reject(error);
												}
								}

								return invoiceProxy;
				};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 401 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP66}
// di.einvoicing.ui.portal.portal.invoices
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var guard = $di.exception.guard;

		module.factory('invoiceRepository', invoiceRepository);

		invoiceRepository.$inject = ['invoiceProxy', '$q', 'notificationHandler'];

		/**
   * Repository for methods on invoice		
   */
		function invoiceRepository(invoiceProxy, $q, notificationHandler) {
			return {
				getInvoices: getInvoices,
				flagInDisputeInvoice: flagInDisputeInvoice,
				voidInvoice: voidInvoice,
				flagPaidInvoice: flagPaidInvoice,
				flagAsScheduledForPayment: flagAsScheduledForPayment,
				submitInvoiceByDocumentId: submitInvoiceByDocumentId,
				releaseInvoice: releaseInvoice,
				releaseInvoices: releaseInvoices,
				deleteInvoice: deleteInvoice,
				getIndex: getIndex,
				getAllowedActions: getAllowedActions
			};

			function getInvoices(searchText, lastNRows, dateType, dateTimeFilters, customDateTimeFilter, sortOption, statusOption) {
				var promise = invoiceProxy.getInvoices(searchText, lastNRows, dateType, dateTimeFilters, customDateTimeFilter, sortOption, statusOption).then(resolved, rejected);

				return promise;

				function resolved(data) {
					return data;
				}

				function rejected(error) {
					return rejectWithErrorNotification(error, '');
				}
			}

			/**
    * Dispute invoice			
    */
			function flagInDisputeInvoice(id, reason, inDispute, reference) {
				guard.throwIfInvalidId("EUP6608E", id, 'id');

				var promise = invoiceProxy.flagInDisputeInvoice(id, reason, inDispute).then(resolved, rejected);

				return promise;

				function resolved(data) {
					var message = "EINVOICING.PORTAL.INVOICES.ACTIONS.NOTIFICATION.SUCCESS.DISPUTE";
					if (!inDispute) {
						message = "EINVOICING.PORTAL.INVOICES.ACTIONS.NOTIFICATION.SUCCESS.NOTDISPUTE";
					}

					displaySuccessNotification(message, reference);
					return data;
				}

				function rejected(error) {
					return rejectWithErrorNotification(error, reference);
				}
			}

			/**
    * Void invoice			
    */
			function voidInvoice(id, reference) {
				guard.throwIfInvalidId("EUP6604E", id, 'id');

				var promise = invoiceProxy.voidInvoice(id).then(resolved, rejected);

				return promise;

				function resolved(data) {
					displaySuccessNotification("EINVOICING.PORTAL.INVOICES.ACTIONS.NOTIFICATION.SUCCESS.VOID", reference);
					return data;
				}

				function rejected(error) {
					return rejectWithErrorNotification(error, reference);
				}
			}

			/**
    * mark as paid or unpaid invoice			
    */
			function flagPaidInvoice(id, isPaid, reference) {
				guard.throwIfInvalidId("EUP6603E", id, 'id');

				var promise = invoiceProxy.flagPaidInvoice(id, isPaid).then(resolved, rejected);

				return promise;

				function resolved(data) {
					var message = "EINVOICING.PORTAL.INVOICES.ACTIONS.NOTIFICATION.SUCCESS.PAID";
					if (!isPaid) {
						message = "EINVOICING.PORTAL.INVOICES.ACTIONS.NOTIFICATION.SUCCESS.NOTPAID";
					}

					displaySuccessNotification(message, reference);
					return data;
				}

				function rejected(error) {
					return rejectWithErrorNotification(error, reference);
				}
			}

			/**
    * Mark as scheduled or not scheduled for payment invoice			
    */
			function flagAsScheduledForPayment(id, isScheduled, reference) {
				guard.throwIfInvalidId("EUP6602E", id, 'id');

				var promise = invoiceProxy.flagAsScheduledForPayment(id, isScheduled, reference).then(resolved, rejected);

				return promise;

				function resolved(data) {
					var message = "EINVOICING.PORTAL.INVOICES.ACTIONS.NOTIFICATION.SUCCESS.SCHEDULED";
					if (!isScheduled) {
						message = "EINVOICING.PORTAL.INVOICES.ACTIONS.NOTIFICATION.SUCCESS.NOTSCHEDULED";
					}

					displaySuccessNotification(message, reference);

					return data;
				}

				function rejected(error) {
					return rejectWithErrorNotification(error, reference);
				}
			}

			/**
    * Submit invoice by document id			 
    */
			function submitInvoiceByDocumentId(id, reference) {
				guard.throwIfInvalidId("EUP6605E", id, 'id');

				var promise = invoiceProxy.submitInvoiceByDocumentId(id).then(resolved, rejected);

				return promise;

				function resolved(data) {
					displaySuccessNotification("EINVOICING.PORTAL.INVOICES.ACTIONS.NOTIFICATION.SUCCESS.SUBMIT", reference);
					return data;
				}

				function rejected(error) {
					if (error.response.responseText === 'SERVCONNEX') {
						return displayWarningNotification("EINVOICING.PORTAL.INVOICES.ACTIONS.NOTIFICATION.WARNING.SERVER_CONNECTION", reference);
					}
					return rejectWithErrorNotification(error, reference);
				}
			}

			/**
   * Releases mismatched single invoice			 
   */
			function releaseInvoice(id, reference) {
				guard.throwIfInvalidId("EUP660DE", id, 'id');

				var ids = [];

				ids.push(id);

				return releaseInvoices(ids, reference);
			}

			/**
    * Releases mismatched invoices			 
    */
			function releaseInvoices(ids, reference) {
				guard.throwIfEmptyArray("EUP660AE", ids, 'ids');

				var promise = invoiceProxy.releaseInvoices(ids, reference).then(resolved, rejected);

				return promise;

				function resolved(data) {
					return data;
				}

				function rejected(error) {
					return rejectWithErrorNotification(error, reference);
				}
			}

			/**
    * marks invoice as deleted			 
    */
			function deleteInvoice(id, reference) {
				guard.throwIfInvalidId("EUP660BE", id, 'id');

				var promise = invoiceProxy.deleteInvoice(id).then(resolved, rejected);

				return promise;

				function resolved(data) {
					displaySuccessNotification("EINVOICING.PORTAL.INVOICES.ACTIONS.NOTIFICATION.SUCCESS.DELETED", reference);
					return data;
				}

				function rejected(error) {
					return rejectWithErrorNotification(error, reference);
				}
			}

			/**
    * find the array index of an object with a specific key value			
    */
			function getIndex(array, keyName, keyValue) {
				return _.findIndex(array, function (item) {
					return item[keyName] === keyValue;
				});
			}

			function getAllowedActions(id, reference) {
				guard.throwIfInvalidId("EUP660CE", id, 'id');

				var promise = invoiceProxy.getAllowedActions(id).then(resolved, rejected);

				return promise;

				function resolved(data) {
					return data;
				}

				function rejected(error) {
					return rejectWithErrorNotification(error, reference);
				}
			}

			/**
    * rejects promise and displays error notification			
    */
			function rejectWithErrorNotification(error, reference) {
				notificationHandler.showError(error.failureReason, reference);
				return $q.reject(error).catch(function () {});
			}

			/**
    * displays success notification			 
    */
			function displaySuccessNotification(message, reference) {
				notificationHandler.showSuccess(message, reference);
			}

			function displayWarningNotification(warning, reference) {
				notificationHandler.showWarning(warning, reference);
			}
		}

		return invoiceRepository;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 402 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP3F}
// di.einvoicing.ui.portal.portal.invoices.lists.components
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(403), __webpack_require__(404)], __WEBPACK_AMD_DEFINE_RESULT__ = function (snippetsLoader, invoiceListDirectiveLoader) {
	'use strict';

	return function (module) {
		snippetsLoader(module);
		invoiceListDirectiveLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 403 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP3D}
// di.einvoicing.ui.portal.portal.invoices.lists.components.snippets
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var snippetContext = $di.angular.snippetRegistrar.createContext(module, 'src/app/portal/invoices/lists/_components/_snippets');

        snippetContext.registerSnippet('diInvoicesSearch', 'invoicesSearch.html');
        snippetContext.registerSnippet('diInvoicesActionButtons', 'invoicesActionButtons.html');
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 404 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP5B}
// di.einvoicing.ui.portal.portal.invoices.lists
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ng) {
    'use strict';

    return function (module) {
        module.directive('diInvoiceList', diInvoiceList);

        function diInvoiceList() {
            return {
                restrict: 'E',
                replace: true,
                scope: {},
                controller: "InvoiceListController",
                controllerAs: "invoiceListCtrl",
                templateUrl: 'src/app/portal/invoices/lists/_components/invoiceList/invoiceList.html',
                link: link
            };

            function link(scope) {
                scope.findElement = findElement;

                return;

                function findElement(name) {
                    return ng.element(name);
                }
            }
        }

        return diInvoiceList;
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 405 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP5P}
// di.einvoicing.ui.portal.portal.invoices.lists
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(402), __webpack_require__(407), __webpack_require__(406)], __WEBPACK_AMD_DEFINE_RESULT__ = function (componentsLoader, invoiceListControllerLoader, invoiceListConfiguratorLoader) {
	'use strict';

	return function (module) {
		componentsLoader(module);
		invoiceListConfiguratorLoader(module);
		invoiceListControllerLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 406 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP2H}
// di.einvoicing.ui.portal.portal.invoices.lists
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var guard = $di.exception.guard;
		var util = $di.utility.util;

		module.provider('invoiceListConfigurator', InvoiceListConfiguratorProvider);

		/**
   * Manages invoice list configuration and set up.
   */
		function InvoiceListConfiguratorProvider() {
			var config = {};

			var buttonsConfiguration = {};

			// Grid columns configuration
			var columnDefinitions = [{
				rights: ['Supplier'],
				field: 'invoiceNumber',
				nameLanguageKey: 'EINVOICING.PORTAL.INVOICES.LISTS.COLUMN_HEADERS.INVOICE_NUMBER_SUPPLIER',
				template: '<span>{{binding.invoiceNumber}}</span>'

			}, {
				rights: ['Buyer'],
				field: 'invoiceNumber',
				nameLanguageKey: 'EINVOICING.PORTAL.INVOICES.LISTS.COLUMN_HEADERS.INVOICE_NUMBER_BUYER',
				template: '<span>{{binding.invoiceNumber}}</span>'
			}, {
				rights: ['Supplier'],
				field: 'orderNumber',
				nameLanguageKey: 'EINVOICING.PORTAL.INVOICES.LISTS.COLUMN_HEADERS.ORDER_NUMBER_SUPPLIER',
				template: '<span ng-if="binding.orderId > 0"><a ui-sref="portal.orders.viewById({{\'{id : binding.orderId}\'}})">{{binding.orderNumber}}</a></span><span ng-if="binding.orderId == 0">{{binding.orderNumber}}</span>',
				cellClass: 'wordWrap'
			}, {
				rights: ['Buyer'],
				field: 'orderNumber',
				nameLanguageKey: 'EINVOICING.PORTAL.INVOICES.LISTS.COLUMN_HEADERS.ORDER_NUMBER_BUYER',
				template: '<span ng-if="binding.orderId > 0"><a ui-sref="portal.orders.viewById({{\'{id : binding.orderId}\'}})">{{binding.orderNumber}}</a></span><span ng-if="binding.orderId == 0">{{binding.orderNumber}}</span>',
				cellClass: 'wordWrap'
			}, {
				rights: ['Supplier', 'Buyer'],
				field: 'createdDateTime',
				nameLanguageKey: 'EINVOICING.PORTAL.INVOICES.LISTS.COLUMN_HEADERS.CREATED_DATE',
				template: '<span>{{ binding.createdDateTime  | diDate }}</span>',
				cellClass: 'centeredcell'
			}, {
				rights: ['Supplier', 'Buyer'],
				field: 'issuedDateTime',
				nameLanguageKey: 'EINVOICING.PORTAL.INVOICES.LISTS.COLUMN_HEADERS.ISSUED_DATE',
				template: '<span>{{ binding.issuedDateTime | diDate }}</span>',
				cellClass: 'centeredcell'
			}, {
				rights: ['Supplier', 'Buyer'],
				field: 'paymentDueDateTime',
				nameLanguageKey: 'EINVOICING.PORTAL.INVOICES.LISTS.COLUMN_HEADERS.PAYMENT_DUE_DATE',
				template: '<span>{{ binding.paymentDueDateTime | diDate }}</span>',
				cellClass: 'centeredcell'
			}, {
				rights: ['Buyer'],
				field: 'supplier',
				nameLanguageKey: 'EINVOICING.PORTAL.INVOICES.LISTS.COLUMN_HEADERS.BILL_FROM',
				template: '<div class="tooltip-wrap">\
									<span class="text-ellipsis">{{binding.supplier}}</span>\
									<div ng-if="(binding.supplier || \'\').length >= 35"\
										ng-class="((binding.supplier || \'\').length > 70) ? [\'tooltip\', \'tooltip-multiline\'] : \'tooltip\'">\
										<span>\
											{{ ::binding.supplier }}\
										</span>\
									</div>\
								</div>',
				cellClass: 'max-width-300'
			}, {
				rights: ['Supplier'],
				field: 'customer',
				nameLanguageKey: 'EINVOICING.PORTAL.INVOICES.LISTS.COLUMN_HEADERS.BILL_TO',
				template: '<div class="tooltip-wrap">\
									<span class="text-ellipsis">{{binding.customer}}</span>\
									<div ng-if="(binding.customer || \'\').length >= 35"\
										ng-class="((binding.customer || \'\').length > 70) ? [\'tooltip\', \'tooltip-multiline\'] : \'tooltip\'">\
										<span>\
											{{ ::binding.customer }}\
										</span>\
									</div>\
								</div>',
				cellClass: 'max-width-300'
			}, {
				rights: ['Supplier', 'Buyer'],
				field: 'totalLines',
				nameLanguageKey: 'EINVOICING.PORTAL.INVOICES.LISTS.COLUMN_HEADERS.LINES',
				template: '<span>{{ binding.totalLines }}</span>',
				cellClass: 'centeredcell'
			}, {
				rights: ['Supplier', 'Buyer'],
				field: 'tax',
				nameLanguageKey: 'EINVOICING.PORTAL.INVOICES.LISTS.COLUMN_HEADERS.TAX',
				template: '<span>{{binding.tax | diCurrency:binding.currencyId}}</span>',
				cellClass: 'numericcell'
			}, {
				rights: ['Supplier', 'Buyer'],
				field: 'total',
				nameLanguageKey: 'EINVOICING.PORTAL.INVOICES.LISTS.COLUMN_HEADERS.TOTAL',
				template: '<span>{{binding.total | diCurrency:binding.currencyId}}</span>',
				cellClass: 'numericcell'
			}, {
				rights: ['Supplier', 'Buyer'],
				field: 'calculatedState',
				nameLanguageKey: 'EINVOICING.PORTAL.INVOICES.LISTS.COLUMN_HEADERS.STATE',
				template: '<span>{{binding.calculatedState}}</span>',
				cellClass: 'centeredcell'
			}, {
				rights: ['Supplier', 'Buyer'],
				field: 'attachment',
				nameLanguageKey: '',
				template: '<div class="icon-16px" ng-if="binding.attachmentCount > 0"><di-image image="attachment" image-colour="button"></di-image></div>',
				cellClass: 'centeredcell'
			}, {
				rights: ['Admin'],
				field: 'documentStateKey',
				nameLanguageKey: 'STATE KEY',
				template: '<span>{{binding.documentStateKey}}</span>',
				cellClass: 'centeredcell'
			}, {
				rights: ['Supplier'],
				field: 'updated',
				nameLanguageKey: '',
				template: '<div class="document-updated" ng-if="binding.updated" di-translate="EINVOICING.PORTAL.INVOICES.LISTS.UPDATED"></div>',
				cellClass: 'centeredcell'
			}];

			// Status filters configuration
			var statusFilters = [];

			var dateTimeDefaultFilters = [{
				value: "Last30Days",
				label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.DATE.LAST_30_DAYS",
				dateTypes: [1, 2, 3]
			}, {
				value: "LastMonth",
				label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.DATE.LAST_MONTH",
				dateTypes: [1, 2, 3]
			}, {
				value: "ThisMonth",
				label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.DATE.THIS_MONTH",
				dateTypes: [1, 2, 3]
			}, {
				value: "Yesterday",
				label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.DATE.YESTERDAY",
				dateTypes: [1, 2, 3]
			}, {
				value: "Today",
				label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.DATE.TODAY",
				dateTypes: [1, 2, 3]
			}, {
				value: "Custom",
				label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.DATE.CUSTOM",
				isHidden: true,
				dateTypes: [1, 2, 3]
			}, {
				value: "Tomorrow",
				label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.DATE.TOMORROW",
				dateTypes: [3]
			}, {
				value: "NextMonth",
				label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.DATE.NEXT_MONTH",
				dateTypes: [3]
			}, {
				value: "Next30Days",
				label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.DATE.NEXT_30_DAYS",
				dateTypes: [3]
			}];

			var dateTypesOptions = [{ value: 1, label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.DATE.TYPES.CREATED" }, { value: 2, label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.DATE.TYPES.ISSUED" }, { value: 3, label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.DATE.TYPES.PAYMENT_DUE" }];

			var sortOptions = [{
				rights: ['User'],
				value: 1,
				label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.SORT.INVOICE_NUMBER_ASC"
			}, {
				rights: ['User'],
				value: 2,
				label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.SORT.INVOICE_NUMBER_DESC"
			}, {
				rights: ['Supplier'],
				value: 11,
				label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.SORT.ORDER_NUMBER_SUPPLIER_ASC"
			}, {
				rights: ['Buyer'],
				value: 11,
				label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.SORT.ORDER_NUMBER_BUYER_ASC"
			}, {
				rights: ['Supplier'],
				value: 12,
				label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.SORT.ORDER_NUMBER_SUPPLIER_DESC"
			}, {
				rights: ['Buyer'],
				value: 12,
				label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.SORT.ORDER_NUMBER_BUYER_DESC"
			}, {
				rights: ['User'],
				value: 3,
				label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.SORT.CREATED_DATE_ASC"
			}, {
				rights: ['User'],
				value: 4,
				label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.SORT.CREATED_DATE_DESC"
			}, {
				rights: ['User'],
				value: 5,
				label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.SORT.ISSUE_DATE_ASC"
			}, {
				rights: ['User'],
				value: 6,
				label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.SORT.ISSUE_DATE_DESC"
			}, {
				rights: ['User'],
				value: 7,
				label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.SORT.PAYMENT_DUE_DATE_ASC"
			}, {
				rights: ['User'],
				value: 8,
				label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.SORT.PAYMENT_DUE_DATE_DESC"
			}, {
				rights: ['Supplier'],
				value: 13,
				label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.SORT.BILL_TO_ASC"
			}, {
				rights: ['Supplier'],
				value: 14,
				label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.SORT.BILL_TO_DESC"
			}, {
				rights: ['Buyer'],
				value: 15,
				label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.SORT.BILL_FROM_ASC"
			}, {
				rights: ['Buyer'],
				value: 16,
				label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.SORT.BILL_FROM_DESC"
			}, {
				rights: ['User'],
				value: 17,
				label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.SORT.LINES_ASC"
			}, {
				rights: ['User'],
				value: 18,
				label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.SORT.LINES_DESC"
			}, {
				rights: ['User'],
				value: 19,
				label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.SORT.TAX_ASC"
			}, {
				rights: ['User'],
				value: 20,
				label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.SORT.TAX_DESC"
			}, {
				rights: ['User'],
				value: 9,
				label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.SORT.TOTAL_INC_TAX_ASC"
			}, {
				rights: ['User'],
				value: 10,
				label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.SORT.TOTAL_INC_TAX_DESC"
			}, {
				rights: ['User'],
				value: 21,
				label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.SORT.STATE_ASC"
			}, {
				rights: ['User'],
				value: 22,
				label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.SORT.STATE_DESC"
			}];

			var initialStatusFilter;
			var initialDateTimeFilter;
			var initialDateType;
			var initialSortOption;

			// Provider definition
			var provider = {
				configure: configure,
				$get: $get
			};

			provider.$get.$inject = ['authorizedObjectsFilter', 'CLIENT_ENUMS'];

			return provider;

			function getOptionByValue(filterItems, value) {
				var filterItem = _.find(filterItems, function (obj) {
					return obj.value === value;
				});

				return filterItem;
			}

			/**
    * Configure the service
    * @param cfg
    */
			function configure(cfg) {
				guard.throwIfNotAnObject("EUP2H01E", cfg, 'cfg');

				config = cfg;
			}

			/**
    * Gets required configuration for the grid.
    */
			function $get(authorizedObjectsFilter, clientEnums) {
				statusFilters = [{
					rights: ['Buyer'],
					order: 1,
					value: clientEnums.documentStateKey.unknown,
					label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.ALL_BUYER"
				}, {
					rights: ['Supplier'],
					order: 1,
					value: clientEnums.documentStateKey.unknown,
					label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.ALL_SUPPLIER"
				}, {
					rights: ['Supplier'],
					order: 2,
					value: clientEnums.documentStateKey.invalid,
					label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.STATE.INVALID"
				}, {
					rights: ['Supplier'],
					order: 3,
					value: clientEnums.documentStateKey.invalidDraft,
					label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.STATE.INVALID_DRAFT"
				}, {
					rights: ['Supplier'],
					order: 4,
					value: clientEnums.documentStateKey.pending,
					label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.STATE.PENDING"
				}, {
					rights: ['Buyer'],
					order: 5,
					value: clientEnums.documentStateKey.sentreceived,
					label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.STATE.SENTRECEIVED_BUYER"
				}, {
					rights: ['Supplier'],
					order: 6,
					value: clientEnums.documentStateKey.sentreceived,
					label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.STATE.SENTRECEIVED_SUPPLIER"
				}, {
					rights: ['Supplier'],
					order: 7,
					value: clientEnums.documentStateKey.sendFailed,
					label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.STATE.SEND_FAILED_SUPPLIER"
				}, {
					rights: ['Buyer'],
					order: 7,
					value: clientEnums.documentStateKey.scheduled,
					label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.STATE.SCHEDULED_FOR_PAYMENT"
				}, {
					rights: ['User'],
					order: 9,
					value: clientEnums.documentStateKey.overdue,
					label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.STATE.OVERDUE"
				}, {
					rights: ['Buyer'],
					order: 8,
					value: clientEnums.documentStateKey.paymentSent,
					label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.STATE.PAYMENT_SENT_BUYER"
				}, {
					rights: ['Supplier'],
					order: 8,
					value: clientEnums.documentStateKey.paymentSent,
					label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.STATE.PAYMENT_SENT_SUPPLIER"
				}, {
					rights: ['Buyer'],
					order: 9,
					value: clientEnums.documentStateKey.paymentReceived,
					label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.STATE.PAYMENT_RECEIVED_BUYER"
				}, {
					rights: ['Supplier'],
					order: 9,
					value: clientEnums.documentStateKey.paymentReceived,
					label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.STATE.PAYMENT_RECEIVED_SUPPLIER"
				}, {
					rights: ['Buyer'],
					order: 10,
					value: clientEnums.documentStateKey.inDispute,
					label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.STATE.INDISPUTE_BUYER"
				}, {
					rights: ['Supplier'],
					order: 10,
					value: clientEnums.documentStateKey.inDispute,
					label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.STATE.INDISPUTE_SUPPLIER"
				}, {
					rights: ['User'],
					order: 11,
					value: clientEnums.documentStateKey.reconciliationInvalid,
					label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.STATE.RECONCILIATIONINVALID"
				}, {
					rights: ['Supplier'],
					order: 12,
					value: clientEnums.documentStateKey.exportFailed,
					label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.STATE.EXPORT_FAILED"
				}, {
					rights: ['Buyer'],
					order: 13,
					value: clientEnums.documentStateKey.cancelled,
					label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.STATE.CANCELLED_BUYER"
				}, {
					rights: ['Supplier'],
					order: 14,
					value: clientEnums.documentStateKey.cancelled,
					label: "EINVOICING.PORTAL.INVOICES.LISTS.FILTERS.STATE.CANCELLED_SUPPLIER"
				}];

				buttonsConfiguration = {
					type: "Invoice",
					visibleButtons: [],
					buttonsSetOne: [{
						rights: ["InvoiceWriter", "Supplier"],
						name: 'edit',
						action: clientEnums.userActions.editInvoice,
						singleAction: true
					}, {
						rights: ["InvoiceReader"],
						name: 'view',
						action: clientEnums.userActions.viewInvoice,
						singleAction: true
					}, {
						rights: ["InvoiceWriter", "Supplier"],
						name: 'submitSmall',
						action: clientEnums.userActions.submit
					}, {
						rights: ["Buyer", "InvoiceReader"],
						name: 'dispute',
						action: clientEnums.userActions.startDispute
					}, {
						rights: ["Buyer", "InvoiceReader"],
						name: 'notDispute',
						action: clientEnums.userActions.endDispute
					}, {
						rights: ["Supplier"],
						name: 'cancelInvoice',
						action: clientEnums.userActions.cancelInvoice
					}, {
						rights: ["Buyer"],
						name: 'paid',
						action: clientEnums.userActions.markAsPaidBuyer
					}, {
						rights: ["Buyer"],
						name: 'notPaid',
						action: clientEnums.userActions.markAsNotPaidBuyer
					}, {
						rights: ["Supplier"],
						name: 'paid',
						action: clientEnums.userActions.markAsPaidSupplier
					}, {
						rights: ["Supplier"],
						name: 'notPaid',
						action: clientEnums.userActions.markAsNotPaidSupplier
					}, {
						rights: ["Buyer"],
						name: 'scheduled',
						action: clientEnums.userActions.markAsScheduledForPayment
					}, {
						rights: ["Buyer"],
						name: 'notScheduled',
						action: clientEnums.userActions.markAsNotScheduledForPayment
					}, {
						rights: ["Buyer"],
						name: 'release',
						action: clientEnums.userActions.release
					}, {
						rights: ["Supplier", "InvoiceWriter"],
						name: 'deleteSmall',
						action: clientEnums.userActions.remove
					}],
					buttonsSetTwo: [{
						rights: ["InvoiceReader"],
						name: 'render',
						action: clientEnums.userActions.downloadInvoice,
						singleAction: true
					}, {
						rights: ["InvoiceReader"],
						name: 'related',
						action: clientEnums.userActions.viewRelatedDocumentsInvoice,
						singleAction: true
					}]
				};

				initialStatusFilter = getOptionByValue(statusFilters, clientEnums.documentStateKey.unknown);
				initialDateType = getOptionByValue(dateTypesOptions, 1);
				initialDateTimeFilter = getOptionByValue(dateTimeDefaultFilters, 'Last30Days');
				initialSortOption = getOptionByValue(sortOptions, 6);

				return {
					getTableConfiguration: getTableConfiguration,
					getStatusFilters: getStatusFilters,
					getDateTimeFilters: getDateTimeFilters,
					getDateTypesOptions: getDateTypesOptions,
					getSortableColumns: getSortableColumns,
					getButtonsSetOneConfiguration: getButtonsSetOneConfiguration,
					getButtonsSetTwoConfiguration: getButtonsSetTwoConfiguration,
					getInitialFilter: getInitialFilter,
					getInitialDateTimeFilter: getInitialDateTimeFilter,
					getInitialDateType: getInitialDateType,
					getInitialSortOption: getInitialSortOption,
					getInitialStatusFilter: getInitialStatusFilter,
					getFreeformSearchDefaultFilter: getFreeformSearchDefaultFilter
				};

				/**
     * Gets initial set of all filters.
     */
				function getInitialFilter() {
					var initialFilters = [];

					initialFilters.push(initialStatusFilter);

					initialFilters.push(initialDateTimeFilter);

					return initialFilters;
				}

				/**
     * Gets initial set of status filters.
     */
				function getInitialStatusFilter() {
					return initialStatusFilter;
				}

				/**
     * Gets initial set of date time filters.
     */
				function getInitialDateTimeFilter(dateTypeId) {
					if (util.isDefined(dateTypeId) && dateTypeId === 3) {
						initialDateTimeFilter = getOptionByValue(dateTimeDefaultFilters, 'Next30Days');
					} else {
						initialDateTimeFilter = getOptionByValue(dateTimeDefaultFilters, 'Last30Days');
					}
					return initialDateTimeFilter;
				}

				/**
     * gets initial date type option
     */
				function getInitialDateType() {
					return initialDateType;
				}

				/**
     * Gets grid configuration options.
     */
				function getTableConfiguration() {
					config.columns = authorizedObjectsFilter.getAuthorizedObjects(columnDefinitions, false);

					return config;
				}

				/**
     * Returns buttons configuration				 
     */
				function getButtonsSetOneConfiguration() {
					return getConfiguration(buttonsConfiguration.buttonsSetOne);
				}

				function getButtonsSetTwoConfiguration() {
					return getConfiguration(buttonsConfiguration.buttonsSetTwo);
				}

				function getConfiguration(array) {
					authorizedObjectsFilter.requireRights(true);

					var configuration = {
						type: "Invoice",
						visibleButtons: []
					};
					configuration.visibleButtons.fill(authorizedObjectsFilter.getAuthorizedObjects(array, true));
					return configuration;
				}

				/**
     * Gets status filters
     */
				function getStatusFilters() {
					authorizedObjectsFilter.requireRights(false);
					var options = authorizedObjectsFilter.getAuthorizedObjects(statusFilters, false);
					return options;
				}

				/**
     * Gets date time default filters for the grid.
     */
				function getDateTimeFilters(dateTypeId) {
					var filters = dateTimeDefaultFilters;

					if (util.isDefined(dateTypeId)) {

						filters = _.filter(dateTimeDefaultFilters, function (filter) {
							return _.contains(filter.dateTypes, dateTypeId);
						});
					}

					return filters;
				}

				/**
     * gets list of available date types                     
     */
				function getDateTypesOptions() {
					return dateTypesOptions;
				}

				/**
     * Gets the column intially used to sort the grid results
     */
				function getInitialSortOption() {
					return initialSortOption;
				}

				/**
     * Gets the columns which can be used to sort the grid
     */
				function getSortableColumns() {
					authorizedObjectsFilter.requireRights(true);
					var options = authorizedObjectsFilter.getAuthorizedObjects(sortOptions, true);
					return options;
				}

				/**
     * Gets the filter to use when filtering triggered by freeform search box
     */
				function getFreeformSearchDefaultFilter() {
					return {
						statusFilter: getOptionByValue(getStatusFilters(), clientEnums.documentStateKey.unknown).value, //all
						sortOption: getOptionByValue(getSortableColumns(), 1).value, //invoice number asc
						dateType: getOptionByValue(getDateTypesOptions(), 1).value, //created
						dateTimeFilter: getOptionByValue(getDateTimeFilters(), "Custom").value,
						fromDate: moment.utc([1900, 0, 1]).format(), // months, hours, minutes, seconds, and milliseconds are all zero indexed
						toDate: moment.utc().format()
					};
				}
			}
		}

		return InvoiceListConfiguratorProvider;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 407 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP2H}
// di.einvoicing.ui.portal.portal.invoices.lists
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.controller('InvoiceListController', InvoiceListController);

		InvoiceListController.$inject = ['diState', 'translator', 'notificationHandler', 'invoiceListConfigurator', '$scope', 'elementNotifier', 'CLIENT_ENUMS', 'enumTranslator', 'currencyCache', 'authorizedObjectsFilter', 'authenticationData', 'documentStateResolver', 'userRightsRepository', 'documentAttributeResolver', 'invoiceRepository', 'documentProxy', '$stateParams', 'vmFiltersListConfigurator', 'userActionsResolver', 'modalSpinner', 'documentDownloader', 'invoiceActionVerifier', 'dateFormatter', 'listsParamsStore'];

		/**
   * Manages and configure invoice list grid.
   */
		function InvoiceListController(diState, translator, notificationHandler, invoiceListConfigurator, scope, elementNotifier, clientEnums, enumTranslator, currencyCache, authorizedObjectsFilter, authenticationData, documentStateResolver, userRightsRepository, documentAttributeResolver, invoiceRepository, documentProxy, stateParams, vmFiltersListConfigurator, userActionsResolver, modalSpinner, documentDownloader, invoiceActionVerifier, dateFormatter, listsParamsStore) {

			var vm = this;
			vm.loading = true;
			var resultsReachedNotification;
			vm.tableOptions = {};
			vm.buttonsSetOneOptions = {};
			vm.buttonsSetTwoOptions = {};
			vm.selectedFilters = {
				searchText: ""
			};
			vm.labels = {};
			vm.invoices = [];
			vm.selectedStates = [];
			vm.selectedActions = [];
			vm.selectedAttributes = [];
			vm.selectedItemsCount = 0;
			vm.sortOptions = [];
			vm.statusOptions = [];
			vm.dateOptions = [];
			vm.dateTypes = [];
			vm.userCanEditInvoices = false;
			vm.filterInvoices = filterInvoices;
			vm.searchInvoices = searchInvoices;

			vm.goToInvoice = goToInvoice;
			vm.viewInvoice = viewInvoice;

			vm.submitInvoices = submitInvoices;
			vm.changeInvoicesDisputeFlag = changeInvoicesDisputeFlag;
			vm.voidInvoices = voidInvoices;
			vm.changeInvoicePaidStates = changeInvoicePaidStates;
			vm.flagAsScheduledForPayments = flagAsScheduledForPayments;
			vm.downloadRenderedInvoice = downloadRenderedInvoice;
			vm.releaseInvoices = releaseInvoices;
			vm.deleteInvoices = deleteInvoices;
			vm.goToRelated = goToRelated;
			vm.clearFilters = clearFilters;

			vm.orderChanged = orderChanged;
			vm.statusChanged = statusChanged;
			vm.dateChanged = dateChanged;
			vm.dateTypeChanged = dateTypeChanged;
			vm.onSelectedChanged = onSelectedChanged;
			vm.onPageSizeChanged = onPageSizeChanged;
			vm.onPageNumberChanged = onPageNumberChanged;
			var spinner;
			initialiseInvoicesGrid();

			return;

			/**
    * Initialises the invoices grid by configuring it and getting initial set of data.
    */
			function initialiseInvoicesGrid() {
				setLabels();
				vmFiltersListConfigurator.configure(stateParams, vm, invoiceListConfigurator);
				vm.userCanEditInvoices = userHasWriteRight();

				translateColumnHeaders();

				currencyCache.getCurrencies().then(function () {
					getInvoices();
				});

				return;

				/**
     * sets labels values depending on user rights
     */
				function setLabels() {
					var data = [{
						rights: ["Supplier"],
						key: "title",
						label: "EINVOICING.PORTAL.INVOICES.LISTS.HEADER.TITLE_SUPPLIER"
					}, {
						key: "title",
						rights: ["Buyer"],
						label: "EINVOICING.PORTAL.INVOICES.LISTS.HEADER.TITLE_BUYER"
					}];

					vm.labels = authorizedObjectsFilter.getAuthorizedObjectsAsAssociative(data, 'key', 'label');
				}

				/**
     * Translates each column header on the grid.
     */
				function translateColumnHeaders() {
					translator.whenReady().then(function () {
						_.each(vm.tableOptions.columns, function (column) {
							column.name = translator.instantTranslate(column.nameLanguageKey);
						});
					});
				}
			}

			/*
    * Triggers the navigation to a new state with free form search applied
    * Filtering using the text search should ignore the set filters and use less restrictive filters
    */
			function searchInvoices() {
				var filters = _.extend({}, vm.searchDefaultFilter || {}, { searchText: vm.selectedFilters.searchText });
				filterInvoices(filters);
			}

			/**
    * Triggers the navigation to a new state with applied filters
    */
			function filterInvoices(filterOptions) {
				vm.loading = true;
				var params = util.isRealObject(filterOptions) ? filterOptions : {
					dateType: vm.selectedFilters.dateType.value,
					dateTimeFilter: vm.selectedFilters.dateTimeFilter.value,
					statusFilter: vm.selectedFilters.statusFilter.value,
					sortOption: vm.selectedFilters.sortOption.value,
					fromDate: dateFormatter.toServerDate(vm.selectedFilters.customDateTimeFilter.fromDate),
					toDate: dateFormatter.toServerDate(vm.selectedFilters.customDateTimeFilter.toDate),
					searchText: vm.selectedFilters.searchText
				};
				//reset page number for each filtering
				params = setInitialPaginationDetails(params);

				//save current filters to local storage before navigating away
				storeParams(params);
				diState.go('.', params, { reload: true });
			}

			/**
    * Starts the loading spinner and calls the invoice repository to retrieve the invoices
    */
			function getInvoices() {
				if (util.isDefined(resultsReachedNotification)) {
					resultsReachedNotification.hide();
				}
				showSpinner();

				var customDateTimeFilter = null;

				if (vm.selectedFilters.customDateTimeFilter.fromDate !== "" && vm.selectedFilters.customDateTimeFilter.toDate !== "") {
					customDateTimeFilter = {
						fromDate: dateFormatter.toServerDate(vm.selectedFilters.customDateTimeFilter.fromDate),
						toDate: dateFormatter.toServerDate(vm.selectedFilters.customDateTimeFilter.toDate)
					};
				}

				invoiceRepository.getInvoices(vm.selectedFilters.searchText, vm.tableOptions.maxItemsToShow, vm.selectedFilters.dateType.value, vm.selectedFilters.dateTimeFilter.value, customDateTimeFilter, vm.selectedFilters.sortOption.value, vm.selectedFilters.statusFilter.value).then(resolved, rejected).finally(function () {
					vm.loading = false;
				});

				return;

				function resolved(data) {
					if (util.isUndefined(data)) {
						data = [];
					}

					if (data.length >= vm.tableOptions.maxItemsToShow) {
						translator.translate("EINVOICING.PORTAL.INVOICES.LISTS.MAXIMUM_INVOICES_REACHED").then(function (translated) {
							resultsReachedNotification = elementNotifier.warning(translated, findElement('#invoicesList'), { clickToHide: true });
							resultsReachedNotification.show();
						});
					}

					if (util.isArray(data)) {
						translateDocumentData(data);
					} else {
						var array = [data];
						translateDocumentData(array);
					}

					vm.tableOptions.data.fill(data);
					vm.invoices.fill(data);

					resetAllowedActions();

					removeSpinner();

					return;

					/**
       * Finds element in DOM
       */
					function findElement(key) {
						if (util.isFunction(scope.findElement)) {
							var element = scope.findElement(key);

							return element;
						}

						return null;
					}

					function translateDocumentData(array) {
						documentStateResolver.resolveDocumentStates("invoice", array);

						_.each(array, function (invoice) {
							documentStateResolver.calculateCurrentState('invoice', invoice.clientEInvoicingStateId, true).then(function (calculated) {
								invoice.calculatedState = calculated;
							});

							enumTranslator.translate(clientEnums.invoiceType, invoice.invoiceType).then(function (translated) {
								invoice.invoiceType = translated;
							});

							invoice.attributes = setAttributes(invoice);
						});

						return;

						function setAttributes(invoice) {
							var array = documentAttributeResolver.resolveAttributeKeys(invoice.attributes);

							if (isUserSupplier()) {
								documentAttributeResolver.removeAttribute(array, clientEnums.documentAttribute.notScheduledForPayment);
								documentAttributeResolver.removeAttribute(array, clientEnums.documentAttribute.scheduledForPayment);
							}

							return array;
						}
					}
				}

				/**
    * Notifies about failure while loading invoice data
    */
				function rejected() {
					removeSpinner();
				}
			}

			/**
    * Edit or view selected invoice.
    */
			function goToInvoice() {
				var selectedInvoice = getSelectedInvoice();

				if (util.isUndefined(selectedInvoice.id)) {
					return;
				}

				if (vm.userCanEditInvoices && invoiceCanBeEdited(selectedInvoice)) {
					diState.go('portal.invoices.editById', { id: selectedInvoice.id });
				} else {
					diState.go('portal.invoices.viewById', { id: selectedInvoice.id });
				}
			}

			function viewInvoice() {
				diState.go('portal.invoices.viewById', { id: getSelectedInvoice().id });
			}

			/**
    * Submits the invoice with the given id (flag for export and sending)
    */
			function submitInvoices() {
				var array = getCurrentlySelectedInvoices();

				_.each(array, function (invoice) {
					submitInvoice(invoice);
				});

				clearSelected();

				return;

				function submitInvoice(invoice) {

					if (validPaymentDueDate(invoice) === false) {
						return;
					}
					invoiceRepository.submitInvoiceByDocumentId(invoice.documentId, invoice.invoiceNumber).then(resolved);

					function resolved() {
						reloadDocumentState(invoice);
						reloadDocumentActions(invoice);
					}

					/**
      * Check the payment due date is not in the past
      */
					function validPaymentDueDate(invoice) {
						var todaysDate = new Date();
						var paymentDueDate = new Date(invoice.paymentDueDateTime);
						if (paymentDueDate.setHours(0, 0, 0, 0) < todaysDate.setHours(0, 0, 0, 0)) {
							notificationHandler.showError("EINVOICING.PORTAL.INVOICES.LISTS.SUBMIT_ERROR.PAYMENT_DUE_DATE", invoice.invoiceNumber);
							return false;
						}
						return true;
					}
				}
			}

			/**
    * Downloads a rendered document for the selected invoice
    */
			function downloadRenderedInvoice() {
				var invoice = getSelectedInvoice();

				if (util.isDefined(invoice)) {
					documentDownloader.downloadRenderedInvoice(invoice.documentId);
				}
			}

			/**
    * Disputes selected invoices
    */
			function changeInvoicesDisputeFlag(inDispute) {
				var array = getCurrentlySelectedInvoices();

				_.each(array, function (invoice) {
					changeInvoiceDisputeFlag(invoice, inDispute);
				});

				clearSelected();

				return;

				function changeInvoiceDisputeFlag(invoice, inDispute) {
					var disputeReason = '';

					if (inDispute) {
						disputeReason = 'not implemented';
					}

					invoiceRepository.flagInDisputeInvoice(invoice.documentId, disputeReason, inDispute, invoice.invoiceNumber).then(resolved);

					function resolved() {
						reloadDocumentState(invoice);
						reloadDocumentActions(invoice);
					}
				}
			}

			/**
    * Voids selected invoices
    */
			function voidInvoices() {
				var array = getCurrentlySelectedInvoices();

				_.each(array, function (invoice) {
					voidInvoice(invoice);
				});

				clearSelected();

				return;

				function voidInvoice(invoice) {
					invoiceRepository.voidInvoice(invoice.documentId, invoice.invoiceNumber).then(resolved);

					function resolved() {
						updateResolvedState(invoice, clientEnums.documentStateKey.cancelled);
						reloadDocumentActions(invoice);
					}
				}
			}

			/**
    * Changes paid state of selected invoices
    */
			function changeInvoicePaidStates(isPaid) {
				var array = getCurrentlySelectedInvoices();

				_.each(array, function (invoice) {
					changeInvoicePaidState(invoice, isPaid);
				});

				clearSelected();

				return;

				function changeInvoicePaidState(invoice, isPaid) {
					invoiceRepository.flagPaidInvoice(invoice.documentId, isPaid, invoice.invoiceNumber).then(resolved);

					function resolved() {
						reloadDocumentState(invoice);
						reloadDocumentActions(invoice);
					}
				}
			}

			/**
    * Changes scheduled state of selected invoices
    */
			function flagAsScheduledForPayments(isScheduled) {
				var array = getCurrentlySelectedInvoices();

				_.each(array, function (invoice) {
					flagAsScheduledForPayment(invoice, isScheduled);
				});

				clearSelected();

				return;

				function flagAsScheduledForPayment(invoice, isScheduled) {
					invoiceRepository.flagAsScheduledForPayment(invoice.documentId, isScheduled, invoice.invoiceNumber).then(resolved);

					function resolved() {
						reloadDocumentState(invoice);
						reloadDocumentActions(invoice);
					}
				}
			}

			/**
    * Releases selected mismatched invoices
    */
			function releaseInvoices() {
				var array = getCurrentlySelectedInvoices();

				var documentIds = [];

				_.each(array, function (invoice) {
					documentIds.push(invoice.documentId);
				});

				var reference = '';

				if (array.length === 1) {
					reference = array[0].invoiceNumber;
				}

				invoiceRepository.releaseInvoices(documentIds, reference).then(resolved);

				clearSelected();

				return;

				function resolved(data) {
					_.each(data, function (success, documentId) {
						var foundInvoice = _.find(vm.invoices, function (invoice) {
							return invoice.documentId === parseInt(documentId);
						});

						if (util.isDefined(foundInvoice)) {

							if (success) {
								notificationHandler.showSuccess("EINVOICING.PORTAL.INVOICES.ACTIONS.NOTIFICATION.SUCCESS.RELEASED", foundInvoice.invoiceNumber);

								reloadDocumentState(foundInvoice);
								reloadDocumentActions(foundInvoice);
							} else {
								notificationHandler.showError("EINVOICING.PROXIES.INVOICE.RELEASE_ERROR", foundInvoice.invoiceNumber);
							}
						}
					});
				}
			}

			/**
    * marks selected invoices as deleted
    */
			function deleteInvoices() {
				var array = getCurrentlySelectedInvoices();

				_.each(array, function (invoice) {
					deleteInvoice(invoice);
				});

				clearSelected();

				return;

				function deleteInvoice(invoice) {
					invoiceRepository.deleteInvoice(invoice.documentId, invoice.invoiceNumber).then(resolved);

					function resolved() {
						var index = invoiceRepository.getIndex(vm.invoices, "id", invoice.id);

						vm.invoices.splice(index, 1);
						resetAllowedActions();
					}
				}
			}

			function goToRelated() {
				var selected = getSelectedInvoice();

				if (util.isDefined(selected.documentId)) {
					diState.go('portal.related.list', { id: selected.documentId });
				}
			}

			/**
    * Resets filters back to default values for the grid and reloads
    */
			function clearFilters() {
				var initialFilters = {
					dateType: invoiceListConfigurator.getInitialDateType().value,
					dateTimeFilter: invoiceListConfigurator.getInitialDateTimeFilter().value,
					statusFilter: invoiceListConfigurator.getInitialStatusFilter().value,
					sortOption: invoiceListConfigurator.getInitialSortOption().value,
					fromDate: undefined,
					toDate: undefined,
					searchText: ""
				};

				filterInvoices(initialFilters);
			}

			/**
    * Reloads invoice state from db
    */
			function reloadDocumentState(invoice) {
				documentProxy.getDocumentClientStateId(invoice.id, clientEnums.documentType.invoice).then(resolved);

				return;

				function resolved(stateId) {
					updateResolvedState(invoice, stateId);
				}
			}

			/**
    * Reloads invoice allowed actions
    */
			function reloadDocumentActions(invoice) {
				invoiceRepository.getAllowedActions(invoice.documentId, invoice.invoiceNumber).then(resolved);
				return;

				function resolved(data) {
					invoice.actions = data;
					resetAllowedActions();
				}
			}

			/**
    * updates invoice state attributes
    */
			function updateResolvedState(invoice, stateId) {
				invoice.clientEInvoicingStateId = stateId;

				documentStateResolver.resolveDocumentState('invoice', stateId).then(function (resolved) {
					invoice.clientEInvoicingState = resolved;
				});

				getCalculatedState(stateId).then(function (calculated) {
					invoice.calculatedState = calculated;
				});
			}

			/**
    * Gets calculated state for display
    */
			function getCalculatedState(stateId) {
				return documentStateResolver.calculateCurrentState('invoice', stateId, true);
			}

			/**
    * Get currently selected invoices from the grid.
    */
			function getCurrentlySelectedInvoices() {
				var selectedRows = [];

				vm.invoices.forEach(function addToSelected(item) {
					if (item.isSelected === true) {
						selectedRows.push(item);
					}
				});

				return selectedRows;
			}

			/**
    * Gets selected invoice
    */
			function getSelectedInvoice() {
				var selectedRows = getCurrentlySelectedInvoices();

				if (selectedRows.length === 1) {
					return selectedRows[0];
				}
				return {};
			}

			/**
    * Clears selected rows
    */
			function clearSelected() {
				_.each(vm.invoices, function (item) {
					item.isSelected = false;
				});

				vm.selectedStates.clear();
				vm.selectedAttributes.clear();
			}

			/**
    * Event handler when rows selection changes
    */
			function onSelectedChanged(items) {
				vm.selectedItemsCount = items.length;

				var arrayStates = [];
				var arrayAttributes = [];
				var arrayActions = [];
				_.each(items, function (item) {
					arrayStates.push(item.documentStateKey);

					arrayActions.push(item.actions);

					var array = [];

					array.fill(item.attributes);

					_.each(array, function (attribute) {
						arrayAttributes.push(attribute);
					});
				});

				var resolvedActions = userActionsResolver.resolveActions(arrayActions, true);

				vm.selectedAttributes.fill(arrayAttributes);
				vm.selectedStates.fill(arrayStates);
				vm.selectedActions.fill(resolvedActions);

				return;
			}

			/**
    * Event handler when order filter has changed
    */
			function orderChanged(value) {
				var item = _.find(vm.sortOptions, function (option) {
					return option.value === value;
				});

				if (util.isUndefined(item)) {
					return;
				}

				vm.selectedFilters.sortOption = item;
			}

			/**
    * Event handler when status filter has changed
    */
			function statusChanged(value) {
				var item = _.find(vm.statusOptions, function (option) {
					return option.value === value;
				});

				if (util.isUndefined(item)) {
					return;
				}

				vm.selectedFilters.statusFilter = item;
			}

			/**
    * Event handler when date filter has changed
    */
			function dateChanged(value, customDate) {
				var item;
				if (util.isDefined(customDate)) {
					vm.selectedFilters.customDateTimeFilter = customDate;

					item = _.find(vm.dateOptions, function (option) {
						return option.value === 'Custom';
					});

					if (util.isDefined(item)) {
						vm.item = item;
					}
				} else {
					item = _.find(vm.dateOptions, function (option) {
						return option.value === value;
					});
				}

				if (util.isUndefined(item)) {
					return;
				}

				vm.selectedFilters.dateTimeFilter = item;
			}

			/**
    * Event handler when date type changes
    */
			function dateTypeChanged(value) {
				var item = _.find(vm.dateTypes, function (option) {
					return option.value === value;
				});

				if (util.isUndefined(item)) {
					return;
				}

				vm.selectedFilters.dateType = item;

				vm.dateOptions = invoiceListConfigurator.getDateTimeFilters(vm.selectedFilters.dateType.value);

				vm.selectedFilters.dateTimeFilter = invoiceListConfigurator.getInitialDateTimeFilter(vm.selectedFilters.dateType.value);
			}

			/*
    * Event handler when the size of the page changes
    */
			function onPageSizeChanged(newSize) {
				updateStoredParams({ pageSize: newSize, pageNumber: 1 });
			}

			/*
    * Event handler when the page changes
    */
			function onPageNumberChanged(newPageNumber) {
				updateStoredParams({ pageNumber: newPageNumber });
			}

			/**
    * Checks if invoice can be edited
    */
			function invoiceCanBeEdited(invoice) {
				return invoiceActionVerifier.canBeEdited(invoice);
			}

			/**
    * Checks if user has write rights
    */
			function userHasWriteRight() {
				return userRightsRepository.userHasRight("InvoiceWriter");
			}

			/**
    * Checks if users is a supplier
    */
			function isUserSupplier() {
				return userRightsRepository.userHasRight("Supplier");
			}

			/**
    * resets allowed actions
    */
			function resetAllowedActions() {
				vm.selectedItemsCount = 0;
				vm.selectedActions.clear();
			}

			/**
   * Adds spinner to the page
   */
			function showSpinner() {
				spinner = modalSpinner.showModalSpinner("#spinnerHolder");
			}

			/**
    * Removes spinner from the page
   */
			function removeSpinner() {
				if (spinner) {
					spinner.remove();
				}
			}

			/*
   * Stores the params in the local storage
   */
			function storeParams(params) {
				listsParamsStore.set("invoices", params);
			}

			/*
    * Updates the params in the local storage
    */
			function updateStoredParams(params) {
				listsParamsStore.update("invoices", params);
			}

			/*
    * Extends the source object with pageSize set to the current paginationPageSize and pageNumber set to 1
    */
			function setInitialPaginationDetails(source) {
				return _.extend(source, {
					pageSize: vm.tableOptions.paginationPageSize,
					pageNumber: 1
				});
			}
		}

		return InvoiceListController;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 408 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(414), __webpack_require__(413), __webpack_require__(409), __webpack_require__(412)], __WEBPACK_AMD_DEFINE_RESULT__ = function (diProductLinesDirectiveLoader, productLinesControllerLoader, columnVisibilityToggleLoader, itemListenerControllerLoader) {
    'use strict';

    return function (module) {
        diProductLinesDirectiveLoader(module);
        productLinesControllerLoader(module);
        columnVisibilityToggleLoader(module);
        itemListenerControllerLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 409 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(410), __webpack_require__(411)], __WEBPACK_AMD_DEFINE_RESULT__ = function (columnVisibilityToggleControllerLoader, columnVisibilityToggleDirectiveLoader) {
				'use strict';

				return function (module) {
								columnVisibilityToggleControllerLoader(module);
								columnVisibilityToggleDirectiveLoader(module);
				};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 410 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CVT02}
// di.einvoicing.ui.portal.components.productLines.components
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.controller('ColumnVisibilityToggleController', ColumnVisibilityToggleController);

		ColumnVisibilityToggleController.$inject = ['$scope', '$rootScope', 'scrollbarResizer'];

		function ColumnVisibilityToggleController(scope, rootScope, scrollbarResizer) {

			var vm = this;

			vm.manageColumnVisibility = manageColumnVisibility;

			return;

			//setup so that the binds are set for each object, then sets class on the button to highlight or not
			function manageColumnVisibility(item, buttonName) {
				switch (buttonName) {
					case 'isVisible':
						item.isVisible = true;
						item.isColumn = false;
						item.isHidden = false;
						break;
					case 'isHidden':
						item.isHidden = true;
						item.isColumn = false;
						item.isVisible = false;
						break;
					case 'isColumn':
						item.isColumn = true;
						item.isVisible = false;
						item.isHidden = false;
						break;

					default:
				}
				rootScope.$broadcast('refreshWatchers');
				scrollbarResizer.resizeHorizontalScrollbar();
			}
		}

		return ColumnVisibilityToggleController;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 411 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CVT01}
// di.einvoicing.ui.portal.components.productLines.components
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.directive('diColumnVisibilityToggle', diColumnVisibilityToggle);

		diColumnVisibilityToggle.$inject = ['translator'];

		function diColumnVisibilityToggle(translator) {
			return {
				restrict: 'E',
				scope: {
					bindToObject: '=',
					bindToIsVisibleProperty: '@',
					bindToIsHiddenProperty: '@',
					bindToIsColumnProperty: '@',
					bindToMandatory: '@'
				},
				controller: 'ColumnVisibilityToggleController',
				controllerAs: 'columnVisibilityToggleController',
				template: template
			};

			function template() {
				var html = '<div style="display: flex; padding-bottom: 5px;"><div class="btn-group small rounded">\
						<button\
									class="btn outline btn-icon small"\
									ng-click="columnVisibilityToggleController.manageColumnVisibility(bindToObject, \'isColumn\')"\
									ng-model="bindToObject[bindToIsColumnProperty]"\
									ng-class="{\'selected\': bindToObject[bindToIsColumnProperty] === true}"\
									title="' + translator.instantTranslate('EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.OPTIONAL_FIELDS.TOGGLE_BUTTONS.SHOW_AS_COLUMN') + '">\
									<di-image\
										image="showAsColumns"\
										image-colour="button"></di-image>\
						 </button>\
							<button\
									class="btn outline btn-icon small"\
									ng-click="columnVisibilityToggleController.manageColumnVisibility(bindToObject, \'isVisible\')"\
									ng-model="bindToObject[bindToIsVisibleProperty]"\
									ng-class="{\'selected\': bindToObject[bindToIsVisibleProperty] === true}"\
									image-colour="button"\
									title="' + translator.instantTranslate('EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.OPTIONAL_FIELDS.TOGGLE_BUTTONS.SHOW_IN_DETAILS') + '">\
									<di-image\
										image="showAsColumnsDetails"\
										image-colour="button"></di-image>\
						 </button>\
						 <button\
									ng-if="!bindToObject[bindToMandatory]"\
									class="btn outline btn-icon small"\
									ng-click="columnVisibilityToggleController.manageColumnVisibility(bindToObject, \'isHidden\')"\
									ng-model="bindToObject[bindToIsHiddenProperty]"\
									ng-class="{\'selected\': bindToObject[bindToIsHiddenProperty] === true}"\
									image-colour="button"\
									title="' + translator.instantTranslate('EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.OPTIONAL_FIELDS.TOGGLE_BUTTONS.HIDE') + '">\
									<di-image\
										image="hideColumnDetails"\
										image-colour="button">\
									</di-image>\
						 </button>\
						 <button\
									ng-if="bindToObject[bindToMandatory]"\
									class="btn outline btn-icon-disabled small"\
									disabled="true">\
									<di-image\
										image="hideColumnDetails"\
										image-colour="offWhite">\
									</di-image>\
						 </button>\
						</div>\
						<label\
							class="label"\
							style="padding: 5px;" ng-bind="::(bindToObject.heading | diTranslate)"></label>\
						</div>';

				return html;
			}
		}

		return diColumnVisibilityToggle;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 412 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP67}
// di.einvoicing.ui.portal.components.productLines.components
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.controller('ItemListenerController', ItemListenerController);

		ItemListenerController.$inject = ['$scope'];

		function ItemListenerController(scope) {

			var util = $di.utility.util;

			var vm = this;
			vm.onChange = onChange;

			return;

			/**
    * Event handler for on change action			
    */
			function onChange() {
				if (scope.onChangeAccessor && util.isFunction(scope.onChangeAccessor)) {
					scope.onChangeAccessor();
				}
			}
		}

		return ItemListenerController;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 413 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP44}
// di.einvoicing.ui.portal.invoices.editor.components
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.controller('ProductLinesController', ProductLinesController);

        ProductLinesController.$inject = ['$scope', '$rootScope', 'taxProxy', 'invoiceProxy', 'staticLookupProxy', 'notificationHandler', 'associativeArrayConvertor', 'scopeCacheFactory', 'unitOfMeasureRepository', '$timeout', 'debounce', 'formAnalyser', 'controlsRestrictionManager'];

        function ProductLinesController(scope, rootScope, taxProxy, invoiceProxy, staticLookupProxy, notificationHandler, associativeArrayConvertor, scopeCacheFactory, unitOfMeasureRepository, $timeout, debounce, formAnalyser, controlsRestrictionManager) {

            var guard = $di.exception.guard;
            var util = $di.utility.util;

            var vm = this;
            vm.currentEditLine = {};
            var lineForms = {};

            vm.readonly = util.isDefined(scope.readonly) ? scope.readonly : false;
            vm.scopeCache = util.isDefined(scope.scopeCache) ? scope.scopeCache : scopeCacheFactory.create(scope);
            vm.settings = scope.settings;
            vm.lines = scope.lines;
            vm.tableFields = _.clone(scope.settings);
            vm.expanded = false;
            vm.countries = [];
            vm.taxData = { taxes: {} };
            vm.productTypes = null;
            vm.unitsOfMeasure = null;
            vm.originCountryId = null;
            vm.currencyId = -1;
            //for an unknown reason, tooltips work only with text values (cannot use a {{}} expression)
            vm.languageKeyParent = util.isDefined(scope.overrideLanguageKey) ? scope.overrideLanguageKey : 'EINVOICING.PORTAL.COMPONENTS.PRODUCT_LINES';
            vm.manageColumnsLanguageKey = vm.languageKeyParent + '.MANAGE_COLUMNS';
            vm.lineItemsLanguageKey = vm.languageKeyParent + '.ITEMS';
            vm.addNewLineLanguageKey = vm.languageKeyParent + '.ADD_NEW_LINE';

            //line methods
            vm.addLine = addLine;
            vm.removeLine = removeLine;
            vm.selectLine = selectLine;
            vm.populateOptionalFields = populateOptionalFields;
            vm.getExpandedLines = getExpandedLines;
            vm.getCollapsedLines = getCollapsedLines;
            vm.collapseAllExpandedLines = collapseAllExpandedLines;
            vm.expandAllLines = expandAllLines;
            vm.getLineCount = getLineCount;
            vm.getExpandedLineCount = getExpandedLineCount;
            vm.getCollapsedLineCount = getCollapsedLineCount;
            vm.getVisibleColumnsCount = getVisibleColumnsCount;
            vm.getVisibleColumns = getVisibleColumns;
            vm.getInvisibleColumns = getInvisibleColumns;
            vm.getEditableColumns = getEditableColumns;
            vm.getHideableColumns = getHideableColumns;
            vm.toggleColumnVisibility = toggleColumnVisibility;
            vm.getUnitOfmeasureLabel = getUnitOfmeasureLabel;
            vm.lineFormCreated = lineFormCreated;
            vm.allowAddNewLine = true;

            //event handlers
            vm.productCodeChanged = productCodeChanged;
            vm.productStandardCodeChanged = productStandardCodeChanged;
            vm.productTypeChanged = productTypeChanged;
            vm.productUnitOfMeasureChanged = productUnitOfMeasureChanged;
            vm.onOriginCountryChanged = onOriginCountryChanged;
            vm.lineChanged = lineChanged;
            vm.subscribeToInvoiceDetailsChange = scope.subscribeToInvoiceDetailsChange;
            vm.taxCodeChanged = taxCodeChanged;

            controlsRestrictionManager.addOptionsSubscription(function (options) {
                vm.allowAddNewLine = options.allowAddNewLine;
            });

            var unWatchLineMonetaryChanges = function unWatchLineMonetaryChanges() {};
            var unWatchLineChanges = function unWatchLineChanges() {};

            init();

            return;

            function init() {
                if (scope.subscribeToInvoiceDetailsChange) {
                    scope.subscribeToInvoiceDetailsChange(setChangedInvoiceDetails);
                }

                scope.$on('$destroy', function () {
                    tearDown();
                });

                if (!vm.readonly) {
                    getProductTypes();
                }
                getUnitsOfMeasure();

                staticLookupProxy.get('Country').then(function (data) {
                    vm.countries.fill(data);

                    scope.$watchCollection(function () {
                        return scope.lines;
                    }, function () {
                        _.each(scope.lines, function (line) {
                            var originCountry = _.find(vm.countries, function (country) {
                                return country.code === line.originCountry;
                            });

                            line.originCountryId = (originCountry || {}).id || -1;
                            line.originCountryName = (originCountry || {}).name || null;
                        });
                    });
                });

                var unwatch = scope.$watch(function () {
                    return scope.optionalFields;
                }, function (value) {
                    if (util.isDefined(value)) {
                        populateOptionalFields();
                        unwatch();
                    }
                });
            }

            /**
            *  Destroy all state, watchers, any event listeners and subscriptions
            */
            function tearDown() {
                unWatchLineMonetaryChanges();
                unWatchLineChanges();
            }

            /**
            * Adds a new row to the invoice table.
            */
            function addLine() {
                var newLine = {
                    editing: false,
                    lineNumber: vm.lines.length + 1,
                    unitOfMeasureId: 1553,
                    id: getNewId(),
                    productType: 1
                };

                vm.lines.push(newLine);

                if (scope.onChange) {
                    scope.onChange();
                }

                lineChanged();

                scope.$evalAsync(function () {
                    selectLine(newLine, null, true);
                });
            }

            function getNewId() {
                var newId = 0;
                var lastIndex = _.findLastIndex(vm.lines, function (line) {
                    return line.id < 0;
                });
                if (lastIndex !== -1) {
                    var lastLine = vm.lines[lastIndex];
                    if (lastLine) {
                        newId = lastLine.id;
                    }
                }

                return newId - 1;
            }

            /**
            * Removes the given line from the collection.
            * @param line
            */
            function removeLine(line, $event) {
                guard.throwIfNullOrUndefined("EUP4404E", line, "line");

                if (util.isDefined($event)) {
                    $event.stopPropagation();
                }

                line.quantity = 0;

                if (line === vm.currentEditLine) {
                    unWatchLineMonetaryChanges();
                    unWatchLineChanges();
                }

                vm.lines.fill(_.reject(vm.lines, function (current) {
                    return current.lineNumber === line.lineNumber;
                }));

                delete lineForms[line.id.toString()];

                reseedLineNumbers();

                refreshLines();

                if (scope.onChange) {
                    scope.onChange();
                }
            }

            function lineFormCreated(lineId, form) {
                lineForms[lineId.toString()] = form;

                formAnalyser.allowCascadingDirty(form, false);
            }

            function getLineForm(line) {
                var lineIdStr = line.id.toString();
                var form = lineForms[lineIdStr];

                return form;
            }

            /**
            * Selects the line
            * @param line
            */
            function selectLine(line, event, isNew) {
                guard.throwIfNullOrUndefined("EUP4401E", line, "line");

                if (vm.readonly) {
                    line.expanded = !line.expanded;

                    scope.$broadcast('refreshWatchers');
                } else {
                    deSelectCurrentEditLine();

                    line.editing = true;
                    line.expanded = true;

                    unWatchLineMonetaryChanges = watchLineMonetaryChanges(line);
                    unWatchLineChanges = watchLineChanges();

                    vm.currentEditLine = line;

                    var form = getLineForm(line);

                    formAnalyser.allowCascadingDirty(form, true);

                    if (!isNew) {
                        var isValid = formAnalyser.isFormValid(form);

                        if (!isValid) {
                            formAnalyser.dirtyTrackedElements(form);
                        }
                    }

                    $timeout(function () {
                        scope.$broadcast('resumeWatchers', line.id.toString());
                    }, 0, false);
                }

                return true;
            }

            function deSelectCurrentEditLine() {
                if (util.isUndefined(vm.currentEditLine.id)) {
                    return;
                }

                vm.currentEditLine.priceBaseQuantity = vm.currentEditLine.priceBaseQuantity > 0 ? vm.currentEditLine.priceBaseQuantity : 1;

                vm.currentEditLine.editing = false;
                vm.currentEditLine.expanded = false;

                unWatchLineMonetaryChanges();
                unWatchLineChanges();

                var form = getLineForm(vm.currentEditLine);
                var lineIdStr = vm.currentEditLine.id.toString();

                formAnalyser.allowCascadingDirty(form, false);

                $timeout(function () {
                    scope.$broadcast('suspendWatchers', lineIdStr);
                }, 0, false).then(function () {
                    formAnalyser.dirtyTrackedElements(form);
                });
            }

            function refreshLines() {
                scope.$broadcast('refreshWatchers');
                scope.$emit('calculateInvoiceTotals');
            }

            /**
            * Watch a single line for relevant monetaty changes and re-calculate totals
            * @param line
            */
            function watchLineMonetaryChanges(line) {
                return scope.$watch(function () {
                    return {
                        'quantity': line.quantity,
                        'unitPrice': line.unitPrice,
                        'allowanceAmount': line.allowanceAmount,
                        'chargeAmount': line.chargeAmount,
                        'taxCode': line.taxCode,
                        'priceBaseQuantity': line.priceBaseQuantity
                    };
                }, debounce(function () {
                    scope.$emit('calculateInvoiceTotals');
                }, 250), true);
            }

            /**
            * Watch a single line for all changes - for dirty checking
            */
            function watchLineChanges() {
                return scope.$watch("productLinesCtrl.currentEditLine", function (newLine, oldLine) {
                    oldLine.quantityUnit = newLine.quantityUnit; //keeps changing when line is selected?

                    if (!angular.equals(newLine, oldLine)) {
                        lineChanged();
                    }
                }, true);
            }

            /**
             * Returns all columns that are marked as expanded
             */
            function getExpandedLines() {
                return _.filter(vm.lines, function (line) {
                    return line.expanded === true;
                });
            }

            /**
            * Returns all columns that are not marked as expanded
            */
            function getCollapsedLines() {
                return _.filter(vm.lines, function (line) {
                    return line.expanded !== true;
                });
            }

            /**
            * Any expanded lines are placed into in-line mode.
            */
            function collapseAllExpandedLines() {
                vm.expanded = false;

                _.each(vm.getExpandedLines(), function (line) {
                    if (!line.editing) {
                        line.expanded = false;
                    }
                });

                deSelectCurrentEditLine();

                scope.$broadcast('refreshWatchers');
            }

            /**
            * Expands all collapsed invoice lines.
            */
            function expandAllLines() {
                vm.expanded = true;

                _.each(vm.getCollapsedLines(), function (line) {
                    line.expanded = true;
                });

                scope.$broadcast('refreshWatchers');
            }

            function getLineCount() {
                return vm.lines.length;
            }

            function getCollapsedLineCount() {
                return getLineCount() - getExpandedLineCount();
            }

            function getExpandedLineCount() {
                return getExpandedLines().length;
            }

            /**
            * Keeps the invoice line numbers in sync when adding/removing lines.
            */
            function reseedLineNumbers() {
                _.each(vm.lines, function (current, index) {
                    current.lineNumber = index + 1;
                });
            }

            /**
            * Returns all columns that are marked as a column
            */
            function getVisibleColumnsCount() {
                return _.filter(vm.tableFields.columns, function (column) {
                    return column.isColumn === true;
                }).length;
            }

            /**
            * Returns all columns that are not marked as invisible
            */
            function getVisibleColumns() {
                return _.filter(vm.tableFields.columns, function (column) {
                    return column.visible !== false;
                });
            }

            function getInvisibleColumns() {
                return _.filter(vm.tableFields.columns, function (column) {
                    return column.visible === false;
                });
            }

            /**
            * Returns all columns that are marked as editable.
            */
            function getEditableColumns() {
                return _.filter(vm.tableFields.columns, function (column) {
                    return column.editable === true;
                });
            }

            /**
            * Returns all columns that are marked as hideable.
            */
            function getHideableColumns() {
                return _.filter(vm.tableFields.columns, function (column) {
                    return column.hideable === true;
                });
            }

            /**
            * Toggles the visibility of a column.
            * @param col
            */
            function toggleColumnVisibility(col) {
                guard.throwIfNotAnObject("EUP4406E", col, "col");

                if (col.visible === undefined || col.visible) {
                    col.visible = false;
                } else {
                    col.visible = true;
                }
            }

            /**
            * Event handler to react to changes to the selected FromCompany
            */
            function setPartyId(partyId) {
                var taxPromise;

                vm.taxData = { taxes: {} };

                if (util.isUndefined(partyId) || partyId <= 0) {
                    return;
                }

                taxPromise = taxProxy.getTaxesByPartyId(partyId);

                taxPromise.then(taxesResolved, taxesRejected);

                function taxesResolved(data) {
                    vm.taxData.taxes = associativeArrayConvertor.convert(data, function (tax) {
                        return tax.id;
                    });
                }

                function taxesRejected(error) {
                    notificationHandler.showError(error.failureReason);
                }
            }

            /**
            * Function which sets additional information on the line about the selected tax code
            * @param line
            */
            function taxCodeChanged(line, tax) {
                if (util.isDefined(tax)) {
                    line.taxCode = tax.code;
                    line.taxRate = tax.rate;
                    line.taxCategory = tax.taxCategory;
                } else {
                    line.taxCode = undefined;
                    line.taxRate = undefined;
                    line.taxCategory = undefined;
                }

                lineChanged();
            }

            function productCodeChanged(line, product) {

                if (util.isDefined(product.id)) {
                    line.code = product.code;
                    line.standardProductCode = product.standardCode;
                    line.standardProductCodeScheme = product.standardCodeScheme;
                    line.eClassCode = product.eClassCode;
                    line.productId = product.id;
                    line.itemName = product.name;
                    line.itemDescription = product.description;
                    line.productType = product.productType;
                } else {
                    line.code = product;
                    line.productId = undefined;
                }

                lineChanged();
            }

            function productStandardCodeChanged(line, product) {
                if (util.isDefined(product.id)) {
                    line.code = product.code;
                    line.standardProductCode = product.standardCode;
                    line.productId = product.id;
                    line.itemName = product.name;
                    line.itemDescription = product.description;
                    line.productType = product.productType;
                } else {
                    line.standardProductCode = product;
                    line.productId = undefined;
                }

                lineChanged();
            }

            function productTypeChanged() {
                lineChanged();
            }

            function productUnitOfMeasureChanged(unitOfMeasure, line) {
                line.priceBaseQuantityUnit = unitOfMeasure.value;
                lineChanged();
            }

            function onOriginCountryChanged(country) {
                if (vm.currentEditLine.originCountry === country.code) {
                    return;
                }

                vm.currentEditLine.originCountry = country.code;
                vm.currentEditLine.originCountryName = country.name;
                vm.lineChanged();
            }

            function lineChanged() {
                if (scope.onLineChange) {
                    scope.onLineChange();
                }
            }

            /**
            * Function which loads the product types from the scope cache or static lookup proxy
            */
            function getProductTypes() {
                vm.scopeCache.get('staticLookupProxy.get', staticLookupProxy.get, ['ProductType']).then(productTypesResolved, productTypesRejected);

                function productTypesResolved(data) {
                    vm.productTypes = associativeArrayConvertor.convert(data, function (productType) {
                        return productType.id;
                    });
                }

                function productTypesRejected(error) {
                    notificationHandler.showError(error.failureReason);
                }
            }

            /**
            * Loads units of measure types from repository
            */
            function getUnitsOfMeasure() {
                unitOfMeasureRepository.getUnitsOfMeasure().then(resolved, rejected);

                function resolved(data) {
                    vm.unitsOfMeasure = associativeArrayConvertor.convert(data, function (item) {
                        return item.id;
                    });
                }

                function rejected(error) {
                    notificationHandler.showError(error.failureReason);
                }
            }

            /**
            * Set unit of measure label for readonly view
            */
            function getUnitOfmeasureLabel(line) {
                if (vm.unitsOfMeasure) {
                    var unitFound = _.find(vm.unitsOfMeasure, function (unit) {
                        return unit.id === line.unitOfMeasureId;
                    });
                    return util.isDefined(unitFound) ? unitFound.name : "";
                }
                return "";
            }

            /**
            * Process the changed invoice details
            * @param invoiceDetails
            */
            function setChangedInvoiceDetails(invoiceDetails) {
                if (util.isDefined(invoiceDetails.supplierPartyId)) {
                    setPartyId(invoiceDetails.supplierPartyId);
                }
                if (util.isDefined(invoiceDetails.currencyId)) {
                    setCurrencyId(invoiceDetails.currencyId);
                    refreshLines();
                }
            }

            /**
            * Sets the currency ID on the current controller to the provided value
            * @param currencyId
            */
            function setCurrencyId(currencyId) {
                vm.currencyId = currencyId;
            }

            /**
            * Populates optional field settings as they may not have loaded when the page firsts loads
            * @returns {}
            */
            function populateOptionalFields() {
                vm.tableFields = scope.settings;

                if (!vm.readonly) {
                    if (!vm.optionalFields) {
                        vm.optionalFields = scope.optionalFields;
                    }
                    if (vm.optionalFields) {
                        _.each(vm.optionalFields, function (optionalField) {
                            var fieldExists = _.find(vm.tableFields.columns, function (field) {
                                return field.clientName === optionalField.clientName;
                            });
                            if (!fieldExists) {
                                if (optionalField.entityTypeName === "InvoiceLine") {
                                    vm.tableFields.columns.push(optionalField);
                                }
                            }
                        });
                    }
                }
            }
        }

        return ProductLinesController;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 414 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP3N}
// di.einvoicing.ui.portal.invoices.editor.components
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.directive('diProductLines', diProductLines);

		function diProductLines() {
			return {
				restrict: 'E',
				replace: true,
				scope: {
					subscribeToInvoiceDetailsChange: '=',
					onChange: '=',
					onLineChange: '=',
					scopeCache: '=',
					lines: '=',
					settings: '=',
					readonly: '=',
					optionalFields: '=',
					overrideLanguageKey: '='
				},
				controller: 'ProductLinesController',
				controllerAs: 'productLinesCtrl',
				templateUrl: 'src/app/portal/invoices/product-lines/product-lines.html',
				link: link
			};

			function link(scope, element, attrs, controller) {
				scope.lineInit = function (lineId) {
					if (scope.readonly) {
						return;
					}

					scope.$evalAsync(function () {
						var form = element.find('#lineForm' + lineId);

						controller.lineFormCreated(lineId, form);
					});
				};
			}
		}

		return diProductLines;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 415 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP3P}
// di.einvoicing.ui.portal.proxies
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_) {
	'use strict';

	return function (module) {
		module.factory('productProxy', productProxy);

		productProxy.$inject = ['webApiHttp', '$q'];

		function productProxy(http, $q) {

			return {
				getProductsByPartyId: getProductsByPartyId
			};

			/**
    * Gets the products for the specified company
    * @param partyId
    */
			function getProductsByPartyId(partyId) {
				var httpPromise = http.get('Product/GetCollectionByPartyId/' + partyId);
				var newPromise = httpPromise.then(successfullyReceivedProducts, failedToReceiveProducts);

				return newPromise;
			}

			/**
    * Function which allows pre-processing of product data
    * @param data
    */
			function successfullyReceivedProducts(data) {
				return data;
			}

			/**
    * Function which allows processing of errors whilst receiving products
    * @param error
    */
			function failedToReceiveProducts(error) {
				error.failureReason = 'EINVOICING.PORTAL.PROXIES.PRODUCT.RECEIVE_ERROR';

				return $q.reject(error);
			}
		}
		return productProxy;
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 416 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(418), __webpack_require__(417)], __WEBPACK_AMD_DEFINE_RESULT__ = function (diProductSelectorDirectiveLoader, productSelectorControllerLoader) {
    'use strict';

    return function (module) {
        diProductSelectorDirectiveLoader(module);
        productSelectorControllerLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 417 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP4B}
// di.einvoicing.ui.portal.invoices.editor.components
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
		'use strict';

		return function (module) {
				var util = $di.utility.util;

				module.controller('ProductSelectorController', ProductSelectorController);

				ProductSelectorController.$inject = ['$scope', 'productProxy', 'notificationHandler', 'scopeCacheFactory'];

				function ProductSelectorController(scope, productProxy, notificationHandler, scopeCacheFactory) {

						var vm = this;

						vm.onChangeAccessor = setBoundIdFromSelectedItem;
						vm.item = {};
						vm.items = [];
						vm.propertyControl = scope.propertyControl;
						vm.scopeCache = util.isDefined(scope.scopeCache) ? scope.scopeCache : scopeCacheFactory.create(scope);

						scope.subscribeToInvoiceDetailsChange(setPartyId);

						var unwatch;
						tearDown();

						return;

						function tearDown() {
								scope.$on('$destroy', function () {
										if (util.isFunction(unwatch)) {
												unwatch();
										}
								});
						}

						function setPartyId(changedInvoiceDetails) {
								var productPromise;

								var partyId = changedInvoiceDetails.supplierPartyId;

								if (util.isUndefined(partyId) || partyId <= 0) {
										return;
								}

								if (util.isDefined(scope.scopeCache)) {
										productPromise = scope.scopeCache.get('productProxy.getProductsByPartyId', productProxy.getProductsByPartyId, [partyId]);
								} else {
										productPromise = productProxy.getProductsByPartyId(partyId);
								}

								productPromise.then(productsResolved, productsRejected);

								function productsResolved(data) {

										var uniqueList = _.uniq(data, function (item) {
												return item[scope.propertyControl] + item.name;
										});

										vm.items.fill(uniqueList);

										unwatch = scope.$watch(function () {
												return scope.bindToObject[scope.bindToProperty];
										}, function () {
												setSelectedItemFromBoundId();
										});
								}

								function productsRejected(error) {
										notificationHandler.showError(error.failureReason);
								}
						}

						function setBoundIdFromSelectedItem() {
								var accessor;

								scope.bindToObject[scope.bindToProperty] = (vm.item || {})[scope.propertyControl];

								if (util.isFunction(scope.onChangeAccessor)) {
										accessor = scope.onChangeAccessor();

										if (util.isFunction(accessor)) {
												accessor(scope.bindToObject, vm.item);
										}
								}
						}

						function setSelectedItemFromBoundId() {
								if (util.isDefined(vm.item) && scope.bindToObject[scope.bindToProperty] === vm.item[scope.propertyControl]) {
										return;
								}

								var item = _.find(vm.items, function (item) {
										return item[scope.propertyControl] === scope.bindToObject[scope.bindToProperty];
								});

								if (util.isUndefined(item)) {
										return;
								}

								vm.item = item;
						}
				}

				return ProductSelectorController;
		};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 418 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP3Q}
// di.einvoicing.ui.portal.invoices.editor.invoiceLines.components
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var util = $di.utility.util;
        module.directive('diProductSelector', diProductSelector);

        function diProductSelector() {
            return {
                restrict: 'E',
                replace: true,
                scope: {
                    subscribeToInvoiceDetailsChange: '=',
                    scopeCache: '=',
                    bindToObject: '=',
                    bindToProperty: '@',
                    validationName: '@',
                    validationMessage: '@',
                    validationModelDisplayName: '@',
                    propertyControl: '@',
                    onChangeAccessor: '&'
                },
                controller: 'ProductSelectorController',
                controllerAs: 'productSelectorCtrl',
                template: template
            };

            function template(element, attrs) {
                var html = '<div>\
    <di-select\
        mode="autoComplete"\
        items="productSelectorCtrl.items"\
        item-unique-property="id"\
        bind-to-object="productSelectorCtrl"\
        bind-to-property="item"\
        class="product-select"\
        watch-binding="true"\
        display-property="' + attrs.propertyControl + '"';
                html += getValidationHtml(attrs);
                html += '        searchable-properties="' + attrs.propertyControl + ',name"\
        on-change-accessor="productSelectorCtrl.onChangeAccessor"\
        allow-empty-display="true"\
        placeholder="EINVOICING.PORTAL.COMPONENTS.PRODUCT_SELECTOR.PRODUCT_SEARCH">\
        <b ng-if="filteredItem.item.' + attrs.propertyControl + '">{{::filteredItem.item.' + attrs.propertyControl + '}}:</b> {{::filteredItem.item.name}}\
    </di-select>\
</div>';

                return html;

                function getValidationHtml(attrs) {
                    var validationHtml = "";

                    if (util.isDefined(attrs.validationName)) {
                        var displayName = attrs.validationName;

                        if (util.isDefined(attrs.validationModelDisplayName)) {
                            displayName = attrs.validationModelDisplayName;
                        }

                        validationHtml += '        di-validate="' + attrs.validationName + '"\
         di-validate-model="invoiceLine"\
         validation-property-name="' + attrs.validationName + '"\
         validation-model="bindToObject[bindToProperty]"\
         validation-model-display-name="' + displayName + '"';
                    }

                    return validationHtml;
                }
            }
        }

        return diProductSelector;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 419 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(421), __webpack_require__(420)], __WEBPACK_AMD_DEFINE_RESULT__ = function (diProductTypeSelectorDirectiveLoader, productTypeSelectorControllerLoader) {
    'use strict';

    return function (module) {
        diProductTypeSelectorDirectiveLoader(module);
        productTypeSelectorControllerLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 420 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP4C}
// di.einvoicing.ui.portal.invoices.editor.components
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var util = $di.utility.util;

        module.controller('ProductTypeSelectorController', ProductTypeSelectorController);

        ProductTypeSelectorController.$inject = ['$scope', 'staticLookupProxy', 'notificationHandler', 'scopeCacheFactory'];

        function ProductTypeSelectorController(scope, staticLookupProxy, notificationHandler, scopeCacheFactory) {

            var vm = this;
            var productTypePromise;

            vm.onChangeAccessor = setBoundIdFromSelectedItem;
            vm.item = {};
            vm.items = [];
            vm.scopeCache = util.isDefined(scope.scopeCache) ? scope.scopeCache : scopeCacheFactory.create(scope);

            if (util.isDefined(scope.scopeCache)) {
                productTypePromise = scope.scopeCache.get('staticLookupProxy.get', staticLookupProxy.get, ['ProductType']);
            } else {
                productTypePromise = staticLookupProxy.get('ProductType');
            }

            productTypePromise.then(productTypesResolved, productTypesRejected);

            function productTypesResolved(data) {
                vm.items.fill(data);

                scope.$watch(function () {
                    return scope.bindToObject[scope.bindToProperty];
                }, function () {
                    setSelectedItemFromBoundId();
                });
            }

            function productTypesRejected(error) {
                notificationHandler.showError(error.failureReason);
            }

            function setBoundIdFromSelectedItem() {
                var accessor;

                scope.bindToObject[scope.bindToProperty] = (vm.item || {}).id;
                scope.bindToObject[scope.bindToSecondProperty] = (vm.item || {}).name;

                if (util.isFunction(scope.onChangeAccessor)) {
                    accessor = scope.onChangeAccessor();

                    if (util.isFunction(accessor)) {
                        accessor(scope.bindToObject, vm.item);
                    }
                }
            }

            function setSelectedItemFromBoundId() {

                if (util.isDefined(vm.item) && scope.bindToObject[scope.bindToProperty] === vm.item.id) {
                    return;
                }

                var item = _.find(vm.items, function (item) {
                    return item.id === scope.bindToObject[scope.bindToProperty];
                });

                if (util.isUndefined(item)) {
                    return;
                }

                vm.item = item;

                if (util.isDefined(vm.item.name)) {
                    scope.bindToObject[scope.bindToSecondProperty] = vm.item.name;
                }
            }
        }

        return ProductTypeSelectorController;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 421 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP3R}
// di.eivoicing.ui.portal.invoices.editor.components.invoiceLines.components
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;
		module.directive('diProductTypeSelector', diProductTypeSelector);

		function diProductTypeSelector() {
			return {
				restrict: 'E',
				replace: true,
				scope: {
					scopeCache: '=',
					bindToObject: '=',
					bindToProperty: '@',
					bindToSecondProperty: '@',
					validationName: '@',
					validationModelDisplayName: '@',
					onChangeAccessor: '&',
					validationPropertyName: '@'
				},
				controller: 'ProductTypeSelectorController',
				controllerAs: 'productTypeSelectorCtrl',
				template: template
			};

			function template(element, attrs) {

				var html = '<div><di-select\
									mode="dropdown"\
									items="productTypeSelectorCtrl.items"\
									item-unique-property="id"\
									bind-to-object="productTypeSelectorCtrl"\
									bind-to-property="item"\
                                    di-validate-model="invoiceLine"\
                                    validation-property-name="{{::validationPropertyName}}"\
				                    watch-binding="true"\
									display-property="name"';
				html += getValidationHtml(attrs);
				html += 'on-change-accessor="productTypeSelectorCtrl.onChangeAccessor">\
									{{::filteredItem.item.name}}\
								</di-select></div>';

				return html;

				function getValidationHtml(attrs) {
					var innerHtml = "";

					if (util.isDefined(attrs.validationName)) {
						var displayName = attrs.validationName;

						if (util.isDefined(attrs.validationModelDisplayName)) {
							displayName = attrs.validationModelDisplayName;
						}

						innerHtml += ' di-validate="' + attrs.validationName + '" ' + ' validation-model="bindToObject[bindToProperty]" ' + ' validation-model-display-name="' + displayName + '"';
					}

					return innerHtml;
				}
			}
		}

		return diProductTypeSelector;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 422 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(423)], __WEBPACK_AMD_DEFINE_RESULT__ = function (servicesLoader) {
	'use strict';

	return function (module) {
		servicesLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 423 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(424)], __WEBPACK_AMD_DEFINE_RESULT__ = function (invoiceAdditionalDocumentReferencesConfigurationLoader) {
	'use strict';

	return function (module) {
		invoiceAdditionalDocumentReferencesConfigurationLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 424 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF1L}
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.constant('INVOICE_ADDITIONAL_DOCUMENT_REFERENCES_CONFIGURATION', invoiceAdditionalDocumentReferencesConfiguration());

		function invoiceAdditionalDocumentReferencesConfiguration() {
			return [{
				field: 'reference',
				header: 'EINVOICING.PORTAL.COMPONENTS.ADDITIONAL_DOCUMENT_REFERENCES.REFERENCE',
				headerClass: "centeredcellDesc",
				readonlyTemplate: '<p class="readonly">{{ binding.reference }}</p>',
				template: '<di-input\
									ng-model="binding"\
									ng-model-property="reference"\
									ng-change="controller.onPropertyChanged()"\
									validation-property-name="reference"\
									validation-model-display-name="EINVOICING.PORTAL.COMPONENTS.ADDITIONAL_DOCUMENT_REFERENCES.REFERENCE"\
									validation-message-position="topright"\
									di-input-type="text">\
								</di-input>',
				editable: true
			}, {
				field: 'documentType',
				header: 'EINVOICING.PORTAL.COMPONENTS.ADDITIONAL_DOCUMENT_REFERENCES.DOCUMENT_TYPE',
				headerClass: "centeredcellDesc",
				readonlyTemplate: '<p class="readonly">{{ binding.documentType }}</p>',
				template: '<di-input\
									ng-model="binding"\
									ng-model-property="documentType"\
									ng-change="controller.onPropertyChanged()"\
									validation-property-name="documentType"\
									validation-model-display-name="EINVOICING.PORTAL.COMPONENTS.ADDITIONAL_DOCUMENT_REFERENCES.DOCUMENT_TYPE"\
									validation-message-position="topright"\
									di-input-type="text">\
								</di-input>',
				editable: true
			}, {
				field: 'fileName',
				header: 'EINVOICING.PORTAL.COMPONENTS.ADDITIONAL_DOCUMENT_REFERENCES.FILENAME',
				headerClass: "centeredcellDesc",
				readonlyTemplate: '<div ng-if="controller.hasAttachment(binding)"\
											ng-click="controller.download({attachmentDataId : binding.attachmentDataId, filename : binding.fileName })">\
											<p class="readonly">\
												<a href="#">{{ binding.fileName }}</a>\
											</p>\
										</div>',
				template: '<di-attachment-uploader\
                                    bind-to-object="binding.lineIdentifier"\
                                    file-name="binding.fileName"\
									attachment-data-id="binding.attachmentDataId"\
                                    on-upload-state-changed="controller.onAttachmentUploadStateChanged({lineIdentifier : lineIdentifier, attachmentDataId :attachmentDataId, filename: filename,status:status})"\
									download="controller.download({ attachmentDataId : id, filename: filename })">\
                                /di-attachment-uploader>',
				editable: true
			}, {
				field: 'uri',
				header: 'EINVOICING.PORTAL.COMPONENTS.ADDITIONAL_DOCUMENT_REFERENCES.URI',
				headerClass: "centeredcellDesc",
				readonlyTemplate: '<div>\
									<div ng-if="controller.isAbsoluteUrl(binding.uri)"\
										title="{{ binding.uri }}">\
										<p class="readonly">\
											<a ng-href="{{ binding.uri }}" target="_blank" di-translate>EINVOICING.PORTAL.COMPONENTS.ADDITIONAL_DOCUMENT_REFERENCES.LINK</a>\
										</p>\
									</div>\
									<div ng-if="!controller.isAbsoluteUrl(binding.uri)">\
										<p class="readonly">{{ binding.uri }}</p>\
									</div>\
								</div>',
				template: '<di-input\
									ng-model="binding"\
									ng-model-property="uri"\
									ng-change="controller.onPropertyChanged()"\
									validation-property-name="uri"\
									validation-model-display-name="EINVOICING.PORTAL.COMPONENTS.ADDITIONAL_DOCUMENT_REFERENCES.URI"\
									validation-message-position="topright"\
									di-input-type="text">\
								</di-input>',
				editable: true
			}, {
				field: 'createdDateTime',
				header: 'EINVOICING.PORTAL.COMPONENTS.ADDITIONAL_DOCUMENT_REFERENCES.UPLOAD_DATE',
				headerClass: "centeredcellDesc",
				readonlyTemplate: '<p class="readonly">{{ binding.createdDateTime | diDate : "DD/MM/YYYY HH:mm:ss" }}</p>',
				template: '<p class="readonly" ng-if="binding.createdDateTime">{{ binding.createdDateTime | diDate : "DD/MM/YYYY HH:mm:ss" }}</p>',
				editable: true
			}];
		}
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 425 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(427), __webpack_require__(426)], __WEBPACK_AMD_DEFINE_RESULT__ = function (diTaxCodeSelectorDirectiveLoader, taxCodeSelectorControllerLoader) {
    'use strict';

    return function (module) {
        diTaxCodeSelectorDirectiveLoader(module);
        taxCodeSelectorControllerLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 426 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP49}
// di.einvoicing.ui.portal.invoices.editor.components
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.controller('TaxCodeSelectorController', TaxCodeSelectorController);

		TaxCodeSelectorController.$inject = ['$scope', 'taxProxy', 'notificationHandler', 'scopeCacheFactory'];

		function TaxCodeSelectorController(scope, taxProxy, notificationHandler, scopeCacheFactory) {

			var vm = this;

			vm.onChangeAccessor = setBoundIdFromSelectedItem;
			vm.item = {};
			vm.items = [];
			vm.scopeCache = util.isDefined(scope.scopeCache) ? scope.scopeCache : scopeCacheFactory.create(scope);

			scope.subscribeToInvoiceDetailsChange(setPartyId);

			return;

			function setPartyId(changedInvoiceDetails) {
				var taxPromise;

				var partyId = changedInvoiceDetails.supplierPartyId;

				if (util.isUndefined(partyId) || partyId <= 0) {
					return;
				}

				if (util.isDefined(scope.scopeCache)) {
					taxPromise = scope.scopeCache.get('taxProxy.getTaxesByPartyId', taxProxy.getTaxesByPartyId, [partyId]);
				} else {
					taxPromise = taxProxy.getTaxesByPartyId(partyId);
				}

				taxPromise.then(taxesResolved, taxesRejected);

				function taxesResolved(data) {
					vm.items.fill(data);

					setItemsDisplayText();

					var unwatch = scope.$watch(function () {
						return scope.bindToObject[scope.bindToProperty];
					}, function () {
						setSelectedItemFromBoundId();
					});
				}

				function taxesRejected(error) {
					notificationHandler.showError(error.failureReason);
				}
			}

			function setItemsDisplayText() {
				_.each(vm.items, function (item) {
					item.displayText = item.code + " (" + item.taxCategory + ") " + item.rate + "%";
				});
			}

			function setBoundIdFromSelectedItem() {
				var accessor;

				scope.bindToObject[scope.bindToProperty] = (vm.item || {}).id;

				if (util.isFunction(scope.onChangeAccessor)) {
					accessor = scope.onChangeAccessor();

					if (util.isFunction(accessor)) {
						accessor(scope.bindToObject, vm.item);
					}
				}
			}

			function setSelectedItemFromBoundId() {
				if (util.isDefined(vm.item) && scope.bindToObject[scope.bindToProperty] === vm.item.id) {
					return;
				}

				var item = _.find(vm.items, function (item) {
					return item.id === scope.bindToObject[scope.bindToProperty];
				});

				if (util.isUndefined(item)) {
					return;
				}

				vm.item = item;
			}
		}

		return TaxCodeSelectorController;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 427 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP46}
// di.einvoicing.ui.portal.invoices.editor.components
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var util = $di.utility.util;
        module.directive('diTaxCodeSelector', diTaxCodeSelector);

        function diTaxCodeSelector() {
            return {
                restrict: 'E',
                replace: true,
                scope: {
                    subscribeToInvoiceDetailsChange: '=',
                    scopeCache: '=',
                    bindToObject: '=',
                    bindToProperty: '@',
                    validationName: '@',
                    validationModelDisplayName: '@',
                    onChangeAccessor: '&',
                    validationPropertyName: '@',
                    diValidateModel: '@'
                },
                controller: 'TaxCodeSelectorController',
                controllerAs: 'taxCodeSelectorCtrl',
                template: template
            };

            function template(element, attrs) {

                var html = '<div>\
                                <di-select\
                                    mode="dropdown"\
                                    items="taxCodeSelectorCtrl.items"\
                                    item-unique-property="id"\
                                    bind-to-object="taxCodeSelectorCtrl"\
                                    bind-to-property="item"\
                                    di-validate-model="{{::diValidateModel}}"\
                                    validation-property-name="{{::validationPropertyName}}"\
                                    display-property="displayText"';
                html += getValidationHtml(attrs);
                html += '           on-change-accessor="taxCodeSelectorCtrl.onChangeAccessor">\
                                    {{::filteredItem.item.code}} ({{::filteredItem.item.taxCategory}}): {{::filteredItem.item.rate}}%\
                                </di-select></div>';
                return html;

                function getValidationHtml(attrs) {
                    var innerHtml = "";

                    if (util.isDefined(attrs.validationName)) {
                        var displayName = attrs.validationName;
                        if (util.isDefined(attrs.validationModelDisplayName)) {
                            displayName = attrs.validationModelDisplayName;
                        }

                        innerHtml += 'di-validate="{{::validationName}}"' + 'validation-model="bindToObject[bindToProperty]"' + 'validation-model-display-name="' + displayName + '"';
                    }

                    return innerHtml;
                }
            }
        }

        return diTaxCodeSelector;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 428 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP01}
// di.einvoicing.ui.portal.proxies
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.factory('taxProxy', taxProxy);

		taxProxy.$inject = ['webApiHttp', '$q'];

		function taxProxy(http, $q) {
			return {
				getTaxesByPartyId: getTaxesByPartyId
			};

			function getTaxesByPartyId(partyId) {
				var requestUrl = 'Tax/GetCollectionByPartyId/' + partyId;

				var httpPromise = http.get(requestUrl);
				var newPromise = httpPromise.then(successfullyReceivedTaxes, errorReceivingTaxes);

				return newPromise;
			}

			/**
    * Function which allows pre-processing of tax data
    * @param data
    */
			function successfullyReceivedTaxes(data) {
				return data;
			}

			/**
    * Function which allows processing of error data
    * Must return a failed promise otherwise chained success callbacks are called
    * @param error
    */
			function errorReceivingTaxes(error) {
				error.failureReason = 'EINVOICING.PORTAL.PROXIES.TAX.RECEIVE_ERROR';
				return $q.reject(error);
			}
		}

		return taxProxy;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 429 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP7O}
// di.einvoicing.ui.portal.components.unitofmeasureselector
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(431), __webpack_require__(432), __webpack_require__(430)], __WEBPACK_AMD_DEFINE_RESULT__ = function (unitOfMeasureSelectorDirectiveLoader, unitOfMeasureControllerLoader, unitOfMeasureRepositoryLoader) {
	'use strict';

	return function (module) {
		unitOfMeasureSelectorDirectiveLoader(module);
		unitOfMeasureControllerLoader(module);
		unitOfMeasureRepositoryLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 430 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP7N}
// di.einvoicing.ui.portal.components.unitofmeasure
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_) {
	'use strict';

	return function (module) {
		module.factory('unitOfMeasureRepository', unitOfMeasureRepository);

		unitOfMeasureRepository.$inject = ['staticLookupProxy'];

		function unitOfMeasureRepository(staticLookupProxy) {
			var units = null;

			return {
				getUnitsOfMeasure: getUnitsOfMeasure
			};

			/**
    * Gets all available units of measure defined in the system.
    */
			function getUnitsOfMeasure() {
				var promise = staticLookupProxy.get('UnitOfMeasure').then(success);

				return promise;

				function success(data) {
					units = data;

					_.each(units, function (unit) {
						unit.label = unit.name;
						unit.value = unit.commonCode;
					});

					units = _.sortBy(units, function (unit) {
						return unit.name;
					});

					return units;
				}
			}
		}

		return unitOfMeasureRepository;
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 431 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP7P}
// di.einvoicing.ui.portal.components.unitofmeasureselector
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;
		module.directive('diUnitOfMeasureSelector', diUnitOfMeasureSelector);

		function diUnitOfMeasureSelector() {
			return {
				restrict: 'E',
				replace: true,
				template: template,
				controller: 'UnitOfMeasureController',
				controllerAs: 'unitOfMeasureCtrl',
				scope: {
					tabIndex: '@',
					items: '=',
					bindToObject: '=',
					bindToProperty: '@',
					bindToSecondProperty: '@',
					onChangeAccessor: '&',
					validationMessage: '@',
					validationName: '@',
					validationModelDisplayName: '@',
					scopeCache: '=',
					validationPropertyName: '@'
				}
			};

			/**
    * Generates html template             
    */
			function template(element, attrs) {
				var html = '<div>\
								<di-select\
									tab-index="{{::tabIndex}}"\
									mode="dropdownSearch"\
									watch-items="true"\
                                    watch-include-default-obj="true"\
									items="unitOfMeasureCtrl.items"\
									item-unique-property="id"\
									bind-to-object="unitOfMeasureCtrl"\
									bind-to-property="item"\
									display-property="name"\
                                    di-validate-model="invoiceLine"\
                                    validation-property-name="{{::validationPropertyName}}"\
									searchable-properties="name,commonCode,symbol"';

				html += getValidationHtml(attrs);
				html += '           on-change-accessor="unitOfMeasureCtrl.onChangeAccessor"\
									placeholder="EINVOICING.PORTAL.COMPONENTS.UNIT_OF_MEASURE.SEARCH">\
									{{::filteredItem.item.commonCode}}: {{::filteredItem.item.name}}\
								</di-select></div>';
				return html;

				/**
     * Adds validation attributes                 
     */
				function getValidationHtml(attrs) {
					var innerHtml = "";

					if (util.isDefined(attrs.validationName)) {
						var displayName = attrs.validationName;
						if (util.isDefined(attrs.validationModelDisplayName)) {
							displayName = attrs.validationModelDisplayName;
						}

						innerHtml += 'di-validate="{{::validationName}}"' + 'validation-model="bindToObject[bindToProperty]"' + 'validation-message="{{::validationMessage}}"' + 'validation-model-display-name="' + displayName + '"';
					}

					return innerHtml;
				}
			}
		}

		return diUnitOfMeasureSelector;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 432 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP7R}
// di.einvoicing.ui.portal.components.unitofmeasureselector
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.controller('UnitOfMeasureController', UnitOfMeasureController);

		UnitOfMeasureController.$inject = ['$scope', 'unitOfMeasureRepository'];

		function UnitOfMeasureController(scope, unitOfMeasureRepository) {
			var vm = this;

			vm.items = [];
			vm.item = {};
			vm.onChangeAccessor = setBoundIdFromSelectedItem;

			init();

			return;

			function init() {
				var unitOfMeasurePromise;

				if (util.isDefined(scope.scopeCache)) {
					unitOfMeasurePromise = scope.scopeCache.get('unitOfMeasureRepository.getUnitsOfMeasure', unitOfMeasureRepository.getUnitsOfMeasure);
				} else {
					unitOfMeasurePromise = unitOfMeasureRepository.getUnitsOfMeasure();
				}

				unitOfMeasurePromise.then(function (data) {
					vm.items.fill(data);

					scope.$watch(function () {
						return scope.bindToObject[scope.bindToProperty];
					}, setSelectedItemFromBoundId);

					return;

					function setSelectedItemFromBoundId() {
						if (util.isDefined(vm.item.id) && scope.bindToObject[scope.bindToProperty] === vm.item.id) {
							return;
						}

						if (scope.bindToObject[scope.bindToProperty] === -1) {
							var unknownItem = {
								id: 0,
								name: scope.bindToObject[scope.bindToSecondProperty],
								commonCode: scope.bindToObject[scope.bindToSecondProperty]
							};

							var exist = _.find(vm.items, function (item) {
								return item.id === unknownItem.id;
							});

							if (util.isUndefined(exist)) {
								vm.items.push(unknownItem);
							}
							scope.bindToObject[scope.bindToProperty] = unknownItem.id;
						}

						var item = _.find(vm.items, function (item) {
							return item.id === scope.bindToObject[scope.bindToProperty];
						});

						if (util.isUndefined(item)) {
							return;
						}

						vm.item = item;

						if (util.isDefined(vm.item.name)) {
							scope.bindToObject[scope.bindToSecondProperty] = vm.item.name;
						}
					}
				});
			}

			function setBoundIdFromSelectedItem() {
				var accessor;

				scope.bindToObject[scope.bindToProperty] = (vm.item || {}).id;
				scope.bindToObject[scope.bindToSecondProperty] = (vm.item || {}).name;

				if (util.isFunction(scope.onChangeAccessor)) {
					accessor = scope.onChangeAccessor();

					if (util.isFunction(accessor)) {
						accessor(vm.item, scope.bindToObject);
					}
				}
			}
		}

		return UnitOfMeasureController;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 433 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP54}
// di.einvoicing.ui.portal.portal.invoices.viewer
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(434), __webpack_require__(435)], __WEBPACK_AMD_DEFINE_RESULT__ = function (snippetsLoader, invoiceDetailsDirectiveLoader) {
	'use strict';

	return function (module) {
		snippetsLoader(module);
		invoiceDetailsDirectiveLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 434 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP3C}
// di.einvoicing.ui.portal.portal.invoices.viewer.components.snippets
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var snippetContext = $di.angular.snippetRegistrar.createContext(module, 'src/app/portal/invoices/viewer/_components/_snippets');

        snippetContext.registerSnippet('diInvoiceDetailsHeader', 'invoiceDetailsHeader.html');
        snippetContext.registerSnippet('diInvoiceAuditSummaryHeader', 'invoiceAuditSummaryHeader.html');
        snippetContext.registerSnippet('diInvoiceDetailsFooter', 'invoiceDetailsFooter.html');
        snippetContext.registerSnippet('diInvoiceDetailsLines', 'invoiceDetailsLines.html');
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 435 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP5I}
// di.einvoicing.ui.portal.portal.invoices.viewer
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ng) {
    'use strict';

    return function (module) {
        module.directive('diInvoiceDetails', diInvoiceDetails);

        function diInvoiceDetails() {
            return {
                restrict: 'E',
                replace: true,
                scope: {},
                controller: "InvoiceViewerController",
                controllerAs: "invoiceViewerCtrl",
                templateUrl: 'src/app/portal/invoices/viewer/_components/invoiceDetails/invoiceDetails.html',
                link: link
            };

            function link(scope) {
                scope.findElement = findElement;

                return;

                function findElement(name) {
                    return ng.element(name);
                }
            }
        }

        return diInvoiceDetails;
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 436 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP06}
// di.einvoicing.ui.portal.portal.invoices.viewer
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(433), __webpack_require__(438), __webpack_require__(437)], __WEBPACK_AMD_DEFINE_RESULT__ = function (componentsLoader, invoiceViewerControllerLoader, invoiceViewDetailsButtonsConfiguratorLoader) {
	'use strict';

	return function (module) {
		componentsLoader(module);
		invoiceViewerControllerLoader(module);
		invoiceViewDetailsButtonsConfiguratorLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 437 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP0E}
// di.einvoicing.ui.portal.portal.invoices.viewer
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var guard = $di.exception.guard;

		module.provider('invoiceViewDetailsButtonsConfigurator', InvoiceViewDetailsButtonsConfigurator);

		/**
   * Manages invoice editor configuration and set up.
   */
		function InvoiceViewDetailsButtonsConfigurator() {
			var config;

			var buttonsConfiguration = {};

			// Provider definition
			var provider = {
				configure: configure,
				$get: $get
			};

			provider.$get.$inject = ['authorizedObjectsFilter', 'CLIENT_ENUMS'];

			return provider;

			/**
    * Configure the service
    * @param cfg
    */
			function configure(cfg) {
				guard.throwIfNotAnObject('EUP2H01E', cfg, 'cfg');

				config = cfg;
			}

			/**
    * Gets required configuration for the grid.
    */
			function $get(authorizedObjectsFilter, clientEnums) {

				buttonsConfiguration = {
					type: 'Invoice',
					visibleButtons: [],
					buttonsSetOne: [{
						rights: ['Buyer', 'InvoiceReader'],
						name: 'dispute',
						action: clientEnums.userActions.startDispute,
						attributesRequired: ['current']
					}, {
						rights: ['Buyer', 'InvoiceReader'],
						name: 'notDispute',
						action: clientEnums.userActions.endDispute,
						attributesRequired: ['current']
					}, {
						rights: ['Supplier'],
						name: 'cancelInvoice',
						action: clientEnums.userActions.cancelInvoice,
						attributesRequired: ['current']
					}, {
						rights: ['Buyer'],
						name: 'paid',
						action: clientEnums.userActions.markAsPaidBuyer,
						attributesRequired: ['current']
					}, {
						rights: ['Buyer'],
						name: 'notPaid',
						action: clientEnums.userActions.markAsNotPaidBuyer,
						attributesRequired: ['current']
					}, {
						rights: ['Supplier'],
						name: 'paid',
						action: clientEnums.userActions.markAsPaidSupplier,
						attributesRequired: ['current']
					}, {
						rights: ['Supplier'],
						name: 'notPaid',
						action: clientEnums.userActions.markAsNotPaidSupplier,
						attributesRequired: ['current']
					}, {
						rights: ['Buyer'],
						name: 'scheduled',
						action: clientEnums.userActions.markAsScheduledForPayment,
						attributesRequired: ['current']
					}, {
						rights: ['Buyer'],
						name: 'notScheduled',
						action: clientEnums.userActions.markAsNotScheduledForPayment,
						attributesRequired: ['current']
					}, {
						rights: ['InvoiceReader'],
						name: 'issues',
						action: clientEnums.userActions.showIssues,
						attributesRequired: ['current']
					}, {
						rights: ['Buyer'],
						name: 'release',
						action: clientEnums.userActions.release,
						attributesRequired: ['current']
					}],
					buttonsSetTwo: [{
						rights: ['InvoiceReader'],
						name: 'render',
						action: clientEnums.userActions.downloadInvoice,
						attributesRequired: ['current']
					}, {
						rights: ['InvoiceReader'],
						name: 'viewHistory',
						action: clientEnums.userActions.viewHistoryInvoice,
						attributesRequired: ['current']
					}, {
						rights: ['InvoiceReader'],
						name: 'related',
						action: clientEnums.userActions.viewRelatedDocumentsInvoice,
						attributesRequired: ['current']
					}],
					buttonsSetThree: [{
						rights: ['InvoiceWriter'],
						name: 'editBig',
						action: clientEnums.userActions.editInvoice,
						attributesRequired: ['current']
					}, {
						rights: ['InvoiceWriter'],
						name: 'submit',
						action: clientEnums.userActions.submit,
						attributesRequired: ['current']
					}]
				};

				return {
					getButtonsSetOneConfiguration: getButtonsSetOneConfiguration,
					getButtonsSetTwoConfiguration: getButtonsSetTwoConfiguration,
					getButtonsSetThreeConfiguration: getButtonsSetThreeConfiguration
				};

				function getButtonsSetOneConfiguration() {
					return getConfiguration(buttonsConfiguration.buttonsSetOne);
				}

				function getButtonsSetTwoConfiguration() {
					return getConfiguration(buttonsConfiguration.buttonsSetTwo);
				}

				function getButtonsSetThreeConfiguration() {
					return getConfiguration(buttonsConfiguration.buttonsSetThree);
				}

				function getConfiguration(array) {
					var configuration = {
						type: 'Invoice',
						visibleButtons: []
					};
					configuration.visibleButtons.fill(authorizedObjectsFilter.getAuthorizedObjects(array, true));
					return configuration;
				}
			}
		}

		return InvoiceViewDetailsButtonsConfigurator;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 438 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP5G}
// di.einvoicing.ui.portal.portal.invoices.viewer
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.controller('InvoiceViewerController', InvoiceViewerController);

		InvoiceViewerController.$inject = ['$scope', '$stateParams', 'invoiceProxy', 'partyProxy', 'auditProxy', 'diState', 'authenticationData', 'translator', 'enumTranslator', 'associativeArrayConvertor', 'scopeCacheFactory', 'authorizedObjectsFilter', 'invoiceViewDetailsButtonsConfigurator', 'currencyCache', 'CLIENT_ENUMS', 'invoiceLinesColumnSettings', 'documentStateResolver', 'userRightsRepository', 'documentAttributeResolver', 'documentProxy', 'invoiceRepository', 'documentIssuesMessageBuilder', 'staticLookupProxy', 'notificationHandler', 'modalSpinner', 'userActionsResolver', 'documentDownloader', 'scrollbarResizer', 'invoiceActionVerifier', 'attachmentProxy', 'INVOICE_ADDITIONAL_DOCUMENT_REFERENCES_CONFIGURATION', 'attachmentDownloadValidator'];

		function InvoiceViewerController(scope, stateParams, invoiceProxy, partyProxy, auditProxy, diState, authenticationData, translator, enumTranslator, associativeArrayConvertor, scopeCacheFactory, authorizedObjectsFilter, invoiceViewDetailsButtonsConfigurator, currencyCache, clientEnums, invoiceLinesColumnSettings, documentStateResolver, userRightsRepository, documentAttributeResolver, documentProxy, invoiceRepository, documentIssuesMessageBuilder, staticLookupProxy, notificationHandler, modalSpinner, userActionsResolver, documentDownloader, scrollbarResizer, invoiceActionVerifier, attachmentProxy, additionalDocumentReferencesTableConfiguration, attachmentDownloadValidator) {
			var vm = this;

			var schemeTranslationPrefix = "EINVOICING.COMPONENTS.CLIENT_ENUMS.SCHEMES.";

			vm.mode = 'current';
			var functionToGetInvoice;
			var parameterToGetInvoice;
			var spinner;

			vm.mode = 'current';

			vm.invoice = {
				lines: [],
				attributes: [],
				actions: [],
				supplierPartyId: {},
				allowancesCharges: []
			};

			vm.invoiceDocumentIssuesDetails = {
				visible: false,
				loaded: false,
				message: ''
			};

			vm.auditSummary = {};

			vm.productTypes = [];
			vm.scopeCache = scopeCacheFactory.create(scope);
			vm.countries = [];
			vm.currentState = '...';
			vm.selectedStates = [];
			vm.selectedAttributes = [];
			vm.selectedActions = [];
			vm.invoiceDetailsChangeSubscriptions = [];
			vm.labels = {};
			vm.invoiceCountry = {};
			vm.buttonsSetOneOptions = {};
			vm.buttonsSetTwoOptions = {};
			vm.buttonsSetThreeOptions = {};
			vm.settings = {};
			vm.submitting = false;
			vm.supplierId = {};
			vm.supplierAddress = {};
			vm.buyerAddress = {};
			vm.deliveryAddress = {};
			vm.countOfAttachments = 0;
			vm.languageKey = "EINVOICING.PORTAL.INVOICES.COMPONENTS.PRODUCT_LINES";
			vm.supplierContactDetails = {};
			vm.customerContactDetails = {};
			vm.hasMainActions = true;
			vm.additionalDocumentReferencesConfiguration = additionalDocumentReferencesTableConfiguration;

			vm.subscribeToInvoiceDetailsChange = subscribeToInvoiceDetailsChange;
			vm.getRenderedInvoice = getRenderedInvoice;
			vm.releaseInvoice = releaseInvoice;
			vm.changeInvoiceDisputeFlag = changeInvoiceDisputeFlag;
			vm.voidInvoice = voidInvoice;
			vm.changeInvoicePaidState = changeInvoicePaidState;
			vm.flagAsScheduledForPayment = flagAsScheduledForPayment;
			vm.backToList = backToList;
			vm.goToEdit = goToEdit;
			vm.goToHistory = goToHistory;
			vm.goToRelated = goToRelated;
			vm.goToViewCurrent = goToViewCurrent;
			vm.viewInvoiceDocumentIssues = viewInvoiceDocumentIssues;
			vm.viewDocumentAttachments = viewDocumentAttachments;
			vm.submit = submit;
			vm.resizeHorizontalScrollbar = scrollbarResizer.resizeHorizontalScrollbar;
			vm.downloadAttachment = downloadAttachment;
			vm.downloadAllAttachments = downloadAllAttachments;

			init();

			return;

			/**
    * Initialises UI and loads data            
    */
			function init() {
				scrollbarResizer.monitorHorizontalBrowserScrollbar();

				vm.buttonsSetOneOptions = invoiceViewDetailsButtonsConfigurator.getButtonsSetOneConfiguration();
				vm.buttonsSetTwoOptions = invoiceViewDetailsButtonsConfigurator.getButtonsSetTwoConfiguration();
				vm.buttonsSetThreeOptions = invoiceViewDetailsButtonsConfigurator.getButtonsSetThreeConfiguration();

				_.each(invoiceLinesColumnSettings.columns, function (col) {
					col.editable = false;
				});

				vm.settings = invoiceLinesColumnSettings;
				if (util.isNumber(stateParams.id)) {
					if (util.isNumber(stateParams.aid)) {
						vm.mode = 'audit';
						functionToGetInvoice = invoiceProxy.getDetailsByAuditId;
						parameterToGetInvoice = stateParams.aid;
					} else {
						functionToGetInvoice = invoiceProxy.getDetailsById;
						parameterToGetInvoice = stateParams.id;
					}
				} else if (util.isNonEmptyString(stateParams.invoiceNumber)) {
					functionToGetInvoice = invoiceProxy.getDetailsByInvoiceNumber;
					parameterToGetInvoice = stateParams.invoiceNumber;
				} else {
					notificationHandler.showError('EINVOICING.PORTAL.INVOICES.VIEWER.');
				}

				setLabels();

				staticLookupProxy.get('Country').then(getCountriesSuccess);

				if (functionToGetInvoice) {
					showSpinner();
					functionToGetInvoice(parameterToGetInvoice).then(invoiceResolved, invoiceRejected);
				}

				return;

				function loadAuditSummary() {
					auditProxy.getAuditRecordForDocument(vm.invoice.documentId, stateParams.aid).then(auditResolved, auditRejected);

					return;

					function auditResolved(data) {
						enumTranslator.translate(clientEnums.eventType, data.eventTypeId).then(function (translated) {
							data.eventTypeName = translated;

							vm.auditSummary = data;
						});
					}

					function auditRejected() {}
				}

				function getCountriesSuccess(data) {
					vm.countries.fill(data);
				}

				/**
     * sets labels values depending on user rights           
     */
				function setLabels() {
					var data = [{
						rights: ["Supplier"],
						key: "title",
						label: "EINVOICING.PORTAL.INVOICES.VIEWER.HEADER.TITLE_SUPPLIER"
					}, {
						rights: ["Buyer"],
						key: "title",
						label: "EINVOICING.PORTAL.INVOICES.VIEWER.HEADER.TITLE_BUYER"
					}, {
						rights: ["Supplier"],
						key: "audit_title",
						label: "EINVOICING.PORTAL.INVOICES.VIEWER.HEADER.AUDIT_TITLE_SUPPLIER"
					}, {
						rights: ["Buyer"],
						key: "audit_title",
						label: "EINVOICING.PORTAL.INVOICES.VIEWER.HEADER.AUDIT_TITLE_BUYER"
					}];

					vm.labels = authorizedObjectsFilter.getAuthorizedObjectsAsAssociative(data, 'key', 'label');
				}

				/**
    *  Loads invoice data     "EUP5G01E"
    */
				function invoiceResolved(data) {
					setSelectedCountry(data.country);
					vm.supplierId = data.supplierPartyId;

					enumTranslator.translateCollection(clientEnums.productType, data.lines, "productType", "productTypeName");
					util.extend(vm.invoice, _.omit(data, 'additionalDocumentReferences'));
					//components one-way bindings watch reference changes (the default of scope.$watch's third param - objectEquality - is false)
					vm.invoice.additionalDocumentReferences = data.additionalDocumentReferences;

					setTaxExemptionReason();
					setAttributes();
					setActions();

					vm.hasMainActions = setMainActionsFlag();

					vm.invoice.allowancesCharges = data.allowancesCharges;

					_.each(vm.invoice.allowancesCharges, function (item) {
						item.taxAmount = item.amount - item.netAmount;
					});

					setState(vm.invoice.clientDocumentState);

					setCurrencies();
					if (vm.mode === "audit") {
						loadAuditSummary();
					}

					setParties();
					setContacts();
					setLegal();
					setAddresses();
					setInvoiceType();

					vm.countOfAttachments = data.countOfAttachments;

					viewInvoiceDocumentIssues(_.find(data.attributes, function (attribute) {
						return attribute === clientEnums.documentAttribute.businessInvalid || attribute === clientEnums.documentAttribute.reconciliationFailed || attribute === clientEnums.documentAttribute.xsltInvalid;
					}));

					return;

					function setInvoiceType() {
						if (util.isDefined(vm.invoice.invoiceTypeId) === false || vm.invoice.invoiceTypeId <= 0) {
							vm.invoice.invoiceTypeId = 1;
						}

						enumTranslator.translate(clientEnums.invoiceType, vm.invoice.invoiceTypeId).then(function (translated) {
							vm.invoice.invoiceType = translated;
						});
					}

					function setAttributes() {
						var array = documentAttributeResolver.resolveAttributeKeys(vm.invoice.attributes);

						vm.selectedAttributes.fill(array);

						if (vm.mode === 'current') {
							addAttribute(clientEnums.documentAttribute.current);
						}

						if (userRightsRepository.userHasRight("Supplier")) {
							removeAttribute(clientEnums.documentAttribute.notScheduledForPayment);
							removeAttribute(clientEnums.documentAttribute.scheduledForPayment);
						}
					}

					function setTaxExemptionReason() {
						_.each(vm.invoice.taxBreakdown, function (taxItem) {
							if (taxItem.taxCategory && taxItem.taxCategory.toUpperCase() === "E") {
								vm.invoice.taxExemptionReason = taxItem.taxExemptionReason;
							}
						});
					}

					/**
      * Sets invoice parties details for sub-directives					
      */
					function setParties() {
						//TODO:- perform transalation before creating object

						vm.supplierParty = {
							partyName: vm.invoice.supplierName,
							partyCode: vm.invoice.supplierCode,
							partyIdentifierScheme: translator.instantTranslate(schemeTranslationPrefix + vm.invoice.supplierCodeScheme),
							vatNumber: vm.invoice.supplierVatNumber,
							vatNumberScheme: translator.instantTranslate(schemeTranslationPrefix + vm.invoice.supplierVatNumberScheme),
							endpointId: vm.invoice.supplierEndpointIdentifier,
							endpointIdentifierScheme: translator.instantTranslate(schemeTranslationPrefix + vm.invoice.supplierEndpointIdentifierScheme)
						};

						vm.supplierParty.isVisible = checkObjectSectionIsVisible(vm.supplierParty);

						vm.customerParty = {
							partyName: vm.invoice.customerName,
							partyCode: vm.invoice.customerCode,
							partyIdentifierScheme: translator.instantTranslate(schemeTranslationPrefix + vm.invoice.customerCodeScheme),
							vatNumber: vm.invoice.buyerVatNumber,
							vatNumberScheme: translator.instantTranslate(schemeTranslationPrefix + vm.invoice.buyerVatNumberScheme),
							endpointId: vm.invoice.buyerEndpointIdentifier,
							endpointIdentifierScheme: translator.instantTranslate(schemeTranslationPrefix + vm.invoice.buyerEndpointIdentifierScheme)
						};

						vm.customerParty.isVisible = checkObjectSectionIsVisible(vm.customerParty);

						vm.deliveryParty = {
							partyName: vm.invoice.deliveryPartyName,
							partyCode: vm.invoice.deliveryPartyCode
						};

						vm.deliveryParty.isVisible = checkObjectSectionIsVisible(vm.deliveryParty);

						vm.payeeParty = {
							partyName: vm.invoice.payeeName,
							regId: vm.invoice.payeeVatNumber,
							regIdScheme: translator.instantTranslate(schemeTranslationPrefix + vm.invoice.payeeVatNumberScheme),
							partyCode: vm.invoice.payeePartyIdentifier,
							partyIdentifierScheme: translator.instantTranslate(schemeTranslationPrefix + vm.invoice.payeePartyIdentifierScheme)
						};

						vm.payeeParty.isVisible = checkObjectSectionIsVisible(vm.payeeParty, ['partyIdentifierScheme', 'regIdScheme']);

						vm.taxRepresentativeParty = {
							partyName: vm.invoice.taxRepresentativePartyName,
							vatNumber: vm.invoice.taxRepresentativePartyVatNumber,
							vatNumberScheme: translator.instantTranslate(schemeTranslationPrefix + vm.invoice.taxRepresentativePartyVatNumberScheme)
						};

						vm.taxRepresentativeParty.isVisible = checkObjectSectionIsVisible(vm.taxRepresentativeParty, ['vatNumberScheme']);
					}

					/**
      * Sets invoice parties contacts details for sub-directives					
      */
					function setContacts() {
						vm.supplierContact = {
							Name: vm.invoice.billFromContactName,
							Telephone: vm.invoice.billFromContactTelephone,
							Fax: vm.invoice.billFromContactFax,
							Email: vm.invoice.billFromContactEmail,
							Reference: vm.invoice.billFromContactReference
						};

						vm.supplierContact.isVisible = checkObjectSectionIsVisible(vm.supplierContact);

						vm.customerContact = {
							Name: vm.invoice.billToContactName,
							Telephone: vm.invoice.billToContactTelephone,
							Fax: vm.invoice.billToContactFax,
							Email: vm.invoice.billToContactEmail,
							Reference: vm.invoice.billToContactReference
						};

						vm.customerContact.isVisible = checkObjectSectionIsVisible(vm.customerContact);
					}

					/**
      * Sets invoice parties legal entity details for sub-directives					
      */
					function setLegal() {
						vm.supplierLegal = {
							registrationName: vm.invoice.supplierLegalRegistrationName,
							companyReference: vm.invoice.supplierLegalCompanyReference,
							cityName: vm.invoice.supplierLegalTown,
							countryName: resolveCountryNameByCode(vm.invoice.supplierLegalCountry)
						};

						vm.supplierLegal.isVisible = checkObjectSectionIsVisible(vm.supplierLegal);

						vm.customerLegal = {
							registrationName: vm.invoice.buyerCustomerLegalRegistrationName,
							companyReference: vm.invoice.buyerCustomerLegalCompanyReference
						};

						vm.customerLegal.isVisible = checkObjectSectionIsVisible(vm.customerLegal);

						vm.payeeLegal = {
							registrationName: '',
							companyReference: vm.invoice.payeeLegalCompanyReference
						};

						vm.payeeLegal.isVisible = checkObjectSectionIsVisible(vm.payeeLegal);
					}

					/**
      * Sets invoice parties addresses details for sub-directives					
      */
					function setAddresses() {
						vm.supplierAddress = {
							Name: vm.invoice.supplierAddressName,
							AddressLine1: vm.invoice.supplierAddressLine1,
							AddressLine2: vm.invoice.supplierAddressLine2,
							AddressTown: vm.invoice.supplierAddressTown,
							AddressCounty: vm.invoice.supplierAddressCounty,
							PostCode: vm.invoice.supplierPostCode,
							Country: resolveCountryNameByCode(vm.invoice.supplierCountry),
							LocationIdentifier: vm.invoice.supplierLocationIdentifier,
							showName: vm.invoice.supplierAddressName !== vm.invoice.supplierName
						};

						if (vm.supplierAddress.showName === false) {
							vm.supplierAddress.Name = '';
						}

						vm.supplierAddress.isVisible = checkObjectSectionIsVisible(vm.supplierAddress);

						vm.customerAddress = {
							Name: vm.invoice.addressName,
							AddressLine1: vm.invoice.addressLine1,
							AddressLine2: vm.invoice.addressLine2,
							AddressTown: vm.invoice.addressTown,
							AddressCounty: vm.invoice.addressCounty,
							PostCode: vm.invoice.postCode,
							Country: resolveCountryNameByCode(vm.invoice.country),
							showName: vm.invoice.addressName !== vm.invoice.customerName
						};

						if (vm.customerAddress.showName === false) {
							vm.customerAddress.Name = '';
						}

						vm.customerAddress.isVisible = checkObjectSectionIsVisible(vm.customerAddress);

						vm.deliveryAddress = {
							Name: vm.invoice.deliveryAddressName,
							AddressLine1: vm.invoice.deliveryAddressLine1,
							AddressLine2: vm.invoice.deliveryAddressLine2,
							AddressTown: vm.invoice.deliveryAddressTown,
							AddressCounty: vm.invoice.deliveryAddressCounty,
							PostCode: vm.invoice.deliveryPostCode,
							Country: resolveCountryNameByCode(vm.invoice.deliveryCountry),
							LocationIdentifier: vm.invoice.deliveryLocationIdentifier,
							LocationIdentifierScheme: translator.instantTranslate(schemeTranslationPrefix + vm.invoice.deliveryLocationIdentifierScheme),
							showName: vm.invoice.deliveryAddressName !== vm.invoice.deliveryPartyName
						};

						if (vm.deliveryAddress.showName === false) {
							vm.deliveryAddress.Name = '';
						}

						vm.deliveryAddress.isVisible = checkObjectSectionIsVisible(vm.deliveryAddress, ['Name', 'LocationIdentifierScheme']);
					}

					function checkObjectSectionIsVisible(object, additionalIgnored) {
						var ignoredProperties = ['showName'];
						var ignored = [];

						if (util.isArray(additionalIgnored)) {

							ignoredProperties = _.union(ignoredProperties, additionalIgnored);
						}

						return util.isAnyObjectPropertyDefined(object, ignoredProperties);
					}

					/**
     * resolves country name by code                
     */
					function resolveCountryNameByCode(code) {
						var country = _.find(vm.countries, function (item) {
							return item.code === code;
						});

						if (util.isDefined(country)) {
							return country.name;
						}

						return code;
					}

					/**
      * Tests if main actions are visible                     
      */
					function setMainActionsFlag() {
						if (!userRightsRepository.userHasRight("InvoiceWriter")) {
							return false;
						}

						return invoiceCanBeEdited(vm.invoice) || invoiceCanBeSubmitted(vm.invoice);

						function invoiceCanBeEdited(invoice) {
							return invoiceActionVerifier.canBeEdited(invoice);
						}

						function invoiceCanBeSubmitted(invoice) {
							return invoiceActionVerifier.canBeSubmitted(invoice);
						}
					}

					function setCurrencies() {
						currencyCache.getCurrencies().then(resolved);

						return;

						function resolved() {
							removeSpinner();

							notifyInvoiceDetailsChangeSubscribers({
								currencyId: vm.invoice.currencyId
							});

							vm.invoice.currency = currencyCache.getCurrencyById(vm.invoice.currencyId);
							vm.invoice.taxCurrency = currencyCache.getCurrencyById(vm.invoice.taxCurrencyId);
						}
					}

					function notifyInvoiceDetailsChangeSubscribers(notificationObject) {
						for (var i = 0; i < vm.invoiceDetailsChangeSubscriptions.length; i++) {
							vm.invoiceDetailsChangeSubscriptions[i](notificationObject);
						}
					}

					function setSelectedCountry(code) {
						var country = _.find(vm.countries, function (country) {
							return country.code === code;
						});

						if (util.isUndefined(country)) {
							country = _.find(vm.countries, function (country) {
								return country.name === code;
							});
						}

						if (util.isUndefined(country)) {
							country = _.find(vm.countries, function (country) {
								return country.code === "GB";
							});
						}

						if (util.isUndefined(country)) {
							country = vm.countries[0];
						}

						if (util.isDefined(country)) {
							vm.invoiceCountry = country;
							vm.invoice.country = country.code;
						}
					}
				}

				/**
     * Notifies about failure while loading invoice data				
     */
				function invoiceRejected() {
					removeSpinner();
					notificationHandler.showError('EINVOICING.PORTAL.INVOICES.EDITOR.COULD_NOT_LOAD_INVOICE', parameterToGetInvoice);
					backToList();
				}
			}

			/**
    * calls dependency to download rendered invoice             
    */
			function getRenderedInvoice() {
				documentDownloader.downloadRenderedInvoice(vm.invoice.documentId);
			}

			/**
    * Releases mismatched invoice			 
    */
			function releaseInvoice() {
				invoiceRepository.releaseInvoice(vm.invoice.documentId, vm.invoice.number).then(resolved);

				return;

				function resolved(response) {
					if (response[vm.invoice.documentId]) {
						notificationHandler.showSuccess("EINVOICING.PORTAL.INVOICES.ACTIONS.NOTIFICATION.SUCCESS.RELEASED", vm.invoice.number);

						reloadDocumentState();
						reloadDocumentActions();
					} else {
						notificationHandler.showError("EINVOICING.PORTAL.INVOICES.ACTIONS.NOTIFICATION.ERROR.RELEASED", vm.invoice.number);
					}
				}
			}

			function changeInvoiceDisputeFlag(inDispute) {
				var disputeReason = '';

				if (inDispute) {
					disputeReason = 'not implemented';
				}

				invoiceRepository.flagInDisputeInvoice(vm.invoice.documentId, disputeReason, inDispute, vm.invoice.number).then(resolved);

				return;

				function resolved() {
					reloadDocumentState();
					reloadDocumentActions();
				}
			}

			/**
    * changes invoice state to voided
    * @returns {} 
    */
			function voidInvoice() {
				invoiceRepository.voidInvoice(vm.invoice.documentId, vm.invoice.number).then(resolved);

				return;

				function resolved() {
					reloadDocumentState();
					reloadDocumentActions();
				}
			}

			/**
    * changes invoice state to paid or not paid
    */
			function changeInvoicePaidState(isPaid) {
				invoiceRepository.flagPaidInvoice(vm.invoice.documentId, isPaid, vm.invoice.number).then(resolved);

				return;

				function resolved() {
					reloadDocumentState();
					reloadDocumentActions();
				}
			}

			/**
    * marks invoice as scheduled for payment or not		
    */
			function flagAsScheduledForPayment(scheduled) {
				invoiceRepository.flagAsScheduledForPayment(vm.invoice.documentId, scheduled, vm.invoice.number).then(resolved);

				return;

				function resolved() {
					reloadDocumentState();
					reloadDocumentActions();
				}
			}

			/**
    * subscribes to invoice details change event           
    */
			function subscribeToInvoiceDetailsChange(subscription) {
				vm.invoiceDetailsChangeSubscriptions.push(subscription);

				subscription({ currencyId: vm.invoice.currencyId });
			}

			/**
    * navigates back to list view
    */
			function backToList() {
				diState.go('portal.invoices.list');
			}

			/**
    * Goes to invoice edit screen			 
    */
			function goToEdit() {
				diState.go('portal.invoices.editById', { id: vm.invoice.headerId });
			}

			/**
    * Navigatest to history list page			 
    */
			function goToHistory() {
				diState.go('portal.audit.list', { id: vm.invoice.documentId });
			}

			function goToRelated() {
				diState.go('portal.related.list', { id: vm.invoice.documentId });
			}

			/**
    * Navigates to view page for current invoice			 
    */
			function goToViewCurrent() {
				diState.go('portal.invoices.viewById', { id: vm.invoice.headerId });
			}

			/**
    * Loads current document state from db			 
    */
			function reloadDocumentState() {
				documentProxy.getDocumentClientStateId(vm.invoice.headerId, clientEnums.documentType.invoice).then(resolved);

				return;

				function resolved(stateId) {
					setState(stateId);
				}
			}

			/**
    * Sets current state for invoice			
    */
			function setState(stateId) {
				var state = documentStateResolver.getDocumentState(stateId);

				vm.invoice.clientDocumentState = stateId;
				vm.selectedStates.fill(state);

				updateCurrentState(stateId);
			}

			/**
    * Updates current state to calculated			 
    */
			function updateCurrentState() {
				documentStateResolver.calculateCurrentState('invoice', vm.invoice.clientDocumentState, true).then(function (calculated) {
					vm.currentState = calculated;
				});
			}

			/**
          * Adds attribute			 
          */
			function addAttribute(aId) {
				documentAttributeResolver.addAttributeById(vm.selectedAttributes, aId);
			}

			/**
    * Removes attribute			 
    */
			function removeAttribute(aId) {
				documentAttributeResolver.removeAttribute(vm.selectedAttributes, aId);
			}

			/**
    * Method which sets the visibility of the errors panel 
    * If not currently loaded then failure details are loaded from the invoice proxy
    * @param newVisibility - Whether the failure details panel should be visible
    */
			function viewInvoiceDocumentIssues(visible) {
				vm.invoiceDocumentIssuesDetails.visible = visible;

				if (visible && vm.invoiceDocumentIssuesDetails.loaded === false) {
					invoiceProxy.getInvoiceDocumentIssues(vm.invoice.headerId).then(invoiceDocumentIssuesResolved, invoiceDocumentIssuesRejected);
				}

				return;

				function invoiceDocumentIssuesResolved(documentIssuesModel) {
					vm.invoiceDocumentIssuesDetails.loaded = true;

					vm.invoiceDocumentIssuesDetails.message = documentIssuesMessageBuilder.buildMessage(documentIssuesModel, true);
				}

				function invoiceDocumentIssuesRejected() {
					notificationHandler.showError('EINVOICING.PORTAL.INVOICES.COMPONENTS.ERRORS.COULD_NOT_LOAD_ERROR_DETAILS');
				}
			}

			/**
    * Changes the visibility of the attachments section
    */
			function viewDocumentAttachments() {
				diState.go('portal.attachments.viewByDocumentId', {
					documentId: vm.invoice.documentId,
					invoiceId: vm.invoice.headerId
				});
			}

			/**
    * submits invoice             
    */
			function submit() {
				vm.submitting = true;
				invoiceRepository.submitInvoiceByDocumentId(vm.invoice.documentId, vm.invoice.number).then(resolved);

				return;

				function resolved() {
					reloadDocumentState();
					reloadDocumentActions();
				}
			}

			/**
    * Reloads invoice allowed actions           
    */
			function reloadDocumentActions() {
				invoiceRepository.getAllowedActions(vm.invoice.documentId, vm.invoice.number).then(resolved);
				return;

				function resolved(data) {
					vm.invoice.actions.fill(data);
					setActions();
				}
			}

			function setActions() {
				var resolvedActions = userActionsResolver.resolveActions(vm.invoice.actions, false);

				vm.selectedActions.fill(resolvedActions);
			}

			/**
    * Adds spinner to the page			 
    */
			function showSpinner() {
				spinner = modalSpinner.showModalSpinner("#spinnerHolder");
			}

			/**
    * Removes spinner from the page
   */
			function removeSpinner() {
				if (spinner) {
					spinner.remove();
				}
			}

			/**
    * Downloads the attachment for the attachment data id
    */
			function downloadAttachment(attachmentDataId, filename) {
				if (attachmentDownloadValidator.allowDownloadSingleFile(filename)) {
					attachmentProxy.downloadFile(attachmentDataId);
				}
			}

			/**
    * Downloads all the attachments
    */
			function downloadAllAttachments() {
				var attachmentDataIds = [];

				if (attachmentDownloadValidator.allowDownloadMultipleFiles(vm.invoice.additionalDocumentReferences, attachmentDataIds)) {
					attachmentProxy.downloadZipFile(attachmentDataIds);
				}
			}
		}

		return InvoiceViewerController;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 439 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(440), __webpack_require__(453), __webpack_require__(76), __webpack_require__(85), __webpack_require__(445), __webpack_require__(441), __webpack_require__(451), __webpack_require__(84)], __WEBPACK_AMD_DEFINE_RESULT__ = function (statesLoader, sharedLoader, contactsLoader, locationsLoader, listLoader, discoveryLoader, partyCodesLoader, componentsLoader) {
	'use strict';

	return function (module) {
		statesLoader(module);
		sharedLoader(module);
		contactsLoader.load(module);
		locationsLoader.load(module);
		listLoader(module);
		discoveryLoader(module);
		partyCodesLoader(module);
		componentsLoader.load(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 440 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.config(configurePartiesStates);

		configurePartiesStates.$inject = ['stateHelperProvider'];
		function configurePartiesStates(stateHelperProvider) {
			stateHelperProvider.addStates({
				templateBaseUrl: "src/app/portal/parties/_states",
				parentStateName: 'portal.parties',
				states: [{
					stateName: "list",
					url: 'list?{forPartyId:int}&{sortOption:int}&{searchText}',
					params: {
						forPartyId: undefined,
						sortOption: undefined,
						searchText: undefined,
						pageTitle: undefined,
						pageNumber: undefined,
						ownStateName: 'portal.parties.list'
					}
				}, {
					stateName: "viewer",
					onlyCreateStateCollection: true,
					stateCollection: [{
						stateName: "viewById",
						url: 'id/{id:int}?{forPartyId:int}&{locationSortOption:int}&{contactSortOption:int}&{singleDetails}',
						params: {
							id: 0,
							forPartyId: 0,
							locationSortOption: undefined,
							contactSortOption: undefined,
							partyName: undefined,
							forPartyName: undefined,
							ownStateName: 'portal.parties.viewById',
							singleDetails: 'false'
						}
					}]
				}, {
					stateName: "mylist",
					params: {
						forPartyId: undefined,
						sortOption: undefined,
						searchText: undefined,
						pageTitle: undefined,
						pageNumber: undefined,
						ownStateName: 'portal.parties.mylist'
					}
				}]
			});
		}
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 441 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(443), __webpack_require__(442), __webpack_require__(444)], __WEBPACK_AMD_DEFINE_RESULT__ = function (discoverPartiesListComponentLoader, discoverPartiesListConfigurationServiceLoader, discoveredPartyDetailsComponentLoader) {
    'use strict';

    return function (module) {
        module.component(discoverPartiesListComponentLoader.DiscoverPartiesListComponent.selector, discoverPartiesListComponentLoader.DiscoverPartiesListComponent);
        module.service('discoverPartiesListConfigurationService', discoverPartiesListConfigurationServiceLoader.DiscoverPartiesListConfigurationService);
        module.component(discoveredPartyDetailsComponentLoader.DiscoveredPartyDetailsComponent.selector, discoveredPartyDetailsComponentLoader.DiscoveredPartyDetailsComponent);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 442 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _columns = Symbol('columns');
var _tableOptions = Symbol('tableOptions');

var DiscoverPartiesListConfigurationService = function () {
    function DiscoverPartiesListConfigurationService() {
        _classCallCheck(this, DiscoverPartiesListConfigurationService);

        this.getTableOptions = this.getTableOptions.bind(this);

        this[_tableOptions] = {
            enableSelect: true,
            multiSelect: false,
            enablePaging: true,
            fixedHeight: true,
            maxItemsToShow: 500,
            paginationPageSize: 5,
            paginationPageNumber: 1,
            maxButtonsShown: 3
        };

        this[_columns] = [{
            field: 'nameAndFirstAddressLine',
            headerCellClass: "collapse",
            template: '<div>\n                    <div>\n                        <span>{{binding.addressBookEntry.party.name}}</span>\n                    </div>\n                    <div>\n                        <span>{{binding.addressBookEntry.resource.line1 || binding.addressBookEntry.resource.country}}</span>\n                    </div>                    \n                </div>'
        }];
    }

    _createClass(DiscoverPartiesListConfigurationService, [{
        key: 'getTableOptions',
        value: function getTableOptions() {
            var tableOptions = angular.copy(this[_tableOptions]);
            tableOptions.columns = this[_columns];
            return Promise.resolve(tableOptions);
        }
    }]);

    return DiscoverPartiesListConfigurationService;
}();

DiscoverPartiesListConfigurationService.prototype.constructor.$inject = [];

exports.DiscoverPartiesListConfigurationService = DiscoverPartiesListConfigurationService;

/***/ }),
/* 443 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var util = $di.utility.util;

var DiscoverPartiesListComponent = exports.DiscoverPartiesListComponent = {
    templateUrl: 'src/app/portal/parties/discovery/discover-parties-list.component.html',
    selector: 'diDiscoverPartiesList',
    bindings: {
        partyId: "<",
        onTradingPartyIdChanged: "&"
    },
    controllerAs: 'discoverPartiesListCtrl',
    controller: function () {
        function DiscoverPartiesListController(partyProxy, discoverPartiesListConfigurationService, $q) {
            _classCallCheck(this, DiscoverPartiesListController);

            this.partyProxy = partyProxy;
            this.discoverPartiesListConfigurationService = discoverPartiesListConfigurationService;
            this.$q = $q;

            this.search = this.search.bind(this);
            this.selectedItemChanged = this.selectedItemChanged.bind(this);
            this.resetSelection = this.resetSelection.bind(this);
        }

        _createClass(DiscoverPartiesListController, [{
            key: '$onInit',
            value: function $onInit() {
                var _this = this;

                var tableOptionsPromise = this.discoverPartiesListConfigurationService.getTableOptions().then(function (tableOptions) {
                    _this.tableOptions = tableOptions;
                });
                this.resetSelection();
            }
        }, {
            key: 'search',
            value: function search(withDelay) {
                if (withDelay) {
                    if (!this.delayStarted) {
                        this.delayStarted = true;
                        _.debounce(this.searchNoDelay, 1000).bind(this)();
                    }
                } else {
                    this.searchNoDelay();
                }
            }
        }, {
            key: 'searchNoDelay',
            value: function searchNoDelay() {
                var _this2 = this;

                this.loading = true;
                if (util.isNullOrUndefined(this.searchText) || this.searchText === '') {
                    this.parties = [];
                    this.allParties = [];
                    this.resetSelection();
                    this.loading = false;
                    this.delayStarted = false;
                } else {
                    this.partyProxy.discoverPotentialTradingRelationshipParties(this.partyId, this.searchText).then(function (data) {
                        _this2.allParties = data;
                        _this2.parties = _.filter(_this2.allParties, function (party) {
                            return party.addressBookEntry.party.isAccountingCustomer == false;
                        });
                        _this2.resetSelection();
                    }).finally(function () {
                        _this2.loading = false;
                        _this2.delayStarted = false;
                    });
                }
            }
        }, {
            key: 'selectedItemChanged',
            value: function selectedItemChanged(items) {
                var _this3 = this;

                if (util.isNonEmptyArray(items) && items.length === 1) {

                    var selectedItem = items[0];

                    var partyId = selectedItem.addressBookEntry.party.isAccountingCustomer ? selectedItem.addressBookEntry.party.buyers[0].id : selectedItem.addressBookEntry.party.id;

                    this.party = selectedItem.addressBookEntry.party.id === partyId ? selectedItem : _.find(this.parties, function (party) {
                        return party.addressBookEntry.party.id === partyId;
                    });

                    var accountingCustomerForThisBuyer = _.find(this.allParties, function (party) {
                        if (party.addressBookEntry.party.isAccountingCustomer) {
                            var selectedBuyer = _.find(party.addressBookEntry.party.buyers, function (buyer) {
                                return buyer.id === _this3.party.addressBookEntry.party.id;
                            });

                            if (util.isDefined(selectedBuyer)) {
                                return party;
                            }
                        }
                    });

                    this.accountingParties = [accountingCustomerForThisBuyer];

                    this.onTradingPartyIdChanged({ tradingPartyId: this.party.addressBookEntry.party.id });
                } else {
                    this.resetSelection();
                }
            }
        }, {
            key: 'resetSelection',
            value: function resetSelection() {
                this.party = undefined;
                this.accountingParties = undefined;

                this.onTradingPartyIdChanged({ tradingPartyId: undefined });
            }
        }]);

        return DiscoverPartiesListController;
    }()
};

DiscoverPartiesListComponent.controller.prototype.constructor.$inject = ['partyProxy', 'discoverPartiesListConfigurationService', '$q'];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 444 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DiscoveredPartyDetailsComponent = exports.DiscoveredPartyDetailsComponent = {
    templateUrl: 'src/app/portal/parties/discovery/discovered-party-details.component.html',
    selector: 'diDiscoveredPartyDetails',
    bindings: {
        partyName: '<',
        address: '<',
        identifiers: '<',
        endpoints: '<'
    },
    transclude: {
        'heading': '?diDiscoveredPartyDetailsHeading'
    },
    controllerAs: 'discoveredPartyDetailsCtrl',
    controller: function DiscoveredPartyDetailsController() {
        _classCallCheck(this, DiscoveredPartyDetailsController);
    }
};

DiscoveredPartyDetailsComponent.controller.prototype.constructor.$inject = [];

/***/ }),
/* 445 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(448), __webpack_require__(447), __webpack_require__(449), __webpack_require__(446), __webpack_require__(450)], __WEBPACK_AMD_DEFINE_RESULT__ = function (partyListComponentLoader, partyListTableConfigurationServiceLoader, partySelectorComponentLoader, allocatedToPartyListComponentLoader, workingForPartyListComponentLoader) {
    'use strict';

    return function (module) {
        module.component(partyListComponentLoader.PartyListComponent.selector, partyListComponentLoader.PartyListComponent);
        module.service('PartyListTableConfigurationService', partyListTableConfigurationServiceLoader.PartyListTableConfigurationService);
        module.component(partySelectorComponentLoader.PartySelectorComponent.selector, partySelectorComponentLoader.PartySelectorComponent);
        module.component(allocatedToPartyListComponentLoader.AllocatedToPartyListComponent.selector, allocatedToPartyListComponentLoader.AllocatedToPartyListComponent);
        module.component(workingForPartyListComponentLoader.WorkingForPartyListComponent.selector, workingForPartyListComponentLoader.WorkingForPartyListComponent);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 446 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _pageTitleOptions = Symbol('pageTitleOptions');

var AllocatedToPartyListComponent = exports.AllocatedToPartyListComponent = {
    templateUrl: 'src/app/portal/parties/list/allocated-to-party-list.component.html',
    selector: 'diAllocatedToPartyList',
    controller: function () {
        function controller(partyProxy) {
            _classCallCheck(this, controller);

            this.partyProxy = partyProxy;

            this.getSearchResults = this.getSearchResults.bind(this);

            this[_pageTitleOptions] = [{
                rights: ["Supplier"],
                languageKey: 'EINVOICING.PORTAL.PARTIES.LIST.PAGE_TITLE.BUYERS'
            }, {
                rights: ["Buyer"],
                languageKey: 'EINVOICING.PORTAL.PARTIES.LIST.PAGE_TITLE.SUPPLIERS'
            }];
        }

        _createClass(controller, [{
            key: '$onInit',
            value: function $onInit() {
                var _this = this;

                this.addEnabled = true;
                this.pageTitleOptions = this[_pageTitleOptions];
                this.partyProxy.getAllPartiesUserCanWorkFor(0).then(function (data) {
                    _this.relatedParties = data;
                });
            }
        }, {
            key: 'getSearchResults',
            value: function getSearchResults() {
                var _this2 = this;

                var searchText = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
                var relatedPartyId = arguments[1];

                return this.partyProxy.getPartyManagementSearchResults(relatedPartyId, searchText).then(function (data) {
                    _this2.partyManagementSearchResults = data;
                });
            }
        }]);

        return controller;
    }()
};

AllocatedToPartyListComponent.controller.prototype.constructor.$inject = ['partyProxy'];

/***/ }),
/* 447 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PartyListTableConfigurationService = function () {
    function PartyListTableConfigurationService() {
        _classCallCheck(this, PartyListTableConfigurationService);
    }

    _createClass(PartyListTableConfigurationService, [{
        key: 'getTableHeaders',
        value: function getTableHeaders() {
            return [{
                field: 'partyName',
                nameLanguageKey: 'EINVOICING.PORTAL.PARTIES.LIST.TABLE.NAME',
                template: '<span>{{binding.partyName}}</span>'
            }, {
                field: 'partyFinancialAddress',
                nameLanguageKey: 'EINVOICING.PORTAL.PARTIES.LIST.TABLE.BUSINESS_ADDRESS',
                template: '<span>{{binding.partyFinancialAddress}}</span>'
            }, {
                field: 'taxReference',
                nameLanguageKey: 'EINVOICING.PORTAL.PARTIES.LIST.TABLE.TAX_REFERENCE',
                template: '<span>{{binding.taxReference}}</span>'
            }];
        }
    }, {
        key: 'getActionColumns',
        value: function getActionColumns() {
            return [{
                field: 'actionButtons',
                template: '<di-button image="view" image-colour="button" action="controller.viewParty(binding)"></di-button>',
                cellClass: 'cell-right'
            }];
        }
    }, {
        key: 'getSortOptions',
        value: function getSortOptions() {
            return [{
                value: 1,
                key: "partyName_Asc",
                label: "EINVOICING.PORTAL.PARTIES.LIST.SORT_BY_VALUES.NAME_ASC"
            }, {
                value: 2,
                key: "partyName_Desc",
                label: "EINVOICING.PORTAL.PARTIES.LIST.SORT_BY_VALUES.NAME_DESC"
            }, {
                value: 3,
                key: "partyBusinessAddress_Asc",
                label: "EINVOICING.PORTAL.PARTIES.LIST.SORT_BY_VALUES.BUSINESS_ADDRESS_ASC"
            }, {
                value: 4,
                key: "partyBusinessAddress_Desc",
                label: "EINVOICING.PORTAL.PARTIES.LIST.SORT_BY_VALUES.BUSINESS_ADDRESS_DESC"
            }, {
                value: 5,
                key: "taxReference_Asc",
                label: "EINVOICING.PORTAL.PARTIES.LIST.SORT_BY_VALUES.TAX_REFERENCE_ASC"
            }, {
                value: 6,
                key: "taxReference_Desc",
                label: "EINVOICING.PORTAL.PARTIES.LIST.SORT_BY_VALUES.TAX_REFERENCE_DESC"
            }];
        }
    }, {
        key: 'getTableOptions',
        value: function getTableOptions() {
            return {
                maxItemsToShow: 500,
                enablePaging: true,
                enableSelect: true,
                multiSelect: false,
                fixedHeight: true,
                paginationPageNumber: 1,
                paginationPageSize: 10,
                maxButtonsShown: 3
            };
        }
    }, {
        key: 'getAddConfiguration',
        value: function getAddConfiguration() {
            //at the moment only suppliers can create new trading relationships
            return [{
                rights: ['Supplier', 'Supervisor'],
                addNewLanguageKey: 'EINVOICING.PORTAL.PARTIES.LIST.TABLE.ADD_NEW_BUYER',
                addLanguageKey: 'EINVOICING.PORTAL.PARTIES.BUTTONS.ADD_BUYER',
                partyType: 'EINVOICING.PORTAL.PARTIES.LIST.PARTY_TYPE_BUYER'
            }];
        }
    }]);

    return PartyListTableConfigurationService;
}();

exports.PartyListTableConfigurationService = PartyListTableConfigurationService;

/***/ }),
/* 448 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PartyListComponent = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _addPartyComponent = __webpack_require__(46);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PartyListComponent = exports.PartyListComponent = {
    templateUrl: 'src/app/portal/parties/list/party-list.component.html',
    selector: 'diPartyList',
    bindings: {
        relatedParties: '<',
        partyManagementSearchResults: '<',
        getSearchResults: '&',
        addEnabled: '<',
        pageTitleOptions: '<'
    },
    controller: function () {
        function controller(partyListTableConfigurationService, diState, stateParams, listsParamsStore, modalWindow, notificationHandler, tradingRelationshipProxy, authorizedObjectsFilter) {
            _classCallCheck(this, controller);

            this.partyListTableConfigurationService = partyListTableConfigurationService;
            this.diState = diState;
            this.stateParams = stateParams;
            this.listsParamsStore = listsParamsStore;
            this.modalWindow = modalWindow;
            this.notificationHandler = notificationHandler;
            this.tradingRelationshipProxy = tradingRelationshipProxy;
            this.authorizedObjectsFilter = authorizedObjectsFilter;

            this.onSelection = this.onSelection.bind(this);
            this.viewParty = this.viewParty.bind(this);
            this.onSortByChanged = this.onSortByChanged.bind(this);
            this.searchPartyList = this.searchPartyList.bind(this);
        }

        _createClass(controller, [{
            key: '$onInit',
            value: function $onInit() {
                var _this = this;

                this.partyManagementTable = [];
                this.dataTableOptions = {};
                this.selectedParty = {};
                this.searchText = "";

                this.dataTableOptions = this.partyListTableConfigurationService.getTableOptions();
                this.dataTableOptions.columns = this.partyListTableConfigurationService.getTableHeaders();
                this.dataTableOptions.actionColumns = this.partyListTableConfigurationService.getActionColumns();
                this.sortByOptions = this.partyListTableConfigurationService.getSortOptions();
                this.sortBy = this.sortByOptions[0];

                var config = this.partyListTableConfigurationService.getAddConfiguration();
                var authorizedConfig = this.authorizedObjectsFilter.getAuthorizedObjects(config, true);
                this.addConfiguration = authorizedConfig && authorizedConfig.length > 0 ? authorizedConfig[0] : undefined;

                var authorizedPageTitleConfig = this.authorizedObjectsFilter.getAuthorizedObjects(this.pageTitleOptions, true);
                this.pageTitle = authorizedPageTitleConfig && authorizedPageTitleConfig.length > 0 ? authorizedPageTitleConfig[0] : undefined;

                if (this.stateParams.pageNumber) {
                    this.dataTableOptions.paginationPageNumber = this.stateParams.pageNumber;
                }
                if (this.stateParams.searchText) {
                    this.searchText = this.stateParams.searchText;
                }
                if (this.stateParams.sortOption) {
                    this.sortBy = _.find(this.sortByOptions, function (sortBy) {
                        return sortBy.value === _this.stateParams.sortOption;
                    });
                }
            }
        }, {
            key: '$onChanges',
            value: function $onChanges(changes) {
                var _this2 = this;

                if (changes.relatedParties && !changes.relatedParties.previousValue && changes.relatedParties.currentValue && changes.relatedParties.currentValue.length > 0) {

                    this.parties = changes.relatedParties.currentValue;
                    this.forPartySelected = this.parties[0];

                    if (this.stateParams.forPartyId) {
                        var party = _.find(changes.relatedParties.currentValue, function (party) {
                            return party.partyId === _this2.stateParams.forPartyId;
                        });

                        if (party && this.forPartySelected && party.partyId !== this.forPartySelected.partyId) {
                            this.forPartySelected = party;
                        }
                    }

                    this.searchPartyList();
                }

                if (changes.partyManagementSearchResults && changes.partyManagementSearchResults.currentValue) {

                    //split into a value/ascension array
                    var splitSortBy = this.sortBy.key.split('_');

                    var sortedByArray = _.sortBy(changes.partyManagementSearchResults.currentValue, splitSortBy[0]);

                    if (splitSortBy[1] === 'Desc') {
                        sortedByArray = sortedByArray.reverse();
                    }

                    this.populateDataTableOptions(sortedByArray);
                    this.partyManagementTable.fill(sortedByArray);
                }
            }

            /**
             * Sets the party that has been selected, and re-fetches the party search data
             * selectedParty = the selected party from the drop down
             */

        }, {
            key: 'onSelection',
            value: function onSelection(selectedParty) {
                if (selectedParty.partyId === this.forPartySelected.partyId) {
                    return;
                }
                this.forPartySelected = angular.copy(selectedParty);
                this.reloadPage();
            }

            /**
             * Triggered when the sort by is changed for this component
             * value = the numeric value assigned to the sortbyOptions list
             */

        }, {
            key: 'onSortByChanged',
            value: function onSortByChanged(value) {
                if (this.sortBy && this.sortBy.value === value) {
                    return;
                }

                if (!this.sortByOptions || this.sortByOptions.length === 0) {
                    this.sortByOptions = this.partyListTableConfigurationService.getSortOptions();
                }

                this.sortBy = _.find(this.sortByOptions, function (sortBy) {
                    return sortBy.value === value;
                });

                this.reloadPage();
            }

            /**
             * Changes the state of the page to the view page for that selected party
             */

        }, {
            key: 'viewParty',
            value: function viewParty(selectedParty) {
                var forPartyId = void 0;
                var forPartyName = void 0;

                if (typeof this.forPartySelected !== 'undefined' && !_.isEmpty(this.forPartySelected)) {
                    forPartyId = this.forPartySelected.partyId;
                    forPartyName = this.forPartySelected.name;
                } else {
                    forPartyId = selectedParty.partyId;
                    forPartyName = selectedParty.partyName;
                }

                var detailsParams = this.listsParamsStore.get('partyDetails') || {};

                var pageParams = {
                    id: selectedParty.partyId,
                    forPartyId: forPartyId,
                    partyName: selectedParty.partyName,
                    forPartyName: forPartyName,
                    singleDetails: 'false'
                };

                var params = _.extend(pageParams, detailsParams);

                this.diState.go('portal.parties.viewById', params);
            }

            /**
             * Search results based on updated search text
             */

        }, {
            key: 'searchPartyList',
            value: function searchPartyList() {
                var _this3 = this;

                this.getSearchResults({ relatedPartyId: this.forPartySelected.partyId, searchText: this.searchText }).then(function (result) {
                    _this3.storeParams();
                });
            }
        }, {
            key: 'reloadPage',
            value: function reloadPage() {
                this.diState.go(this.stateParams.ownStateName, {
                    pageTitle: this.stateParams.pageTitle,
                    sortOption: this.sortBy.value,
                    searchText: this.searchText,
                    forPartyId: (this.forPartySelected || {}).partyId,
                    pageNumber: 1
                }, { reload: true });
            }
        }, {
            key: 'populateDataTableOptions',
            value: function populateDataTableOptions(data) {
                this.dataTableOptions.data = [];
                this.dataTableOptions.data.fill(data);
            }
        }, {
            key: 'storeParams',
            value: function storeParams() {
                if (!this.forPartySelected || !this.forPartySelected.partyId || !this.sortBy || !this.sortBy.value) {
                    return;
                }
                var params = _.extend({}, {
                    sortOption: this.sortBy.value,
                    searchText: this.searchText,
                    pageTitle: this.stateParams.pageTitle,
                    forPartyId: (this.forPartySelected || {}).partyId
                });
                params.pageNumber = this.dataTableOptions.paginationPageNumber = 1;
                this.listsParamsStore.set("parties", params);
            }
        }, {
            key: 'addParty',
            value: function addParty() {
                var options = {
                    controller: _addPartyComponent.AddPartyComponentController,
                    templateUrl: 'src/app/portal/parties/add-party.component.html',
                    partyId: (this.forPartySelected || {}).partyId,
                    modalTitle: (this.addConfiguration || {}).addNewLanguageKey,
                    saveButtonText: (this.addConfiguration || {}).addLanguageKey
                };

                this.showPopup(options);
            }
        }, {
            key: 'showPopup',
            value: function showPopup(options) {
                var _this4 = this;

                this.modalWindow.show(options, function (result) {
                    _this4.tradingRelationshipProxy.createTradingRelationship((_this4.forPartySelected || {}).partyId, result).then(function (res) {
                        if (res) {
                            _this4.getSearchResults({ relatedPartyId: _this4.forPartySelected.partyId, searchText: _this4.searchText });
                            _this4.notificationHandler.showSuccess('EINVOICING.PORTAL.PARTIES.ACTIONS.ADDED', (_this4.addConfiguration || {}).partyType);
                        } else {
                            _this4.notificationHandler.showError(message, identifier);
                        }
                    }, function () {
                        var response = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

                        _this4.notificationHandler.showError(response.failureReason);
                    });
                });
            }
        }]);

        return controller;
    }()
};

PartyListComponent.controller.prototype.constructor.$inject = ['PartyListTableConfigurationService', 'diState', '$stateParams', 'listsParamsStore', 'modalWindow', 'notificationHandler', 'tradingRelationshipProxy', 'authorizedObjectsFilter'];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 449 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PartySelectorComponent = exports.PartySelectorComponent = {
    templateUrl: 'src/app/portal/parties/list/party-selector.component.html',
    selector: 'diPartySelector',
    bindings: {
        parties: '<',
        selectedId: '<',
        onSelection: '&'
    },
    controller: function () {
        function controller() {
            _classCallCheck(this, controller);

            this.partiesCollection = [];
            this.selectedParty = {};

            this.onSelected = this.onSelected.bind(this);
        }

        _createClass(controller, [{
            key: '$onInit',
            value: function $onInit() {
                this.init();
            }
        }, {
            key: '$onChanges',
            value: function $onChanges(changes) {
                if (changes.selectedId.currentValue) {
                    this.selectPartyById(changes.selectedId.currentValue);
                }
            }
        }, {
            key: 'init',
            value: function init() {
                this.partiesCollection = this.parties;
            }
        }, {
            key: 'selectPartyById',
            value: function selectPartyById(id) {
                this.selectedParty = _.find(this.parties, function (party) {
                    return party.partyId === id;
                });
            }
        }, {
            key: 'onSelected',
            value: function onSelected(selectedParty) {

                this.selectedParty = selectedParty;

                this.onSelection({ selectedParty: selectedParty });
            }
        }]);

        return controller;
    }()
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 450 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _pageTitleOptions = Symbol('pageTitleOptions');

var WorkingForPartyListComponent = exports.WorkingForPartyListComponent = {
    templateUrl: 'src/app/portal/parties/list/allocated-to-party-list.component.html',
    selector: 'diWorkingForPartyList',
    controller: function () {
        function controller(partyProxy) {
            _classCallCheck(this, controller);

            this.partyProxy = partyProxy;
            this.getSearchResults = this.getSearchResults.bind(this);

            this[_pageTitleOptions] = [{
                rights: ["Buyer"],
                languageKey: 'EINVOICING.PORTAL.PARTIES.LIST.PAGE_TITLE.PARTY_MANAGEMENT'
            }, {
                rights: ["Supplier"],
                languageKey: 'EINVOICING.PORTAL.PARTIES.LIST.PAGE_TITLE.PARTY_MANAGEMENT'
            }];
        }

        _createClass(controller, [{
            key: '$onInit',
            value: function $onInit() {
                this.addEnabled = false;
                this.pageTitleOptions = this[_pageTitleOptions];
                this.getSearchResults();
            }
        }, {
            key: 'getSearchResults',
            value: function getSearchResults() {
                var _this = this;

                var searchText = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

                return this.partyProxy.getWorkingForPartyManagementSearchResults(searchText).then(function (data) {
                    _this.partyManagementSearchResults = data;
                });
            }
        }]);

        return controller;
    }()
};

WorkingForPartyListComponent.controller.prototype.constructor.$inject = ['partyProxy'];

/***/ }),
/* 451 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(452), __webpack_require__(95), __webpack_require__(97)], __WEBPACK_AMD_DEFINE_RESULT__ = function (partyCodesComponentLoader, partyCodeComponentLoader, sharedLoader) {
    'use strict';

    return function (module) {
        module.component(partyCodesComponentLoader.PartyCodesComponent.selector, partyCodesComponentLoader.PartyCodesComponent);
        partyCodeComponentLoader.load(module);
        sharedLoader.load(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 452 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PartyCodesComponent = exports.PartyCodesComponent = {
    templateUrl: 'src/app/portal/parties/party-codes/party-codes.component.html',
    selector: 'diPartyCodes',
    bindings: {
        readonly: '<',
        partyId: '<',
        identifiers: '<',
        endpoints: '<',
        taxReferences: '<',
        addNewCode: '&',
        updatePartyCode: '&',
        deletePartyCode: '&'
    },
    controllerAs: 'partyCodesCtrl',
    controller: function () {
        function PartyCodesController(partyProxy) {
            _classCallCheck(this, PartyCodesController);

            this.partyProxy = partyProxy;

            this.addNewPartyCode = this.addNewPartyCode.bind(this);
            this.updateCode = this.updateCode.bind(this);
        }

        _createClass(PartyCodesController, [{
            key: '$onInit',
            value: function $onInit() {
                var _this = this;

                this.partyProxy.getAssociatedPartiesTradingRelationshipsByParty(this.partyId).then(function (parties) {
                    _this.relatedParties = parties;

                    //only working for identifiers ATM
                    _this.identifiers = _.map(_this.identifiers, function (partyCode) {
                        if (partyCode.relatedParty > 0) {
                            var party = _.find(_this.relatedParties, function (relatedParty) {
                                return partyCode.relatedParty === relatedParty.id;
                            });

                            partyCode.relatedPartyDetails = party;
                        }

                        return partyCode;
                    });
                });
            }
        }, {
            key: 'addNewPartyCode',
            value: function addNewPartyCode(data) {
                data.partyId = this.partyId;
                this.addNewCode({ data: data });
            }
        }, {
            key: 'updateCode',
            value: function updateCode(data) {
                data.partyId = this.partyId;
                this.updatePartyCode({ data: data });
            }
        }, {
            key: 'deleteCode',
            value: function deleteCode(data) {
                data.partyId = this.partyId;
                this.deletePartyCode({ data: data });
            }
        }]);

        return PartyCodesController;
    }()
};

PartyCodesComponent.controller.prototype.constructor.$inject = ['partyProxy'];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 453 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 454 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP7L}
// di.einvoicing.ui.portal.portal.grn.viewer
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    return function (module) {
        var util = $di.utility.util;
        module.controller('portalController', portalController);

        portalController.$inject = ['activityMonitor'];

        function portalController(activityMonitor) {
            activityMonitor.start();
        }
        return portalController;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 455 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(456), __webpack_require__(460), __webpack_require__(473), __webpack_require__(467), __webpack_require__(466), __webpack_require__(465), __webpack_require__(464)], __WEBPACK_AMD_DEFINE_RESULT__ = function (statesLoader, listsLoader, viewerLoader, purchaseOrderRepositoryLoader, purchaseOrderLinesColumnSettingsLoader, purchaseOrderProxyLoader, additionalDocumentReferencesConfigurator) {
  'use strict';

  return function (module) {
    statesLoader(module);
    listsLoader(module);
    viewerLoader(module);
    purchaseOrderRepositoryLoader(module);
    purchaseOrderLinesColumnSettingsLoader(module);
    purchaseOrderProxyLoader(module);
    additionalDocumentReferencesConfigurator(module);
  };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 456 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP2C}
// di.einvoicing.ui.portal.portal.purchaseorders
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
				'use strict';

				return function (module) {
								module.config(configurePurchaseOrdersStates);

								configurePurchaseOrdersStates.$inject = ['stateHelperProvider'];
								function configurePurchaseOrdersStates(stateHelperProvider) {
												stateHelperProvider.addStates({
																templateBaseUrl: "src/app/portal/purchaseOrders/_states",
																parentStateName: 'portal.orders',
																states: [{
																				stateName: "list",
																				url: 'list?{dateType:int}&{dateTimeFilter}&{statusFilter:int}&{sortOption:int}&{fromDate:date}&{toDate:date}&{searchText}',
																				params: {
																								dateType: undefined,
																								dateTimeFilter: undefined,
																								statusFilter: undefined,
																								sortOption: undefined,
																								fromDate: undefined,
																								toDate: undefined,
																								searchText: undefined,
																								pageSize: undefined,
																								pageNumber: undefined
																				}
																}, {
																				stateName: "viewer",
																				rights: ["PurchaseOrderReader"],
																				onlyCreateStateCollection: true,
																				stateCollection: [{
																								stateName: "viewByPurchaseOrderNumber",
																								url: '{purchaseOrderNumber}'
																				}, {
																								stateName: "viewById",
																								url: 'id/{id:int}',
																								params: {
																												id: 0
																								}
																				}, {
																								stateName: "viewByAuditId",
																								url: 'view/id/{id:int}-v{aid:int}',
																								data: {
																												header: { title: "EINVOICING.PORTAL.ORDERS.VIEWER.VIEW.HEADER.TITLE" }
																								},
																								params: {
																												id: 0,
																												aid: 0
																								}
																				}]
																}]
												});
								}
				};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 457 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:/UP07}
// di.einvoicing.ui.portal.portal.purcahseorders.lists.components
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(458), __webpack_require__(459)], __WEBPACK_AMD_DEFINE_RESULT__ = function (snippetsLoader, purchaseOrderListDirectiveLoader) {
    'use strict';

    return function (module) {
        snippetsLoader(module);
        purchaseOrderListDirectiveLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 458 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP02}
// di.einvoicing.ui.portal.portal.purchaseorders.lists.components.snippets
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var snippetContext = $di.angular.snippetRegistrar.createContext(module, 'src/app/portal/purchaseOrders/lists/_components/_snippets');

        snippetContext.registerSnippet('diPurchaseOrderActionButtons', 'purchaseOrderActionButtons.html');
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 459 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP5B}
// di.einvoicing.ui.portal.portal.purchaseorder.lists
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ng) {
    'use strict';

    return function (module) {
        module.directive('diPurchaseOrderList', diPurchaseOrderList);

        function diPurchaseOrderList() {
            return {
                restrict: 'E',
                replace: true,
                scope: {},
                controller: "PurchaseOrderListController",
                controllerAs: "purchaseOrderListCtrl",
                templateUrl: 'src/app/portal/purchaseOrders/lists/_components/purchaseOrderList/purchaseOrderList.html',
                link: link
            };

            function link(scope) {
                scope.findElement = findElement;

                return;

                function findElement(name) {
                    return ng.element(name);
                }
            }
        }

        return diPurchaseOrderList;
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 460 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP5A}
// di.einvoicing.ui.portal.portal.invoices.lists
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(457), __webpack_require__(463), __webpack_require__(462), __webpack_require__(461)], __WEBPACK_AMD_DEFINE_RESULT__ = function (componentsLoader, purchaseOrderListFiltersControllerLoader, purchaseOrderListControllerLoader, purchaseOrderListConfiguratorLoader) {
	'use strict';

	return function (module) {
		componentsLoader(module);
		purchaseOrderListFiltersControllerLoader(module);
		purchaseOrderListControllerLoader(module);
		purchaseOrderListConfiguratorLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 461 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP2H}
// di.einvoicing.ui.portal.portal.purchaseorders.lists
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var guard = $di.exception.guard;
		var util = $di.utility.util;

		module.provider('purchaseOrderListConfigurator', PurchaseOrderListConfiguratorProvider);

		/**
   * Manages purchase order list configuration and set up.
   */
		function PurchaseOrderListConfiguratorProvider() {
			var config = {};

			var buttonsConfiguration = {};

			var columnDefinitions = [{
				rights: ['Buyer'],
				field: 'purchaseOrderNumber',
				nameLanguageKey: 'EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.COLUMN_HEADERS.PURCHASE_ORDER_NUMBER',
				template: '<span>{{binding.purchaseOrderNumber}}</span>'
			}, {
				rights: ['Supplier'],
				field: 'purchaseOrderNumber',
				nameLanguageKey: 'EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.COLUMN_HEADERS.SALES_ORDER_NUMBER',
				template: '<span>{{binding.purchaseOrderNumber}}</span>'
			}, {
				rights: ['Supplier', 'Buyer'],
				field: 'orderType',
				nameLanguageKey: 'EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.COLUMN_HEADERS.DOCUMENT_TYPE',
				template: '<span>{{binding.orderType}}</span>'
			}, {
				rights: ['Supplier', 'Buyer'],
				field: 'createdDateTime',
				nameLanguageKey: 'EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.COLUMN_HEADERS.CREATED_DATE',
				template: '<span>{{ binding.createdDateTime | diDate }}</span>',
				cellClass: 'centeredcell'
			}, {
				rights: ['Supplier', 'Buyer'],
				field: 'issuedDateTime',
				nameLanguageKey: 'EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.COLUMN_HEADERS.ISSUED_DATE',
				template: '<span>{{ binding.issuedDateTime | diDate }}</span>',
				cellClass: 'centeredcell'
			}, {
				rights: ['Supplier', 'Buyer'],
				field: 'expectedDeliveryDateTime',
				nameLanguageKey: 'EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.COLUMN_HEADERS.DELIVERY_DATE',
				template: '<span>{{ binding.expectedDeliveryDateTime | diDate }}</span>',
				cellClass: 'centeredcell'
			}, {
				rights: ['Buyer'],
				field: 'supplier',
				nameLanguageKey: 'EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.COLUMN_HEADERS.SELLER',
				template: '<div class="tooltip-wrap">\
									<span class="text-ellipsis">{{binding.supplier}}</span>\
									<div ng-if="(binding.supplier || \'\').length >= 35"\
										ng-class="((binding.supplier || \'\').length > 70) ? [\'tooltip\', \'tooltip-multiline\'] : \'tooltip\'">\
										<span>\
											{{ ::binding.supplier }}\
										</span>\
									</div>\
								</div>',
				cellClass: 'max-width-300'
			}, {
				rights: ['Supplier'],
				field: 'customer',
				nameLanguageKey: 'EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.COLUMN_HEADERS.BUYER',
				template: '<div class="tooltip-wrap">\
									<span class="text-ellipsis">{{binding.customer}}</span>\
									<div ng-if="(binding.customer || \'\').length >= 35"\
										ng-class="((binding.customer || \'\').length > 70) ? [\'tooltip\', \'tooltip-multiline\'] : \'tooltip\'">\
										<span>\
											{{ ::binding.customer }}\
										</span>\
									</div>\
								</div>',
				cellClass: 'max-width-300'
			}, {
				rights: ['Supplier', 'Buyer'],
				field: 'totalLines',
				nameLanguageKey: 'EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.COLUMN_HEADERS.LINES',
				template: '<span>{{ binding.totalLines }}</span>',
				cellClass: 'centeredcell'
			}, {
				rights: ['Supplier', 'Buyer'],
				field: 'total',
				nameLanguageKey: 'EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.COLUMN_HEADERS.TOTAL',
				template: '<span>{{ binding.total | diCurrency:binding.currencyId }}</span>',
				cellClass: 'numericcell'
			}, {
				rights: ['Supplier', 'Buyer'],
				field: 'clientEInvoicingState',
				nameLanguageKey: 'EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.COLUMN_HEADERS.STATE',
				template: '<span>{{binding.calculatedState}}</span>',
				cellClass: 'centeredcell'
			}, {
				rights: ['Admin'],
				field: 'documentStateKey',
				nameLanguageKey: 'STATE KEY',
				template: '<span>{{binding.documentStateKey}}</span>',
				cellClass: 'centeredcell'
			}, {
				rights: ['Supplier', 'Buyer'],
				field: 'attachment',
				nameLanguageKey: '',
				template: '<div class="icon-16px" ng-if="binding.attachmentCount > 0"><di-image image="attachment" image-colour="button"></di-image></div>',
				cellClass: 'centeredcell'
			}, {
				rights: ['Supplier'],
				field: 'updated',
				nameLanguageKey: '',
				template: '<div class="document-updated" ng-if="binding.updated" di-translate="EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.UPDATED"></div>',
				cellClass: 'centeredcell'
			}];

			var dateTimeDefaultFilters = [{
				value: "Last30Days",
				label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.DATE.LAST_30_DAYS",
				dateTypes: [1, 2, 3]
			}, {
				value: "LastMonth",
				label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.DATE.LAST_MONTH",
				dateTypes: [1, 2, 3]
			}, {
				value: "ThisMonth",
				label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.DATE.THIS_MONTH",
				dateTypes: [1, 2, 3]
			}, {
				value: "Yesterday",
				label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.DATE.YESTERDAY",
				dateTypes: [1, 2, 3]
			}, {
				value: "Today",
				label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.DATE.TODAY",
				dateTypes: [1, 2, 3]
			}, {
				value: "Custom",
				label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.DATE.CUSTOM",
				isHidden: true,
				dateTypes: [1, 2, 3]
			}, {
				value: "Tomorrow",
				label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.DATE.TOMORROW",
				dateTypes: [3]
			}, {
				value: "NextMonth",
				label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.DATE.NEXT_MONTH",
				dateTypes: [3]
			}, {
				value: "Next30Days",
				label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.DATE.NEXT_30_DAYS",
				dateTypes: [3]
			}];

			var dateTypesOptions = [{ value: 1, label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.DATE.TYPES.CREATED" }, { value: 2, label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.DATE.TYPES.ISSUED" }, { value: 3, label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.DATE.TYPES.DELIVERY" }];

			var sortOptions = [{
				rights: ['User'],
				value: 1,
				label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.SORT.PURCHASE_ORDER_NUMBER_ASC"
			}, {
				rights: ['User'],
				value: 2,
				label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.SORT.PURCHASE_ORDER_NUMBER_DESC"
			}, {
				rights: ['User'],
				value: 11,
				label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.SORT.DOCUMENT_TYPE_ASC"
			}, {
				rights: ['User'],
				value: 12,
				label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.SORT.DOCUMENT_TYPE_DESC"
			}, {
				rights: ['User'],
				value: 3,
				label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.SORT.CREATED_DATE_ASC"
			}, {
				rights: ['User'],
				value: 4,
				label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.SORT.CREATED_DATE_DESC"
			}, {
				rights: ['User'],
				value: 5,
				label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.SORT.ISSUED_DATE_ASC"
			}, {
				rights: ['User'],
				value: 6,
				label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.SORT.ISSUED_DATE_DESC"
			}, {
				rights: ['User'],
				value: 7,
				label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.SORT.DELIVERY_DATE_ASC"
			}, {
				rights: ['User'],
				value: 8,
				label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.SORT.DELIVERY_DATE_DESC"
			}, {
				rights: ['Supplier'],
				value: 13,
				label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.SORT.BUYER_ASC"
			}, {
				rights: ['Supplier'],
				value: 14,
				label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.SORT.BUYER_DESC"
			}, {
				rights: ['Buyer'],
				value: 15,
				label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.SORT.SUPPLIER_ASC"
			}, {
				rights: ['Buyer'],
				value: 16,
				label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.SORT.SUPPLIER_DESC"
			}, {
				rights: ['User'],
				value: 17,
				label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.SORT.LINES_ASC"
			}, {
				rights: ['User'],
				value: 18,
				label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.SORT.LINES_DESC"
			}, {
				rights: ['User'],
				value: 9,
				label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.SORT.TOTAL_ASC"
			}, {
				rights: ['User'],
				value: 10,
				label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.SORT.TOTAL_DESC"
			}, {
				rights: ['User'],
				value: 19,
				label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.SORT.STATUS_ASC"
			}, {
				rights: ['User'],
				value: 20,
				label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.SORT.STATUS_DESC"
			}];

			// Status filters configuration
			var statusFilters = [];

			var initialDateTimeFilter;
			var initialSortOption;
			var initialDateType;
			var initialStatusFilter;

			// Provider definition
			var provider = {
				configure: configure,
				$get: $get
			};

			provider.$get.$inject = ['authorizedObjectsFilter', 'CLIENT_ENUMS'];

			return provider;

			function getOptionByValue(filterItems, value) {
				var filterItem = _.find(filterItems, function (obj) {
					return obj.value === value;
				});

				return filterItem;
			}

			/**
    * Configure the service
    * @param cfg
    */
			function configure(cfg) {
				guard.throwIfNotAnObject("EUP2H02E", cfg, 'cfg');

				config = cfg;
			}

			/**
    * Gets required configuration for the grid.
    */
			function $get(authorizedObjectsFilter, clientEnums) {
				buttonsConfiguration = {
					type: "Order",
					visibleButtons: [],
					buttonsSetOne: [{
						rights: ["PurchaseOrderReader"],
						name: 'view',
						action: clientEnums.userActions.viewPurchaseOrder,
						singleAction: true
					}, {
						rights: ["PurchaseOrderFlipper"],
						name: 'flip',
						action: clientEnums.userActions.flip
					}, {
						rights: ["Supplier", "PurchaseOrderReader"],
						name: 'accept',
						action: clientEnums.userActions.accept
					}, {
						rights: ["Supplier", "PurchaseOrderReader"],
						name: 'reject',
						action: clientEnums.userActions.reject
					}, {
						rights: ["Supplier", "PurchaseOrderReader"],
						name: 'shipped',
						action: clientEnums.userActions.markAsShipped
					}, {
						rights: ["Supplier", "PurchaseOrderReader"],
						name: 'notShipped',
						action: clientEnums.userActions.markAsNotShipped
					}, {
						rights: ["Supplier", "PurchaseOrderReader"],
						name: 'invoiced',
						action: clientEnums.userActions.markAsInvoiced
					}, {
						rights: ["Buyer", "PurchaseOrderReader"],
						name: 'delivered',
						action: clientEnums.userActions.markAsDelivered
					}, {
						rights: ["Buyer", "PurchaseOrderReader"],
						name: 'notDelivered',
						action: clientEnums.userActions.markAsNotDelivered
					}, {
						rights: ["Buyer", "PurchaseOrderReader"],
						name: 'close',
						action: clientEnums.userActions.close
					}, {
						rights: ["Buyer", "PurchaseOrderReader"],
						name: 'cancelOrder',
						action: clientEnums.userActions.cancelPurchaseOrder
					}],
					buttonsSetTwo: [{
						rights: ["PurchaseOrderReader"],
						name: 'render',
						action: clientEnums.userActions.downloadPurchaseOrder,
						singleAction: true
					}, {
						rights: ["PurchaseOrderReader"],
						name: 'downloadCsv',
						action: clientEnums.userActions.downloadAsCsv,
						fallbackOnSecondaryContext: true
					}, {
						rights: ["PurchaseOrderReader"],
						name: 'related',
						action: clientEnums.userActions.viewRelatedDocumentsPurchaseOrder,
						singleAction: true
					}]
				};

				statusFilters = [{
					rights: ['Buyer'],
					order: 1,
					value: clientEnums.documentStateKey.unknown,
					label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.ALL_BUYER"
				}, {
					rights: ['Supplier'],
					order: 1,
					value: clientEnums.documentStateKey.unknown,
					label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.ALL_SUPPLIER"
				}, {
					rights: ['Buyer'],
					order: 2,
					value: clientEnums.documentStateKey.invalid,
					label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.STATE.INVALID"
				}, {
					rights: ['Buyer'],
					order: 3,
					value: clientEnums.documentStateKey.sentreceived,
					label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.STATE.SENTRECEIVED_BUYER"
				}, {
					rights: ['Supplier'],
					order: 3,
					value: clientEnums.documentStateKey.sentreceived,
					label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.STATE.SENTRECEIVED_SUPPLIER"
				}, {
					rights: ['Buyer'],
					order: 4,
					value: clientEnums.documentStateKey.accepted,
					label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.STATE.ACCEPTED_BUYER"
				}, {
					rights: ['Supplier'],
					order: 4,
					value: clientEnums.documentStateKey.accepted,
					label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.STATE.ACCEPTED_SUPPLIER"
				}, {
					rights: ['Supplier'],
					order: 5,
					value: clientEnums.documentStateKey.shipped,
					label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.STATE.SHIPPED_SUPPLIER"
				}, {
					rights: ['Buyer'],
					order: 5,
					value: clientEnums.documentStateKey.shipped,
					label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.STATE.SHIPPED_BUYER"
				}, {
					rights: ['Supplier'],
					order: 6,
					value: clientEnums.documentStateKey.partiallyInvoiced,
					label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.STATE.PARTIALLY_INVOICED_SUPPLIER"
				}, {
					rights: ['Buyer'],
					order: 6,
					value: clientEnums.documentStateKey.partiallyInvoiced,
					label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.STATE.PARTIALLY_INVOICED_BUYER"
				}, {
					rights: ['Supplier', 'Buyer'],
					order: 7,
					value: clientEnums.documentStateKey.fullyInvoiced,
					label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.STATE.FULLY_INVOICED"
				}, {
					rights: ['Buyer'],
					order: 8,
					value: clientEnums.documentStateKey.delivered,
					label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.STATE.DELIVERED_BUYER"
				}, {
					rights: ['Supplier'],
					order: 8,
					value: clientEnums.documentStateKey.delivered,
					label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.STATE.DELIVERED_SUPPLIER"
				}, {
					rights: ['Buyer'],
					order: 9,
					value: clientEnums.documentStateKey.rejected,
					label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.STATE.REJECTED_BUYER"
				}, {
					rights: ['Supplier'],
					order: 9,
					value: clientEnums.documentStateKey.rejected,
					label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.STATE.REJECTED_SUPPLIER"
				}, {
					rights: ['Supplier'],
					order: 10,
					value: clientEnums.documentStateKey.closed,
					label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.STATE.CLOSED_SUPPLIER"
				}, {
					rights: ['Buyer'],
					order: 10,
					value: clientEnums.documentStateKey.closed,
					label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.STATE.CLOSED_BUYER"
				}, {
					rights: ['Buyer'],
					order: 11,
					value: clientEnums.documentStateKey.cancelled,
					label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.STATE.CANCELLED_BUYER"
				}, {
					rights: ['Supplier'],
					order: 11,
					value: clientEnums.documentStateKey.cancelled,
					label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.FILTERS.STATE.CANCELLED_SUPPLIER"
				}];

				initialDateTimeFilter = getOptionByValue(dateTimeDefaultFilters, 'Last30Days');
				initialSortOption = getOptionByValue(sortOptions, 6);
				initialDateType = getOptionByValue(dateTypesOptions, 1);
				initialStatusFilter = getOptionByValue(statusFilters, 1);

				return {
					getTableConfiguration: getTableConfiguration,
					getStatusFilters: getStatusFilters,
					getDateTimeFilters: getDateTimeFilters,
					getSortableColumns: getSortableColumns,
					getDateTypesOptions: getDateTypesOptions,
					getButtonsSetOneConfiguration: getButtonsSetOneConfiguration,
					getButtonsSetTwoConfiguration: getButtonsSetTwoConfiguration,
					getInitialFilter: getInitialFilter,
					getInitialDateTimeFilter: getInitialDateTimeFilter,
					getInitialSortOption: getInitialSortOption,
					getInitialStatusFilter: getInitialStatusFilter,
					getInitialDateType: getInitialDateType,
					getFreeformSearchDefaultFilter: getFreeformSearchDefaultFilter
				};

				/**
     * Returns buttons configuration settings
     */
				function getButtonsSetOneConfiguration() {
					return getConfiguration(buttonsConfiguration.buttonsSetOne);
				}

				function getButtonsSetTwoConfiguration() {
					return getConfiguration(buttonsConfiguration.buttonsSetTwo);
				}

				function getConfiguration(array) {
					authorizedObjectsFilter.requireRights(true);

					var configuration = {
						type: "Invoice",
						visibleButtons: []
					};
					configuration.visibleButtons.fill(authorizedObjectsFilter.getAuthorizedObjects(array, true));
					return configuration;
				}

				/**
     * Gets initial set of all filters.
     */
				function getInitialFilter() {
					var initialFilters = [];

					initialFilters.push(initialDateTimeFilter);

					return initialFilters;
				}

				/**
     * Gets initial set of date time filters.
     */
				function getInitialDateTimeFilter(dateTypeId) {
					if (util.isDefined(dateTypeId) && dateTypeId === 3) {
						initialDateTimeFilter = getOptionByValue(dateTimeDefaultFilters, 'Next30Days');
					} else {
						initialDateTimeFilter = getOptionByValue(dateTimeDefaultFilters, 'Last30Days');
					}
					return initialDateTimeFilter;
				}

				/**
     * Gets grid configuration options.
     */
				function getTableConfiguration() {
					config.columns = authorizedObjectsFilter.getAuthorizedObjects(columnDefinitions, false);
					return config;
				}

				/**
     * Gets date time default filters for the grid.
     */
				function getDateTimeFilters(dateTypeId) {
					var filters = dateTimeDefaultFilters;

					if (util.isDefined(dateTypeId)) {

						filters = _.filter(dateTimeDefaultFilters, function (filter) {
							return _.contains(filter.dateTypes, dateTypeId);
						});
					}

					return filters;
				}

				/**
     * Gets the column intially used to sort the grid results
     */
				function getInitialSortOption() {
					return initialSortOption;
				}

				/**
     * Gets initial set of status filters.
     */
				function getInitialStatusFilter() {
					return initialStatusFilter;
				}

				/**
     * gets initial date type option
     * @returns {}
     */
				function getInitialDateType() {
					return initialDateType;
				}

				/**
     * Gets the columns which can be used to sort the grid
     */
				function getSortableColumns() {
					authorizedObjectsFilter.requireRights(true);
					var options = authorizedObjectsFilter.getAuthorizedObjects(sortOptions, true);
					return options;
				}

				/**
     * Gets status filters
     */
				function getStatusFilters() {
					authorizedObjectsFilter.requireRights(false);
					var options = authorizedObjectsFilter.getAuthorizedObjects(statusFilters, false);
					return options;
				}

				/**
     * gets list of available date types
     */
				function getDateTypesOptions() {
					return dateTypesOptions;
				}

				/**
     * Gets the filter to use when filtering triggered by freeform search box
     */
				function getFreeformSearchDefaultFilter() {
					return {
						statusFilter: getOptionByValue(getStatusFilters(), clientEnums.documentStateKey.unknown).value, //all
						sortOption: getOptionByValue(getSortableColumns(), 1).value, //po number asc
						dateType: getOptionByValue(getDateTypesOptions(), 1).value, //created
						dateTimeFilter: getOptionByValue(getDateTimeFilters(), "Custom").value,
						fromDate: moment.utc([1900, 0, 1]).format(), // months, hours, minutes, seconds, and milliseconds are all zero indexed
						toDate: moment.utc().format()
					};
				}
			}
		}

		return PurchaseOrderListConfiguratorProvider;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 462 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP2H}
// di.einvoicing.ui.portal.portal.purchaseOrder.lists
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.controller('PurchaseOrderListController', PurchaseOrderListController);

		PurchaseOrderListController.$inject = ['diState', 'translator', 'enumTranslator', 'notificationHandler', 'purchaseOrderListConfigurator', '$scope', 'elementNotifier', 'currencyCache', 'authorizedObjectsFilter', 'CLIENT_ENUMS', 'authenticationData', 'documentStateResolver', 'documentAttributeResolver', 'userRightsRepository', 'purchaseOrderRepository', 'documentProxy', '$stateParams', 'vmFiltersListConfigurator', 'userActionsResolver', 'modalSpinner', 'documentDownloader', 'dateFormatter', 'listsParamsStore'];

		/**
   * Manages and configure purchase orders list table.		
   */
		function PurchaseOrderListController(diState, translator, enumTranslator, notificationHandler, purchaseOrderListConfigurator, scope, elementNotifier, currencyCache, authorizedObjectsFilter, clientEnums, authenticationData, documentStateResolver, documentAttributeResolver, userRightsRepository, purchaseOrderRepository, documentProxy, stateParams, vmFiltersListConfigurator, userActionsResolver, modalSpinner, documentDownloader, dateFormatter, listsParamsStore) {
			var vm = this;
			vm.loading = true;
			var resultsReachedNotification;

			vm.purchaseOrders = [];
			vm.tableOptions = {};
			vm.buttonsSetOneOptions = {};
			vm.buttonsSetTwoOptions = {};
			vm.selectedStates = {
				primary: [],
				secondary: []
			};
			vm.selectedAttributes = {
				primary: [],
				secondary: []
			};
			vm.selectedActions = {
				primary: [],
				secondary: []
			};
			vm.selectedItemsCount = {
				primary: 0,
				secondary: 0
			};
			vm.selectedFilters = {
				searchText: ""
			};
			vm.labels = {};
			vm.sortOptions = [];
			vm.statusOptions = [];
			vm.dateOptions = [];
			vm.dateTypes = [];

			vm.initialiseTable = initialiseTable;
			vm.filterPurchaseOrders = filterPurchaseOrders;
			vm.searchPurchaseOrders = searchPurchaseOrders;
			vm.viewPurchaseOrder = viewPurchaseOrder;
			vm.flipOrders = flipOrders;
			vm.acceptOrders = acceptOrders;
			vm.rejectOrders = rejectOrders;
			vm.flagAsShippedOrders = flagAsShippedOrders;
			vm.flagAsDeliveredOrders = flagAsDeliveredOrders;
			vm.cancelOrders = cancelOrders;
			vm.closeOrders = closeOrders;
			vm.goToRelated = goToRelated;
			vm.getCurrentlySelectedPurchaseOrders = getCurrentlySelectedPurchaseOrders;
			vm.orderChanged = orderChanged;
			vm.dateChanged = dateChanged;
			vm.dateTypeChanged = dateTypeChanged;
			vm.onSelectedChanged = onSelectedChanged;
			vm.onDataDisplayed = onDataDisplayed;
			vm.statusChanged = statusChanged;
			vm.onPageSizeChanged = onPageSizeChanged;
			vm.onPageNumberChanged = onPageNumberChanged;
			vm.clearFilters = clearFilters;
			vm.downloadRenderedPurchaseOrder = downloadRenderedPurchaseOrder;
			vm.downloadPurchaseOrdersAsCsv = downloadPurchaseOrdersAsCsv;
			vm.markOrdersAsInvoiced = markOrdersAsInvoiced;
			var spinner;

			initialiseTable();

			return;

			/**
    * Initialises the table by configuring it and getting initial set of data.
    */
			function initialiseTable() {

				setLabels();

				vmFiltersListConfigurator.configure(stateParams, vm, purchaseOrderListConfigurator);

				currencyCache.getCurrencies().then(function () {
					getPurchaseOrders();
				});

				return;

				/**
     * Sets labels values depending on user rights           
     */
				function setLabels() {
					var data = [{
						rights: ["Supplier"],
						key: "title",
						label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.HEADER.TITLE_SUPPLIER"
					}, {
						key: "title",
						rights: ["Buyer"],
						label: "EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.HEADER.TITLE_BUYER"
					}];

					vm.labels = authorizedObjectsFilter.getAuthorizedObjectsAsAssociative(data, 'key', 'label');
				}
			}

			/*
    * Triggers the navigation to a new state with free form search applied
    * Filtering using the text search should ignore the set filters and use less restrictive filters
    */
			function searchPurchaseOrders() {
				var filters = _.extend({}, vm.searchDefaultFilter || {}, { searchText: vm.selectedFilters.searchText });
				filterPurchaseOrders(filters);
			}

			/**
    * Triggers the navigation to a new state with applied filters
    */
			function filterPurchaseOrders(filterOptions) {
				vm.loading = true;
				var params = util.isRealObject(filterOptions) ? filterOptions : {
					dateType: vm.selectedFilters.dateType.value,
					dateTimeFilter: vm.selectedFilters.dateTimeFilter.value,
					statusFilter: vm.selectedFilters.statusFilter.value,
					sortOption: vm.selectedFilters.sortOption.value,
					fromDate: dateFormatter.toServerDate(vm.selectedFilters.customDateTimeFilter.fromDate),
					toDate: dateFormatter.toServerDate(vm.selectedFilters.customDateTimeFilter.toDate),
					searchText: vm.selectedFilters.searchText
				};
				//reset page number for each filtering
				params = setInitialPaginationDetails(params);

				//save current filters to local storage before navigating away
				storeParams(params);
				diState.go('.', params, { reload: true });
			}

			/**
    * Starts the loading spinner and calls the purchaseOrder repository to retrieve the purchase orders
    */
			function getPurchaseOrders() {
				if (util.isDefined(resultsReachedNotification)) {
					resultsReachedNotification.hide();
				}

				showSpinner();

				var customDateTimeFilter = null;
				if (vm.selectedFilters.customDateTimeFilter.fromDate !== "" && vm.selectedFilters.customDateTimeFilter.toDate !== "") {
					customDateTimeFilter = {
						fromDate: dateFormatter.toServerDate(vm.selectedFilters.customDateTimeFilter.fromDate),
						toDate: dateFormatter.toServerDate(vm.selectedFilters.customDateTimeFilter.toDate)
					};
				}

				purchaseOrderRepository.getPurchaseOrders(vm.selectedFilters.searchText, vm.tableOptions.maxItemsToShow, vm.selectedFilters.dateType.value, vm.selectedFilters.dateTimeFilter.value, customDateTimeFilter, vm.selectedFilters.sortOption.value, vm.selectedFilters.statusFilter.value, vm.selectedFilters.attributesFilter).then(resolved, rejected).finally(function () {
					vm.loading = false;
				});

				return;

				/**
     * Callback after promise resolved
     */
				function resolved(data) {
					if (util.isUndefined(data)) {
						data = [];
					}

					if (data.length >= vm.tableOptions.maxItemsToShow) {
						translator.translate("EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.MAXIMUM_PURCHASE_ORDERS_REACHED").then(function (translated) {
							resultsReachedNotification = elementNotifier.warning(translated, findElement('#purchaseOrdersList'), { clickToHide: true });
							resultsReachedNotification.show();
						});
					}

					translateDocumentData(data);

					vm.purchaseOrders.fill(data);

					onSelectedChanged([]);

					removeSpinner();

					return;

					function translateDocumentData(array) {
						documentStateResolver.resolveDocumentStates("order", array);

						_.each(array, function (order) {
							getCalculatedState(order.clientEInvoicingStateId).then(function (calculated) {
								order.calculatedState = calculated;
							});

							enumTranslator.translate(clientEnums.orderType, order.orderType).then(function (translated) {
								order.orderType = translated;
							});

							order.attributes = setAttributes(order);
						});
					}

					function setAttributes(order) {
						var array = documentAttributeResolver.resolveAttributeKeys(order.attributes);

						if (isUserSupplier()) {
							documentAttributeResolver.removeAttribute(array, clientEnums.documentAttribute.notScheduledForPayment);
							documentAttributeResolver.removeAttribute(array, clientEnums.documentAttribute.scheduledForPayment);
						}

						return array;
					}

					/**
      * Finds element in DOM					             
      */
					function findElement(key) {
						if (util.isFunction(scope.findElement)) {
							var element = scope.findElement(key);

							return element;
						}

						return null;
					}
				}

				/**
      * Notifies about failure while loading purchase order data				
      */
				function rejected() {
					removeSpinner();
				}
			}

			/**
    * View selected purchase order.
    */
			function viewPurchaseOrder() {
				var selectedRows = vm.getCurrentlySelectedPurchaseOrders();

				if (selectedRows.length <= 0 || selectedRows.length > 1) {
					return;
				}

				var selectedPoIds = _.pluck(selectedRows, 'id');

				var selectedPoId = selectedPoIds[0];

				diState.go('portal.orders.viewById', { id: selectedPoId });
			}

			/**
    * Flips order into invoice             
    */
			function flipOrders() {
				var selectedRows = vm.getCurrentlySelectedPurchaseOrders();

				if (selectedRows.length <= 0) {
					return;
				}

				_.each(selectedRows, function (order) {
					flipOrder(order);
				});

				clearSelected();

				return;

				/**
     * Flips selected orders into invoices if possible                 
     */
				function flipOrder(order) {
					purchaseOrderRepository.flipOrder(order.id, order.purchaseOrderNumber).then(resolved);

					return;

					/**
      * Promise resolved                     
      */
					function resolved(data) {
						translator.translate("EINVOICING.PORTAL.PURCHASE_ORDERS.ACTIONS.NOTIFICATION.SUCCESS.FLIP_GO_TO_INVOICE_LINK").then(function (translated) {
							var link = translated;

							switch (data.success) {
								case false:
									var message = translator.instantTranslate("EINVOICING.PORTAL.PURCHASE_ORDERS.ACTIONS.NOTIFICATION.ERROR.FLIP_FAILURE_REASON." + data.failureReason);

									var viewAction = goToViewInvoice;

									if (data.invoiceId <= 0) {
										link = "";
										viewAction = null;
									} else {
										link = '<br/>' + link;
									}

									notificationHandler.showWarning(message + link, order.purchaseOrderNumber, viewAction);
									break;
								default:
									notificationHandler.showSuccess(translator.instantTranslate("EINVOICING.PORTAL.PURCHASE_ORDERS.ACTIONS.NOTIFICATION.SUCCESS.FLIP_SUCCESS") + '<br />' + link, order.purchaseOrderNumber, goToEditInvoice);
									break;
							}

							reloadDocumentActions(order);
						});

						return;

						/**
      * Redirects to invoice details page                         
      */
						function goToEditInvoice() {
							if (data.invoiceId > 0) {
								diState.go('portal.invoices.editById', { id: data.invoiceId });
							}
						}

						function goToViewInvoice() {
							if (data.invoiceId > 0) {
								diState.go('portal.invoices.viewById', { id: data.invoiceId });
							}
						}
					}
				}
			}

			/**
    * Handler for accepting orders
    */
			function acceptOrders() {
				var selectedRows = vm.getCurrentlySelectedPurchaseOrders();

				if (selectedRows.length <= 0) {
					return;
				}

				_.each(selectedRows, function (order) {
					acceptOrder(order);
				});

				clearSelected();

				return;

				/**
     * Accepts single order			 
     */
				function acceptOrder(order) {
					purchaseOrderRepository.acceptOrder(order.documentId, order.purchaseOrderNumber).then(resolved);

					return;

					function resolved() {
						updateResolvedState(order, clientEnums.documentStateKey.accepted);
						reloadDocumentActions(order);
					}
				}
			}

			/**
    * Handler for rejecting orders
    */
			function rejectOrders() {
				var selectedRows = vm.getCurrentlySelectedPurchaseOrders();

				if (selectedRows.length <= 0) {
					return;
				}

				_.each(selectedRows, function (order) {
					rejectOrder(order);
				});

				clearSelected();

				return;

				function rejectOrder(order) {
					purchaseOrderRepository.rejectOrder(order.documentId, order.purchaseOrderNumber).then(resolved);

					return;

					function resolved() {
						updateResolvedState(order, clientEnums.documentStateKey.rejected);
						reloadDocumentActions(order);
					}
				}
			}

			/**
    * Handler for flagging orders as shipped or not shipped
    */
			function flagAsShippedOrders(shipped) {
				var selectedRows = vm.getCurrentlySelectedPurchaseOrders();

				if (selectedRows.length <= 0) {
					return;
				}

				_.each(selectedRows, function (order) {
					flagAsShipped(order, shipped);
				});

				clearSelected();

				return;

				function flagAsShipped(order, shipped) {
					purchaseOrderRepository.flagAsShipped(order.documentId, shipped, order.purchaseOrderNumber).then(resolved);

					return;

					function resolved() {
						if (shipped) {
							updateResolvedState(order, clientEnums.documentStateKey.shipped);
						} else {
							reloadDocumentState(order);
						}

						reloadDocumentActions(order);
					}
				}
			}

			/**
    * Handler for flagging orders as delivered or not delivered
    */
			function flagAsDeliveredOrders(delivered) {
				var selectedRows = vm.getCurrentlySelectedPurchaseOrders();

				if (selectedRows.length <= 0) {
					return;
				}

				_.each(selectedRows, function (order) {
					flagAsDelivered(order, delivered);
				});

				clearSelected();

				return;

				function flagAsDelivered(order, delivered) {
					purchaseOrderRepository.flagAsDelivered(order.documentId, delivered, order.purchaseOrderNumber).then(resolved);

					return;

					function resolved() {

						if (delivered) {
							updateResolvedState(order, clientEnums.documentStateKey.delivered);
						} else {
							reloadDocumentState(order);
						}

						reloadDocumentActions(order);
					}
				}
			}

			/**
    * Handler for canceling selected orders			 
    */
			function cancelOrders() {
				var selectedRows = vm.getCurrentlySelectedPurchaseOrders();

				if (selectedRows.length <= 0) {
					return;
				}

				_.each(selectedRows, function (order) {
					cancelOrder(order);
				});

				clearSelected();

				return;

				function cancelOrder(order) {
					purchaseOrderRepository.cancelOrder(order.documentId, order.purchaseOrderNumber).then(resolved);

					return;

					function resolved() {
						updateResolvedState(order, clientEnums.documentStateKey.cancelled);
						reloadDocumentActions(order);
					}
				}
			}

			/**
    * Handler for closing selected orders			 
    */
			function closeOrders() {
				var selectedRows = vm.getCurrentlySelectedPurchaseOrders();

				if (selectedRows.length <= 0) {
					return;
				}

				_.each(selectedRows, function (order) {
					closePurchaseOrder(order);
				});

				clearSelected();

				return;

				function closePurchaseOrder(order) {
					purchaseOrderRepository.closeOrder(order.documentId, order.purchaseOrderNumber).then(resolved);

					return;

					function resolved() {
						updateResolvedState(order, clientEnums.documentStateKey.closed);
						reloadDocumentActions(order);
					}
				}
			}

			function goToRelated() {
				var selected = getSelectedPurchaseOrder();

				if (util.isDefined(selected.documentId)) {
					diState.go('portal.related.list', { id: selected.documentId });
				}
			}

			/**
    * Updates document state on the list or shows error
    */
			function updateResolvedState(order, stateId) {
				order.clientEInvoicingStateId = stateId;

				documentStateResolver.resolveDocumentState('order', stateId).then(function (resolved) {
					order.clientEInvoicingState = resolved;

					getCalculatedState(stateId).then(function (calculated) {
						order.calculatedState = calculated;
					});
				});
			}

			/**
   * Clears selected items                 
   */
			function clearSelected() {
				vm.purchaseOrders.forEach(function clearSelected(item) {
					item.isSelected = false;
				});

				vm.selectedStates.primary.clear();
				vm.selectedAttributes.primary.clear();
			}

			/**
    * Gets calculated document state			
    */
			function getCalculatedState(stateId) {
				return documentStateResolver.calculateCurrentState('order', stateId, true);
			}

			/**
    * Resets the search filters on the page back to the default values and reloads
    */
			function clearFilters() {
				var initialFilters = {
					dateType: purchaseOrderListConfigurator.getInitialDateType().value,
					dateTimeFilter: purchaseOrderListConfigurator.getInitialDateTimeFilter().value,
					statusFilter: purchaseOrderListConfigurator.getInitialStatusFilter().value,
					sortOption: purchaseOrderListConfigurator.getInitialSortOption().value,
					fromDate: undefined,
					toDate: undefined,
					searchText: ""
				};

				filterPurchaseOrders(initialFilters);
			}

			/**
    * Downloads a rendered document for the selected purchase order
    */
			function downloadRenderedPurchaseOrder() {
				var purchaseOrder = getSelectedPurchaseOrder();

				if (util.isDefined(purchaseOrder)) {
					documentDownloader.downloadRenderedPurchaseOrder(purchaseOrder.documentId);
				}
			}

			/**
    * Downloads a csv file containing data for the selected or displayed purchase orders
    */
			function downloadPurchaseOrdersAsCsv() {
				var toDownload = getCurrentlySelectedPurchaseOrders();

				if ((!util.isArray(toDownload) || toDownload.length === 0) && vm.purchaseOrders.length > 0) {
					toDownload = getCurrentlyDisplayedPurchaseOrders();
				}

				var purchaseOrderIds = _.reduce(toDownload, function (result, order) {
					if (!util.isNullOrUndefined(order.id)) {
						result.push(order.id);
					}
					return result;
				}, []);

				if (util.isArray(purchaseOrderIds) && purchaseOrderIds.length > 0) {
					documentDownloader.downloadPurchaseOrdersCsv(purchaseOrderIds);
				}
			}

			/**
    * Function which marks the currently selected purchase orders as fully invoiced
    */
			function markOrdersAsInvoiced() {
				var toMarkAsInvoiced = getCurrentlySelectedPurchaseOrders();

				var documentIdsToMarkInvoiced = _.pluck(toMarkAsInvoiced, 'documentId');

				purchaseOrderRepository.markPurchaseOrdersAsInvoiced(documentIdsToMarkInvoiced).then(resolved, rejected);

				clearSelected();

				return;

				function resolved(data) {
					if (util.isArray(data) === false) {
						return;
					}

					_.each(data, function (updatedItem) {
						var order = _.find(vm.purchaseOrders, function (order) {
							return order.documentId === updatedItem.documentId;
						});
						if (util.isObject(order)) {
							order.actions = updatedItem.userActions;
							updateResolvedState(order, updatedItem.documentState);
						}
					});
					resetAllowedActions();

					notificationHandler.showSuccess('EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.ACTIONS.MARK_INVOICED.SUCCESS');
				}

				function rejected() {
					notificationHandler.showError('EINVOICING.PORTAL.PURCHASE_ORDERS.LISTS.ACTIONS.MARK_INVOICED.FAILURE');
				}
			}

			/**
    * Event when order filter has changed            
    */
			function orderChanged(value) {
				var item = _.find(vm.sortOptions, function (option) {
					return option.value === value;
				});

				if (util.isUndefined(item)) {
					return;
				}

				vm.selectedFilters.sortOption = item;
			}

			/**
    * Event when date filter has changed           
    */
			function dateChanged(value, customDate) {
				var item = _.find(vm.dateOptions, function (option) {
					return option.value === value;
				});

				if (util.isUndefined(item)) {
					return;
				}

				vm.selectedFilters.dateTimeFilter = item;

				if (customDate) {
					vm.selectedFilters.customDateTimeFilter = customDate;
				} else {
					vm.selectedFilters.customDateTimeFilter.fromDate = '';
					vm.selectedFilters.customDateTimeFilter.toDate = '';
				}
			}

			/**
    * Event when date type changed			
    */
			function dateTypeChanged(value) {
				var item = _.find(vm.dateTypes, function (option) {
					return option.value === value;
				});

				if (util.isUndefined(item)) {
					return;
				}

				vm.selectedFilters.dateType = item;

				vm.dateOptions = purchaseOrderListConfigurator.getDateTimeFilters(vm.selectedFilters.dateType.value);
				vm.selectedFilters.dateTimeFilter = purchaseOrderListConfigurator.getInitialDateTimeFilter(vm.selectedFilters.dateType.value);
			}

			/**
    * Event handler when selection changed             
    */
			function onSelectedChanged(items) {
				vm.selectedItemsCount.primary = items.length;

				var arrayStates = [];
				var arrayAttributes = [];
				var arrayActions = [];

				populateStatesActionsAndAttributes(items, arrayStates, arrayActions, arrayAttributes);

				var resolvedActions = userActionsResolver.resolveActions(arrayActions, true);

				vm.selectedAttributes.primary.fill(arrayAttributes);
				vm.selectedActions.primary.fill(resolvedActions);
				vm.selectedStates.primary.fill(arrayStates);
			}

			function populateStatesActionsAndAttributes(items, arrayStates, arrayActions, arrayAttributes) {
				_.each(items, function (item) {
					arrayStates.push(item.documentStateKey);

					arrayActions.push(item.actions);

					var array = [];

					array.fill(item.attributes);

					_.each(array, function (attribute) {
						arrayAttributes.push(attribute);
					});
				});
			}

			/**
    * Event handler after data is displayed
    */
			function onDataDisplayed(items) {
				resetSelectedSecondaryItems();

				var arrayStates = [];
				var arrayAttributes = [];
				var arrayActions = [];

				populateStatesActionsAndAttributes(items, arrayStates, arrayActions, arrayAttributes);

				var resolvedActions = userActionsResolver.resolveActions(arrayActions, true);

				vm.selectedItemsCount.secondary = items.length;
				vm.selectedAttributes.secondary.fill(arrayAttributes);
				vm.selectedActions.secondary.fill(resolvedActions);
				vm.selectedStates.secondary.fill(arrayStates);
			}

			/**
    * Clears the secondary array property of selectedAttributes, selectedActions and selectedStates
    * Sets the secondary int property of selectedItemsCount to 0
    */
			function resetSelectedSecondaryItems() {
				vm.selectedItemsCount.secondary = 0;
				vm.selectedAttributes.secondary.clear();
				vm.selectedActions.secondary.clear();
				vm.selectedStates.secondary.clear();
			}

			/**
    * Event handler when status filter has changed           
    */
			function statusChanged(value) {
				var item = _.find(vm.statusOptions, function (option) {
					return option.value === value;
				});

				if (util.isUndefined(item)) {
					return;
				}

				vm.selectedFilters.statusFilter = item;
			}

			/*
    * Event handler when the size of the page changes
    */
			function onPageSizeChanged(newSize) {
				updateStoredParams({ pageSize: newSize, pageNumber: 1 });
			}

			/*
    * Event handler when the page changes
    */
			function onPageNumberChanged(newPageNumber) {
				updateStoredParams({ pageNumber: newPageNumber });
			}

			/**
    * Get currently selected purchase orders from the table.
    */
			function getCurrentlySelectedPurchaseOrders() {
				var selectedRows = [];

				vm.purchaseOrders.forEach(function addToSelected(item) {
					if (item.isSelected === true) {
						selectedRows.push(item);
					}
				});

				return selectedRows;
			}

			/**
    * Returns the currently displayed purchase orders
    */
			function getCurrentlyDisplayedPurchaseOrders() {
				var displayedRows = _.filter(vm.purchaseOrders, function (item) {
					return item.isDisplayed;
				});
				return displayedRows;
			}

			function getSelectedPurchaseOrder() {
				var selectedRows = getCurrentlySelectedPurchaseOrders();

				if (selectedRows.length === 1) {
					return selectedRows[0];
				}
				return {};
			}

			function reloadDocumentState(order) {
				documentProxy.getDocumentClientStateId(order.id, clientEnums.documentType.purchaseOrder).then(resolved);

				return;

				function resolved(stateId) {
					updateResolvedState(order, stateId);
				}
			}

			/**
    * Reloads document allowed actions           
    */
			function reloadDocumentActions(order) {
				purchaseOrderRepository.getAllowedActions(order.documentId, order.purchaseOrderNumber).then(resolved);
				return;

				function resolved(data) {
					order.actions = data;
					resetAllowedActions();
				}
			}

			function isUserSupplier() {
				return userRightsRepository.userHasRight("Supplier");
			}

			/**
    * resets allowed actions             
    */
			function resetAllowedActions() {
				vm.selectedItemsCount.primary = 0;
				vm.selectedActions.primary.clear();
			}

			/**
   * Adds spinner to the page			 
   */
			function showSpinner() {
				spinner = modalSpinner.showModalSpinner("#spinnerHolder");
			}

			/**
    * Removes spinner from the page
   */
			function removeSpinner() {
				if (spinner) {
					spinner.remove();
				}
			}

			/*
   * Stores the params in the local storage
   */
			function storeParams(params) {
				listsParamsStore.set("orders", params);
			}

			/*
    * Updates the params in the local storage
    */
			function updateStoredParams(params) {
				listsParamsStore.update("orders", params);
			}

			/*
    * Extends the source object with pageSize set to the current paginationPageSize and pageNumber set to 1
    */
			function setInitialPaginationDetails(source) {
				return _.extend(source, {
					pageSize: vm.tableOptions.paginationPageSize,
					pageNumber: 1
				});
			}
		}

		return PurchaseOrderListController;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 463 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP51}
// di.einvoicing.ui.portal.portal.purchaseorders.lists
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.controller('PurchaseOrderListFiltersController', PurchaseOrderListFiltersController);

        PurchaseOrderListFiltersController.$inject = ['$scope', 'purchaseOrderListConfigurator', 'translator'];

        /**
        * Manages and configure purchase orders list filter options.
        * @param scope
        * @param purchaseOrderListConfigurator
        * @returns
        */
        function PurchaseOrderListFiltersController(scope, purchaseOrderListConfigurator, translator) {

            var vm = this;

            vm.availableDateTimeFilters = [];
            vm.availableSortableColumns = [];

            vm.translateFilterLabels = translateFilterLabels;

            getAvailableFilters();

            return;

            /**
            * Initialises the table filters.
            */
            function getAvailableFilters() {
                getAvailableDateTimeFilters();
                getAvailableSortableColumns();
            }

            /**
            * Initialises the date time filters.
            */
            function getAvailableDateTimeFilters() {
                vm.availableDateTimeFilters = purchaseOrderListConfigurator.getDateTimeFilters();
                vm.translateFilterLabels(vm.availableDateTimeFilters);
            }

            /**
            * Sets the default sortable columns based on the value in the purchase order list configurator
            */
            function getAvailableSortableColumns() {
                vm.availableSortableColumns = purchaseOrderListConfigurator.getSortableColumns();
                vm.translateFilterLabels(vm.availableSortableColumns);
            }

            /**
            * Translate filter labels collection using translator service.
            * @param filters
            */
            function translateFilterLabels(filters) {
                translator.whenReady().then(function () {
                    _.each(filters, function (filter) {
                        translator.instantTranslate(filter.label).then(function (translated) {
                            filter.label = translated;
                        });
                    });
                });
            }
        }

        return PurchaseOrderListFiltersController;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 464 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF1M}
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.constant('PURCHASE_ORDER_ADDITIONAL_DOCUMENT_REFERENCES_CONFIGURATION', purchaseOrderAdditionalDocumentReferencesConfiguration());

		function purchaseOrderAdditionalDocumentReferencesConfiguration() {
			return [{
				field: 'reference',
				header: 'EINVOICING.PORTAL.COMPONENTS.ADDITIONAL_DOCUMENT_REFERENCES.REFERENCE',
				headerClass: "centeredcellDesc",
				readonlyTemplate: '<p class="readonly">{{ binding.reference }}</p>'
			}, {
				field: 'documentType',
				header: 'EINVOICING.PORTAL.COMPONENTS.ADDITIONAL_DOCUMENT_REFERENCES.DOCUMENT_TYPE',
				headerClass: "centeredcellDesc",
				readonlyTemplate: '<p class="readonly">{{ binding.documentType }}</p>'
			}, {
				field: 'fileName',
				header: 'EINVOICING.PORTAL.COMPONENTS.ADDITIONAL_DOCUMENT_REFERENCES.FILENAME',
				headerClass: "centeredcellDesc",
				readonlyTemplate: '<div ng-if="controller.hasAttachment(binding)"\
											ng-click="controller.download({attachmentDataId : binding.attachmentDataId, filename: binding.fileName })">\
											<p class="readonly">\
												<a href="#">{{ binding.fileName }}</a>\
											</p>\
										</div>'
			}, {
				field: 'uri',
				header: 'EINVOICING.PORTAL.COMPONENTS.ADDITIONAL_DOCUMENT_REFERENCES.URI',
				headerClass: "centeredcellDesc",
				readonlyTemplate: '<div>\
									<div ng-if="controller.isAbsoluteUrl(binding.uri)"\
										title="{{ binding.uri }}">\
										<p class="readonly">\
											<a ng-href="{{ binding.uri }}" target="_blank" di-translate>EINVOICING.PORTAL.COMPONENTS.ADDITIONAL_DOCUMENT_REFERENCES.LINK</a>\
										</p>\
									</div>\
									<div ng-if="!controller.isAbsoluteUrl(binding.uri)">\
										<p class="readonly">{{ binding.uri }}</p>\
									</div>\
								</div>'
			}];
		}
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 465 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:UPP01}
// di.einvoicing.ui.portal.proxies
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
				'use strict';

				return function (module) {
								var guard = $di.exception.guard;
								var util = $di.utility.util;

								module.factory('purchaseOrderProxy', purchaseOrderProxy);

								purchaseOrderProxy.$inject = ['webApiHttp', '$q', 'purchaseOrderFormatter', 'CLIENT_ENUMS', 'enumTranslator', 'urlHelper', 'proxyErrorInterceptor'];

								function purchaseOrderProxy(http, $q, purchaseOrderFormatter, clientEnums, enumTranslator, urlHelper, proxyErrorInterceptor) {
												var defaultFailureReason = 'EINVOICING.PORTAL.PURCHASE_ORDERS.PROXIES.DEFAULT_ERROR';

												return {
																getById: getById,
																getDetailsByAuditId: getDetailsByAuditId,
																getByPurchaseOrderNumber: getByPurchaseOrderNumber,
																commitPurchaseOrder: commitPurchaseOrder,
																getPurchaseOrders: getPurchaseOrders,
																submitPurchaseOrderByDocumentId: submitPurchaseOrderByDocumentId,
																acceptPurchaseOrder: acceptPurchaseOrder,
																rejectPurchaseOrder: rejectPurchaseOrder,
																flipPurchaseOrder: flipPurchaseOrder,
																flagAsShipped: flagAsShipped,
																flagAsDelivered: flagAsDelivered,
																cancelPurchaseOrder: cancelPurchaseOrder,
																closePurchaseOrder: closePurchaseOrder,
																getAllowedActions: getAllowedActions,
																markPurchaseOrdersAsInvoiced: markPurchaseOrdersAsInvoiced
												};

												/**
             * Gets the purchase order with the specified ID from the web API
             * @param id
             */
												function getById(id) {
																var requestUrl = 'PurchaseOrder/GetById/' + id;

																var promise = http.get(requestUrl);

																var newPromise = promise.then(purchaseOrderFormatter.reformatServerPurchaseOrderForClient, errorReceivingPurchaseOrder);

																return newPromise;
												}

												function getDetailsByAuditId(id) {
																guard.throwIfInvalidId("UPP010EE", id, 'id');

																var requestUrl = 'PurchaseOrder/GetDetailsByAuditId/' + id;

																var promise = http.get(requestUrl);

																var newPromise = promise.then(purchaseOrderFormatter.reformatServerInvoiceDetailsForClient, errorReceivingPurchaseOrder);

																return newPromise;
												}

												/**
             * Gets the purchase order with the specified purchase order number from the web API
             * @param number
             */
												function getByPurchaseOrderNumber(number) {
																guard.throwIfEmptyString("UPP0102E", number, 'number');

																var requestParams = {
																				purchaseOrderNumber: number
																};

																var requestUrl = urlHelper.setParameters('PurchaseOrder/GetByPurchaseOrderNumber', requestParams);

																var promise = http.get(requestUrl);

																var newPromise = promise.then(purchaseOrderFormatter.reformatServerPurchaseOrderForClient, errorReceivingPurchaseOrder);

																return newPromise;
												}

												/**
             * Commits the specified purchase order to the web API
             * @param purchaseOrder
             */
												function commitPurchaseOrder(purchaseOrder) {
																guard.throwIfNotAnObject("EUP4002E", purchaseOrder, 'purchaseOrder');

																var reformattedPurchaseOrder = purchaseOrderFormatter.reformatClientPurchaseOrderForServer(purchaseOrder);

																var promise = http.post('PurchaseOrder/CommitPurchaseOrder', reformattedPurchaseOrder);

																var newPromise = promise.then(resolve, reject);

																return newPromise;

																/**
                 * Callback when the purchase order ID is received successfully after committing a purchase order	
                 * @param data
                 */
																function resolve(data) {
																				guard.throwIfInvalidId("UPP0103E", data, "data");
																				return data;
																}

																/**
                 * Callback function executed when an error occurs saving a purchase order	
                 * @param error 
                 */
																function reject(error) {
																				return errorProcessingPurchaseOrder(error, 'EINVOICING.PORTAL.PURCHASE_ORDERS.PROXIES.SAVE_ERROR');
																}
												}

												/**
             * Get purchase orders collection from the database             
             */
												function getPurchaseOrders(searchText, lastNRows, dateType, dateTimeFilters, customDateTimeFilter, sortOption, statusOption, attributes) {
																guard.throwIfNotANumber("UPP0105E", lastNRows, "lastNRows");
																guard.throwIfInvalidId("EUP400AE", dateType, "dateType");
																guard.throwIfNullOrUndefined("UPP0106E", dateTimeFilters, "dateTimeFilters");
																guard.throwIfInvalidId("UPP0107E", sortOption, "sortOption");
																guard.throwIfInvalidId("UPP010BE", statusOption, "sortOption");

																if (!customDateTimeFilter) {
																				customDateTimeFilter = {
																								fromDate: new Date(),
																								toDate: new Date()
																				};
																}

																var requestedParams = {
																				lastNRows: lastNRows,
																				dateType: dateType,
																				dateTimeFilterOption: dateTimeFilters.toString(),
																				fromDate: JSON.stringify(customDateTimeFilter.fromDate).replace(/"/g, ""),
																				toDate: JSON.stringify(customDateTimeFilter.toDate).replace(/"/g, ""),
																				sortOption: sortOption,
																				statusOption: statusOption,
																				attributes: attributes
																};

																if (util.isNonEmptyString(searchText)) {
																				requestedParams.searchText = searchText;
																}

																var requestedUrl = urlHelper.setParameters('PurchaseOrder/GetPurchaseOrderSearchResults', requestedParams);

																var promise = http.get(requestedUrl);

																var newPromise = promise.then(success, failure);

																return newPromise;

																function success(data) {
																				return data;
																}

																function failure(error) {
																				return errorProcessingPurchaseOrder(error, 'EINVOICING.PORTAL.PURCHASE_ORDERS.PROXIES.RECEIVE_ERROR');
																}
												}

												/**
             * Submits the purchase order with the given document id (flag for export and sending)            
             */
												function submitPurchaseOrderByDocumentId(id) {
																guard.throwIfInvalidId("UPP0104E", id, 'id');

																var promise = http.post('PurchaseOrder/SubmitPurchaseOrderByDocumentId', id);

																var newPromise = promise.then(success, failure);

																return newPromise;

																function success(data) {
																				return data;
																}

																function failure(error) {
																				return errorProcessingPurchaseOrder(error, 'EINVOICING.PORTAL.PURCHASE_ORDERS.PROXIES.SHIPPED_ERROR');
																}
												}

												/**
             * Callback function executed when an error occurs saving a purchase order
             * @param error
             */
												function errorReceivingPurchaseOrder(error) {
																return errorProcessingPurchaseOrder(error, 'EINVOICING.PORTAL.PURCHASE_ORDERS.PROXIES.RECEIVE_ERROR');
												}

												function flagAsShipped(id, shipped) {
																guard.throwIfInvalidId("UPP010AE", id, "id");

																var requestParams = {
																				id: id
																};

																var url = 'PurchaseOrder/FlagAsShipped';

																if (util.isDefined(shipped) && shipped === false) {
																				url = 'PurchaseOrder/FlagAsNotShipped';
																}

																var requestUrl = urlHelper.setParameters(url, requestParams);

																var promise = http.post(requestUrl);

																var newPromise = promise.then(success, failure);

																return newPromise;

																function success(data) {
																				return data;
																}

																function failure(error) {
																				return errorProcessingPurchaseOrder(error, 'EINVOICING.PORTAL.PURCHASE_ORDERS.PROXIES.SHIPPED_ERROR');
																}
												}

												function flagAsDelivered(id, delivered) {

																guard.throwIfInvalidId("UPP010AE", id, "id");

																var requestParams = {
																				id: id
																};

																var url = 'PurchaseOrder/FlagAsDelivered';

																if (util.isDefined(delivered) && delivered === false) {
																				url = 'PurchaseOrder/FlagAsNotDelivered';
																}

																var requestUrl = urlHelper.setParameters(url, requestParams);

																var promise = http.post(requestUrl);

																var newPromise = promise.then(success, failure);

																return newPromise;

																function success(data) {
																				return data;
																}

																function failure(error) {
																				return errorProcessingPurchaseOrder(error, 'EINVOICING.PORTAL.PURCHASE_ORDERS.PROXIES.DELIVERED_ERROR');
																}
												}

												function cancelPurchaseOrder(id) {
																guard.throwIfInvalidId("UPP010AE", id, "id");

																var url = 'PurchaseOrder/VoidPurchaseOrder';

																var requestParams = {
																				id: id
																};

																var requestUrl = urlHelper.setParameters(url, requestParams);

																var promise = http.post(requestUrl);

																var newPromise = promise.then(success, failure);

																return newPromise;

																function success(data) {
																				return data;
																}

																function failure(error) {
																				return errorProcessingPurchaseOrder(error, 'EINVOICING.PORTAL.PURCHASE_ORDERS.PROXIES.CANCELLED_ERROR');
																}
												}

												function closePurchaseOrder(id) {
																guard.throwIfInvalidId("UPP010AE", id, "id");

																var url = 'PurchaseOrder/ClosePurchaseOrder';

																var requestParams = {
																				id: id
																};

																var requestUrl = urlHelper.setParameters(url, requestParams);

																var promise = http.post(requestUrl);

																var newPromise = promise.then(success, failure);

																return newPromise;

																function success(data) {
																				return data;
																}

																function failure(error) {
																				return errorProcessingPurchaseOrder(error, 'EINVOICING.PORTAL.PURCHASE_ORDERS.PROXIES.CLOSED_ERROR');
																}
												}

												/**
             * Loads allowed actions for purchase order
             */
												function getAllowedActions(id) {
																guard.throwIfInvalidId("UPP010CE", id, 'id');

																var requestUrl = 'PurchaseOrder/GetActionsAllowed/' + id;

																var promise = http.get(requestUrl);

																var newPromise = promise.then(resolved, rejected);

																return newPromise;

																function resolved(data) {
																				return data;
																}

																function rejected(error) {
																				return errorProcessingPurchaseOrder(error, 'EINVOICING.PORTAL.PURCHASE_ORDERS.PROXIES.ACTIONS_ERROR');
																}
												}

												function flipPurchaseOrder(id) {
																guard.throwIfInvalidId("UPP010AE", id, "id");

																var url = 'PurchaseOrder/FlipOrder';

																var requestParams = {
																				id: id
																};

																var requestUrl = urlHelper.setParameters(url, requestParams);

																var promise = http.post(requestUrl);

																var newPromise = promise.then(success, failure);

																return newPromise;

																function success(data) {
																				return data;
																}

																function failure(error) {
																				return errorProcessingPurchaseOrder(error, 'EINVOICING.PORTAL.PURCHASE_ORDERS.PROXIES.FLIP_ERROR');
																}
												}

												function acceptPurchaseOrder(id) {
																guard.throwIfInvalidId("UPP010AE", id, "id");

																var url = 'PurchaseOrder/AcceptPurchaseOrder';

																var requestParams = {
																				id: id
																};

																var requestUrl = urlHelper.setParameters(url, requestParams);

																var promise = http.post(requestUrl);

																var newPromise = promise.then(success, failure);

																return newPromise;

																function success(data) {
																				return data;
																}

																function failure(error) {
																				return errorProcessingPurchaseOrder(error, 'EINVOICING.PORTAL.PURCHASE_ORDERS.PROXIES.ACCEPTED_ERROR');
																}
												}

												function rejectPurchaseOrder(id) {
																guard.throwIfInvalidId("UPP010AE", id, "id");

																var url = 'PurchaseOrder/RejectPurchaseOrder';

																var requestParams = {
																				id: id
																};

																var requestUrl = urlHelper.setParameters(url, requestParams);

																var promise = http.post(requestUrl);

																var newPromise = promise.then(success, failure);

																return newPromise;

																function success(data) {
																				return data;
																}

																function failure(error) {
																				return errorProcessingPurchaseOrder(error, 'EINVOICING.PORTAL.PURCHASE_ORDERS.PROXIES.REJECTED_ERROR');
																}
												}

												/**
             * Function to mark the provided array of document Ids as invoiced
             * @param documentIds - array of document Ids to mark as invoiced
             * @returns - promise which resolves when the purchase orders are marked as invoiced 
             */
												function markPurchaseOrdersAsInvoiced(documentIds) {
																guard.throwIfNotArray("UPP010DE", documentIds, 'documentIds');

																var url = 'PurchaseOrder/MarkAsInvoiced';

																return http.post(url, documentIds);
												}

												/**
             * Callback function executed when an error occurs processing the purchase order
             * @param error
             */
												function errorProcessingPurchaseOrder(error, failureReason) {
																proxyErrorInterceptor.handleError(error, failureReason, defaultFailureReason);
																return $q.reject(error);
												}
								}

								return purchaseOrderProxy;
				};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 466 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF0V}
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var guard = $di.exception.guard;

		guard.throwIfNotAnObject("DEF0V01E", module, "module");

		module.factory('purchaseOrderLinesColumnSettings', purchaseOrderLinesColumnSettings);

		purchaseOrderLinesColumnSettings.$inject = ['authorizedObjectsFilter'];

		function purchaseOrderLinesColumnSettings(authorizedObjectsFilter) {
			var columnDefinitions = [{
				rights: ['Supplier', 'Buyer'],
				heading: 'EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COLUMN_HEADERS.ID',
				model: 'line.lineReference',
				headerClass: 'has-ordinal',
				readonlyTemplate: '<p class="centeredcell wordWrapBreakWord readonly">{{ binding.lineReference }}</p>',
				visible: true,
				hideable: false,
				isColumn: true,
				mandatory: true
			}, {
				rights: ['Supplier'],
				heading: 'EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COLUMN_HEADERS.SUPPLIER_CODE',
				model: 'line.code',
				headerClass: 'centeredcell',
				readonlyTemplate: '<p class="readonly">{{ binding.suppliersProductCode }}</p>',
				visible: true,
				hideable: true,
				isVisible: false,
				isHidden: false,
				isColumn: true,
				mandatory: true
			}, {
				rights: ['Buyer'],
				heading: 'EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COLUMN_HEADERS.CUSTOMER_CODE',
				model: 'line.code',
				headerClass: 'centeredcell',
				readonlyTemplate: '<p class="readonly">{{ binding.customersProductCode }}</p>',
				visible: true,
				hideable: true,
				isVisible: false,
				isHidden: false,
				isColumn: true,
				mandatory: true
			}, {
				rights: ['Supplier', 'Buyer'],
				heading: 'EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COLUMN_HEADERS.STANDARD_PRODUCT_CODE',
				model: 'line.standardProductCode',
				headerClass: 'centeredcell',
				readonlyTemplate: '<p class="readonly">{{ binding.standardProductCode }}</p>',
				visible: true,
				hideable: true,
				isVisible: true,
				isHidden: false,
				isColumn: false,
				mandatory: false
			}, {
				rights: ['Supplier', 'Buyer'],
				heading: 'EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COLUMN_HEADERS.STANDARD_PRODUCT_CODE_SCHEME',
				model: 'line.standardProductCodeScheme',
				headerClass: 'centeredcell',
				readonlyTemplate: '<p class="readonly">{{ binding.standardProductCodeScheme }}</p>',
				visible: true,
				hideable: true,
				isVisible: true,
				isHidden: false,
				isColumn: false,
				mandatory: false
			}, {
				rights: ['Supplier', 'Buyer'],
				heading: 'EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COLUMN_HEADERS.PRODUCT_TYPE',
				model: '(productLinesCtrl.productTypes[line.productType] || {}).name',
				headerClass: 'centeredcell',
				readonlyTemplate: '<p class="readonly">{{binding.productTypeName}}</p>',
				visible: true,
				hideable: true,
				isVisible: false,
				isHidden: false,
				isColumn: true,
				mandatory: true
			}, {
				rights: ['Supplier', 'Buyer'],
				heading: 'EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COLUMN_HEADERS.ITEM_NAME',
				model: 'line.itemName',
				headerClass: 'centeredcell',
				readonlyTemplate: '<p class="readonly">{{ binding.itemName }}</p>',
				visible: true,
				hideable: false,
				isVisible: false,
				isHidden: false,
				isColumn: true,
				mandatory: true
			}, {
				rights: ['Supplier', 'Buyer'],
				heading: 'EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COLUMN_HEADERS.ITEM_DESCRIPTION',
				model: 'line.description',
				headerClass: 'centeredcell',
				readonlyTemplate: '<p class="readonly">{{ binding.itemDescription }}</p>',
				visible: true,
				hideable: true,
				isVisible: false,
				isHidden: false,
				isColumn: true,
				mandatory: true
			}, {
				rights: ['Supplier', 'Buyer'],
				heading: 'EINVOICING.PORTAL.INVOICES.COMPONENTS.TABLE.COLUMNS.UNIT_PRICE',
				model: 'line.unitPrice',
				headerClass: "centeredcell",
				cellClass: "numericcell",
				dataType: 'number',
				readonlyTemplate: '<p class="readonly numericcell">{{ binding.unitPrice | diCurrency:binding.currencyId }}</p>',
				visible: true,
				hideable: false,
				isVisible: false,
				isHidden: false,
				isColumn: true,
				mandatory: true
			}, {
				rights: ['Supplier', 'Buyer'],
				heading: 'EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COLUMN_HEADERS.QUANTITY',
				model: 'line.quantity',
				headerClass: "centeredcell",
				cellClass: "numericcell",
				dataType: 'number',
				readonlyTemplate: '<p class="readonly numericcell">{{ binding.quantity }}</p>',
				visible: true,
				hideable: false,
				isVisible: false,
				isHidden: false,
				isColumn: true,
				mandatory: true
			}, {
				rights: ['Supplier', 'Buyer'],
				heading: 'EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COLUMN_HEADERS.QUANTITY_UNIT',
				model: 'line.unitOfMeasureId ? (productLinesCtrl.unitsOfMeasure[line.unitOfMeasureId] || {}).name : ""',
				headerClass: 'centeredcell',
				readonlyTemplate: '<p class="readonly">{{binding.quantityUnit}}</p>',
				visible: true,
				hideable: true,
				isVisible: false,
				isHidden: false,
				isColumn: true,
				mandatory: true
			}, {
				rights: ['Supplier', 'Buyer'],
				heading: 'EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COLUMN_HEADERS.TAX_CODE',
				model: 'line.taxCodeId ? line.taxCode + \': \' + line.taxRate + \'%\' : ""',
				headerClass: 'centeredcell',
				readonlyTemplate: '<p class="readonly">{{ binding.taxCode ? binding.taxCode + (binding.taxCategory ? \' (\' + binding.taxCategory + \')\' : \'\') + \': \' + binding.taxRate + \'%\' : "" }}</p>',
				visible: true,
				hideable: true,
				isVisible: false,
				isHidden: false,
				isColumn: true,
				mandatory: true
			}, {
				rights: ['Supplier', 'Buyer'],
				heading: 'EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COLUMN_HEADERS.TAX_AMOUNT',
				headerClass: "centeredcell",
				cellClass: "numericcell",
				model: 'line.taxAmount',
				dataType: 'number',
				readonlyTemplate: '<p class="readonly numericcell">{{ binding.taxAmount | diCurrency:binding.currencyId }}</p>',
				visible: true,
				hideable: true,
				isVisible: false,
				isHidden: false,
				isColumn: true,
				mandatory: true
			}, {
				rights: ['Supplier', 'Buyer'],
				heading: 'EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COLUMN_HEADERS.ECLASS_CODE',
				model: 'line.eClassCode',
				headerClass: 'centeredcell',
				readonlyTemplate: '<p class="readonly">{{binding.eClassCode}}</p>',
				visible: true,
				hideable: true,
				isVisible: true,
				isHidden: false,
				isColumn: false,
				mandatory: false
			}, {
				rights: ['Supplier', 'Buyer'],
				heading: 'EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COLUMN_HEADERS.PRICE_BASE_QUANTITY',
				model: 'line.priceBaseQuantity',
				headerClass: "centeredcell",
				cellClass: "numericcell",
				dataType: 'number',
				readonlyTemplate: '<p class="readonly numericcell">{{ binding.priceBaseQuantity }}</p>',
				visible: true,
				hideable: true,
				isVisible: true,
				isHidden: false,
				isColumn: false,
				mandatory: false
			}, {
				rights: ['Supplier', 'Buyer'],
				heading: 'EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COLUMN_HEADERS.AMOUNT',
				model: 'line.quantity * line.unitPrice',
				headerClass: "centeredcell",
				cellClass: "numericcell",
				dataType: 'number',
				readonlyTemplate: '<p class="readonly numericcell">{{ binding.lineAmount | diCurrency:binding.currencyId }}</p>',
				visible: true,
				hideable: false,
				isVisible: false,
				isHidden: false,
				isColumn: true,
				mandatory: true
			}, {
				rights: ['Supplier', 'Buyer'],
				heading: 'EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COLUMN_HEADERS.PRICE_ALLOWANCE_CHARGE_AMOUNT',
				model: 'line.allowanceChargeAmount',
				headerClass: "centeredcell",
				cellClass: "numericcell",
				dataType: 'number',
				readonlyTemplate: '<p class="readonly numericcell">{{ binding.priceAllowanceChargeAmount | diCurrency:binding.currencyId }}</p>',
				visible: true,
				hideable: true,
				isVisible: true,
				isHidden: false,
				isColumn: false,
				mandatory: false
			}, {
				rights: ['Supplier', 'Buyer'],
				heading: 'EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COLUMN_HEADERS.PRICE_ALLOWANCE_CHARGE_IS_CHARGE',
				model: 'line.allowanceChargeIsCharge',
				headerClass: "centeredcell",
				readonlyTemplate: '<p class="readonly">{{ binding.priceAllowanceChargeIsCharge | diYesNo }}</p>',
				visible: true,
				hideable: true,
				isVisible: true,
				isHidden: false,
				isColumn: false,
				mandatory: false
			}, {
				rights: ['Supplier', 'Buyer'],
				heading: 'EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COLUMN_HEADERS.PRICE_ALLOWANCE_CHARGE_BASE_AMOUNT',
				model: 'line.allowanceChargeBaseAmount',
				headerClass: "centeredcell",
				cellClass: "numericcell",
				dataType: 'number',
				readonlyTemplate: '<p class="readonly numericcell">{{ binding.priceAllowanceChargeBaseAmount | diCurrency:binding.currencyId }}</p>',
				visible: true,
				hideable: true,
				isVisible: true,
				isHidden: false,
				isColumn: false,
				mandatory: false
			}, {
				rights: ['Supplier', 'Buyer'],
				heading: 'EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COLUMN_HEADERS.ACCOUNTING_COST_REFERENCE',
				model: 'line.accountingCostReference',
				headerClass: "centeredcell",
				readonlyTemplate: '<p class="readonly">{{ binding.accountingCostReference }}</p>',
				visible: true,
				hideable: true,
				isVisible: true,
				isHidden: false,
				isColumn: false,
				mandatory: false
			}, {
				rights: ['Supplier', 'Buyer'],
				heading: 'EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COLUMN_HEADERS.ITEM_SPECIFICATION_DOCUMENT_REFERENCE',
				model: 'line.itemSpecificationDocumentReference',
				headerClass: "centeredcell",
				readonlyTemplate: '<p class="readonly">{{ binding.itemSpecificationDocumentReference }}</p>',
				visible: true,
				hideable: true,
				isVisible: true,
				isHidden: false,
				isColumn: false,
				mandatory: false
			}, {
				rights: ['Supplier', 'Buyer'],
				heading: 'EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COLUMN_HEADERS.REQUESTED_DELIVERY_PERIOD',
				model: 'line.requestedDeliveryPeriod',
				headerClass: "centeredcell",
				readonlyTemplate: "\n                        <p class=\"readonly\">\n                            <span>\n\t                            <span ng-if=\"binding.requestedDeliveryStartDate && binding.requestedDeliveryEndDate\">\n\t\t\t\t                {{binding.requestedDeliveryStartDate | diDate}} - {{binding.requestedDeliveryEndDate | diDate}}\n\t                            </span>\n\t                            <span ng-if=\"binding.requestedDeliveryStartDate && !binding.requestedDeliveryEndDate\">\n\t\t                        <span di-translate=\"EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COMPONENTS.DATE_DISPLAY.FROM\">\n\t\t                        </span>\n\t\t\t\t                {{ binding.requestedDeliveryStartDate | diDate }}\n                                </span>\n\t                            <span ng-if=\"!binding.requestedDeliveryStartDate && binding.requestedDeliveryEndDate\">\n\t\t                        <span di-translate=\"EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COMPONENTS.DATE_DISPLAY.BY\">\n\t\t                        </span>\n\t\t\t\t                {{ binding.requestedDeliveryEndDate | diDate}}\n\t                            </span>\n\t                            <span ng-if=\"!binding.requestedDeliveryStartDate && !binding.requestedDeliveryEndDate\"\n\t\t                              di-translate=\"EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COMPONENTS.DATE_DISPLAY.NOT_SPECIFIED\">\n\t                            </span>\n                            </span>\n\t\t\t\t\t\t</p>",
				visible: true,
				hideable: true,
				isVisible: true,
				isHidden: false,
				isColumn: false,
				mandatory: false
			}, {
				rights: ['Supplier', 'Buyer'],
				heading: 'EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COLUMN_HEADERS.ALLOW_PARTIAL_FULFILMENT',
				model: 'line.allowPartialFulfilment',
				headerClass: "centeredcell",
				readonlyTemplate: '<p class="readonly">{{ binding.allowPartialFulfilment | diYesNo }}</p>',
				visible: true,
				hideable: true,
				isVisible: true,
				isHidden: false,
				isColumn: false,
				mandatory: false
			}, {
				rights: ['Supplier', 'Buyer'],
				heading: 'EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COLUMN_HEADERS.ADDITIONAL_ITEM_PROPERTY',
				model: 'line.displayAdditionalItemProperty',
				headerClass: "centeredcell",
				readonlyTemplate: "\n                        <div>\n                            <div ng-repeat=\"item in ::binding.additionalItemProperties track by item.id\">\n                            {{item.name.toUpperCase() }}: {{item.value}} {{item.valueQuantity}} {{item.valueQuantityUnitName || item.valueQuantityUnit}} {{item.valueQualifier}}.\n                        </div>\n                        </div>",
				visible: true,
				hideable: true,
				isVisible: true,
				isHidden: false,
				isColumn: false,
				mandatory: false
			}, {
				rights: ['Supplier', 'Buyer'],
				heading: 'EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COLUMN_HEADERS.ORIGINATOR_PARTY',
				model: 'line.originatorPartyReference',
				headerClass: 'centeredcell',
				readonlyTemplate: '<p class="readonly" ng-if="binding.originatorPartyName">{{binding.originatorPartyName}}\
																	<span ng-if="binding.originatorPartyReference">\
																	<span ng-if="binding.originatorPartyName">(</span>{{ binding.originatorPartyReference }}<span ng-if="binding.originatorPartyName">)</span></span></p>',
				visible: true,
				hideable: true,
				isVisible: true,
				isHidden: false,
				isColumn: false,
				mandatory: false
			}, {
				rights: ['Supplier', 'Buyer'],
				heading: 'EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COLUMN_HEADERS.ORDER_NOTES',
				model: 'line.orderNotes',
				headerClass: "centeredcell",
				readonlyTemplate: '<textarea style="width:500px; height: 100px; background-color: inherit;" class="form-control" ng-disabled="true" ng-value="binding.orderNotes"></textarea>',
				visible: true,
				hideable: false,
				isVisible: true,
				isHidden: false,
				isColumn: false,
				mandatory: false
			}];
			var settings = getColumnSettings();

			return settings;

			/**
    * Returns a collection of settings for the purchase order columns
    */
			function getColumnSettings() {
				return {
					columns: _.map(authorizedObjectsFilter.getAuthorizedObjects(columnDefinitions, false), function (columnDefinition) {
						return _.omit(columnDefinition, 'rights');
					})
				};
			}
		}

		return purchaseOrderLinesColumnSettings;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 467 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP68}
// di.einvoicing.ui.portal.portal.purchaseorders
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var guard = $di.exception.guard;

		module.factory('purchaseOrderRepository', purchaseOrderRepository);

		purchaseOrderRepository.$inject = ['purchaseOrderProxy', '$q', 'notificationHandler'];

		/**
   * Repository for Purchase Orders		
   */
		function purchaseOrderRepository(purchaseOrderProxy, $q, notificationHandler) {
			return {
				getPurchaseOrders: getPurchaseOrders,
				acceptOrder: acceptOrder,
				rejectOrder: rejectOrder,
				closeOrder: closeOrder,
				cancelOrder: cancelOrder,
				flagAsShipped: flagAsShipped,
				flagAsDelivered: flagAsDelivered,
				flipOrder: flipOrder,
				getAllowedActions: getAllowedActions,
				markPurchaseOrdersAsInvoiced: markPurchaseOrdersAsInvoiced
			};

			/**
    * Loads list of orders from database			 
    */
			function getPurchaseOrders(searchText, lastNRows, dateType, dateTimeFilters, customDateTimeFilter, sortOption, statusOption) {
				var promise = purchaseOrderProxy.getPurchaseOrders(searchText, lastNRows, dateType, dateTimeFilters, customDateTimeFilter, sortOption, statusOption).then(resolved, rejected).catch();

				return promise;

				function resolved(data) {
					return data;
				}

				function rejected(error) {
					return rejectWithErrorNotification(error, '');
				}
			}

			/**
    * 	Flags order as accepted	 
    */
			function acceptOrder(id, reference) {
				guard.throwIfInvalidId("EUP6606E", id, 'id');

				var promise = purchaseOrderProxy.acceptPurchaseOrder(id).then(resolved, rejected);

				return promise;

				function resolved(data) {
					displaySuccessNotification("EINVOICING.PORTAL.PURCHASE_ORDERS.ACTIONS.NOTIFICATION.SUCCESS.ACCEPTED", reference);
					return data;
				}

				function rejected(error) {
					return rejectWithErrorNotification(error, reference);
				}
			}

			/**
    * 	Flags order as rejected	 
    */
			function rejectOrder(id, reference) {
				guard.throwIfInvalidId("EUP6801E", id, 'id');

				var promise = purchaseOrderProxy.rejectPurchaseOrder(id).then(resolved, rejected);

				return promise;

				function resolved(data) {
					displaySuccessNotification("EINVOICING.PORTAL.PURCHASE_ORDERS.ACTIONS.NOTIFICATION.SUCCESS.REJECTED", reference);
					return data;
				}

				function rejected(error) {
					return rejectWithErrorNotification(error, reference);
				}
			}

			/**
    * 	Flags order as closed	 
    */
			function closeOrder(id, reference) {
				guard.throwIfInvalidId("EUP6802E", id, 'id');

				var promise = purchaseOrderProxy.closePurchaseOrder(id).then(resolved, rejected);

				return promise;

				function resolved(data) {
					displaySuccessNotification("EINVOICING.PORTAL.PURCHASE_ORDERS.ACTIONS.NOTIFICATION.SUCCESS.CLOSED", reference);
					return data;
				}

				function rejected(error) {
					return rejectWithErrorNotification(error, reference);
				}
			}

			/**
    * 	Flags order as cancelled 
    */
			function cancelOrder(id, reference) {
				guard.throwIfInvalidId("EUP6803E", id, 'id');

				var promise = purchaseOrderProxy.cancelPurchaseOrder(id).then(resolved, rejected);

				return promise;

				function resolved(data) {
					displaySuccessNotification("EINVOICING.PORTAL.PURCHASE_ORDERS.ACTIONS.NOTIFICATION.SUCCESS.CANCELLED", reference);
					return data;
				}

				function rejected(error) {
					return rejectWithErrorNotification(error, reference);
				}
			}

			/**
    * 	Flags order as shipped or not		 
    */
			function flagAsShipped(id, isShipped, reference) {
				guard.throwIfInvalidId("EUP6804E", id, 'id');

				var promise = purchaseOrderProxy.flagAsShipped(id, isShipped).then(resolved, rejected);

				return promise;

				function resolved(data) {
					var message = "EINVOICING.PORTAL.PURCHASE_ORDERS.ACTIONS.NOTIFICATION.SUCCESS.SHIPPED";
					if (!isShipped) {
						message = "EINVOICING.PORTAL.PURCHASE_ORDERS.ACTIONS.NOTIFICATION.SUCCESS.NOTSHIPPED";
					}

					displaySuccessNotification(message, reference);
					return data;
				}

				function rejected(error) {
					return rejectWithErrorNotification(error, reference);
				}
			}

			/**
    * 	Flags order as delivered or not		 
    */
			function flagAsDelivered(id, isDelivered, reference) {
				guard.throwIfInvalidId("EUP6805E", id, 'id');

				var promise = purchaseOrderProxy.flagAsDelivered(id, isDelivered).then(resolved, rejected);

				return promise;

				function resolved(data) {
					var message = "EINVOICING.PORTAL.PURCHASE_ORDERS.ACTIONS.NOTIFICATION.SUCCESS.DELIVERED";
					if (!isDelivered) {
						message = "EINVOICING.PORTAL.PURCHASE_ORDERS.ACTIONS.NOTIFICATION.SUCCESS.NOTDELIVERED";
					}

					displaySuccessNotification(message, reference);
					return data;
				}

				function rejected(error) {
					return rejectWithErrorNotification(error, reference);
				}
			}

			/**
    * Flips purchase order into invoice			 
    */
			function flipOrder(id, reference) {
				guard.throwIfInvalidId("EUP6807E", id, 'id');

				var promise = purchaseOrderProxy.flipPurchaseOrder(id).then(resolved, rejected);

				return promise;

				function resolved(data) {
					return data;
				}

				function rejected(error) {
					return rejectWithErrorNotification(error, reference);
				}
			}

			/**
    * Function which marks a purchase order as invoiced
    * @param documentIds - The documents to mark as invoiced
    * @returns - Promise which resolves to the new state and available actions for the each document to update 
    */
			function markPurchaseOrdersAsInvoiced(documentIds) {
				guard.throwIfNotArray("EUP6809E", documentIds);

				var promise = purchaseOrderProxy.markPurchaseOrdersAsInvoiced(documentIds);

				return promise;
			}

			/**
    * Loads allowed actions for order            
    */
			function getAllowedActions(id, reference) {
				guard.throwIfInvalidId("EUP6808E", id, 'id');

				var promise = purchaseOrderProxy.getAllowedActions(id, reference).then(resolved, rejected);

				return promise;

				function resolved(data) {
					return data;
				}

				function rejected(error) {
					return rejectWithErrorNotification(error, reference);
				}
			}

			/**
    * rejects promise and displays error notification			
    */
			function rejectWithErrorNotification(error, reference) {
				notificationHandler.showError(error.failureReason, reference);

				return $q.reject(error).catch(function () {});
			}

			/**
    * Displays success notification			
    */
			function displaySuccessNotification(message, reference) {
				notificationHandler.showSuccess(message, reference);
			}
		};

		return purchaseOrderRepository;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 468 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP54}
// di.einvoicing.ui.portal.portal.purchaseOrders.viewer
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(469), __webpack_require__(472), __webpack_require__(470)], __WEBPACK_AMD_DEFINE_RESULT__ = function (snippetsLoader, purchaseOrderDetailsDirectiveLoader, dateRangeDisplayLoader) {
	'use strict';

	return function (module) {
		snippetsLoader(module);
		purchaseOrderDetailsDirectiveLoader(module);
		dateRangeDisplayLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 469 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP3C}
// di.einvoicing.ui.portal.purchaseOrders.components.snippets
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var snippetContext = $di.angular.snippetRegistrar.createContext(module, 'src/app/portal/purchaseOrders/viewer/_components/_snippets');

        snippetContext.registerSnippet('diPurchaseOrderHeader', 'purchaseOrderHeader.html');
        snippetContext.registerSnippet('diPurchaseOrderFooter', 'purchaseOrderFooter.html');
        snippetContext.registerSnippet('diPurchaseOrderLines', 'purchaseOrderLines.html');
        snippetContext.registerSnippet('diPurchaseOrderAllowancesCharges', 'purchaseOrderAllowancesCharges.html');
        snippetContext.registerSnippet('diPurchaseOrderSummaryHeader', 'purchaseOrderAuditSummaryHeader.html');
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 470 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP92}
// di.einvoicing.ui.portal.dateRangeDisplay
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(471)], __WEBPACK_AMD_DEFINE_RESULT__ = function (diDateRangeDisplayDirectiveLoader) {
	'use strict';

	return function (module) {
		diDateRangeDisplayDirectiveLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 471 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

// di.einvoicing.ui.portal.dateRangeDisplay
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.directive('diDateRangeDisplay', diDateRangeDisplay);

		function diDateRangeDisplay() {
			return {
				restrict: 'E',
				scope: {
					startDate: '=',
					endDate: '='
				},
				templateUrl: 'src/app/portal/purchaseOrders/viewer/_components/dateRangeDisplay/dateRangeDisplay.html'
			};
		}

		return diDateRangeDisplay;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 472 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP5C}
// di.einvoicing.ui.portal.portal.purchaseOrders.viewer
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ng) {
    'use strict';

    return function (module) {
        module.directive('diPurchaseOrderDetails', diPurchaseOrderDetails);

        function diPurchaseOrderDetails() {
            return {
                restrict: 'E',
                replace: true,
                scope: {},
                controller: "PurchaseOrderViewerController",
                controllerAs: "purchaseOrderViewerCtrl",
                templateUrl: 'src/app/portal/purchaseOrders/viewer/_components/purchaseOrderDetails/purchaseOrderDetails.html',
                link: link
            };

            function link(scope) {
                scope.findElement = findElement;

                return;

                function findElement(name) {
                    return ng.element(name);
                }
            }
        }

        return diPurchaseOrderDetails;
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 473 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP53}
// di.einvoicing.ui.portal.portal.purchaseOrders.viewer
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(468), __webpack_require__(475), __webpack_require__(474)], __WEBPACK_AMD_DEFINE_RESULT__ = function (componentsLoader, purchaseOrderViewerLinesConfiguratorLoader, purchaseOrderViewerControllerLoader) {
    'use strict';

    return function (module) {
        componentsLoader(module);
        purchaseOrderViewerLinesConfiguratorLoader(module);
        purchaseOrderViewerControllerLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 474 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP52}
// di.einvoicing.ui.portal.portal.purchaseOrders.viewer
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.controller('PurchaseOrderViewerController', PurchaseOrderViewerController);

		PurchaseOrderViewerController.$inject = ['$scope', 'headerData', '$stateParams', 'purchaseOrderProxy', 'diState', 'translator', 'enumTranslator', 'promptWindow', 'purchaseOrderViewerLinesConfigurator', 'currencyCache', 'authorizedObjectsFilter', 'CLIENT_ENUMS', 'documentStateResolver', 'documentAttributeResolver', 'documentProxy', 'purchaseOrderRepository', 'notificationHandler', 'modalSpinner', 'userActionsResolver', 'purchaseOrderLinesColumnSettings', 'scopeCacheFactory', 'documentDownloader', 'staticLookupProxy', 'attachmentProxy', '$q', 'auditProxy', 'PURCHASE_ORDER_ADDITIONAL_DOCUMENT_REFERENCES_CONFIGURATION', 'attachmentDownloadValidator'];

		function PurchaseOrderViewerController(scope, headerData, stateParams, purchaseOrderProxy, diState, translator, enumTranslator, diPrompt, purchaseOrderViewerLinesConfigurator, currencyCache, authorizedObjectsFilter, clientEnums, documentStateResolver, documentAttributeResolver, documentProxy, purchaseOrderRepository, notificationHandler, modalSpinner, userActionsResolver, purchaseOrderLinesColumnSettings, scopeCacheFactory, documentDownloader, staticLookupProxy, attachmentProxy, $q, auditProxy, purchaseOrderAdditionalDocumentReferencesConfiguration, attachmentDownloadValidator) {

			var vm = this;
			var functionToGetPurchaseOrder;
			var parameterToGetPurchaseOrder;

			var schemeTranslationPrefix = "EINVOICING.COMPONENTS.CLIENT_ENUMS.SCHEMES.";

			vm.mode = 'current';
			vm.auditSummary = {};

			vm.canFlip = false;
			vm.purchaseOrder = {
				lines: [],
				attributes: [],
				actions: [],
				allowanceCharges: []
			};
			vm.countries = [];
			vm.currentState = '...';
			vm.selectedStates = [];
			vm.selectedAttributes = [];
			vm.selectedActions = [];
			vm.labels = {};
			vm.buttonsSetOneOptions = {};
			vm.buttonsSetTwoOptions = {};
			vm.buttonsSetThreeOptions = {};
			vm.scopeCache = scopeCacheFactory.create(scope);
			vm.settings = purchaseOrderLinesColumnSettings;
			vm.languageKey = "EINVOICING.PORTAL.PURCHASE_ORDERS.COMPONENTS.PRODUCT_LINES";
			vm.additionalDocumentReferencesConfiguration = purchaseOrderAdditionalDocumentReferencesConfiguration;

			vm.billFromContact = {};
			vm.billToContact = {};
			vm.deliveryContact = {};
			vm.originatorCustomer = {};

			vm.supplierAddress = {};
			vm.buyerAddress = {};
			vm.deliveryAddress = {};
			vm.accountingCustomerAddress = {};

			vm.backToList = backToList;
			vm.flipOrder = flipOrder;
			vm.acceptOrder = acceptOrder;
			vm.rejectOrder = rejectOrder;
			vm.flagAsShipped = flagAsShipped;
			vm.flagAsDelivered = flagAsDelivered;
			vm.cancelOrder = cancelOrder;
			vm.closeOrder = closeOrder;
			vm.getRenderedOrder = getRenderedOrder;
			vm.downloadPurchaseOrderAsCsv = downloadPurchaseOrderAsCsv;
			vm.getRelatedDocuments = getRelatedDocuments;
			vm.downloadAttachment = downloadAttachment;
			vm.downloadAllAttachments = downloadAllAttachments;
			vm.markAsInvoiced = markAsInvoiced;
			vm.goToHistory = goToHistory;
			vm.goToViewCurrent = goToViewCurrent;

			vm.allowances = [];
			vm.charges = [];
			var spinner;

			initialise();

			return;

			/**
    * Initialises loading purchase order details
    * @returns {}
    */
			function initialise() {
				showSpinner();
				setLabels();
				vm.canFlip = util.isDefined(vm.labels.flipOrder);

				vm.buttonsSetOneOptions = purchaseOrderViewerLinesConfigurator.getButtonsSetOneConfiguration();
				vm.buttonsSetTwoOptions = purchaseOrderViewerLinesConfigurator.getButtonsSetTwoConfiguration();
				vm.buttonsSetThreeOptions = purchaseOrderViewerLinesConfigurator.getButtonsSetThreeConfiguration();

				staticLookupProxy.get('Country').then(function (data) {
					vm.countries.fill(data);
				});

				currencyCache.getCurrencies().then(function () {});

				loadPurchaseOrder();

				return;

				/**
     * loads purchase order details
     */
				function loadPurchaseOrder() {
					if (util.isNumber(stateParams.id)) {
						if (util.isNumber(stateParams.aid)) {
							vm.mode = 'audit';
							functionToGetPurchaseOrder = purchaseOrderProxy.getDetailsByAuditId;
							parameterToGetPurchaseOrder = stateParams.aid;
						} else {
							functionToGetPurchaseOrder = purchaseOrderProxy.getById;
							parameterToGetPurchaseOrder = stateParams.id;
						}
					} else if (util.isNonEmptyString(stateParams.purchaseOrderNumber)) {
						functionToGetPurchaseOrder = purchaseOrderProxy.getByPurchaseOrderNumber;
						parameterToGetPurchaseOrder = stateParams.purchaseOrderNumber;
					}

					if (functionToGetPurchaseOrder) {
						functionToGetPurchaseOrder(parameterToGetPurchaseOrder).then(resolved, rejected);
					}

					return;

					/**
      * resolved promise handler
      */
					function resolved(data) {
						removeSpinner();
						util.extend(vm.purchaseOrder, data);

						if (vm.mode === "audit") {
							loadAuditSummary();
						}

						setAttributes();
						setActions();
						setParties();
						setContacts();
						setLegal();
						setAddresses();

						setState(vm.purchaseOrder.clientDocumentState);
						setAllowancesCharges();
						setOrderType();
						return;

						function loadAuditSummary() {
							auditProxy.getAuditRecordForDocument(vm.purchaseOrder.documentId, stateParams.aid).then(auditResolved, auditRejected);

							return;

							function auditResolved(data) {
								enumTranslator.translate(clientEnums.eventType, data.eventTypeId).then(function (translated) {
									data.eventTypeName = translated;
									vm.auditSummary = data;
								});
							}

							function auditRejected() {}
						}

						function setAttributes() {
							var array = documentAttributeResolver.resolveAttributeKeys(vm.purchaseOrder.attributes);
							vm.selectedAttributes.fill(array);

							if (vm.mode === 'current') {
								documentAttributeResolver.addAttributeById(vm.selectedAttributes, clientEnums.documentAttribute.current);
							}
						}

						function setOrderType() {
							if (util.isDefined(vm.purchaseOrder.orderTypeId)) {
								if (vm.purchaseOrder.orderTypeId <= 0) {
									vm.purchaseOrder.orderTypeId = 1;
								}
								enumTranslator.translate(clientEnums.orderType, vm.purchaseOrder.orderTypeId).then(function (translated) {
									vm.purchaseOrder.orderType = translated;
								});
							}
						}
					}

					/**
                  * rejected promise handler
                  */
					function rejected() {
						removeSpinner();

						notificationHandler.showError(vm.labels.notLoaded, parameterToGetPurchaseOrder);
						backToList();
					}
				}

				/**
    * sets labels values depending on user rights
    */
				function setLabels() {
					var data = [{
						rights: ["Supplier"],
						key: "title",
						label: "EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.VIEW.HEADER.TITLE_SUPPLIER"
					}, {
						rights: ["Buyer"],
						key: "title",
						label: "EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.VIEW.HEADER.TITLE_BUYER"
					}, {
						rights: ["Supplier"],
						key: "orderNumber",
						label: "EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COMPONENTS.DETAILS.PURCHASE_ORDER_NUMBER_SUPPLIER"
					}, {
						rights: ["Buyer"],
						key: "orderNumber",
						label: "EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COMPONENTS.DETAILS.PURCHASE_ORDER_NUMBER_BUYER"
					}, {
						rights: ["Supplier"],
						key: "detailsHeading",
						label: "EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COMPONENTS.DETAILS.HEADING_SUPPLIER"
					}, {
						rights: ["Buyer"],
						key: "detailsHeading",
						label: "EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COMPONENTS.DETAILS.HEADING_BUYER"
					}, {
						rights: ["Supplier"],
						key: "notLoaded",
						label: "EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COULD_NOT_LOAD_PURCHASE_ORDER"
					}, {
						rights: ["Buyer"],
						key: "notLoaded",
						label: "EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.COULD_NOT_LOAD_SALES_ORDER"
					}, {
						rights: ["PurchaseOrderFlipper"],
						key: "flipOrder",
						label: "EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.ACTIONS.FLIP_ORDER_BUYER"
					}, {
						rights: ["Supplier"],
						key: "audit_title",
						label: "EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.VIEW.HEADER.AUDIT_TITLE_SUPPLIER"
					}, {
						rights: ["Buyer"],
						key: "audit_title",
						label: "EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.VIEW.HEADER.AUDIT_TITLE_BUYER"
					}];

					vm.labels = authorizedObjectsFilter.getAuthorizedObjectsAsAssociative(data, 'key', 'label');
				}
			}

			/**
    * redirection to list view
    */
			function backToList() {
				diState.goBack().catch(function () {
					if (vm.mode === 'current') {
						diState.go('portal.orders.list');
					} else {
						diState.go('portal.audit.list', { id: vm.purchaseOrder.documentId });
					}
				});
			}

			/**
    * calls repository to create invoice from current order
    */
			function flipOrder() {
				translator.whenReady().then(function () {
					purchaseOrderRepository.flipOrder(vm.purchaseOrder.id, vm.purchaseOrder.number).then(resolved, rejected);
				});

				return;

				function resolved(data) {

					var link = translator.instantTranslate("EINVOICING.PORTAL.PURCHASE_ORDERS.ACTIONS.NOTIFICATION.SUCCESS.FLIP_GO_TO_INVOICE_LINK");

					switch (data.success) {
						case false:
							var message = translator.instantTranslate("EINVOICING.PORTAL.PURCHASE_ORDERS.ACTIONS.NOTIFICATION.ERROR.FLIP_FAILURE_REASON." + data.failureReason);
							var viewAction = goToViewInvoice;

							if (data.invoiceId <= 0) {
								link = "";
								viewAction = null;
							} else {
								link = '<br/>' + link;
							}

							notificationHandler.showWarning(message + link, vm.purchaseOrder.number, viewAction);
							break;
						default:
							notificationHandler.showSuccess("EINVOICING.PORTAL.PURCHASE_ORDERS.ACTIONS.NOTIFICATION.SUCCESS.FLIP_SUCCESS", vm.purchaseOrder.number);
							goToEditInvoice();
							break;
					}

					reloadDocumentActions();

					return;

					function goToEditInvoice() {
						if (data.invoiceId > 0) {
							diState.go('portal.invoices.editById', { id: data.invoiceId });
						}
					}

					function goToViewInvoice() {
						if (data.invoiceId > 0) {
							diState.go('portal.invoices.viewById', { id: data.invoiceId });
						}
					}
				}

				function rejected(error) {
					notificationHandler.showError(error.failureReason);
				}
			}

			/**
    * calls repository to accept order
    */
			function acceptOrder() {
				purchaseOrderRepository.acceptOrder(vm.purchaseOrder.documentId, vm.purchaseOrder.number).then(resolved);

				return;

				function resolved() {
					setState(clientEnums.documentStateKey.accepted);
					reloadDocumentActions();
				}
			}

			/**
    * calls repository to reject order
    */
			function rejectOrder() {
				purchaseOrderRepository.rejectOrder(vm.purchaseOrder.documentId, vm.purchaseOrder.number).then(resolved);

				return;

				function resolved() {
					setState(clientEnums.documentStateKey.rejected);
					reloadDocumentActions();
				}
			}

			/**
    * calls repository to cancel order
    */
			function cancelOrder() {
				purchaseOrderRepository.cancelOrder(vm.purchaseOrder.documentId, vm.purchaseOrder.number).then(resolved);

				return;

				function resolved() {
					setState(clientEnums.documentStateKey.cancelled);
					reloadDocumentActions();
				}
			}

			/**
    * calls repository to close order
    */
			function closeOrder() {
				purchaseOrderRepository.closeOrder(vm.purchaseOrder.documentId, vm.purchaseOrder.number).then(resolved);

				return;

				function resolved() {
					setState(clientEnums.documentStateKey.closed);
					reloadDocumentActions();
				}
			}

			/**
    * calls repository to flag as shipped or not shipped order
    */
			function flagAsShipped(shipped) {
				purchaseOrderRepository.flagAsShipped(vm.purchaseOrder.documentId, shipped, vm.purchaseOrder.number).then(resolved);

				return;

				function resolved(result) {
					if (result) {
						setState(clientEnums.documentStateKey.shipped);
					} else {
						reloadDocumentState();
					}

					reloadDocumentActions();
				}
			}

			/**
    * calls repository to flag as delivered or not delivered order
    */
			function flagAsDelivered(delivered) {
				purchaseOrderRepository.flagAsDelivered(vm.purchaseOrder.documentId, delivered, vm.purchaseOrder.number).then(resolved);

				return;

				function resolved(result) {
					if (result) {
						setState(clientEnums.documentStateKey.delivered);
					} else {
						reloadDocumentState();
					}

					reloadDocumentActions();
				}
			}

			/**
    * Marks the current purchase order as invoiced
    */
			function markAsInvoiced() {
				purchaseOrderRepository.markPurchaseOrdersAsInvoiced([vm.purchaseOrder.documentId]).then(resolved, rejected);

				function resolved(data) {
					if (util.isArray(data) === false || data.length === 0) {
						return;
					}

					var poState = data[0];

					vm.purchaseOrder.actions.fill(poState.userActions);
					setActions();

					setState(poState.documentState);

					notificationHandler.showSuccess('EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.ACTIONS.MARK_INVOICED.SUCCESS', vm.purchaseOrder.number);
				}

				function rejected() {
					notificationHandler.showError('EINVOICING.PORTAL.PURCHASE_ORDERS.VIEWER.ACTIONS.MARK_INVOICED.FAILED', vm.purchaseOrder.number);
				}
			}

			/**
    * Downloads order as pdf
    */
			function getRenderedOrder() {
				var documentId = vm.purchaseOrder.documentId;
				documentDownloader.downloadRenderedPurchaseOrder(documentId);
			}

			/**
    * Downloads a csv file containing data for the selected purchase orders
    */
			function downloadPurchaseOrderAsCsv() {
				if (!util.isNullOrUndefined(vm.purchaseOrder.id)) {
					var purchaseOrderIds = [vm.purchaseOrder.id];
					documentDownloader.downloadPurchaseOrdersCsv(purchaseOrderIds);
				}
			}

			/**
    * Downloads the attachment of the additionalDocumentReference
    */
			function downloadAttachment(attachmentDataId, filename) {
				if (attachmentDownloadValidator.allowDownloadSingleFile(filename)) {
					attachmentProxy.downloadFile(attachmentDataId);
				}
			}

			/**
    * Downloads all the attachments of the PO
    */
			function downloadAllAttachments() {
				var attachmentDataIds = [];

				if (attachmentDownloadValidator.allowDownloadMultipleFiles(vm.purchaseOrder.additionalDocumentReferences, attachmentDataIds)) {
					attachmentProxy.downloadZipFile(attachmentDataIds);
				}
			}

			/**
    * Navigates to related documents page
    */
			function getRelatedDocuments() {
				diState.go('portal.related.list', { id: vm.purchaseOrder.documentId });
			}

			/**
    * Navigatest to history list page
    */
			function goToHistory() {
				diState.go('portal.audit.list', { id: vm.purchaseOrder.documentId });
			}

			/**
    * Navigates to view page for current order
    */
			function goToViewCurrent() {
				diState.go('portal.orders.viewById', { id: vm.purchaseOrder.id });
			}

			/**
    * sets current order state
    */
			function setState(stateId) {
				var state = documentStateResolver.getDocumentState(stateId);
				vm.purchaseOrder.clientDocumentState = stateId;
				vm.selectedStates.fill(state);

				updateCurrentState(stateId);
			}

			/**
    * updates current
    */
			function updateCurrentState() {
				documentStateResolver.calculateCurrentState('order', vm.purchaseOrder.clientDocumentState, true).then(function (calculated) {
					vm.currentState = calculated;
				});
			}

			/**
    * reloads document state
    */
			function reloadDocumentState() {
				documentProxy.getDocumentClientStateId(vm.purchaseOrder.id, clientEnums.documentType.purchaseOrder).then(resolved, rejected);

				return;

				function resolved(stateId) {
					setState(stateId);
				}

				function rejected() {}
			}

			/**
    * Reloads document allowed actions
    */
			function reloadDocumentActions() {
				purchaseOrderRepository.getAllowedActions(vm.purchaseOrder.documentId, vm.purchaseOrder.number).then(resolved);
				return;

				function resolved(data) {
					vm.purchaseOrder.actions.fill(data);
					setActions();
				}
			}

			/**
    *  resolves allowed actions
    */
			function setActions() {
				var resolvedActions = userActionsResolver.resolveActions(vm.purchaseOrder.actions, false);
				vm.selectedActions.fill(resolvedActions);
			}

			function setParties() {
				vm.supplierParty = {
					partyName: vm.purchaseOrder.supplierName,
					partyCode: vm.purchaseOrder.supplierCode,
					partyIdentifierScheme: translator.instantTranslate(schemeTranslationPrefix + vm.purchaseOrder.supplierPartyIdentifierScheme),
					endpointId: vm.purchaseOrder.supplierEndpointIdentifier,
					endpointIdenfitierScheme: translator.instantTranslate(schemeTranslationPrefix + vm.purchaseOrder.supplierEndpointIdentifierScheme)
				};

				vm.supplierParty.isVisible = checkObjectSectionIsVisible(vm.supplierParty);

				vm.customerParty = {
					partyName: vm.purchaseOrder.customerName,
					partyCode: vm.purchaseOrder.customerCode,
					partyIdentifierScheme: translator.instantTranslate(schemeTranslationPrefix + vm.purchaseOrder.customerPartyIdentifierScheme),
					vatNumber: vm.purchaseOrder.buyerVatNumber,
					vatNumberScheme: translator.instantTranslate(schemeTranslationPrefix + vm.purchaseOrder.buyerVatNumberScheme),
					endpointId: vm.purchaseOrder.buyerEndpointIdentifier,
					endpointIdenfitierScheme: translator.instantTranslate(schemeTranslationPrefix + vm.purchaseOrder.buyerEndpointIdentifierScheme)
				};

				vm.customerParty.isVisible = checkObjectSectionIsVisible(vm.customerParty);

				vm.deliveryParty = {
					partyName: vm.purchaseOrder.deliveryPartyName,
					partyCode: vm.purchaseOrder.deliveryPartyCode,
					partyIdentifierScheme: translator.instantTranslate(schemeTranslationPrefix + vm.purchaseOrder.deliveryPartyIdentifierScheme)
				};

				vm.deliveryParty.isVisible = checkObjectSectionIsVisible(vm.deliveryParty, ['partyIdentifierScheme']);

				vm.accountingParty = {
					partyName: vm.purchaseOrder.accountingCustomerName,
					partyCode: vm.purchaseOrder.accountingCustomerCode,
					partyIdentifierScheme: translator.instantTranslate(schemeTranslationPrefix + vm.purchaseOrder.accountingCustomerPartyIdentifierScheme),
					vatNumber: vm.purchaseOrder.accountingCustomerVatNumber,
					vatNumberScheme: translator.instantTranslate(schemeTranslationPrefix + vm.purchaseOrder.accountingCustomerVatNumberScheme),
					endpointId: vm.purchaseOrder.accountingCustomerEndpointIdentifier,
					endpointIdentifierScheme: translator.instantTranslate(schemeTranslationPrefix + vm.purchaseOrder.accountingCustomerEndpointIdentifierScheme)
				};

				vm.accountingParty.isVisible = checkObjectSectionIsVisible(vm.accountingParty, ['endpointIdentifierScheme', 'partyIdentifierScheme', 'vatNumberScheme']);

				vm.originatorParty = {
					partyName: vm.purchaseOrder.originatorCustomerPartyName,
					partyCode: vm.purchaseOrder.originatorCustomerPartyReference,
					partyIdentifierScheme: translator.instantTranslate(schemeTranslationPrefix + vm.purchaseOrder.originatorCustomerPartyIdentifierScheme)
				};

				vm.originatorParty.isVisible = checkObjectSectionIsVisible(vm.originatorParty, ['partyIdentifierScheme']);
			}

			/**
   	* populates contacts variables for use on the UI
   	*/
			function setContacts() {
				vm.billFromContact = {
					Name: vm.purchaseOrder.billFromContactName,
					Telephone: vm.purchaseOrder.billFromContactTelephone,
					Email: vm.purchaseOrder.billFromContactEmail,
					Fax: vm.purchaseOrder.billFromContactFax,
					Reference: vm.purchaseOrder.billFromContactReference
				};

				vm.billFromContact.isVisible = checkObjectSectionIsVisible(vm.billFromContact);

				vm.billToContact = {
					Name: vm.purchaseOrder.billToContactName,
					Telephone: vm.purchaseOrder.billToContactTelephone,
					Email: vm.purchaseOrder.billToContactEmail,
					Fax: vm.purchaseOrder.billToContactFax,
					Reference: vm.purchaseOrder.billToContactReference
				};

				vm.billToContact.isVisible = checkObjectSectionIsVisible(vm.billToContact);

				vm.deliveryContact = {
					Name: vm.purchaseOrder.deliveryContactName,
					Telephone: vm.purchaseOrder.deliveryContactTelephone,
					Email: vm.purchaseOrder.deliveryContactEmail,
					Fax: vm.purchaseOrder.deliveryContactFax,
					Reference: vm.purchaseOrder.deliveryContactReference
				};

				vm.deliveryContact.isVisible = checkObjectSectionIsVisible(vm.deliveryContact);

				vm.accountingCustomerContact = {
					Reference: vm.purchaseOrder.accountingCustomerContactReference
				};

				vm.accountingCustomerContact.isVisible = checkObjectSectionIsVisible(vm.accountingCustomerContact);

				vm.originatorCustomerContact = {
					Name: vm.purchaseOrder.originatorCustomerContactName,
					Telephone: vm.purchaseOrder.originatorCustomerContactTelephone,
					Email: vm.purchaseOrder.originatorCustomerContactEmail,
					Fax: vm.purchaseOrder.originatorCustomerContactFax
				};

				vm.originatorCustomerContact.isVisible = checkObjectSectionIsVisible(vm.originatorCustomerContact);
			}

			function setLegal() {
				vm.accountingLegal = {
					registrationName: vm.purchaseOrder.accountingCustomerLegalName,
					companyReference: vm.purchaseOrder.accountingCustomerLegalCompanyReference,
					companyReferenceScheme: translator.instantTranslate(schemeTranslationPrefix + vm.purchaseOrder.accountingCustomerLegalCompanyReferenceScheme),
					cityName: vm.purchaseOrder.accountingCustomerLegalTown,
					countryName: resolveCountryNameByCode(vm.purchaseOrder.accountingCustomerLegalCountry)
				};

				vm.accountingLegal.isVisible = checkObjectSectionIsVisible(vm.accountingLegal, ['companyReferenceScheme']);

				vm.buyerLegal = {
					registrationName: vm.purchaseOrder.buyerLegalRegistrationName,
					companyReference: vm.purchaseOrder.buyerLegalCompanyReference,
					companyReferenceScheme: translator.instantTranslate(schemeTranslationPrefix + vm.purchaseOrder.buyerLegalCompanyReferenceScheme),
					cityName: vm.purchaseOrder.buyerLegalTown,
					countryName: resolveCountryNameByCode(vm.purchaseOrder.buyerLegalCountry)
				};

				vm.buyerLegal.isVisible = checkObjectSectionIsVisible(vm.buyerLegal, ['companyReferenceScheme']);

				return;
			}

			function setAddresses() {
				vm.supplierAddress = {
					Name: vm.purchaseOrder.supplierDetailsName,
					AddressLine1: vm.purchaseOrder.supplierDetailsAddressLine1,
					AddressLine2: vm.purchaseOrder.supplierDetailsAddressLine2,
					AddressTown: vm.purchaseOrder.supplierDetailsAddressTown,
					AddressCounty: vm.purchaseOrder.supplierDetailsAddressCounty,
					PostCode: vm.purchaseOrder.supplierDetailsPostCode,
					Country: resolveCountryNameByCode(vm.purchaseOrder.supplierDetailsCountry),
					LocationIdentifier: vm.purchaseOrder.supplierLocationIdentifier,
					showName: vm.purchaseOrder.supplierDetailsName !== vm.purchaseOrder.supplierName
				};

				if (vm.supplierAddress.showName === false) {
					vm.supplierAddress.Name = '';
				}

				vm.supplierAddress.isVisible = checkObjectSectionIsVisible(vm.supplierAddress);

				vm.buyerAddress = {
					Name: vm.purchaseOrder.invoiceAddressName,
					AddressLine1: vm.purchaseOrder.invoiceAddressLine1,
					AddressLine2: vm.purchaseOrder.invoiceAddressLine2,
					AddressTown: vm.purchaseOrder.invoiceAddressTown,
					AddressCounty: vm.purchaseOrder.invoiceAddressCounty,
					PostCode: vm.purchaseOrder.invoiceAddressPostCode,
					Country: resolveCountryNameByCode(vm.purchaseOrder.invoiceAddressCountry),
					LocationIdentifier: vm.purchaseOrder.invoiceLocationIdentifier,
					showName: vm.purchaseOrder.invoiceAddressName !== vm.purchaseOrder.customerName
				};

				if (vm.buyerAddress.showName === false) {
					vm.buyerAddress.Name = '';
				}

				vm.buyerAddress.isVisible = checkObjectSectionIsVisible(vm.buyerAddress);

				vm.deliveryAddress = {
					Name: vm.purchaseOrder.deliveryAddressName,
					AddressLine1: vm.purchaseOrder.deliveryAddressLine1,
					AddressLine2: vm.purchaseOrder.deliveryAddressLine2,
					AddressTown: vm.purchaseOrder.deliveryAddressTown,
					AddressCounty: vm.purchaseOrder.deliveryAddressCounty,
					PostCode: vm.purchaseOrder.deliveryAddressPostCode,
					Country: resolveCountryNameByCode(vm.purchaseOrder.deliveryAddressCountry),
					LocationIdentifier: vm.purchaseOrder.deliveryLocationIdentifier,
					LocationIdentifierScheme: vm.purchaseOrder.deliveryLocationIdentifierScheme,
					showName: vm.purchaseOrder.deliveryAddressName !== vm.purchaseOrder.deliveryPartyName
				};

				if (vm.deliveryAddress.showName === false) {
					vm.deliveryAddress.Name = '';
				}

				vm.deliveryAddress.isVisible = checkObjectSectionIsVisible(vm.deliveryAddress, ['Name', 'LocationIdentifierScheme']);

				vm.accountingCustomerAddress = {
					Name: vm.purchaseOrder.accountingCustomerAddressName,
					AddressLine1: vm.purchaseOrder.accountingCustomerAddressLine1,
					AddressLine2: vm.purchaseOrder.accountingCustomerAddressLine2,
					AddressTown: vm.purchaseOrder.accountingCustomerAddressTown,
					AddressCounty: vm.purchaseOrder.accountingCustomerAddressCounty,
					PostCode: vm.purchaseOrder.accountingCustomerAddressPostCode,
					Country: resolveCountryNameByCode(vm.purchaseOrder.accountingCustomerAddressCountry),
					LocationIdentifier: vm.purchaseOrder.accountingCustomerLocationIdentifier,
					showName: vm.purchaseOrder.accountingCustomerAddressName !== vm.purchaseOrder.accountingCustomerName
				};

				if (vm.accountingCustomerAddress.showName === false) {
					vm.accountingCustomerAddress.Name = '';
				}

				vm.accountingCustomerAddress.isVisible = checkObjectSectionIsVisible(vm.accountingCustomerAddress, ['Name']);
			}

			function checkObjectSectionIsVisible(object, additionalIgnored) {

				var ignoredProperties = ['showName'];

				if (util.isArray(additionalIgnored)) {

					ignoredProperties = _.union(ignoredProperties, additionalIgnored);
				}

				return util.isAnyObjectPropertyDefined(object, ignoredProperties);
			}

			/**
   * resolves country name by code
   */
			function resolveCountryNameByCode(code) {
				var country = _.find(vm.countries, function (item) {
					return item.code === code;
				});

				if (util.isDefined(country)) {
					return country.name;
				}

				return code;
			}

			/**
   * Splits the header allowancesCharges into two arrays
   */
			function setAllowancesCharges() {
				var results = _.partition(vm.purchaseOrder.allowanceCharges, function (ac) {
					return ac.isCharge;
				});
				vm.charges = results[0];
				vm.allowances = results[1];
			}

			/**
   * Adds spinner to the page
   */
			function showSpinner() {
				spinner = modalSpinner.showModalSpinner("#spinnerHolder");
			}

			/**
    * Removes spinner from the page
   */
			function removeSpinner() {
				if (spinner) {
					spinner.remove();
				}
			}
		}

		return PurchaseOrderViewerController;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 475 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP2H}
// di.einvoicing.ui.portal.portal.purchaseOrders.viewer
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var guard = $di.exception.guard;

		module.provider('purchaseOrderViewerLinesConfigurator', PurchaseOrderViewerLinesConfiguratorProvider);

		/**
   * Manages purchase order details configuration and set up.
   */
		function PurchaseOrderViewerLinesConfiguratorProvider() {
			var config = {};

			var buttonsConfiguration = {};

			// Provider definition
			var provider = {
				configure: configure,
				$get: $get
			};

			provider.$get.$inject = ['authorizedObjectsFilter', 'CLIENT_ENUMS'];

			return provider;

			/**
    * Configure the service
    * @param cfg
    */
			function configure(cfg) {
				guard.throwIfNotAnObject("EUP2H02E", cfg, 'cfg');

				config = cfg;
			}

			/**
    * Gets required configuration for the grid.
    */
			function $get(authorizedObjectsFilter, clientEnums) {
				buttonsConfiguration = {
					type: "Order",
					visibleButtons: [],
					buttonsSetOne: [{
						rights: ["Supplier"],
						name: 'accept',
						action: clientEnums.userActions.accept,
						attributesRequired: ["current"]
					}, {
						rights: ["Supplier"],
						name: 'reject',
						action: clientEnums.userActions.reject,
						attributesRequired: ["current"]
					}, {
						rights: ["Buyer"],
						name: 'delivered',
						action: clientEnums.userActions.markAsDelivered,
						attributesRequired: ["current"]
					}, {
						rights: ["Buyer"],
						name: 'notDelivered',
						action: clientEnums.userActions.markAsNotDelivered,
						attributesRequired: ["current"]
					}, {
						rights: ["Supplier"],
						name: 'shipped',
						action: clientEnums.userActions.markAsShipped,
						attributesRequired: ["current"]
					}, {
						rights: ["Supplier"],
						name: 'notShipped',
						action: clientEnums.userActions.markAsNotShipped,
						attributesRequired: ["current"]
					}, {
						rights: ["Supplier"],
						name: 'invoiced',
						action: clientEnums.userActions.markAsInvoiced,
						attributesRequired: ["current"]
					}, {
						rights: ["Buyer"],
						name: 'cancelOrder',
						action: clientEnums.userActions.cancelPurchaseOrder,
						attributesRequired: ["current"]
					}, {
						rights: ["Buyer"],
						name: 'close',
						action: clientEnums.userActions.close,
						attributesRequired: ["current"]
					}],
					buttonsSetTwo: [{
						rights: ["PurchaseOrderReader"],
						name: 'render',
						action: clientEnums.userActions.downloadPurchaseOrder,
						attributesRequired: ["current"]
					}, {
						rights: ["PurchaseOrderReader"],
						name: 'downloadCsv',
						action: clientEnums.userActions.downloadAsCsv,
						attributesRequired: ["current"]
					}, {
						rights: ["PurchaseOrderReader"],
						name: 'viewHistory',
						action: clientEnums.userActions.viewHistoryPurchaseOrder,
						attributesRequired: ["current"]
					}, {
						rights: ["PurchaseOrderReader"],
						name: 'related',
						action: clientEnums.userActions.viewRelatedDocumentsPurchaseOrder,
						attributesRequired: ["current"]
					}],
					buttonsSetThree: [{
						rights: ["PurchaseOrderFlipper"],
						name: 'flipLarge',
						action: clientEnums.userActions.flip,
						attributesRequired: ["current"]
					}]
				};
				return {
					getButtonsSetOneConfiguration: getButtonsSetOneConfiguration,
					getButtonsSetTwoConfiguration: getButtonsSetTwoConfiguration,
					getButtonsSetThreeConfiguration: getButtonsSetThreeConfiguration
				};

				/**
     * gets buttons set one configuration				 
     */
				function getButtonsSetOneConfiguration() {
					return getConfiguration(buttonsConfiguration.buttonsSetOne);
				}

				/**
     * gets buttons set two configuration				 
     */
				function getButtonsSetTwoConfiguration() {

					return getConfiguration(buttonsConfiguration.buttonsSetTwo);
				}

				/**
     * gets buttons set three configuration				 
     */
				function getButtonsSetThreeConfiguration() {

					return getConfiguration(buttonsConfiguration.buttonsSetThree);
				}

				/**
     * gets buttons configuration				 
     */
				function getConfiguration(array) {
					authorizedObjectsFilter.requireRights(true);

					var configuration = {
						type: "Order",
						visibleButtons: []
					};
					configuration.visibleButtons.fill(authorizedObjectsFilter.getAuthorizedObjects(array, true));
					return configuration;
				}
			}
		}

		return PurchaseOrderViewerLinesConfiguratorProvider;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 476 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(477), __webpack_require__(481), __webpack_require__(484)], __WEBPACK_AMD_DEFINE_RESULT__ = function (statesLoader, listsLoader, relatedDocumentsLoader) {
	'use strict';

	return function (module) {
		statesLoader(module);
		listsLoader(module);
		relatedDocumentsLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 477 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP5S}
// di.einvoicing.ui.portal.portal.audit
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.config(configureRelatedDocumentsStates);

		configureRelatedDocumentsStates.$inject = ['stateHelperProvider'];

		function configureRelatedDocumentsStates(stateHelperProvider) {
			stateHelperProvider.addStates({
				templateBaseUrl: "src/app/portal/related/_states",
				parentStateName: 'portal.related',
				states: [{
					stateName: "list",
					url: 'document/{id:int}',
					params: {
						id: 0
					}
				}]
			});
		}
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 478 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP6U}
// di.einvoicing.ui.portal.portal.related.lists.components
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(479), __webpack_require__(480)], __WEBPACK_AMD_DEFINE_RESULT__ = function (snippetsLoader, relatedListDirectiveLoader) {
	'use strict';

	return function (module) {
		snippetsLoader(module);
		relatedListDirectiveLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 479 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP6S}
// di.einvoicing.ui.portal.portal.related.lists.components.snippets
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var snippetContext = $di.angular.snippetRegistrar.createContext(module, 'src/app/portal/related/lists/_components/_snippets');

		snippetContext.registerSnippet('diRelatedActionButtons', 'relatedActionButtons.html');
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 480 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP6T}
// di.einvoicing.ui.portal.portal.related.lists
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ng) {
	'use strict';

	return function (module) {
		module.directive('diRelatedList', diRelatedList);

		function diRelatedList() {
			return {
				restrict: 'E',
				replace: true,
				scope: {},
				controller: "RelatedListController",
				controllerAs: "relatedListCtrl",
				templateUrl: 'src/app/portal/related/lists/_components/relatedList/relatedList.html'
			};
		}

		return diRelatedList;
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 481 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP6P}
// di.einvoicing.ui.portal.portal.related.lists
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(478), __webpack_require__(483), __webpack_require__(482)], __WEBPACK_AMD_DEFINE_RESULT__ = function (componentsLoader, relatedListControllerLoader, relatedListConfiguratorLoader) {
	'use strict';

	return function (module) {
		componentsLoader(module);
		relatedListControllerLoader(module);
		relatedListConfiguratorLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 482 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP5T}
// di.einvoicing.ui.portal.portal.related.lists
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var guard = $di.exception.guard;

		module.factory('relatedListConfigurator', relatedListConfigurator);

		relatedListConfigurator.$inject = ['authorizedObjectsFilter'];

		/**
   * Manages audit list configuration and set up.
   */
		function relatedListConfigurator(authorizedObjectsFilter) {
			var buttonsConfiguration = {
				type: "RELATED",
				visibleButtons: [],
				buttons: [{
					rights: ["User"],
					statesRequired: ['VIEWABLE'],
					name: 'view'
				}]
			};

			return {
				getButtonsConfiguration: getButtonsConfiguration
			};

			function getButtonsConfiguration() {
				authorizedObjectsFilter.requireRights(true);
				buttonsConfiguration.visibleButtons.fill(authorizedObjectsFilter.getAuthorizedObjects(buttonsConfiguration.buttons, true));
				return buttonsConfiguration;
			}
		}

		return relatedListConfigurator;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 483 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP6R}
// di.einvoicing.ui.portal.portal.related.lists
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.controller('RelatedListController', RelatedListController);

		RelatedListController.$inject = ['$scope', 'diState', '$stateParams', 'translator', 'CLIENT_ENUMS', 'enumTranslator', 'authorizedObjectsFilter', 'relatedListConfigurator', 'documentTypeResolver', 'modalSpinner'];

		/**
   * Manages and configure audit list grid.		
   */
		function RelatedListController(scope, diState, stateParams, translator, clientEnums, enumTranslator, authorizedObjectsFilter, relatedListConfigurator, documentTypeResolver, modalSpinner) {
			var vm = this;

			vm.actionButtonsOptions = {};
			vm.document = {};
			vm.labels = {};
			vm.documents = [];
			vm.selectedStates = [];

			vm.viewRelatedDocument = viewRelatedDocument;
			vm.viewCurrentDocument = viewCurrentDocument;
			vm.documentsLoaded = documentsLoaded;
			vm.documentLinkClicked = documentLinkClicked;
			vm.documentLinkDoubleClicked = documentLinkDoubleClicked;
			vm.onSelectedChanged = onSelectedChanged;
			var spinner;
			initialise();

			return;

			/**
    * Initialises the audits table by configuring it and getting initial set of data.
    */
			function initialise() {

				showSpinner();

				setLabels();

				vm.actionButtonsOptions = relatedListConfigurator.getButtonsConfiguration();

				setDetails();

				return;

				function setDetails() {
					if (util.isNumber(stateParams.id)) {
						vm.document.id = stateParams.id;
					}

					return;
				}

				/**
     * sets labels values depending on user rights           
     */
				function setLabels() {
					var data = [{
						rights: ["User"],
						key: "title",
						label: "EINVOICING.PORTAL.RELATED.LISTS.HEADER.TITLE"
					}, {
						rights: ["Supplier"],
						key: "invoice",
						label: "EINVOICING.PORTAL.RELATED.LISTS.HEADER.TYPE.SUPPLIER_INVOICE"
					}, {
						rights: ["Buyer"],
						key: "invoice",
						label: "EINVOICING.PORTAL.RELATED.LISTS.HEADER.TYPE.BUYER_INVOICE"
					}, {
						rights: ["Supplier"],
						key: "order",
						label: "EINVOICING.PORTAL.RELATED.LISTS.HEADER.TYPE.SUPPLIER_ORDER"
					}, {
						rights: ["Buyer"],
						key: "order",
						label: "EINVOICING.PORTAL.RELATED.LISTS.HEADER.TYPE.BUYER_ORDER"
					}, {
						rights: ["User"],
						key: "grn",
						label: "EINVOICING.PORTAL.RELATED.LISTS.HEADER.TYPE.GRN"
					}];

					translator.whenReady().then(function () {
						_.each(data, function (item) {
							item.label = translator.instantTranslate(item.label);
						});

						vm.labels = authorizedObjectsFilter.getAuthorizedObjectsAsAssociative(data, 'key', 'label');
					});
				}
			}

			/**
    * Navigates to related document		 
    */
			function viewRelatedDocument() {
				var selectedDocument = getSelectedDocument();
				selectedDocument.id = selectedDocument.headerId;
				goToDocument(selectedDocument);
			}

			/**
    * Navigates to current document			 
    */
			function viewCurrentDocument() {
				goToDocument(vm.document);
			}

			/**
    * Documents loaded			 
    */
			function documentsLoaded(model) {
				vm.documents.fill(model.relatedDocuments);
				vm.document.number = model.number;
				vm.document.documentType = model.documentType;
				vm.document.id = model.headerId;

				var typeKey = documentTypeResolver.getTypeKeyById(vm.document.documentType);

				translator.translate(vm.labels[typeKey]).then(function (translated) {
					vm.labels.summaryTitle = translated;

					vm.labels.summaryTitle += ' [' + vm.document.number + ']';
				});

				removeSpinner();
			}

			/**
    * Handler for document link clicked			 
    */
			function documentLinkClicked(item) {
				onSelectedChanged([item]);
			}

			/**
    * Handler for document link double clicked			 
    */
			function documentLinkDoubleClicked(item) {
				item.id = item.headerId;
				goToDocument(item);
			}

			/**
    * Event handler when rows selection changes                          
    */
			function onSelectedChanged(items) {
				var array = [];
				_.each(items, function (item) {
					if (item.isSelected) {
						array.push("VIEWABLE");
					}
				});

				vm.selectedStates.fill(array);
			}

			/**
    * Returns selected document			 
    */
			function getSelectedDocument() {
				var selectedRows = getCurrentlySelectedDocuments();

				if (selectedRows.length === 1) {
					return selectedRows[0];
				}
				return {};
			}

			/**
    * Returns all selected documents			
    */
			function getCurrentlySelectedDocuments() {
				var selectedRows = [];

				vm.documents.forEach(function addToSelected(item) {
					if (item.isSelected === true) {
						selectedRows.push(item);
					}
				});

				return selectedRows;
			}

			/**
    * Navigates to document details page			
    */
			function goToDocument(selectedDocument) {
				if (util.isUndefined(selectedDocument.id)) {
					return;
				}

				switch (selectedDocument.documentType) {
					case clientEnums.documentType.invoice:
						diState.go('portal.invoices.viewById', { id: selectedDocument.id });
						break;
					case clientEnums.documentType.purchaseOrder:
						diState.go('portal.orders.viewById', { id: selectedDocument.id });
						break;
					case clientEnums.documentType.goodsReceiptNote:
						diState.go('portal.grn.viewById', { id: selectedDocument.id });
						break;
				}
			}

			/**
   * Adds spinner to the page			 
   */
			function showSpinner() {
				spinner = modalSpinner.showModalSpinner("#spinnerHolder");
			}

			/**
    * Removes spinner from the page
   */
			function removeSpinner() {
				if (spinner) {
					spinner.remove();
				}
			}
		}

		return RelatedListController;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 484 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(486), __webpack_require__(487), __webpack_require__(485)], __WEBPACK_AMD_DEFINE_RESULT__ = function (relatedDocumentsControllerLoader, relatedDocumentsDirectiveLoader, relatedDocumentsConfiguratorLoader) {
	'use strict';

	return function (module) {
		relatedDocumentsControllerLoader(module);
		relatedDocumentsDirectiveLoader(module);
		relatedDocumentsConfiguratorLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 485 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP6K}
// di.einvoicing.ui.portal.portal.invoices.lists
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var guard = $di.exception.guard;

		module.provider('relatedDocumentsConfigurator', RelatedDocumentsConfiguratorProvider);

		/**
   * Manages invoice list configuration and set up.
   */
		function RelatedDocumentsConfiguratorProvider() {
			var config = {};

			// Grid columns configuration
			var columnDefinitions = [{
				rights: ['User'],
				field: 'number',
				nameLanguageKey: 'DOCUMENT NUMBER',
				template: '<span>{{binding.number}}</span>'

			}, {
				rights: ['User'],
				field: 'date',
				nameLanguageKey: 'DATE',
				template: '<span>{{ binding.date | diDate }}</span>',
				cellClass: 'centeredcell'
			}, {
				rights: ['User'],
				field: 'total',
				nameLanguageKey: 'TOTAL',
				template: '<span>{{binding.formattedTotal}}</span>',
				cellClass: 'numericcell'
			}, {
				rights: ['User'],
				field: 'calculatedState',
				nameLanguageKey: 'STATE',
				template: '<span>{{binding.calculatedState}}</span>',
				cellClass: 'centeredcell'
			}, {
				rights: ['User'],
				field: 'documentTypeName',
				nameLanguageKey: 'TYPE',
				template: '<span>{{binding.documentTypeName}}</span>',
				cellClass: 'centeredcell'
			}];

			// Provider definition
			var provider = {
				configure: configure,
				$get: $get
			};

			provider.$get.$inject = ['authorizedObjectsFilter'];

			return provider;

			/**
    * Configure the service
    * @param cfg
    */
			function configure(cfg) {
				guard.throwIfNotAnObject("EUP6K02E", cfg, 'cfg');

				config = cfg;
			}

			/**
    * Gets required configuration for the grid.
    */
			function $get(authorizedObjectsFilter) {
				return {
					getTableConfiguration: getTableConfiguration
				};

				/**
     * Gets grid configuration options.
     */
				function getTableConfiguration() {
					config.columns = authorizedObjectsFilter.getAuthorizedObjects(columnDefinitions, false);

					return config;
				}
			}
		}

		return RelatedDocumentsConfiguratorProvider;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 486 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP6H}
// di.einvoicing.ui.portal.components.relateddocuments
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.controller('RelatedDocumentsController', RelatedDocumentsController);

		RelatedDocumentsController.$inject = ['$scope', '$filter', 'documentProxy', 'translator', 'CLIENT_ENUMS', 'relatedDocumentsConfigurator', 'documentStateResolver', 'documentTypeResolver', 'notificationHandler'];

		function RelatedDocumentsController(scope, $filter, documentProxy, translator, clientEnums, configurator, documentStateResolver, documentTypeResolver, notificationHandler) {
			var vm = this;
			vm.showControl = false;
			vm.documentId = 0;
			vm.documents = [];
			vm.relatedResponse = {};
			vm.tableOptions = {};

			vm.loadDocuments = loadDocuments;
			vm.linkClicked = linkClicked;
			vm.linkDoubleClicked = linkDoubleClicked;
			vm.documentsLoaded = documentsLoaded;

			init();

			return;

			/**
   * initialises the controller				
   */
			function init() {
				var unwatch = scope.$watch('id', function (id) {
					if (util.isDefined(id)) {
						vm.documentId = id;

						vm.tableOptions = configurator.getTableConfiguration();

						loadDocuments();

						unwatch();
					}
				});
			}

			/**
   * Loads related documents				
   */
			function loadDocuments() {
				documentProxy.getRelatedDocuments(vm.documentId).then(resolved, rejected);

				return;

				function resolved(data) {
					if (util.isArray(data.relatedDocuments)) {
						formatDocumentData(data.relatedDocuments);
					} else {
						var array = [data.relatedDocuments];
						formatDocumentData(array);
					}

					vm.documents.fill(data.relatedDocuments);

					vm.tableOptions.data.fill(data.relatedDocuments);
					vm.relatedResponse = data;
					documentsLoaded();

					return;

					/**
      * Formats array by resolving calculated properties					 
      */
					function formatDocumentData(array) {
						_.each(array, function (document) {
							var type = documentTypeResolver.getTypeKeyById(document.documentType);

							var currencyFilter = $filter('diCurrency');

							if (document.currencyId !== 0) {
								document.formattedTotal = currencyFilter(document.total, document.currencyId);
							} else {
								translator.translate('EINVOICING.PORTAL.RELATED.LISTS.HEADER.NOTAVAILABLE').then(function (translated) {
									document.formattedTotal = translated;
								});
							}

							documentTypeResolver.resolveDocumentType(document.documentType).then(function (resolved) {
								document.documentTypeName = resolved;
							});

							documentStateResolver.calculateCurrentState(type, document.state, true).then(function (state) {
								document.calculatedState = state;
							});
							;
						});
					}
				}

				function rejected(error) {
					notificationHandler.showError(error.failureReason);
				}
			}

			/**
    * Handler for related document link clicked event			 
    */
			function linkClicked(item) {
				if (scope.onDocumentLinkClicked) {
					scope.onDocumentLinkClicked(item);
				}
			}

			/**
    * Handler for related document link double clicked event			 
    */
			function linkDoubleClicked(item) {
				if (scope.onDocumentLinkDoubleClicked) {
					scope.onDocumentLinkDoubleClicked(item);
				}
			}

			/**
    * Handler for related documents loaded event			
    */
			function documentsLoaded() {
				if (scope.onDocumentsLoaded) {
					scope.onDocumentsLoaded(vm.relatedResponse);
				}
			}
		}

		return RelatedDocumentsController;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 487 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP6I}
// di.einvoicing.ui.portal.components.relateddocuments
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.directive('diRelatedDocuments', diRelatedDocuments);

		function diRelatedDocuments() {
			return {
				restrict: 'E',
				scope: {
					id: "=",
					onDocumentsLoaded: "=",
					onDocumentLinkClicked: "=",
					onDocumentLinkDoubleClicked: "="
				},
				templateUrl: 'src/app/portal/related/related-documents/related-documents.html',
				controller: "RelatedDocumentsController",
				controllerAs: "relatedDocumentsCtrl"
			};
		}

		return diRelatedDocuments;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 488 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(489), __webpack_require__(523), __webpack_require__(528), __webpack_require__(532), __webpack_require__(537), __webpack_require__(535)], __WEBPACK_AMD_DEFINE_RESULT__ = function (componentsLoader, servicesLoader, buttonStateResolverLoader, documentAttributeResolverLoader, fileExtensionValidatorLoader, documentTypeResolverLoader) {
	'use strict';

	return function (module) {
		componentsLoader(module);
		servicesLoader(module);
		buttonStateResolverLoader(module);
		documentAttributeResolverLoader(module);
		fileExtensionValidatorLoader(module);
		documentTypeResolverLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 489 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(490), __webpack_require__(503), __webpack_require__(507), __webpack_require__(509), __webpack_require__(496), __webpack_require__(515), __webpack_require__(512), __webpack_require__(517), __webpack_require__(519), __webpack_require__(498), __webpack_require__(505), __webpack_require__(521)], __WEBPACK_AMD_DEFINE_RESULT__ = function (actionButtonsLoader, addressViewDetailsLoader, contactViewDetailsLoader, dateSelectorLoader, additionalDocumentReferencesLoader, documentStateSelectorLoader, documentStateDisplayLoader, legalViewDetailsLoader, partyViewDetailsLoader, addressEditDetailsLoader, contactDetailsLoader, setFocusLoader) {
    'use strict';

    return function (module) {
        actionButtonsLoader(module);
        addressViewDetailsLoader(module);
        contactViewDetailsLoader(module);
        dateSelectorLoader(module);
        additionalDocumentReferencesLoader(module);
        documentStateSelectorLoader(module);
        documentStateDisplayLoader(module);
        legalViewDetailsLoader(module);
        partyViewDetailsLoader(module);
        addressEditDetailsLoader(module);
        contactDetailsLoader(module);
        setFocusLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 490 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(491), __webpack_require__(492), __webpack_require__(493)], __WEBPACK_AMD_DEFINE_RESULT__ = function (actionButtonsControllerLoader, diActionButtonsDirectiveLoader, statefulButtonLoader) {
    'use strict';

    return function (module) {
        statefulButtonLoader(module);
        actionButtonsControllerLoader(module);
        diActionButtonsDirectiveLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 491 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP04}
// di.einvoicing.ui.portal.portal.components.actionbuttons
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var util = $di.utility.util;

        module.controller('ActionButtonsController', ActionButtonsController);

        ActionButtonsController.$inject = ['$scope', 'buttonStateResolver', 'formAnalyser'];

        function ActionButtonsController(scope, buttonStateResolver, formAnalyser) {
            var vm = this;
            vm.useActions = false;
            vm.loaded = false;
            vm.type = {};
            vm.buttons = [];
            vm.buttonClick = buttonClick;
            vm.buttonPreSaveInvoiceClick = buttonPreSaveInvoiceClick;
            vm.buttonPreCreateUserClick = buttonPreCreateUserClick;
            vm.getFromConfiguration = getFromConfiguration;

            var deregisterWatchListItemsCount = function deregisterWatchListItemsCount() {};
            var deregisterWatchUserActions = function deregisterWatchUserActions() {};
            var deregisterContextAttributes = function deregisterContextAttributes() {};
            var deregisterWatchContextStates = function deregisterWatchContextStates() {};

            init();
            tearDown();

            return;

            /**
            * initialization             
            */
            function init() {
                if (util.isDefined(scope.configuration)) {
                    loadConfiguration();
                    watchItems();
                }

                return;

                function watchItems() {
                    if (util.isDefined(scope.userActions)) {
                        vm.useActions = true;
                        deregisterWatchListItemsCount = scope.$watchCollection('listItemsCount', setUp);
                        deregisterWatchUserActions = scope.$watchCollection('userActions', setUp);
                        deregisterContextAttributes = scope.$watchCollection('contextAttributes', setUp);
                    } else {
                        deregisterWatchContextStates = scope.$watchCollection('contextStates', function () {
                            deregisterWatchUserActions = scope.$watchCollection('contextAttributes', setUp);
                        });
                    }
                }

                function loadConfiguration() {
                    vm.type = scope.configuration.type;

                    _.each(scope.configuration.visibleButtons, function (button) {
                        vm.buttons.push(button);
                    });
                }

                /**
                * sets button states
                */
                function setUp() {
                    var primaryActionsContext = [];
                    var secondaryActionsContext = [];
                    var primaryStatesContext = [];
                    var secondaryStatesContext = [];
                    var primaryAttributesContext = [];
                    var secondaryAttributesContext = [];

                    var canSetupButtons = false;
                    var dataLoaded = false;

                    if (vm.useActions) {
                        dataLoaded = trySetPrimaryAndSecondaryContexts(scope.userActions, primaryActionsContext, secondaryActionsContext);
                        canSetupButtons = canSetupBasedOnActions(dataLoaded);
                    } else {
                        dataLoaded = trySetPrimaryAndSecondaryContexts(scope.contextStates, primaryStatesContext, secondaryStatesContext);
                        canSetupButtons = canSetupBasedOnStates(dataLoaded);
                    }

                    trySetPrimaryAndSecondaryContexts(scope.contextAttributes, primaryAttributesContext, secondaryAttributesContext);
                    setStates();

                    return;

                    /*
                    * Sets the states of the buttons 
                    */
                    function setStates() {
                        if (canSetupButtons) {

                            _.each(vm.buttons, function (button) {
                                setButtonState(button);
                            });

                            if (scope.displayControl) {
                                scope.displayControl();
                            }
                        }
                    }

                    /**
                    * Handles displaying control before data is loaded             
                    */
                    function canSetupBasedOnActions(actionsLoaded) {
                        if (util.isUndefined(scope.waitForData) || scope.waitForData === false) {
                            return true;
                        }

                        return actionsLoaded;
                    }

                    function canSetupBasedOnStates(statesLoaded) {
                        if (util.isUndefined(scope.waitForStates) || scope.waitForStates === false) {
                            return true;
                        }

                        return statesLoaded;
                    }

                    /**
                    * sets if button is visible / enabled
                    */
                    function setButtonState(button) {
                        var visibleName = button.name + "Visible";
                        var enabledName = button.name + "Enabled";

                        var listItemsCount = getListItemsCount(button);
                        var enabled = false;
                        var context;

                        if (vm.useActions) {
                            context = selectContext(button, primaryActionsContext, secondaryActionsContext);
                            enabled = buttonStateResolver.isEnabledForActions(button, context, listItemsCount);
                        } else {
                            context = selectContext(button, primaryStatesContext, secondaryStatesContext);
                            enabled = buttonStateResolver.isEnabledForStates(button, context, util.isDefined(button.requireAllStates) ? button.requireAllStates : scope.requireAllStates);
                        }

                        if (enabled) {

                            context = selectContext(button, primaryAttributesContext, secondaryAttributesContext);
                            enabled = buttonStateResolver.isAttributeEnabled(button, context);
                        }

                        scope[enabledName] = enabled;
                        button.isEnabled = enabled;

                        if (!enabled && button.denyStyle === 'hidden') {
                            scope[visibleName] = false;
                        } else {
                            scope[visibleName] = true;
                        }
                        return;
                    }
                }
            }

            /**
            *  Destroy all state, any event listeners and subscriptions
            */
            function tearDown() {
                scope.$on('$destroy', function () {
                    deregisterWatchListItemsCount();
                    deregisterWatchUserActions();
                    deregisterContextAttributes();
                    deregisterWatchContextStates();
                });
            }

            /**
            * Gets the listItemsCount number from the object on the scope
            */
            function getListItemsCount(button) {
                if (util.isNumber(scope.listItemsCount)) {
                    return scope.listItemsCount;
                }
                if (util.isRealObject(scope.listItemsCount)) {
                    return selectContext(button, scope.listItemsCount.primary, scope.listItemsCount.secondary);
                }
                return 0;
            }

            /**
            * Selects the secondary context when the primary context is not set and the button specifies to fallback on secondary context
            * Selects the primary context otherwise
            */
            function selectContext(button, primaryContext, secondaryContext) {
                if (button.fallbackOnSecondaryContext && (util.isArray(primaryContext) && primaryContext.length == 0 || util.isNumber(primaryContext) && primaryContext <= 0)) {
                    return secondaryContext;
                }
                return primaryContext;
            }

            /**
            * Fills in the given primaryContext and secondaryContext arrays with data from the contextObject param
            * Assumes the arrays are initialised before they are passed in
            * Returns true if the primary context is not empty, false otherwise			
            */
            function trySetPrimaryAndSecondaryContexts(contextObject, primaryContext, secondaryContext) {
                primaryContext.clear();
                secondaryContext.clear();

                if (util.isArray(contextObject)) {
                    primaryContext.fill(contextObject);
                } else if (util.isRealObject(contextObject)) {
                    if (util.isDefined(contextObject.primary)) {
                        primaryContext.fill(contextObject.primary);
                    }
                    if (util.isDefined(contextObject.secondary)) {
                        secondaryContext.fill(contextObject.secondary);
                    }
                }
                return primaryContext.length > 0;
            }

            /**
            * Event handler for submit button click             
            */
            function buttonClick(eventName, submit) {
                var eventActionName = "button" + toTitleCase(eventName) + "Click";

                if (submit) {
                    var formToSubmit = formAnalyser.getFormInstance(scope);
                    if (formToSubmit) {
                        formToSubmit.$setSubmitted(true);
                    }
                }

                if (util.isFunction(scope[eventActionName])) {
                    handleClick(scope[eventActionName]);
                }

                return;

                function handleClick(action) {
                    var enabledName = eventName + "Enabled";

                    if (scope[enabledName] && action) {
                        action();
                    }
                }

                /**
                * Changes string to sentence case				
                */
                function toTitleCase(str) {
                    return str.replace(/\w\S*/g, function (txt) {
                        return txt.charAt(0).toUpperCase() + txt.substr(1);
                    });
                }
            }

            /**
            * Get the value from the configuration (useful when  dynamic data is used, eg user name)
            */
            function getFromConfiguration(configurationProperty, actionName, defaultValue) {
                if (!util.isNullOrUndefined(scope.configuration) && !util.isNullOrUndefined(scope.configuration[configurationProperty])) {

                    return scope.configuration[configurationProperty][actionName];
                }

                return defaultValue;
            }

            function buttonPreSaveInvoiceClick() {
                if (scope.saveInvoiceEnabled && scope.buttonPreSaveInvoiceClick) {
                    return scope.buttonPreSaveInvoiceClick();
                }

                return function () {};
            }

            function buttonPreCreateUserClick() {
                if (scope.createUserEnabled && scope.buttonPreCreateUserClick) {
                    return scope.buttonPreCreateUserClick();
                }

                return function () {};
            }
        }

        return ActionButtonsController;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 492 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP0F}
// di.einvoicing.ui.portal.portal.components.actionbuttons
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ng) {
	'use strict';

	return function (module) {
		module.directive('diActionButtons', diActionButtons);

		function diActionButtons() {
			return {
				restrict: 'E',
				scope: {
					className: "@",
					requireAllStates: '=',
					contextStates: "=",
					listItemsCount: "=",
					userActions: "=",
					waitForData: "=",
					contextAttributes: "=",
					configuration: "=",
					buttonEditClick: '&',
					buttonEditBigClick: '&',
					buttonViewClick: '&',
					buttonRefreshClick: '&',
					buttonFlipClick: '&',
					buttonFlipLargeClick: '&',
					buttonSubmitClick: '&',
					buttonSubmitSmallClick: '&',
					buttonRenderClick: '&',
					buttonDownloadCsvClick: '&',
					buttonEnableUserClick: '&',
					buttonDisableUserClick: '&',
					buttonUnlockUserClick: '&',
					buttonLockUserClick: '&',
					buttonAcceptClick: '&',
					buttonRejectClick: '&',
					buttonDisputeClick: '&',
					buttonNotDisputeClick: '&',
					buttonCancelInvoiceClick: '&',
					buttonCancelOrderClick: '&',
					buttonShippedClick: '&',
					buttonNotShippedClick: '&',
					buttonDeliveredClick: '&',
					buttonNotDeliveredClick: '&',
					buttonPaidClick: '&',
					buttonNotPaidClick: '&',
					buttonScheduledClick: '&',
					buttonNotScheduledClick: '&',
					buttonSaveUserClick: '&',
					buttonSaveInvoiceClick: '&',
					buttonSaveInvoiceSmallClick: '&',
					buttonDeleteInvoiceClick: '&',
					buttonDeleteSmallClick: '&',
					buttonPreSaveInvoiceClick: '&',
					buttonPreCreateUserClick: '&',
					buttonViewHistoryClick: '&',
					buttonCloseClick: '&',
					buttonIssuesClick: '&',
					buttonRelatedClick: '&',
					buttonAttachmentsClick: '&',
					buttonReleaseClick: '&',
					buttonResetPasswordClick: '&',
					buttonClearFiltersClick: '&',
					buttonInvoicedClick: '&',
					buttonCreateUserClick: '&',
					buttonDeleteUserClick: '&',
					buttonGeneratePasswordClick: '&'
				},
				templateUrl: 'src/app/portal/shared/components/action-buttons/action-buttons.html',
				controller: "ActionButtonsController",
				controllerAs: "actionButtonsCtrl",
				link: link
			};

			function link(scope, element) {
				scope.findElement = findElement;

				scope.displayControl = displayControl;

				return;

				function findElement(name) {
					return ng.element(name);
				}

				function displayControl() {
					element.parent().removeClass("buttons-hidden");
				}
			}
		}

		return diActionButtons;
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 493 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(494), __webpack_require__(495)], __WEBPACK_AMD_DEFINE_RESULT__ = function (statefulButtonControllerLoader, statefulButtonDirectiveLoader) {
    'use strict';

    return function (module) {
        statefulButtonControllerLoader(module);
        statefulButtonDirectiveLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 494 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP6B}
// di.einvoicing.ui.portal.components.statefulbutton
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.controller('StatefulButtonController', StatefulButtonController);

		StatefulButtonController.$inject = ['$scope', 'buttonStateResolver'];

		function StatefulButtonController(scope, buttonStateResolver) {
			var vm = this;
			vm.useActions = false;
			vm.buttons = [];
			vm.showControl = false;
			vm.showDisabled = false;

			vm.buttonClick = buttonClick;
			vm.getImageProperties = getImageProperties;

			init();

			return;

			/**
    * initialization             
    */
			function init() {
				if (util.isDefined(scope.configuration)) {
					loadConfiguration();
					watchItems();
				}
				return;

				/**
     * sets watches on context items				
     */
				function watchItems() {
					if (util.isDefined(scope.userActions)) {
						vm.useActions = true;
						scope.$watchCollection('listItemsCount', setUp);
						scope.$watchCollection('userActions', setUp);
						scope.$watchCollection('contextAttributes', setUp);
					} else {
						scope.$watchCollection('contextStates', function () {
							scope.$watchCollection('contextAttributes', setUp);
						});
					}
				}

				/**
     * loads configuration				
     */
				function loadConfiguration() {
					var config = getStatefulConfiguration(scope.keys);

					if (config.length > 0) {
						vm.showControl = true;
					}

					_.each(config, function (button) {
						setProperties(button);
						vm.buttons.push(button);
					});

					return;

					function setProperties(button) {
						button.image = getImageProperties(button).image;
						button.imageColour = getImageProperties(button).colour;
						button.tooltip = getActionTooltip(button.name);
					}

					/**
      * Parses main configuration to get required buttons configuration					
      */
					function getStatefulConfiguration(array) {
						return _.filter(scope.configuration.visibleButtons, function (button) {
							var found = _.find(array, function (item) {
								return button.name === item;
							});
							return util.isDefined(found);
						});
					}
				}

				/**
     * sets state of buttons on context changes				 
     */
				function setUp() {
					scope.isVisible = [];
					_.each(vm.buttons, function (button) {
						button.isVisible = setButtonState(button);
					});

					setDisabledButtonState();

					return;

					/**
      * sets if button is visible / enabled                             
      */
					function setButtonState(button) {
						var visibleName = button.name + "Visible";

						var enabled;
						if (vm.useActions) {
							var actions = scope.userActions;
							if (scope.userActions && scope.userActions.primary) {
								actions = scope.userActions.primary;
							}

							var listItemsCount = scope.listItemsCount;

							if (scope.listItemsCount && scope.listItemsCount.primary) {
								listItemsCount = scope.listItemsCount.primary;
							}

							enabled = buttonStateResolver.isEnabledForActions(button, actions, listItemsCount);
						} else {
							var states = scope.contextStates;
							if (scope.contextStates && scope.contextStates.primary) {
								states = scope.contextStates.primary;
							}

							enabled = buttonStateResolver.isEnabledForStates(button, states, util.isDefined(button.requireAllStates) ? button.requireAllStates : scope.requireAllStates);
						}

						if (enabled) {
							var attributes = scope.contextAttributes;
							if (scope.contextAttributes && scope.contextAttributes.primary) {
								attributes = scope.contextAttributes.primary;
							}

							enabled = buttonStateResolver.isAttributeEnabled(button, attributes);
						}

						if (!enabled) {
							scope[visibleName] = false;
						} else {
							scope[visibleName] = true;
						}

						return scope[visibleName];
					}

					/**
      * Sets disabled button state					
      */
					function setDisabledButtonState() {
						var visible = _.find(vm.buttons, function (button) {
							return button.isVisible === true;
						});

						if (util.isDefined(visible)) {
							vm.showDisabled = false;
						} else {
							vm.showDisabled = true;
						}
					}
				}
			}

			function getImageProperties(button) {
				return {
					image: button.image ? button.image : button.name,
					colour: "button"
				};
			}

			/**
    * resolves button tooltip key			
    */
			function getActionTooltip(name) {
				return "EINVOICING.PORTAL.COMPONENTS.ACTIONS.FLAG_" + name.toUpperCase();
			}

			/**
    * Event handler for submit button click             
    */
			function buttonClick(index) {
				if (util.isFunction(scope.actions[index])) {
					handleClick(scope.actions[index], index);
				}

				return;

				function handleClick(action, index) {
					if (action && vm.buttons[index].isVisible) {
						action();
					}
				}
			}
		}

		return StatefulButtonController;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 495 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP0F}
// di.einvoicing.ui.portal.components.statefulbutton
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ng) {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.directive('diStatefulButton', diStatefulButton);

		function diStatefulButton() {
			return {
				restrict: 'E',
				replace: true,
				scope: {
					keys: "=",
					contextStates: "=",
					contextAttributes: "=",
					listItemsCount: "=",
					userActions: "=",
					disabledImage: "@",
					configuration: "=",
					actions: '='
				},
				templateUrl: 'src/app/portal/shared/components/action-buttons/stateful-button/stateful-button.html',
				controller: "StatefulButtonController",
				controllerAs: "statefulButtonCtrl",
				link: link
			};

			function link(scope) {
				scope.findElement = findElement;

				return;

				function findElement(name) {
					return ng.element(name);
				}
			}
		}

		return diStatefulButton;
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 496 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF1O}
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(497)], __WEBPACK_AMD_DEFINE_RESULT__ = function (AdditionalDocumentReferencesComponent) {
	'use strict';

	return function (module) {
		module.component(AdditionalDocumentReferencesComponent.selector, AdditionalDocumentReferencesComponent);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 497 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF1N}
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return AdditionalDocumentReferencesComponent();

	function AdditionalDocumentReferencesComponent() {
		var util = $di.utility.util;

		return {
			templateUrl: 'src/app/portal/shared/components/additional-document-references/additional-document-references.component.html',
			selector: 'diAdditionalDocumentReferences',
			bindings: {
				items: "<",
				configuration: "<",
				editable: "@",
				download: "&",
				downloadAll: "&",
				addLine: "&",
				removeLine: "&",
				onChanged: "&",
				onUploaded: "&",
				onUploadStarted: "&",
				onUploadFailed: "&"
			},
			controllerAs: "additionalDocumentReferencesCtrl",
			controller: ['$scope', 'absoluteUrl', AdditionalDocumentReferencesController]
		};

		function AdditionalDocumentReferencesController(scope, absoluteUrl) {
			var vm = this;

			vm.$onInit = calculateCtrlFlags;
			vm.$onChanges = onChanges;

			vm.isAbsoluteUrl = absoluteUrl.isAbsoluteUrl;
			vm.hasAttachment = hasAttachment;
			vm.onAttachmentUploadStateChanged = onAttachmentUploadStateChanged;
			vm.onPropertyChanged = onPropertyChanged;

			return;

			/*
   * Sets the components visibility flags
   */
			function calculateCtrlFlags() {
				vm.isShown = vm.editable || util.isNonEmptyArray(vm.items);
				vm.hasAttachments = util.isNonEmptyArray(vm.items) && _.some(vm.items, hasAttachment);
			}

			/*
    * Watches for changes of the controller's one-way bindings
    */
			function onChanges(changes) {
				calculateCtrlFlags();

				if (!vm.editable && util.isDefined(changes.items) && util.isNonEmptyArray(changes.items.currentValue)) {
					vm.$onChanges = undefined;
				}
			}

			/*
    * Returns true if the additional document reference has an attachment
    * Looks at attachmentDataId to determine if there was an attachment
    */
			function hasAttachment(additionalDocumentReference) {
				return !util.isNullOrUndefined(additionalDocumentReference) && util.isNumber(additionalDocumentReference.attachmentDataId);
			}

			/*
    * Reacts to changes of input values
    */
			function onPropertyChanged() {
				if (util.isFunction(vm.onChanged)) {
					vm.onChanged();
				}

				calculateCtrlFlags();
			}

			/*
         * Triggered when a attachment upload process changed
         */
			function onAttachmentUploadStateChanged(state) {
				switch (state.status) {
					case 'started':
						if (util.isFunction(vm.onUploadStarted)) {
							vm.onUploadStarted({ lineIdentifier: state.lineIdentifier });
						}
						break;
					case 'success':
						if (util.isFunction(vm.onUploaded)) {
							vm.onUploaded({ lineIdentifier: state.lineIdentifier, attachmentDataId: state.attachmentDataId, filename: state.filename });
						}
						break;
					default:
						if (util.isFunction(vm.onUploadFailed)) {
							vm.onUploadFailed({ lineIdentifier: state.lineIdentifier });
						}
						break;
				}

				calculateCtrlFlags();
			}
		}
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 498 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP8J}
// di.einvoicing.ui.portal.addressEditDetails
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(499), __webpack_require__(501), __webpack_require__(500), __webpack_require__(502)], __WEBPACK_AMD_DEFINE_RESULT__ = function (addressDetailsComponentLoader, addressEditDetailsDirectiveLoader, addressEditDetailsControllerLoader, addressValidationPropertyNameProviderLoader) {
    'use strict';

    return function (module) {
        module.component(addressDetailsComponentLoader.AddressDetailsComponent.selector, addressDetailsComponentLoader.AddressDetailsComponent);
        addressEditDetailsDirectiveLoader(module);
        addressEditDetailsControllerLoader(module);
        addressValidationPropertyNameProviderLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 499 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var util = $di.utility.util;

var AddressDetailsComponent = exports.AddressDetailsComponent = {
    templateUrl: 'src/app/portal/shared/components/address-edit-details/address-details.html',
    selector: 'diAddressDetails',
    bindings: {
        address: "<",
        party: "<",
        allowedTypes: "<",
        identifiers: "<",
        onDataChanged: "&",
        readOnly: "<",
        showIsUpdatable: "<",
        isAddressUpdateableOnly: "<"
    },
    controllerAs: '$ctrl',
    controller: function () {
        function controller(addressValidationPropertyNameProvider, staticLookupProxy, validationRulesSetter, translator, CLIENT_ENUMS) {
            _classCallCheck(this, controller);

            this.addressValidationPropertyNameProvider = addressValidationPropertyNameProvider;
            this.staticLookupProxy = staticLookupProxy;
            this.validationRulesSetter = validationRulesSetter;
            this.translator = translator;
            this.CLIENT_ENUMS = CLIENT_ENUMS;

            this.onCountryChanged = this.onCountryChanged.bind(this);
            this.onAddressTypeChanged = this.onAddressTypeChanged.bind(this);
            this.onUpdatableChanged = this.onUpdatableChanged.bind(this);
            this.onLocationIdentifierChanged = this.onLocationIdentifierChanged.bind(this);

            this.countries = [];
            this.updateOptions = [];
        }

        _createClass(controller, [{
            key: '$onInit',
            value: function $onInit() {
                var _this = this;

                this.validationRulesSetter.setValidationRules("Location");

                this.staticLookupProxy.get('Country').then(function (data) {
                    _this.countries.fill(data);
                    _this.translator.whenReady().then(function () {
                        _this.updateOptions = [{
                            name: _this.translator.instantTranslate("CORE.PROMPT.YES"),
                            id: true
                        }, {
                            name: _this.translator.instantTranslate("CORE.PROMPT.NO"),
                            id: false
                        }];
                    });
                });

                if (util.isDefined(this.party.locationType)) {
                    this.showIdentifier(this.party.locationType);
                    this.setValidation(this.party.locationType);
                } else {
                    this.showLocationIdentifier = false;
                    this.showFinancialIdentifier = false;
                }
            }
        }, {
            key: 'getCountryById',
            value: function getCountryById(data, id) {
                var country = _.find(data, function (item) {
                    return item.id === id;
                });

                if (util.isUndefined(country)) {
                    country = {};
                }

                return country;
            }
        }, {
            key: 'onCountryChanged',
            value: function onCountryChanged(country) {
                if (util.isDefined(country)) {
                    this.address.country = country.name;
                    this.address.countryCode = country.code;
                    this.address.countryId = country.id;
                }

                this.onDataChanged();
            }
        }, {
            key: 'onAddressTypeChanged',
            value: function onAddressTypeChanged(party) {
                if (util.isDefined(party)) {
                    this.party = party;
                    this.address.locationType = party.locationType;
                    this.address.locationTypeTranslated = party.name;
                    this.address.party = party;
                    this.showIdentifier(this.party.locationType);

                    this.setValidation(this.party.locationType);

                    this.onDataChanged();
                }
            }
        }, {
            key: 'onUpdatableChanged',
            value: function onUpdatableChanged(obj) {
                //in order for the change to take effect, the value of the scope[property] has to change
                this.address.isUpdatable = obj.id;
                this.onDataChanged();
            }
        }, {
            key: 'onLocationIdentifierChanged',
            value: function onLocationIdentifierChanged(obj) {
                if (util.isObject(obj)) {
                    this.address.locationIdentifier = obj.code;
                    this.address.locationIdentifierScheme = obj.scheme;
                    this.address.locationIdentifierSchemeId = obj.schemeId;
                }

                this.onDataChanged();
            }
        }, {
            key: 'setValidation',
            value: function setValidation(locationType) {
                this.validationProperties = this.addressValidationPropertyNameProvider.getValidationPropertyNames('location', locationType);

                this.showAddressDetails = true;
            }
        }, {
            key: 'showIdentifier',
            value: function showIdentifier(locationType) {
                this.showLocationIdentifier = locationType === this.CLIENT_ENUMS.locationType.Delivery;
                this.showFinancialIdentifier = !this.showLocationIdentifier;
            }
        }, {
            key: 'matchIdentifier',
            value: function matchIdentifier(i1, i2) {
                return i1.identifier === i2.identifier;
            }
        }]);

        return controller;
    }()
};

AddressDetailsComponent.controller.prototype.constructor.$inject = ['addressValidationPropertyNameProvider', 'staticLookupProxy', 'validationRulesSetter', 'translator', 'CLIENT_ENUMS'];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 500 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP8V}
// di.einvoicing.ui.portal.addressDetails
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var util = $di.utility.util;

        module.controller('AddressEditDetailsController', AddressEditDetailsController);

        AddressEditDetailsController.$inject = ['$scope', 'addressValidationPropertyNameProvider'];

        function AddressEditDetailsController(scope, addressValidationPropertyNameProvider) {
            var vm = this;

            vm.showLocationIdentifier = true;

            vm.onCountryChanged = onCountryChanged;
            vm.onLocationIdentifierChanged = onLocationIdentifierChanged;
            vm.onDataChanged = onDataChanged;
            vm.validationProperties = addressValidationPropertyNameProvider.getValidationPropertyNames('invoice', scope.addressType);
            vm.matchLocationIdentifier = matchLocationIdentifier;

            init();

            return;

            function init() {
                if (util.isDefined(scope.showLocationIdentifier)) {
                    vm.showLocationIdentifier = scope.showLocationIdentifier;
                }
            }

            function matchLocationIdentifier(i1, i2) {
                return i1.identifier === i2.identifier;
            }

            function onDataChanged() {
                if (scope.onDataChanged) {
                    scope.onDataChanged();
                }
            }

            function onCountryChanged(country) {
                if (scope.onCountryChanged) {
                    scope.onCountryChanged(country);
                }
            }

            function onLocationIdentifierChanged(location) {
                onDataChanged();
            }
        }

        return AddressEditDetailsController;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 501 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP5B}
// di.einvoicing.ui.portal.addressDetails
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.directive('diAddressEditDetails', diAddressEditDetails);

		function diAddressEditDetails() {
			return {
				restrict: 'E',
				scope: {
					bindToObject: "=",
					addressType: "@",
					country: "=",
					countries: "=",
					identifiers: "=",
					onDataChanged: "=",
					onCountryChanged: "=",
					readOnly: "=",
					showLocationIdentifier: "="

				},
				controller: 'AddressEditDetailsController',
				controllerAs: 'addressEditDetailsCtrl',
				templateUrl: 'src/app/portal/shared/components/address-edit-details/address-edit-details.html'
			};
		}

		return diAddressEditDetails;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 502 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:UPA01}
// di.einvoicing.ui.portal.addressDetails
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;

        module.factory('addressValidationPropertyNameProvider', addressValidationPropertyNameProvider);

        function addressValidationPropertyNameProvider() {
            return {
                getValidationPropertyNames: getValidationPropertyNames
            };

            /**
            * Gets validation property names for a specific type of address
            * @locationType (billToAddress or deliveryAddress)
            */
            function getValidationPropertyNames(entityType, locationType) {
                if (entityType === 'invoice') {
                    switch (locationType) {
                        case 'billToAddress':
                            return {
                                addressName: 'addressName',
                                addressLine1: 'addressLine1',
                                addressLine2: 'addressLine2',
                                addressTown: 'addressTown',
                                addressCounty: 'addressCounty',
                                addressPostCode: 'postCode',
                                locationIdentifier: 'locationIdentifier'
                            };
                        case 'deliveryAddress':
                            return {
                                addressName: 'deliveryAddressName',
                                addressLine1: 'deliveryAddressLine1',
                                addressLine2: 'deliveryAddressLine2',
                                addressTown: 'deliveryAddressTown',
                                addressCounty: 'deliveryAddressCounty',
                                addressPostCode: 'deliveryPostCode',
                                locationIdentifier: 'deliveryLocationIdentifier'
                            };
                        default:
                            guard.throwNew("UPA0101E", 'Not supported address type.');
                    }
                } else {
                    return {
                        locationType: 'locationType',
                        addressName: 'name',
                        addressLine1: 'addressLine1',
                        addressLine2: 'addressLine2',
                        addressTown: 'town',
                        addressCounty: 'county',
                        addressPostCode: 'postalCode',
                        locationIdentifier: 'locationIdentifier'
                    };
                }
            }
        }

        return addressValidationPropertyNameProvider;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 503 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(504)], __WEBPACK_AMD_DEFINE_RESULT__ = function (addressViewDetailsDirectiveLoader) {
    'use strict';

    return function (module) {
        addressViewDetailsDirectiveLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 504 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
  'use strict';

  return function (module) {
    module.directive('diAddressViewDetails', diAddressViewDetails);

    function diAddressViewDetails() {
      return {
        restrict: 'E',
        scope: {
          bindToObject: "=",
          blockId: '@'
        },
        templateUrl: 'src/app/portal/shared/components/address-view-details/address-view-details.html'
      };
    }

    return diAddressViewDetails;
  };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 505 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP9I}
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(506)], __WEBPACK_AMD_DEFINE_RESULT__ = function (contactDetailsComponentLoader) {
    'use strict';

    return function (module) {
        module.component(contactDetailsComponentLoader.ContactDetailsComponent.selector, contactDetailsComponentLoader.ContactDetailsComponent);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 506 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var util = $di.utility.util;

var ContactDetailsComponent = exports.ContactDetailsComponent = {
    templateUrl: 'src/app/portal/shared/components/contact-details/contact-details.html',
    selector: 'diContactDetailsPopup',
    bindings: {
        contact: "<",
        party: "<",
        typeOptions: "<",
        onDataChanged: "&",
        readOnly: "<",
        showIsUpdatable: "<"
    },
    controllerAs: '$ctrl',
    controller: function () {
        function controller(validationRulesSetter, translator) {
            _classCallCheck(this, controller);

            this.validationRulesSetter = validationRulesSetter;
            this.translator = translator;
            this.onUpdatableChanged = this.onUpdatableChanged.bind(this);
            this.onContactTypeChanged = this.onContactTypeChanged.bind(this);
        }

        _createClass(controller, [{
            key: '$onInit',
            value: function $onInit() {
                this.init();
            }
        }, {
            key: 'init',
            value: function init() {
                var _this = this;

                this.translator.whenReady().then(function () {
                    _this.updateOptions = [{
                        name: _this.translator.instantTranslate("CORE.PROMPT.YES"),
                        id: true
                    }, {
                        name: _this.translator.instantTranslate("CORE.PROMPT.NO"),
                        id: false
                    }];
                });

                this.validationRulesSetter.setValidationRules("Invoice");
            }
        }, {
            key: 'onContactTypeChanged',
            value: function onContactTypeChanged(party) {
                if (util.isDefined(party)) {
                    this.contact.partyId = party.id;
                    this.onDataChanged();
                }
            }
        }, {
            key: 'onUpdatableChanged',
            value: function onUpdatableChanged(obj) {
                this.contact.isUpdatable = obj.id;
                this.onDataChanged();
            }
        }]);

        return controller;
    }()
};

ContactDetailsComponent.controller.prototype.constructor.$inject = ['validationRulesSetter', 'translator'];

/***/ }),
/* 507 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(508)], __WEBPACK_AMD_DEFINE_RESULT__ = function (contactViewDetailsDirectiveLoader) {
    'use strict';

    return function (module) {
        contactViewDetailsDirectiveLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 508 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var util = $di.utility.util;
        module.directive('diContactViewDetails', diContactViewDetails);

        function diContactViewDetails() {
            return {
                restrict: 'E',
                scope: {
                    bindToObject: "=",
                    blockId: '@'
                },
                templateUrl: 'src/app/portal/shared/components/contact-view-details/contact-view-details.html'
            };
        }

        return diContactViewDetails;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 509 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(511), __webpack_require__(510)], __WEBPACK_AMD_DEFINE_RESULT__ = function (diDateSelectorDirectiveLoader, diDateSelectorControllerLoader) {
    'use strict';

    return function (module) {
        diDateSelectorDirectiveLoader(module);
        diDateSelectorControllerLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 510 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:UPD02}
// di.einvoicing.ui.portal.dateSelector
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var ngUtil = $di.angular.util;
		var util = $di.utility.util;

		module.controller('DiDateSelectorController', DiDateSelectorController);

		DiDateSelectorController.$inject = ['$scope', 'translator', '$stateParams', 'diState', 'dateFormatter'];

		function DiDateSelectorController(scope, translator, stateParams, diState, dateFormatter) {

			var CUSTOM = "Custom";
			var customOption;
			var ignoreBoundObjectProperty;

			var vm = this;
			vm.dateTypes = [];
			vm.items = [];
			vm.dateType = {};
			vm.item = {};
			vm.customItem = { fromDate: '', toDate: '' };
			vm.showDateTypes = false;

			vm.selectNonCustomDate = selectNonCustomDate;
			vm.selectCustomDate = selectCustomDate;
			vm.selectDateType = selectDateType;
			vm.dateChanged = dateChanged;
			vm.validSelectedDates = areSelectedDatesValid();
			initialize();

			return;

			/**
    * Sets default item when options are loaded.
    * @returns {} 
    */
			function initialize() {

				setDateTypes();
				setDateRanges();

				if (translateQueryParamsToDropDown()) {
					return;
				}

				watchBoundObjectProperty();

				return;

				/**
     * loads list of date types                 
     */
				function setDateTypes() {
					ngUtil.$watchCollection(scope, 'dateTypes', function (dateTypes) {
						if (dateTypes) {
							vm.dateTypes = dateTypes;
							vm.showDateTypes = dateTypes.length > 1;
							translateFilterLabels(vm.dateTypes);
							var item = _.find(dateTypes, function (option) {
								return option.value === scope.defaultType;
							});

							if (util.isDefined(item)) {
								vm.dateType = item;
							} else {
								vm.dateType = dateTypes[0];
							}
						}
					});
				}

				/**
     * loads list of date ranges
     */
				function setDateRanges() {
					ngUtil.$watchCollection(scope, 'items', function (items) {
						if (items) {
							vm.items = items;
							translateFilterLabels(vm.items);

							var item = _.find(items, function (option) {
								return option.value === scope.defaultRange;
							});

							if (util.isDefined(item)) {
								vm.item = item;
							} else {
								vm.item = items[0];
							}

							//get Custom option only when the items change, not at every custom date selection
							if (scope.defaultRange === CUSTOM) {
								customOption = item;
							} else {
								customOption = getCustomOption(vm.items);
							}
						}
					});
				}

				/*
     * Gets the object with the Custom value
     */
				function getCustomOption(options) {
					return _.find(options, function (option) {
						return option.value === CUSTOM;
					});
				}

				/**
     * Translate labels collection using translator service.
     * @param filters
     */
				function translateFilterLabels(filters) {
					translator.whenReady().then(function () {
						_.each(filters, function (filter) {
							filter.label = translator.instantTranslate(filter.label);
						});
					});
				}

				/**
     * Translate the custom query params from dashboard summary to UI dropdown
     */

				function translateQueryParamsToDropDown() {
					if (stateParams.dateType && stateParams.dateTimeFilter && stateParams.dateTimeFilter === 'Custom' && stateParams.fromDate && stateParams.toDate) {

						var item = getCustomOption(scope.items);
						if (item) {
							vm.customItem.fromDate = dateFormatter.toClientDate(stateParams.fromDate);
							vm.customItem.toDate = dateFormatter.toClientDate(stateParams.toDate);
							vm.item = item;
							return true;
						}
					}
					return false;
				};
			}

			/**
    * Event when changed non custom option
    */
			function selectNonCustomDate(item) {
				vm.item = item;
				vm.customItem = {
					fromDate: '', toDate: ''
				};
				vm.validSelectedDates = areSelectedDatesValid();
				onRangeChanged(vm.item.value);
			}

			/**
    * Event when changed custom option.
    * @returns {} 
    */
			function selectCustomDate() {
				if (areSelectedDatesValid() && util.isDefined(customOption)) {
					vm.item = customOption;
					onRangeChanged(vm.item.value, vm.customItem);
				}
			}

			/*
    * Calls event handlers for changed range
    */
			function onRangeChanged(newRange, customDates) {
				if (scope.onChangedRange) {
					scope.onChangedRange(newRange, customDates);
				}
			}

			/**
    * Triggered when one of the dates from the custom item change
    * @returns {} 
    */
			function dateChanged() {
				vm.validSelectedDates = areSelectedDatesValid();
			}

			/**
    * Checks if the selected dates are valid
    * @returns {} 
    */
			function areSelectedDatesValid() {
				return vm.customItem.fromDate !== "" && vm.customItem.toDate !== "" && vm.customItem.toDate !== undefined && vm.customItem.fromDate !== undefined;
			}

			function selectDateType(item) {
				vm.dateType = item;
				if (scope.onChangedType) {
					scope.onChangedType(item.value);
				}
			}

			/**
    * Create watcher against the object property passed into the directive
    */
			function watchBoundObjectProperty() {
				if (scope.bindToDateTypeObject === undefined || scope.bindToDateTypeProperty === undefined) {
					return;
				}

				ignoreBoundObjectProperty = scope.$watch(function () {
					return scope.bindToDateTypeObject[scope.bindToDateTypeProperty];
				}, function (item, oldItem) {
					itemWatchCallback(item, oldItem, 'datetype');
				});

				ignoreBoundObjectProperty = scope.$watch(function () {
					return scope.bindToDateRangeObject[scope.bindToDateRangeProperty];
				}, function (item, oldItem) {
					itemWatchCallback(item, oldItem, 'daterange');
				});

				function itemWatchCallback(item, oldItem, itemType) {
					if (util.isRealObject(item) && item !== oldItem) {
						itemSelected(item, false, itemType);

						if (!scope.watchBinding) {
							ignoreBoundObjectProperty();
						}
					}
				}
			}

			/**
    * Changes the bound property of the item selected
    */
			function itemSelected(item, updateBoundProperty, property) {

				if (property === 'daterange') {
					if (item.isHidden === true) {
						selectCustomDate(item);
					} else {
						selectNonCustomDate(item);
					}
				} else if (property === 'datetype') {
					selectDateType(item);
				}

				if (updateBoundProperty) {
					ignoreBoundObjectProperty();

					if (scope.watchBinding) {
						watchBoundObjectProperty();
					}

					if (util.isFunction(scope.onChangeAccessor)) {
						var onChangeAccessor = scope.onChangeAccessor();

						if (util.isFunction(onChangeAccessor)) {
							onChangeAccessor(item);
						}
					}
				}
			}
		}

		return DiDateSelectorController;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 511 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:UPD03}
// di.einvoicing.ui.portal.dateSelector
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.directive('diDateSelector', diDateSelector);

        function diDateSelector() {
            return {
                restrict: 'E',
                replace: true,
                scope: {
                    dateTypes: '=',
                    items: '=',
                    defaultRange: '=',
                    defaultType: '=',
                    onChangedRange: "=",
                    onChangedType: "=",
                    bindToDateTypeObject: '=',
                    bindToDateTypeProperty: '@',
                    bindToDateRangeObject: '=',
                    bindToDateRangeProperty: '@',
                    watchBinding: '=' //default: false
                },
                controller: "DiDateSelectorController",
                controllerAs: "diDateSelectorCtrl",
                templateUrl: 'src/app/portal/shared/components/date-selector/date-selector.html'
            };
        }

        return diDateSelector;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 512 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(514), __webpack_require__(513)], __WEBPACK_AMD_DEFINE_RESULT__ = function (documentStateDisplayDirectiveLoader, documentStateDisplayControllerLoader) {
	'use strict';

	return function (module) {
		documentStateDisplayDirectiveLoader(module);
		documentStateDisplayControllerLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 513 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EIP0Q}
// di.einvoicing.ui.portal._components.documentStateDisplay
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.controller('DocumentStateDisplayController', DocumentStateDisplayController);

		DocumentStateDisplayController.$inject = ['documentStateResolver', '$scope'];

		function DocumentStateDisplayController(documentStateResolver, scope) {
			var vm = this;

			documentStateResolver.resolveDocumentState(scope.documentType, scope.stateId).then(function (resolved) {
				vm.documentState = resolved;
			});

			return;
		}

		return DocumentStateDisplayController;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 514 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EIP0P}
// di.einvoicing.ui.portal._components.documentStateDisplay
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.directive('diDocumentStateDisplay', diDocumentStateDisplay);

		function diDocumentStateDisplay() {
			return {
				restrict: 'E',
				replace: true,
				scope: {
					documentType: '=',
					stateId: '='
				},
				controller: 'DocumentStateDisplayController',
				controllerAs: 'documentStateDisplayCtrl',
				templateUrl: 'src/app/portal/shared/components/document-state-display/document-state-display.html'
			};
		}

		return diDocumentStateDisplay;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 515 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(516), __webpack_require__(101)], __WEBPACK_AMD_DEFINE_RESULT__ = function (documentStateResolverLoader, documentStateSelectorComponentLoader) {
    'use strict';

    return function (module) {
        documentStateResolverLoader(module);
        documentStateSelectorComponentLoader.load(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 516 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAD03}
// di.core.angular.documentStateSelector
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var guard = $di.exception.guard;

		module.factory('documentStateResolver', documentStateResolver);

		documentStateResolver.$inject = ['authenticationData', 'translator', 'enumTranslator', 'CLIENT_ENUMS', 'enumsKeyResolver'];

		/**
   * resolves document state based on einvoicing state
   */
		function documentStateResolver(authenticationData, translator, enumTranslator, clientEnums, enumsKeyResolver) {
			return {
				getDocumentState: getDocumentState,
				resolveDocumentStates: resolveDocumentStates,
				resolveDocumentState: resolveDocumentState,
				calculateCurrentState: calculateCurrentState
			};

			/**
   * Gets state key for given id                
   */
			function getDocumentState(stateId) {
				guard.throwIfInvalidId("CAD0303E", stateId, "stateId");

				var state = enumTranslator.getLanguageKey(clientEnums.documentStateKey, stateId);

				return translator.translate(state);
			}

			/**
    * Resolves array of document states for display             
    */
			function resolveDocumentStates(docType, data) {
				guard.throwIfEmptyString("CAD0305E", docType, "docType");
				var enums = enumsKeyResolver.getEnumsForCurrentRole(clientEnums.documentStateKey, docType);

				enumTranslator.translateCollection(enums, data, 'clientEInvoicingStateId', 'clientEInvoicingState');
			}

			/**
    * Resolves document state key by state id          
    */
			function resolveDocumentState(docType, stateId) {
				guard.throwIfEmptyString("CAD0305E", docType, "docType");
				guard.throwIfInvalidId("CAD0304E", stateId, "stateId");

				var enums = enumsKeyResolver.getEnumsForCurrentRole(clientEnums.documentStateKey, docType);

				return enumTranslator.translate(enums, stateId);
			}

			function calculateCurrentState(docType, stateId, translate) {
				if (translate) {
					return resolveDocumentState(docType, stateId);
				} else {
					return getDocumentState(stateId);
				}
			}
		}

		return documentStateResolver;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 517 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(518)], __WEBPACK_AMD_DEFINE_RESULT__ = function (legalViewDetailsDirectiveLoader) {
    'use strict';

    return function (module) {
        legalViewDetailsDirectiveLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 518 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
  'use strict';

  return function (module) {
    module.directive('diLegalViewDetails', diLegalViewDetails);

    function diLegalViewDetails() {
      return {
        restrict: 'E',
        scope: {
          bindToObject: "=",
          blockId: '@'
        },
        templateUrl: 'src/app/portal/shared/components/legal-view-details/legal-view-details.html'
      };
    }

    return diLegalViewDetails;
  };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 519 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(520)], __WEBPACK_AMD_DEFINE_RESULT__ = function (partyViewDetailsDirectiveLoader) {
    'use strict';

    return function (module) {
        partyViewDetailsDirectiveLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 520 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
  'use strict';

  return function (module) {
    module.directive('diPartyViewDetails', diPartyViewDetails);

    function diPartyViewDetails() {
      return {
        restrict: 'E',
        scope: {
          bindToObject: "=",
          blockId: '@'
        },
        templateUrl: 'src/app/portal/shared/components/party-view-details/party-view-details.html'
      };
    }

    return diPartyViewDetails;
  };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 521 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(522)], __WEBPACK_AMD_DEFINE_RESULT__ = function (setFocusDirectiveLoader) {
    'use strict';

    return function (module) {
        module.directive('diSetFocus', function () {
            return new setFocusDirectiveLoader.default();
        });
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 522 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var util = $di.utility.util;

var SetFocus = function () {
  function SetFocus() {
    _classCallCheck(this, SetFocus);

    this.restrict = 'A';
  }

  _createClass(SetFocus, [{
    key: 'link',
    value: function link($scope, $element, $attrs) {
      var setFocusOn = $element[0].querySelector($attrs.diSetFocus);

      if (setFocusOn !== null && setFocusOn != undefined) {
        if (util.isDefined($attrs.diSetFocusParent)) {
          setFocusOn.parentNode.focus();
        } else {
          setFocusOn.focus();
        }
      } else {
        $element[0].focus();
      }
    }
  }]);

  return SetFocus;
}();

exports.default = SetFocus;

/***/ }),
/* 523 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(549), __webpack_require__(554), __webpack_require__(527), __webpack_require__(534), __webpack_require__(542), __webpack_require__(526), __webpack_require__(539), __webpack_require__(524), __webpack_require__(552), __webpack_require__(555), __webpack_require__(547), __webpack_require__(530), __webpack_require__(551), __webpack_require__(550)], __WEBPACK_AMD_DEFINE_RESULT__ = function (partyProxyLoader, userProxyLoader, auditProxyLoader, documentProxyLoader, formattersLoader, attachmentProxyLoader, fileTransferLoader, attachmentDownloadValidatorLoader, userActionsResolverLoader, vmListConfiguratorLoader, notificationHandlerLoader, documentAttachmentConfiguratorLoader, tradingRelationshipProxyLoader, proxyErrorInterceptorService) {
	'use strict';

	return function (module) {
		partyProxyLoader(module);
		userProxyLoader(module);
		auditProxyLoader(module);
		documentProxyLoader(module);
		formattersLoader(module);
		attachmentProxyLoader(module);
		fileTransferLoader(module);
		attachmentDownloadValidatorLoader(module);
		userActionsResolverLoader(module);
		vmListConfiguratorLoader(module);
		notificationHandlerLoader(module);
		documentAttachmentConfiguratorLoader(module);
		module.service('tradingRelationshipProxy', tradingRelationshipProxyLoader.TradingRelationshipProxy);
		module.service('proxyErrorInterceptor', proxyErrorInterceptorService.ProxyErrorInterceptor);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 524 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(525)], __WEBPACK_AMD_DEFINE_RESULT__ = function (attachmentDownloadValidatorFactoryLoader) {
    'use strict';

    return function (module) {
        attachmentDownloadValidatorFactoryLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 525 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP9H}
// di.einvoicing.ui.portal.components.attachmentdownloadvalidator
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;

        module.factory('attachmentDownloadValidator', attachmentDownloadValidator);
        attachmentDownloadValidator.$inject = ['fileExtensionValidator', 'notificationHandler'];

        function attachmentDownloadValidator(fileExtensionValidator, notificationHandler) {
            return {
                allowDownloadSingleFile: allowDownloadSingleFile,
                allowDownloadMultipleFiles: allowDownloadMultipleFiles
            };

            /**
            * Check if the file extension provided is valid against a list of invalid extensions
            */
            function allowDownloadSingleFile(fileName) {
                guard.throwIfEmptyString("EUP9H01E", fileName, 'fileName');

                if (fileExtensionValidator.isFileExtensionValid(fileName) === false) {
                    notificationHandler.showWarning('EINVOICING.PORTAL.COMPONENTS.ATTACHMENTS.DOWNLOAD_INVALID_FILE_TYPE');
                    return false;
                };

                return true;
            }

            /**
            * Check if the array of attachments provided is valid against a list of invalid extensions
            */
            function allowDownloadMultipleFiles(array, attachmentDataIds) {
                guard.throwIfNullOrUndefined("EUP9H03E", array, 'array');
                guard.throwIfNotArray("EUP9H04E", array, 'array');
                guard.throwIfEmptyArray("EUP9H05E", array, 'array');
                guard.throwIfNullOrUndefined("EUP9H06E", attachmentDataIds, 'attachmentDataIds');
                guard.throwIfNotArray("EUP9H07E", attachmentDataIds, 'attachmentDataIds');

                var foundInvalidFileExtension = false;

                _.each(array, function (additionalDocumentReference) {
                    if (fileExtensionValidator.isFileExtensionValid(additionalDocumentReference.fileName)) {
                        attachmentDataIds.push(additionalDocumentReference.attachmentDataId);
                    } else {
                        foundInvalidFileExtension = true;
                    }
                });

                if (attachmentDataIds.length === 0) {
                    notificationHandler.showWarning('EINVOICING.PORTAL.COMPONENTS.ATTACHMENTS.DOWNLOADALL_ONLY_INVALID_FILE_TYPE');
                    return false;
                } else if (foundInvalidFileExtension) {
                    notificationHandler.showInfo('EINVOICING.PORTAL.COMPONENTS.ATTACHMENTS.DOWNLOADALL_INVALID_FILE_TYPE');
                }

                return true;
            }
        }

        return attachmentDownloadValidator;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 526 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP5L}
// di.einvoicing.ui.portal.proxies
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var guard = $di.exception.guard;

		module.factory('attachmentProxy', attachmentProxy);

		attachmentProxy.$inject = ['$q', 'fileUploader', 'webApiHttp', 'fileDownloader', 'urlHelper', 'proxyErrorInterceptor'];

		/**
   *
   * @param fileUploader - Service which uploads the file
   * @param urlHelper - Service which helps to create URLs
   */
		function attachmentProxy($q, fileUploader, webApiHttp, fileDownloader, urlHelper, proxyErrorInterceptor) {
			return {
				addAttachmentData: addAttachmentData,
				addAttachments: addAttachments,
				uploadAttachment: uploadAttachment,
				getAttachmentsForDocument: getAttachmentsForDocument,
				downloadFile: downloadFile,
				downloadZipFile: downloadZipFile,
				removeAttachment: removeAttachment
			};

			function addAttachmentData(file) {
				var relativeUrl = 'Attachment/AddAttachmentData';

				var newPromise = fileUploader.upload(relativeUrl, file).then(s, f);

				return newPromise;

				function s(id) {
					guard.throwIfInvalidId("EUP5L03E", id[0], 'id');
					return id[0];
				}

				function f(error) {
					proxyErrorInterceptor.handleError(error, "", "");
					return $q.reject(error);
				};
			}

			function addAttachments(documentId, documentVersion, attachments) {
				var urlParameters = {
					documentId: documentId,
					documentVersion: documentVersion
				};
				var relativeUrl = urlHelper.setParameters('Attachment/AddAttachments', urlParameters);
				return webApiHttp.post(relativeUrl, attachments);
			}

			/**
    * Function which uploads the specified file and associates it with the specified document ID
    * @param documentId - The document ID to associate the uploaded file with
    * @param file - The file to upload
    * @returns - Promise representing the file upload
    */
			function uploadAttachment(documentId, documentVersion, file) {
				guard.throwIfInvalidId("EUP5L03E", documentId, 'documentId');
				guard.throwIfInvalidId("EUP5L07E", documentVersion, 'documentVersion');
				guard.throwIfNotAnObject("EUP5L02E", file, 'file');

				var relativeUrl = 'Attachment/AddAttachmentData';

				return fileUploader.upload(relativeUrl, file).then(success, failure);

				function success(ids) {
					//CHANGE this if multiple files can be uploaded at once
					var attachments = _.map(ids, function (id) {
						return {
							attachmentDataId: id,
							//TODO this should be a different field
							fileReference: file.name,
							fileName: file.name,
							mimeType: file.type
						};
					});
					return addAttachments(documentId, documentVersion, attachments);
				}

				function failure(error) {
					proxyErrorInterceptor.handleError(error, "An error occurred uploading attachment.", "");
					return $q.reject(error);
				}
			}

			/**
    * Function which gets the attachments associated with the currently selected document
    * @param documentId - The ID of the document to get the associated attachments for
    * @returns - A promise which resolves to the attachments related to the provided document ID
    */
			function getAttachmentsForDocument(documentId) {
				guard.throwIfInvalidId("EUP5L01E", documentId, 'documentId');

				var queryData = {
					documentId: documentId
				};

				var url = urlHelper.setParameters('Attachment/GetAttachmentsForDocument', queryData);

				return webApiHttp.get(url);
			}

			/**
    * Function to download a zip file containing the data for the document attachment IDs
    * @param documentAttachmentIds  - The ids associated with the attachments being zipped and returned
    * @returns - A promise which resolves to the downloaded zip file
    */
			function downloadZipFile(attachmentDataIds) {
				guard.throwIfNotAnObject("EUP5L06E", attachmentDataIds, 'attachmentDataIds');

				var queryData = {
					attachmentDataIds: attachmentDataIds
				};

				var url = urlHelper.setParameters('Attachment/GetZippedAttachmentData', queryData);

				return fileDownloader.downloadFile(url);
			}

			/**
    * Function to download a file with the specified document attachment ID
    * @param documentAttachmentId - The ID of the document attachment to download
    * @returns - A promise which resolves to the downloaded file
    */
			function downloadFile(attachmentDataId) {
				guard.throwIfInvalidId("EUP5L04E", attachmentDataId, 'attachmentDataId');

				var queryParams = {
					attachmentDataId: attachmentDataId
				};

				var url = urlHelper.setParameters('Attachment/GetAttachmentData', queryParams);

				return fileDownloader.downloadFile(url);
			}

			/**
    * Removes the attachment with the specified document attachment ID
    * @param documentAttachmentId - the ID of the document attachment to remove
    * @returns - A promise which resolves when the document attachment has been removed
    */
			function removeAttachment(documentAttachmentId) {
				guard.throwIfInvalidId("EUP5L05E", documentAttachmentId, 'attachmentId');

				var urlParameters = {
					documentAttachmentId: documentAttachmentId
				};

				return webApiHttp.post(urlHelper.setParameters('Attachment/RemoveAttachment', urlParameters));
			}
		}

		return attachmentProxy;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 527 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP5L}
// di.einvoicing.ui.portal.proxies
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
			'use strict';

			return function (module) {
						var guard = $di.exception.guard;

						module.factory('auditProxy', auditProxy);

						auditProxy.$inject = ['webApiHttp', '$q', 'CLIENT_ENUMS', 'enumTranslator', 'urlHelper', 'proxyErrorInterceptor'];

						var DEFAULT_ERROR_MSG = "EINVOICING.PORTAL.PROXIES.AUDIT.RECEIVE_ERROR";

						function auditProxy(http, $q, clientEnums, enumTranslator, urlHelper, proxyErrorInterceptor) {
									return {
												getAuditsByDocumentId: getAuditsByDocumentId,
												getAuditDocummentSummaryByDocumentId: getAuditDocummentSummaryByDocumentId,
												getAuditRecordForDocument: getAuditRecordForDocument
									};

									/**
          * Gets audits for document id, filtered and sorted           
          */
									function getAuditsByDocumentId(documentId, lastNRows, eventType, dateTimeFilters, customDateTimeFilter, sortOption) {
												guard.throwIfInvalidId("EUP5L03E", documentId, 'documentId');
												guard.throwIfNotANumber("EUP5L04E", lastNRows, "lastNRows");
												guard.throwIfNotANumber("EUP5L05E", eventType, "eventType");
												guard.throwIfNullOrUndefined("EUP5L06E", dateTimeFilters, "dateTimeFilters");
												guard.throwIfInvalidId("EUP5L07E", sortOption, "sortOption");

												if (!customDateTimeFilter) {
															customDateTimeFilter = {
																		fromDate: new Date(),
																		toDate: new Date()
															};
												}

												var requestedParams = {
															documentId: documentId,
															lastNRows: lastNRows,
															eventType: eventType,
															dateTimeFilterOption: dateTimeFilters.toString(),
															fromDate: JSON.stringify(customDateTimeFilter.fromDate).replace(/"/g, ""),
															toDate: JSON.stringify(customDateTimeFilter.toDate).replace(/"/g, ""),
															sortOption: sortOption
												};

												var requestedUrl = urlHelper.setParameters('Audit/GetCollectionByDocumentId', requestedParams);

												var httpPromise = http.get(requestedUrl);
												var newPromise = httpPromise.then(resolved, rejected);

												return newPromise;

												/**
            * Function which allows pre-processing of audit data			
            */
												function resolved(data) {
															var translated = translateEventTypes(data);
															return translated;
												}

												/**
                      * Function which allows processing of error data
                      * Must return a failed promise otherwise chained success callbacks are called
                      * @param error
                      */
												function rejected(error) {
															return handleRejectedError(error);
												}
									}

									function getAuditDocummentSummaryByDocumentId(documentId) {
												guard.throwIfInvalidId("EUP5L08E", documentId, 'documentId');

												var requestedParams = {
															documentId: documentId
												};

												var requestedUrl = urlHelper.setParameters('Audit/GetAuditDocumentSummaryForDocument', requestedParams);

												var httpPromise = http.get(requestedUrl);
												var newPromise = httpPromise.then(resolved, rejected);

												return newPromise;

												/**
            * Function which allows pre-processing of audit data			
            */
												function resolved(data) {
															enumTranslator.translate(clientEnums.documentType, data.documentType).then(function (translated) {
																		data.documentTypeName = translated;
															});
															return data;
												}

												/**
                      * Function which allows processing of error data
                      * Must return a failed promise otherwise chained success callbacks are called
                      * @param error
                      */
												function rejected(error) {
															return handleRejectedError(error);
												}
									}

									function getAuditRecordForDocument(documentId, versionId) {
												guard.throwIfInvalidId("EUP5L08E", documentId, 'documentId');
												guard.throwIfInvalidId("EUP5L09E", versionId, 'versionId');

												var requestedParams = {
															documentId: documentId,
															versionId: versionId
												};

												var requestedUrl = urlHelper.setParameters('Audit/GetAuditRecordForDocument', requestedParams);

												var httpPromise = http.get(requestedUrl);
												var newPromise = httpPromise.then(resolved, rejected);

												return newPromise;

												/**
            * Function which allows pre-processing of audit data			
            */
												function resolved(data) {
															enumTranslator.translate(clientEnums.documentType, data.documentType).then(function (translated) {
																		data.documentTypeName = translated;
																		return data;
															});
												}

												/**
                      * Function which allows processing of error data
                      * Must return a failed promise otherwise chained success callbacks are called
                      * @param error
                      */
												function rejected(error) {
															return handleRejectedError(error);
												}
									}

									function handleRejectedError(error) {
												proxyErrorInterceptor.handleError(error, DEFAULT_ERROR_MSG, "");
												return $q.reject(error);
									}

									function translateEventTypes(data) {
												enumTranslator.translateCollection(clientEnums.eventType, data, 'eventTypeId', 'eventTypeName');

												return data;
									}
						}

						return auditProxy;
			};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 528 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(529)], __WEBPACK_AMD_DEFINE_RESULT__ = function (buttonStateResolverLoader) {
    'use strict';

    return function (module) {
        buttonStateResolverLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 529 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_, $) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP6C}
// di.core.angular.buttonStateResolver
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.factory('buttonStateResolver', buttonStateResolver);

		/**
   * resolves document state based on einvoicing state
   */
		function buttonStateResolver() {
			return {
				isAttributeEnabled: isAttributeEnabled,
				isEnabledForActions: isEnabledForActions,
				isEnabledForStates: isEnabledForStates
			};

			/**
    * checks if button required attributes matches context array of attributes			
    */
			function isAttributeEnabled(button, contextArray) {
				var result = true;

				if (util.isDefined(button.attributesRequired)) {

					var attributes = [];

					_.each(contextArray, function (a) {
						attributes.push(a.key);
					});

					if (util.isDefined(button.anyAttribute)) {
						result = containsAny(attributes, button.attributesRequired);
					} else {
						result = containsAll(attributes, button.attributesRequired);
					}
				}

				return result;
			}

			/**
    * checks if button required states matches context array of states			
    */
			function isEnabledForActions(button, contextArray, itemCount) {
				var enabled = false;

				if (button.singleAction && itemCount > 1) {
					enabled = false;
				} else {

					var found = _.find(contextArray, function (action) {
						return button.action === action;
					});

					if (util.isDefined(found)) {
						enabled = true;
					}
				}

				return enabled;
			}

			/**
    * checks if button required states matches context array of states			
    */
			function isEnabledForStates(button, contextArray, requireAllStates) {
				var result = false;

				if (!button.statesRequired) {
					result = true;
				} else if (contextArray) {
					if (button.singleAction && contextArray.length > 1) {
						result = false;
					} else {
						if (button.statesRequired[0] === "ANY" && contextArray.length > 0) {
							result = true;
						} else if (requireAllStates) {
							result = containsAll(button.statesRequired, contextArray);
						} else {
							result = containsAny(contextArray, button.statesRequired);
						}
					}
				}

				if (result && util.isDefined(button.statesDenied)) {
					result = !containsAny(contextArray, button.statesDenied);
				}

				return result;
			}

			/**
   * Checks if array contains any element of sub array							 
   */
			function containsAny(states, requiredStates) {
				var filtered = _.find(requiredStates, function (state) {
					var a = [];
					a.push(state);

					return checkAnyExist(a, states);
				});

				return util.isDefined(filtered);

				function checkAnyExist(needles, haystack) {
					if (!needles) {
						return true;
					}

					for (var i = 0, len = needles.length; i < len; i++) {
						if ($.inArray(needles[i], haystack) !== -1) return true;
					}
					return false;
				}
			}

			/**
   *	Checks if array contains all elements of sub array						 
   */
			function containsAll(sup, sub) {
				sup.sort();
				sub.sort();

				var i, j;
				for (i = 0, j = 0; i < sup.length && j < sub.length;) {
					if (sup[i] < sub[j]) {
						++i;
					} else if (sup[i] === sub[j]) {
						++i;
						++j;
					} else {
						// sub[j] not in sup, so sub not subbag
						return false;
					}
				}
				// make sure there are no elements left in sub
				return j === sub.length;
			}
		}

		return buttonStateResolver;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(4)))

/***/ }),
/* 530 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(531)], __WEBPACK_AMD_DEFINE_RESULT__ = function (documentAttachmentConfiguratorLoader) {
	'use strict';

	return function (module) {
		documentAttachmentConfiguratorLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 531 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP6V}
// di.einvoicing.ui.portal.portal.attachments.components
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var guard = $di.exception.guard;

		module.provider('documentAttachmentConfigurator', documentAttachmentConfiguratorProvider);

		/**
   * Manages configuration of the document attachment directive
   */
		function documentAttachmentConfiguratorProvider() {
			var maximumAttachmentSize;

			var provider = {
				configure: configure,
				$get: $get
			};

			return provider;

			/**
    * Configure the service
    * @param cfg
    */
			function configure(cfg) {
				guard.throwIfNotAnObject("EUP6V01E", cfg, 'cfg');

				maximumAttachmentSize = cfg.maximumAttachmentSize;
			}

			/**
    * Gets required configuration for the document attachment controller.
    */
			function $get() {
				return {
					getMaximumAttachmentSize: getMaximumAttachmentSize
				};

				function getMaximumAttachmentSize() {
					return maximumAttachmentSize;
				}
			}
		}

		return documentAttachmentConfiguratorProvider;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 532 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(533)], __WEBPACK_AMD_DEFINE_RESULT__ = function (documentAttributeResolverLoader) {
    'use strict';

    return function (module) {
        documentAttributeResolverLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 533 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CAD03}
// di.core.angular.documentAttribute
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;
		var guard = $di.exception.guard;

		module.factory('documentAttributeResolver', documentAttributeResolver);

		documentAttributeResolver.$inject = ['CLIENT_ENUMS'];

		/**
   * resolves document attributes array
   */
		function documentAttributeResolver(clientEnums) {
			return {
				resolveAttributeKeys: resolveAttributeKeys,
				addAttributeById: addAttributeById,
				removeAttribute: removeAttribute
			};

			/**
   * Resolves array of documents state keys                
   */
			function resolveAttributeKeys(ids) {
				var resolvedArray = [];

				var uniqueList = _.uniq(ids, function (item) {
					return item;
				});

				_.each(uniqueList, function (id) {
					var resolved = resolveAttributeKey(id, true);
					resolvedArray.push(resolved);
				});

				return resolvedArray;
			}

			/**
    * adds attribute object to array by attribute id			
    */
			function addAttributeById(array, attributeId, show) {
				var exists = _.find(array, function (item) {
					return item.id === attributeId;
				});
				if (!exists) {
					array.push(resolveAttributeKey(attributeId, show));
				}
			}
			/**
    * removes attribute object from array			
    */
			function removeAttribute(array, attributeId) {
				array.fill(array.filter(function (obj) {
					return obj.id !== attributeId;
				}));
			}

			/**
   * Gets attribute key for given id                
   */
			function resolveAttributeKey(attributeId, show) {
				guard.throwIfInvalidId("CAD0303E", attributeId, "attributeId");

				if (!util.isDefined(show)) {
					show = true;
				}

				var key = findFirstKeyWhere(clientEnums.documentAttribute, attributeId);

				return {
					id: attributeId,
					key: key,
					hidden: !show

					/**
      * Finds dictionary key by its value                
      */
				};function findFirstKeyWhere(obj, value) {
					var key;

					_.find(obj, function (v, k) {
						if (v === value) {
							key = k;
							return true;
						}
						return false;
					});

					return key;
				}
			}
		}

		return documentAttributeResolver;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 534 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:UPP02}
// di.einvoicing.ui.portal.proxies
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var guard = $di.exception.guard;

		module.factory('documentProxy', documentProxy);

		documentProxy.$inject = ['webApiHttp', 'urlHelper', '$q', 'proxyErrorInterceptor'];

		function documentProxy(http, urlHelper, $q, proxyErrorInterceptor) {
			return {
				getDocumentClientStateId: getDocumentClientStateId,
				getRelatedDocuments: getRelatedDocuments
			};

			/**
    * Gets document client state id by document id		 
    */
			function getDocumentClientStateId(id, type) {
				guard.throwIfInvalidId("UPP0201E", id, 'id');
				guard.throwIfInvalidId("UPP0202E", type, 'type');

				var requestParams = {
					id: id,
					type: type
				};

				var requestUrl = urlHelper.setParameters('Document/GetDocumentClientState', requestParams);

				var promise = http.get(requestUrl);

				var newPromise = promise.then(resolve, reject);

				return newPromise;

				function resolve(data) {
					return data;
				}

				function reject(error) {
					return error;
				}
			}

			/**
    * gets model of related documents by document id			
    */
			function getRelatedDocuments(documentId) {
				var requestParams = {
					id: documentId
				};

				var requestUrl = urlHelper.setParameters('Document/GetRelatedDocuments', requestParams);

				var promise = http.get(requestUrl);

				var newPromise = promise.then(resolve, reject);

				return newPromise;

				function resolve(data) {
					data.relatedDocuments.sort(function (a, b) {
						a = new Date(a.date);
						b = new Date(b.date);
						return a > b ? -1 : a < b ? 1 : 0;
					});

					return data;
				}

				function reject(error) {
					proxyErrorInterceptor.handleError(error, "EINVOICING.PORTAL.PROXIES.DOCUMENT.RECEIVE_RELATED_ERROR", "");
					return $q.reject(error);
				}
			}
		}

		return documentProxy;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 535 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(536)], __WEBPACK_AMD_DEFINE_RESULT__ = function (documentTypeResolverLoader) {
    'use strict';

    return function (module) {
        documentTypeResolverLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 536 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP6M}
// di.einvoicing.ui.portal.documentType
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var guard = $di.exception.guard;

		module.factory('documentTypeResolver', documentTypeResolver);

		documentTypeResolver.$inject = ['enumTranslator', 'CLIENT_ENUMS', 'enumsKeyResolver'];

		/**
   * resolves document type name
   */
		function documentTypeResolver(enumTranslator, clientEnums, enumsKeyResolver) {
			return {
				resolveDocumentType: resolveDocumentType,
				getTypeKeyById: getTypeKeyById
			};

			function resolveDocumentType(typeId) {
				guard.throwIfInvalidId("EUP6M01E", typeId, "typeId");

				var enums = enumsKeyResolver.getEnumsForCurrentRole(clientEnums.documentType);

				return enumTranslator.translate(enums, typeId);
			}

			function getTypeKeyById(typeId) {
				guard.throwIfInvalidId("EUP6M02E", typeId, "typeId");

				var types = ['', 'unknown', 'invoice', 'order', 'grn'];

				return types[typeId];
			}
		}

		return documentTypeResolver;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 537 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(538)], __WEBPACK_AMD_DEFINE_RESULT__ = function (fileExtensionValidatorFactoryLoader) {
    'use strict';

    return function (module) {
        fileExtensionValidatorFactoryLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 538 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:FEV01}
// di.einvoicing.ui.portal.components.fileExtensionValidator
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
  'use strict';

  return function (module) {
    var util = $di.utility.util;
    var guard = $di.exception.guard;

    module.factory('fileExtensionValidator', fileExtensionValidator);
    fileExtensionValidator.$inject = ['documentAttachmentConfigurator'];

    function fileExtensionValidator(documentAttachmentConfigurator) {
      return {
        isFileExtensionValid: isFileExtensionValid
      };

      /**
      * Check if the file extension provided is valid against a list of invalid extensions
      */
      function isFileExtensionValid(fileName) {
        guard.throwIfEmptyString("FEV0101E", fileName, 'fileName');
        guard.throwIfUndefined("FEV0101E", fileName, 'fileName');

        var fileExtension = fileName.substr((~-fileName.lastIndexOf(".") >>> 0) + 2);
        if (util.isNonEmptyString(fileExtension) === false) {
          return false;
        }

        var invalidFileExtensions = documentAttachmentConfigurator.getDisallowedFileExtensions();

        var disallowedExtension = _.find(invalidFileExtensions, function (invalidFileExtension) {
          return invalidFileExtension === fileExtension;
        });

        if (util.isNullOrUndefined(disallowedExtension)) {
          return true;
        }

        return false;
      }
    }

    return fileExtensionValidator;
  };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 539 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EIP02}
// di.einvoicing.proxies.fileTransfer
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(541), __webpack_require__(540)], __WEBPACK_AMD_DEFINE_RESULT__ = function (fileUploaderLoader, documentDownloaderLoader) {
	'use strict';

	return function (module) {
		fileUploaderLoader(module);
		documentDownloaderLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 540 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF0Z}
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var guard = $di.exception.guard;

		module.factory('documentDownloader', documentDownloader);

		documentDownloader.$inject = ['fileDownloader', 'urlHelper'];

		function documentDownloader(fileDownloader, urlHelper) {
			return {
				downloadRenderedInvoice: downloadRenderedInvoice,
				downloadRenderedPurchaseOrder: downloadRenderedPurchaseOrder,
				downloadPurchaseOrdersCsv: downloadPurchaseOrdersCsv
			};

			/**
   * Download rendered invoice by document id			 
   */
			function downloadRenderedInvoice(documentId) {
				guard.throwIfInvalidId("DEF0Z01E", documentId, 'documentId');

				var url = 'Invoice/GetRenderedInvoiceByDocumentId/' + documentId;

				fileDownloader.downloadFile(url);
			}

			/**
    * Downloads rendered order			
    */
			function downloadRenderedPurchaseOrder(documentId) {
				guard.throwIfInvalidId("DEF0Z02E", documentId, 'documentId');

				var url = 'PurchaseOrder/GetRenderedPurchaseOrderByDocumentId/' + documentId;

				fileDownloader.downloadFile(url);
			}

			/**
    * Downloads the CSV file containing data for the requested purchase order ids
    * @param {} purchaseOrderIds 
    * @returns {} 
    */
			function downloadPurchaseOrdersCsv(purchaseOrderIds) {
				guard.throwIfEmptyArray("DEF0Z03E", purchaseOrderIds, 'purchaseOrderIds');

				var requestParams = {
					ids: purchaseOrderIds
				};

				var requestUrl = urlHelper.setParameters('PurchaseOrder/DownloadAsCsv', requestParams);

				fileDownloader.downloadFile(requestUrl);
			}
		}

		return documentDownloader;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 541 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:/UP0W}
// di.einvoicing.ui.portal.proxies.fileTransfer
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
			'use strict';

			return function (module) {
						module.factory('fileUploader', fileUploader);

						fileUploader.$inject = ['Upload', 'endpoints', 'serverResponseHandler', 'authenticationTicketValidator'];

						/**
       * File Uploader wrapper for the ng-file-upload operation
       */
						function fileUploader(httpUpload, endpoints, serverResponseHandler, authenticationTicketValidator) {
									var util = $di.utility.util;

									return {
												upload: validateAuthenticationTicketAndUpload
									};

									/**
          * Handles uploading the specified file to the specified relative URL and endpoint
          * @param relativeUrl - The relative URL to upload the file to
          * @param file - The file to upload
          * @param endpoint - The endpoint to upload the file to
          * @returns - Promise representing the file upload
          */
									function validateAuthenticationTicketAndUpload(relativeUrl, file, endpoint) {
												return authenticationTicketValidator.validateTicket(true, upload);

												function upload() {
															var url = endpoints.getUrl(relativeUrl, endpoint);

															var promise = httpUpload.upload({
																		url: url,
																		data: {
																					file: file
																		}
															});

															promise = promise.then(success);

															/**
               * Function which extracts the HTTP data from the response to make the promise 
               * compatible with the server response handler
               * @param httpResponse - The HTTP response to extract the data from
               * @returns - The data from the HTTP response
               */
															function success(httpResponse) {
																		if (util.isObject(httpResponse)) {
																					return httpResponse.data;
																		} else {
																					return httpResponse;
																		}
															}

															var newPromise = serverResponseHandler.handleServerResponsePromise(promise);

															return newPromise;
												}
									}
						}

						return fileUploader;
			};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 542 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EIP01}
// di.einvoicing.proxies.formatters
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(545), __webpack_require__(546), __webpack_require__(544), __webpack_require__(543)], __WEBPACK_AMD_DEFINE_RESULT__ = function (invoiceFormatterLoader, purchaseOrderFormatterLoader, grnFormatterLoader, dateFormatterLoader) {
    'use strict';

    return function (module) {
        invoiceFormatterLoader(module);
        purchaseOrderFormatterLoader(module);
        grnFormatterLoader(module);
        dateFormatterLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 543 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF15}
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5)], __WEBPACK_AMD_DEFINE_RESULT__ = function (moment) {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.factory('dateFormatter', dateFormatter);
		dateFormatter.$inject = ['diMoment', 'diDateFilter'];

		function dateFormatter(diMoment, diDate) {

			return {
				toServerDate: toServerDate,
				toClientDate: toClientDate,
				toDateTimeWithZone: toDateTimeWithZone

				/**
     * Formats the client date into the server accepted format
     */
			};function toServerDate(clientDate) {
				if (util.isNullOrUndefined(clientDate) || clientDate === '') {
					return clientDate;
				}

				if (moment.isMoment(clientDate) && clientDate.isValid()) {
					return clientDate.format();
				}

				var dateAsMoment = diMoment(clientDate);
				if (moment.isMoment(dateAsMoment) && dateAsMoment.isValid()) {
					return dateAsMoment.format();
				}

				return clientDate;
			}

			/**
    * Formats the server date into the client accepted format
    */
			function toClientDate(serverDate) {
				if (util.isNullOrUndefined(serverDate) || serverDate === '') {
					return serverDate;
				}

				var clientDate = diDate(serverDate);
				return clientDate;
			}

			/*
    * Formats the server utc date to the local client datetime format using the client's timezone
    */
			function toDateTimeWithZone(serverDate) {
				if (util.isNullOrUndefined(serverDate) || serverDate === '') {
					return serverDate;
				}

				var zone = moment.tz.guess() || "Europe/London";

				var clientDate = moment.utc(serverDate).tz(zone);
				return clientDate;
			}
		}

		return dateFormatter;
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 544 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var util = $di.utility.util;

        module.factory('grnFormatter', grnFormatter);

        function grnFormatter() {

            return {
                reformatServerGrnDetailsForClient: reformatServerGrnDetailsForClient
            };

            function reformatServerGrnDetailsForClient(serverObject) {
                if (!util.isObject(serverObject)) {
                    return null;
                }

                var reformattedGrn = serverObject;
                return reformattedGrn;
            }
        }
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 545 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP40}
// di.einvoicing.ui.portal.components.company
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
				'use strict';

				return function (module) {
								var util = $di.utility.util;

								module.factory('invoiceFormatter', invoiceFormatter);
								invoiceFormatter.$inject = ['dateFormatter'];

								function invoiceFormatter(dateFormatter) {
												var mapClientToServer = {
																code: 'suppliersProductCode',
																supplierCodeScheme: 'supplierPartyIdentifierScheme',
																supplierCodeSchemeId: 'supplierPartyIdentifierSchemeId',
																customerCodeScheme: 'customerPartyIdentifierScheme',
																customerCodeSchemeId: 'customerPartyIdentifierSchemeId',
																accountingCustomerCode: 'accountingCustomerPartyIdentifier',
																accountingCustomerCodeScheme: 'accountingCustomerPartyIdentifierScheme',
																accountingCustomerCodeSchemeId: 'accountingCustomerPartyIdentifierSchemeId'
												};

												var mapServerToClient = _.invert(mapClientToServer);
												var headerDatesPropertiesKeys = ['date', 'taxPointDate', 'deliveryDate', 'periodStartDate', 'periodEndDate', 'paymentDueDate'];
												var lineDatesPropertiesKeys = ['periodStartDate', 'periodEndDate'];
												var additionalDocumentReferencesDatesPropertiesKeys = ['createdDateTime'];
												var toClientDate = dateFormatter.toClientDate;
												var toServerDate = dateFormatter.toServerDate;
												var toDateTimeWithZone = dateFormatter.toDateTimeWithZone;

												return {
																reformatServerInvoiceDetailsForClient: reformatServerInvoiceDetailsForClient,
																reformatServerInvoiceForClient: reformatServerInvoiceForClient,
																reformatClientInvoiceForServer: reformatClientInvoiceForServer
												};

												/**
             * Reformats a server invoice for the client
             * @param invoice
             */
												function reformatServerInvoiceForClient(serverObject) {
																if (!util.isObject(serverObject)) {
																				return null;
																}

																var invoice = serverObject.invoice;
																var reformattedInvoice = reformatObject(invoice.header, mapServerToClient, headerDatesPropertiesKeys, toClientDate);

																if (serverObject.paymentTerms) {
																				reformattedInvoice.paymentDueDate = toClientDate(serverObject.paymentTerms.paymentDueDate);
																				reformattedInvoice.paymentTermsId = serverObject.paymentTerms.id;
																				reformattedInvoice.invoiceHeaderId = serverObject.paymentTerms.invoiceHeaderId;
																				reformattedInvoice.paymentTerms = serverObject.paymentTerms.paymentTerms;
																				reformattedInvoice.paymentTermsVersion = serverObject.paymentTerms.version;
																}

																reformattedInvoice.createdByUserId = serverObject.createdByUserId;
																reformattedInvoice.createdDateTime = serverObject.createdDateTime;
																reformattedInvoice.lastModifiedByUserId = serverObject.lastModifiedByUserId;
																reformattedInvoice.lastModifiedDateTime = serverObject.lastModifiedDateTime;
																reformattedInvoice.documentSource = serverObject.documentSource;
																reformattedInvoice.lastDocumentSource = serverObject.lastDocumentSource;
																reformattedInvoice.clientEInvoicingState = serverObject.clientState;
																reformattedInvoice.countOfAttachments = serverObject.countOfAttachments;

																reformattedInvoice.attributes.fill(serverObject.attributes);
																reformattedInvoice.actions.fill(serverObject.actions);

																reformattedInvoice.allowancesCharges = [];
																reformattedInvoice.lines = [];
																_.each(serverObject.allowancesCharges, function (allowanceCharge) {

																				var reformattedAllowanceCharge = reformatObject(allowanceCharge, mapServerToClient);

																				reformattedInvoice.allowancesCharges.push(reformattedAllowanceCharge);
																});

																reformattedInvoice.taxBreakdown = [];
																_.each(serverObject.taxBreakdown, function (taxItem) {
																				var reformattedTaxItem = reformatObject(taxItem, mapServerToClient);

																				reformattedInvoice.taxBreakdown.push(reformattedTaxItem);
																});

																_.each(invoice.details, function (invoiceLine) {

																				var reformattedLine = reformatObject(invoiceLine, mapServerToClient, lineDatesPropertiesKeys, toClientDate);

																				reformattedInvoice.lines.push(reformattedLine);
																});

																reformattedInvoice.additionalDocumentReferences = reformatAdditionalDocumentReferences(serverObject.additionalDocumentReferences, toDateTimeWithZone);

																return reformattedInvoice;
												}

												/**
             * Reformats a server invoice details for the client           
             */
												function reformatServerInvoiceDetailsForClient(serverObject) {
																if (!util.isObject(serverObject)) {
																				return null;
																}

																var reformattedInvoice = reformatObject(serverObject, mapServerToClient, headerDatesPropertiesKeys, toClientDate);

																var reformattedInvoiceAllowancesCharges = [];

																_.each(reformattedInvoice.allowancesCharges, function (allowanceCharge) {

																				var reformattedAllowanceCharge = reformatObject(allowanceCharge, mapServerToClient);

																				reformattedInvoiceAllowancesCharges.push(reformattedAllowanceCharge);
																});

																reformattedInvoice.allowancesCharges = reformattedInvoiceAllowancesCharges;

																var reformattedInvoiceLines = [];

																_.each(reformattedInvoice.lines, function (invoiceLine) {
																				var reformattedLine = reformatObject(invoiceLine, mapServerToClient, lineDatesPropertiesKeys, toClientDate);

																				reformattedInvoiceLines.push(reformattedLine);
																});

																reformattedInvoice.lines = reformattedInvoiceLines;
																reformattedInvoice.additionalDocumentReferences = reformatAdditionalDocumentReferences(serverObject.additionalDocumentReferences, toDateTimeWithZone);

																return reformattedInvoice;
												}

												/**
             * Reformats a client invoice for the server
             * @param invoice
             */
												function reformatClientInvoiceForServer(invoice) {
																if (util.isObject(invoice) === false) {
																				return null;
																}

																var reformattedInvoice = {};

																var allowancesCharges = [];

																reformattedInvoice.header = reformatObject(invoice, mapClientToServer, headerDatesPropertiesKeys, toServerDate);
																delete reformattedInvoice.header.lines;
																reformattedInvoice.details = [];

																_.each(invoice.lines, function (invoiceLine) {
																				var reformattedLine = reformatObject(invoiceLine, mapClientToServer, lineDatesPropertiesKeys, toServerDate);
																				reformattedInvoice.details.push(reformattedLine);
																});

																_.each(invoice.allowancesCharges, function (allowanceCharge) {
																				var reformattedAllowanceCharge = reformatObject(allowanceCharge, mapClientToServer);
																				allowancesCharges.push(reformattedAllowanceCharge);
																});

																var taxBreakdown = [];
																_.each(invoice.taxBreakdown, function (taxBreakdownItem) {
																				var reformattedTaxBreakdownItem = reformatObject(taxBreakdownItem, mapClientToServer);
																				taxBreakdown.push(reformattedTaxBreakdownItem);
																});

																var additionalDocumentReferences = reformatAdditionalDocumentReferences(invoice.additionalDocumentReferences, toServerDate);

																var paymentTerms = {
																				id: invoice.paymentTermsId,
																				paymentDueDate: toServerDate(invoice.paymentDueDate),
																				invoiceHeaderId: invoice.invoiceHeaderId,
																				paymentTerms: invoice.paymentTerms,
																				version: invoice.paymentTermsVersion
																};

																var serverObject = {
																				createdByUserId: invoice.createdByUserId,
																				createdDateTime: invoice.createdDateTime,
																				lastModifiedByUserId: invoice.lastModifiedByUserId,
																				lastModifiedDateTime: invoice.lastModifiedDateTime,
																				documentSource: invoice.documentSource,
																				lastDocumentSource: invoice.lastDocumentSource,
																				invoice: reformattedInvoice,
																				allowancesCharges: allowancesCharges,
																				paymentTerms: paymentTerms,
																				taxBreakdown: taxBreakdown,
																				additionalDocumentReferences: additionalDocumentReferences
																};

																return serverObject;
												}

												/**
             * Reformats the specified object using the specified map
             * @param objectToReformat
             * @param map
             */
												function reformatObject(objectToReformat, map, transformKeys, transformFn) {
																var outputObject = {
																				attributes: [],
																				actions: []

																};

																var transformed = reformatAndTransform(objectToReformat, transformKeys, transformFn, map);

																return _.extend(outputObject, transformed);
												}

												function reformatAndTransform(objectToReformat, transformKeys, transformFn, map) {
																var outputObject = {};

																var hasKeysToTransform = util.isArray(transformKeys);
																var hasTransformFunction = util.isFunction(transformFn);

																_.each(objectToReformat, function (value, key) {
																				var propertyKey = (map || {})[key] !== undefined ? map[key] : key;
																				outputObject[propertyKey] = hasKeysToTransform && hasTransformFunction && _.contains(transformKeys, propertyKey) ? transformFn(value) : value;
																});

																return outputObject;
												}

												function reformatAdditionalDocumentReferences(additionalDocumentReferences, dateFormattingFunc) {
																return _.map(additionalDocumentReferences, function (additionalReference) {
																				return reformatAndTransform(additionalReference, additionalDocumentReferencesDatesPropertiesKeys, dateFormattingFunc);
																});
												}
								}

								return invoiceFormatter;
				};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 546 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP40}
// di.einvoicing.ui.portal.components.company
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var util = $di.utility.util;

        module.factory('purchaseOrderFormatter', purchaseOrderFormatter);

        function purchaseOrderFormatter() {
            return {
                reformatServerPurchaseOrderForClient: reformatServerPurchaseOrderForClient,
                reformatClientPurchaseOrderForServer: reformatClientPurchaseOrderForServer
            };

            /**
             * Reformats a server purchase order for the client
             * @param purchaseOrder
             */
            function reformatServerPurchaseOrderForClient(serverObject) {
                if (!util.isObject(serverObject)) {
                    return null;
                }

                var po = serverObject;

                var reformattedPo = po;
                return reformattedPo;
            }

            /**
             * Reformats a client purchase order for the server
             * @param purchaseOrder
             */
            function reformatClientPurchaseOrderForServer(purchaseOrder) {
                if (util.isObject(purchaseOrder) === false) {
                    return null;
                }

                var reformattedPurchaseOrder = purchaseOrder;

                return reformattedPurchaseOrder;
            }
        }

        return purchaseOrderFormatter;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 547 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(548)], __WEBPACK_AMD_DEFINE_RESULT__ = function (notificationHandlerLoader) {
    'use strict';

    return function (module) {
        notificationHandlerLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 548 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP7G}
// di.einvoicing.ui.portal.portal.invoices._components
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
			'use strict';

			return function (module) {
						var util = $di.utility.util;

						module.factory('notificationHandler', notificationHandler);

						notificationHandler.$inject = ['notifier', 'translator'];

						function notificationHandler(notifier, translator) {

									return {
												showSuccess: showSuccess,
												showWarning: showWarning,
												showInfo: showInfo,
												showError: showError
									};

									function showSuccess(message, identifier, onClick, title, timeOut) {
												formatMessage(message, identifier).then(function (translated) {
															var popupTitle = resolveTitle(title, 'success');
															notifier.success(translated, popupTitle, onClick, timeOut);
												});
									}

									function showWarning(message, identifier, onClick, title) {
												formatMessage(message, identifier).then(function (translated) {
															var popupTitle = resolveTitle(title, 'warning');
															notifier.warning(translated, popupTitle, onClick);
												});
									}

									function showInfo(message, identifier, title) {
												formatMessage(message, identifier).then(function (translated) {
															var popupTitle = resolveTitle(title, 'info');
															notifier.info(translated, popupTitle);
												});
									}

									function showError(message, identifier, title) {
												showNotification('error', message, identifier, title);
									}

									function showNotification(type, message, identifier, title, action) {
												formatMessage(message, identifier).then(function (translated) {
															var popupTitle = resolveTitle(title, type);

															if (util.isFunction(notifier[type])) {
																		notifier[type](translated, popupTitle, action);
															}
												});
									}

									function resolveTitle(title, type) {
												if (util.isNonEmptyString(title)) {
															return translator.instantTranslate(title);
												} else {
															switch (type) {
																		case 'error':
																					return translator.instantTranslate("EINVOICING.PORTAL.ACTIONS.DEFAULT_ERROR_TITLE");
																		case 'info':
																					return translator.instantTranslate("EINVOICING.PORTAL.ACTIONS.DEFAULT_INFO_TITLE");
																		case 'warning':
																					return translator.instantTranslate("EINVOICING.PORTAL.ACTIONS.DEFAULT_WARNING_TITLE");
																		default:
																					return translator.instantTranslate("EINVOICING.PORTAL.ACTIONS.DEFAULT_SUCCESS_TITLE");
															}
												}
									}

									/**
          *  formats notification message             
          */
									function formatMessage(message, identifier) {
												var ref = resolveIdentifier(identifier);

												return translator.translate(message, {
															ref: ref
												});

												/**
             * resolves reference from identifier             
             */
												function resolveIdentifier(value) {
															var reference = value || '';

															return reference.toString();
												}
									}
						}

						return notificationHandler;
			};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 549 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP2O}
// di.einvoicing.ui.portal.proxies
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
				'use strict';

				return function (module) {
								var guard = $di.exception.guard;
								var util = $di.utility.util;

								module.factory('partyProxy', partyProxy);

								partyProxy.$inject = ['webApiHttp', '$q', 'urlHelper', 'proxyErrorInterceptor', 'CLIENT_ENUMS'];

								function partyProxy(http, $q, urlHelper, proxyErrorInterceptor, clientEnums) {
												return {
																get: get,
																getPartyCountriesByType: getPartyCountriesByType,
																getCountryByCode: getCountryByCode,
																getAllPartiesUserCanWorkFor: getAllPartiesUserCanWorkFor,
																getAllPartiesUserCanBeAllocatedTo: getAllPartiesUserCanBeAllocatedTo,
																getAllRelatedPartyCountries: getAllRelatedPartyCountries,
																getPartyContacts: getPartyContacts,
																getLocationsForParty: getLocationsForParty,
																getPartyManagementSearchResults: getPartyManagementSearchResults,
																getWorkingForPartyManagementSearchResults: getWorkingForPartyManagementSearchResults,
																getPartyWithAccountingCustomers: getPartyWithAccountingCustomers,
																getAllUserWorkingForRelatedAllocatedToParties: getAllUserWorkingForRelatedAllocatedToParties,
																discoverPotentialTradingRelationshipParties: discoverPotentialTradingRelationshipParties,
																getEnabledSchemes: getEnabledSchemes,
																resolveSchemeCodeFromId: resolveSchemeCodeFromId,
																addNewPartyCode: addNewPartyCode,
																updatePartyCode: updatePartyCode,
																getPartyCodesForParty: getPartyCodesForParty,
																getAssociatedPartiesTradingRelationshipsByParty: getAssociatedPartiesTradingRelationshipsByParty,
																validatePartyCode: validatePartyCode
												};

												/**
             * Retrieves a party by its id
             */
												function get(id) {
																var requestUrl = urlHelper.setParameters('Party/Get', { id: id });

																var httpPromise = http.get(requestUrl);
																var newPromise = httpPromise.then(function (data) {
																				return data;
																}, function (error) {
																				return handleRejectError(error, "EINVOICING.PROXIES.PARTY_GET.RECEIVE_ERROR");
																});

																return newPromise;
												}

												/**
            * Loads party contacts     
            */
												function getPartyContacts(partyId) {
																var requestProperties = {
																				partyId: partyId
																};

																var requestUrl = urlHelper.setParameters('Party/GetPartyContacts', requestProperties);

																var httpPromise = http.get(requestUrl);
																var newPromise = httpPromise.then(resolved, rejected);

																return newPromise;

																/**
                * Function which allows pre-processing of the data			
                */
																function resolved(data) {
																				return data;
																}

																/**
                * Method which is processed when the receive of data fails			
                */
																function rejected(error) {
																				return handleRejectError(error, "EINVOICING.PROXIES.PARTY_CONTACTS.RECEIVE_ERROR");
																}
												}

												/**
             * Loads party locations     
             */
												function getLocationsForParty(partyId, locationType) {
																var requestProperties = {
																				partyId: partyId,
																				typeId: locationType
																};

																var requestUrl = urlHelper.setParameters('Party/GetPartyLocations', requestProperties);

																var httpPromise = http.get(requestUrl);
																var newPromise = httpPromise.then(resolved, rejected);

																return newPromise;

																/**
                 * Function which allows pre-processing of the data			
                 */
																function resolved(data) {
																				return data;
																}

																function rejected(error) {
																				return handleRejectError(error, "EINVOICING.PROXIES.PARTY_LOCATIONS.RECEIVE_ERROR");
																}
												}

												/**
             * Gets model for the party managment page
             */
												function getPartyManagementSearchResults(relatedPartyId, searchText) {
																var requestProperties = {
																				relatedPartyId: relatedPartyId,
																				searchText: searchText
																};

																var requestUrl = urlHelper.setParameters('Party/GetPartyManagementSearchResults', requestProperties);

																var httpPromise = http.get(requestUrl);
																var newPromise = httpPromise.then(resolved, rejected);

																return newPromise;

																function resolved(data) {
																				return data;
																}

																function rejected(error) {
																				return handleRejectError(error, "EINVOICING.PROXIES.PARTY_MANAGEMENT.RESULT_ERROR");
																}
												}

												function getWorkingForPartyManagementSearchResults(searchText) {
																var requestProperties = {
																				searchText: searchText
																};

																var requestUrl = urlHelper.setParameters('Party/GetWorkingForPartyManagementSearchResults', requestProperties);

																var httpPromise = http.get(requestUrl);
																var newPromise = httpPromise.then(resolved, rejected);

																return newPromise;

																function resolved(data) {
																				return data;
																}

																function rejected(error) {
																				return handleRejectError(error, "EINVOICING.PROXIES.PARTY_MANAGEMENT.RESULT_ERROR");
																}
												}

												/**
             * Loads working parties          
             */
												function getAllPartiesUserCanWorkFor(userId) {

																var requestProperties = {
																				userId: userId
																};

																var requestUrl = urlHelper.setParameters('Party/GetWorkingPartyCollection', requestProperties);

																var httpPromise = http.get(requestUrl);
																var newPromise = httpPromise.then(resolved, rejected);

																return newPromise;

																/**
                 * Function which allows pre-processing of the data			
                 */
																function resolved(data) {
																				return data;
																}

																/**
                 * Method which is processed when the receive of data fails			
                 */
																function rejected(error) {
																				return handleRejectError(error, "EINVOICING.PROXIES.PARTY_COUNTRY.RECEIVE_ERROR");
																}
												}

												/**
             * Loads allocated parties			
             */
												function getAllPartiesUserCanBeAllocatedTo(userId, filteredIds) {
																var requestProperties = {
																				userId: userId
																};

																var requestUrl = urlHelper.setParameters('Party/GetAllocatedPartyCollection', requestProperties);

																var httpPromise = http.get(requestUrl);
																var newPromise = httpPromise.then(resolved, rejected);

																return newPromise;

																/**
                 * Function which allows pre-processing of the party country data			
                 */
																function resolved(data) {
																				var output = [];
																				var ids = [];
																				_.each(data, function (party) {

																								var filtered = _.find(filteredIds, function (id) {
																												return party.partyId === id;
																								});

																								if (filtered) {
																												output.push(party);
																												ids.push(party.partyId);
																								}
																				});

																				return output;
																}

																/**
                 * Method which is processed when the receive of party countries fails			
                 */
																function rejected(error) {
																				return handleRejectError(error, "EINVOICING.PROXIES.PARTY_COUNTRY.RECEIVE_ERROR");
																}
												}

												function getAllUserWorkingForRelatedAllocatedToParties(userId, workingForIds) {
																var requestProperties = {
																				userId: userId,
																				ids: workingForIds
																};

																var requestUrl = urlHelper.setParameters('Party/GetAllUserWorkingForRelatedAllocatedToParties', requestProperties);
																var httpPromise = http.get(requestUrl);
																var newPromise = httpPromise.then(resolved);

																return newPromise;

																function resolved(data) {

																				_.each(data, function (dataItem) {
																								dataItem.name = dataItem.party.name;
																								dataItem.partyId = dataItem.party.id;
																								dataItem.parentId = dataItem.party.parentPartyId;
																				});

																				return data;
																}
												}

												function getAllRelatedPartyCountries(userId, workingForIds) {
																var requestProperties = {
																				userId: userId,
																				id: 0,
																				ids: workingForIds
																};

																var requestUrl = urlHelper.setParameters('Party/GetRelatedPartyCollection', requestProperties);

																var httpPromise = http.get(requestUrl);
																var newPromise = httpPromise.then(resolved, rejected);

																return newPromise;

																/**
                 * Function which allows pre-processing of the party country data			
                 */
																function resolved(data) {
																				var output = [];
																				var ids = [];
																				_.each(data, function (party) {

																								var filtered = _.find(workingForIds, function (id) {
																												return party.party.id === id;
																								});

																								if (!filtered) {
																												output.push(party);
																												ids.push(party.party.id);
																								}
																				});

																				return output;
																}

																/**
                 * Method which is processed when the receive of party countries fails			
                 */
																function rejected(error) {
																				return handleRejectError(error, "EINVOICING.PROXIES.PARTY_COUNTRY.RECEIVE_ERROR");
																}
												}

												/**
             * Loads party countries by party type           
             */
												function getPartyCountriesByType(partyType) {
																guard.throwIfEmptyString("EUP2O01E", partyType, 'partyType');

																var requestProperties = {
																				partyType: partyType
																};

																var requestUrl = urlHelper.setParameters('Party/GetCollectionByPartyType', requestProperties);

																var httpPromise = http.get(requestUrl);
																var newPromise = httpPromise.then(resolved, rejected);

																return newPromise;

																/**
                 * Function which allows pre-processing of the party country data			
                 */
																function resolved(data) {
																				return data;
																}

																/**
                 * Method which is processed when the receive of party countries fails			
                 */
																function rejected(error) {
																				return handleRejectError(error, "EINVOICING.PROXIES.PARTY_COUNTRY.RECEIVE_ERROR");
																}
												}

												/**
             * Loads country details data by country code             
             */
												function getCountryByCode(countryCode) {
																guard.throwIfEmptyString("EUP2O02E", countryCode, 'countryCode');

																var requestProperties = {
																				code: countryCode
																};

																var requestUrl = urlHelper.setParameters('Party/GetCountryByCountryCode', requestProperties);

																var httpPromise = http.get(requestUrl);
																var newPromise = httpPromise.then(resolved(), rejected);

																return newPromise;

																/**
                 * Function which allows pre-processing of the resolved data	            
                 */
																function resolved(data) {
																				return data;
																}

																/**
                 * Called when loading country data fails             
                 */
																function rejected(error) {
																				return handleRejectError(error, "EINVOICING.PORTAL.PROXIES.COUNTRY.RECEIVE_ERROR");
																}
												}

												function getPartyWithAccountingCustomers(partyId) {
																var requestProperties = {
																				partyId: partyId
																};

																var requestUrl = urlHelper.setParameters('Party/GetPartyWithAccountingCustomers', requestProperties);

																var httpPromise = http.get(requestUrl);
																var newPromise = httpPromise.then(resolved, rejected);

																return newPromise;

																/**
                * Function which allows pre-processing of the party country data			
                */
																function resolved(data) {
																				return data;
																}

																/**
                * Method which is processed when the receive of party countries fails			
                */
																function rejected(error) {
																				return handleRejectError(error, "EINVOICING.PROXIES.PARTY_MANAGEMENT.RESULT_ERROR");
																}
												}

												function discoverPotentialTradingRelationshipParties(partyId, searchText) {
																var requestProperties = {
																				partyId: partyId,
																				searchText: searchText
																};

																var requestUrl = urlHelper.setParameters('Party/DiscoverPotentialTradingRelationshipParties', requestProperties);

																var httpPromise = http.get(requestUrl);
																var newPromise = httpPromise.then(function (data) {
																				return data;
																}, function (error) {
																				return handleRejectError(error, "EINVOICING.PROXIES.DISCOVER_PARTIES.RESULT_ERROR");
																});

																return newPromise;
												}

												/**
                 * Loads schemes based on party code type             
                 */
												function getEnabledSchemes() {
																var httpPromise = http.get("Party/GetSchemesForPartyCodeType");
																var newPromise = httpPromise.then(resolved, rejected);

																return newPromise;

																/**
                          * Function which allows pre-processing of the resolved data	            
                          */
																function resolved(data) {
																				return data;
																}

																/**
                          * Called when loading scheme data fails             
                          */
																function rejected(error) {
																				return handleRejectError(error, "EINVOICING.PROXIES.SCHEME.RECEIVE_ERROR");
																}
												}

												function resolveSchemeCodeFromId(id) {
																if (util.isDefined(clientEnums.schemes[id])) {
																				return clientEnums.schemes[id];
																}

																return "UNKNOWN";
												}

												function addNewPartyCode(partyId, data) {
																var requestProperties = {
																				partyId: partyId
																};

																var requestUrl = urlHelper.setParameters('Party/AddNewPartyCode', requestProperties);
																return http.post(requestUrl, data).then(function (data) {
																				return data;
																}, function (error) {
																				return handleRejectError(error, 'EINVOICING.PROXIES.PARTY_CODE.ADD_ERROR');
																});
												}

												function validatePartyCode(data) {
																return http.post('Party/ValidatePartyCode', data).then(function (data) {
																				return data;
																}, function (error) {
																				return handleRejectError(error, 'EINVOICING.PROXIES.PARTY_CODE.VALIDATE_CODE_ERROR');
																});
												}

												function updatePartyCode(data) {
																var partyCodeModel = {
																				code: {
																								id: data.id,
																								partyId: data.partyId,
																								codeValue: data.code,
																								schemeId: data.schemeId,
																								partyCodeType: data.partyCodeType,
																								relatedPartyId: data.relatedPartyId
																				}
																};

																return http.post('Party/UpdatePartyCode', partyCodeModel).then(function (data) {
																				return data;
																}, function (error) {
																				return handleRejectError(error, error.response.statusText);
																});
												}

												function getPartyCodesForParty(partyId) {
																var requestProperties = {
																				partyId: partyId
																};

																var requestUrl = urlHelper.setParameters('Party/GetPartyCodesForParty', requestProperties);

																var httpPromise = http.get(requestUrl);

																var newPromise = httpPromise.then(function (data) {
																				return data;
																}, function (error) {
																				return handleRejectError(error, response.statusText);
																});

																return newPromise;
												}

												function getAssociatedPartiesTradingRelationshipsByParty(partyId) {
																var requestProperties = {
																				partyId: partyId
																};

																var requestUrl = urlHelper.setParameters('Party/GetAssociatedPartiesTradingRelationshipsByPartyId', requestProperties);
																var httpPromise = http.get(requestUrl);

																var newPromise = httpPromise.then(function (data) {
																				return data;
																}, function (error) {
																				return handleRejectError(error, 'EINVOICING.PROXIES.TRADING_RELATIONSHIP.FETCH_ERROR');
																});

																return newPromise;
												}

												function handleRejectError(error, failureReason) {
																proxyErrorInterceptor.handleError(error, failureReason, "");
																return $q.reject(error);
												}
								}

								return partyProxy;
				};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 550 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ProxyErrorInterceptor = function () {
    function ProxyErrorInterceptor(authenticationResult, translator) {
        _classCallCheck(this, ProxyErrorInterceptor);

        this._authenticationResult = authenticationResult;
        this._translator = translator;
    }

    _createClass(ProxyErrorInterceptor, [{
        key: 'handleError',
        value: function handleError(error, failureReason, defaultFailureReason) {
            if (error.failureReason === this._authenticationResult.ServerDown) {
                error.failureReason = this._translator.instantTranslate('EINVOICING.PORTAL.PROXIES.SERVER_DOWN_ERROR');
                return;
            }

            if (failureReason || defaultFailureReason) {
                error.failureReason = failureReason || defaultFailureReason;
            }
        }
    }]);

    return ProxyErrorInterceptor;
}();

ProxyErrorInterceptor.prototype.constructor.$inject = ['AUTHENTICATION_RESULT', 'translator'];

exports.ProxyErrorInterceptor = ProxyErrorInterceptor;

/***/ }),
/* 551 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TradingRelationshipProxy = function () {
    function TradingRelationshipProxy(http, $q, urlHelper) {
        _classCallCheck(this, TradingRelationshipProxy);

        this.http = http;
        this.$q = $q;
        this.urlHelper = urlHelper;
    }

    _createClass(TradingRelationshipProxy, [{
        key: 'createTradingRelationship',
        value: function createTradingRelationship(partyId, tradingPartyId) {
            var _this = this;

            var requestProperties = {
                partyId: partyId, tradingPartyId: tradingPartyId
            };

            var requestUrl = this.urlHelper.setParameters('TradingRelationship/CreateTradingRelationship', requestProperties);
            var httpPromise = this.http.post(requestUrl).then(function (data) {
                return data;
            }, function (error) {
                error.failureReason = 'EINVOICING.PORTAL.PROXIES.TRADING_RELATIONSHIP.CREATE.RESULT_ERROR';
                return _this.$q.reject(error);
            });

            return httpPromise;
        }
    }, {
        key: 'removeTradingRelationship',
        value: function removeTradingRelationship(partyId, tradingPartyId) {
            var _this2 = this;

            var requestProperties = {
                partyId: partyId, tradingPartyId: tradingPartyId
            };

            var requestUrl = this.urlHelper.setParameters('TradingRelationship/RemoveTradingRelationship', requestProperties);
            var httpPromise = this.http.doDelete(requestUrl).then(function (data) {
                return data;
            }, function (error) {
                error.failureReason = 'EINVOICING.PORTAL.PROXIES.TRADING_RELATIONSHIP.REMOVE.RESULT_ERROR';
                return _this2.$q.reject(error);
            });

            return httpPromise;
        }
    }]);

    return TradingRelationshipProxy;
}();

TradingRelationshipProxy.prototype.constructor.$inject = ['webApiHttp', '$q', 'urlHelper'];

exports.TradingRelationshipProxy = TradingRelationshipProxy;

/***/ }),
/* 552 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(553)], __WEBPACK_AMD_DEFINE_RESULT__ = function (userActionsResolverLoader) {
    'use strict';

    return function (module) {
        userActionsResolverLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 553 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP7X}
// di.einvoicing.ui.portal.userActionsResolver
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.factory('userActionsResolver', userActionsResolver);

		/**
   * resolves user actions
   */
		function userActionsResolver() {
			return {
				resolveActions: resolveActions
			};

			/**
    * resolves array of available user actions			
    */
			function resolveActions(arrayActions, isMultiArray) {
				var transformed = arrayActions;

				if (isMultiArray && arrayActions.length > 0) {
					transformed = arrayActions.shift().filter(function (v) {
						return arrayActions.every(function (a) {
							return a.indexOf(v) !== -1;
						});
					});
				}

				return transformed;
			}
		}

		return userActionsResolver;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 554 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:UPP01}
// di.einvoicing.ui.portal.proxies
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
				'use strict';

				return function (module) {
								var guard = $di.exception.guard;

								module.factory('userProxy', userProxy);

								userProxy.$inject = ['webApiHttp', '$q', 'urlHelper', 'proxyErrorInterceptor'];

								function userProxy(http, $q, urlHelper, proxyErrorInterceptor) {
												return {
																getById: getById,
																getDetailsModelById: getDetailsModelById,
																getUsers: getUsers,
																getRoles: getRoles,
																getRoleRights: getRoleRights,
																getAllRights: getAllRights,
																saveUser: saveUser,
																createUser: createUser,
																getUserRights: getUserRights,
																saveUserNotifications: saveUserNotifications,
																getAllowedActions: getAllowedActions,
																generatePassword: generatePassword,
																remove: remove
												};

												/**
             * Gets user by Id			 
             */
												function getById(id) {
																guard.throwIfInvalidId("UPP0108E", id, 'id');

																var requestUrl = 'User/GetUserById/' + id;

																var promise = http.get(requestUrl);

																var newPromise = promise.then(resolve, reject);

																return newPromise;

																function resolve(data) {
																				return data;
																}

																function reject(error) {
																				return handleRejectError(error);
																}
												}

												/**
             * Gets user details by user Id			 
             */
												function getDetailsModelById(id) {
																guard.throwIfInvalidId("UPP0107E", id, 'id');

																var requestUrl = 'User/GetDetailsModelById/' + id;

																var promise = http.get(requestUrl);

																var newPromise = promise.then(resolve, reject);

																return newPromise;

																function resolve(data) {
																				return data;
																}

																function reject(error) {
																				return handleRejectError(error);
																}
												}

												/**
             * gets list of users			 
             */
												function getUsers(searchText, lastNRows) {
																guard.throwIfNotANumber("UPP0106E", lastNRows, "lastNRows");

																var requestedParams = {
																				searchText: searchText,
																				lastNRows: lastNRows
																};

																var requestedUrl = urlHelper.setParameters('User/GetUserSearchResults', requestedParams);

																var promise = http.get(requestedUrl).then(resolve, reject);

																return promise;

																function resolve(data) {
																				return data;
																}

																function reject(error) {
																				return handleRejectError(error);
																}
												}

												function getUserRights(id) {
																var requestUrl = 'User/GetUserRights/' + id;

																var promise = http.get(requestUrl);

																var newPromise = promise.then(resolve, reject);

																return newPromise;

																function resolve(data) {
																				return data;
																}

																function reject(error) {
																				return handleRejectError(error);
																}
												}

												/**
             * gets all roles			
             */
												function getRoles() {
																var requestUrl = 'User/GetAllRoles/';

																var promise = http.get(requestUrl);

																var newPromise = promise.then(resolve, reject);

																return newPromise;

																function resolve(data) {
																				return data;
																}

																function reject(error) {
																				return handleRejectError(error);
																}
												}

												function getAllRights() {
																var requestUrl = 'User/GetAllRights/';

																var promise = http.get(requestUrl);

																var newPromise = promise.then(resolve, reject);

																return newPromise;

																function resolve(data) {
																				return data;
																}

																function reject(error) {
																				return handleRejectError(error);
																}
												}

												function getRoleRights() {
																var url = 'User/GetRoleRights';
																var promise = http.get(url);

																var newPromise = promise.then(resolve, reject);
																return newPromise;

																function resolve(data) {
																				return data;
																}

																function reject(error) {
																				return handleRejectError(error);
																}
												}

												/**
             * saves user details			 
             */
												function saveUser(user) {
																guard.throwIfNotAnObject("EUP4002E", user, 'user');

																var promise = http.post('User/SaveUser', user);

																var newPromise = promise.then(resolved, rejected);

																return newPromise;

																function resolved(data) {
																				if (!data.success) {
																								return handleRejectError(data, data.failureReason);
																				}
																				return data;
																}

																function rejected(error) {
																				return handleRejectError(error);
																}
												}

												/**
             * Creates new user             
             */
												function createUser(user) {
																guard.throwIfNotAnObject("UPP010FE", user, 'user');

																var promise = http.post('User/CreateUser', user);

																var newPromise = promise.then(resolved, rejected);

																return newPromise;

																function resolved(data) {
																				return data;
																}

																function rejected(error) {
																				return $q.reject(error);
																}
												}

												/**
            * generates user password			 
            */
												function generatePassword(id) {
																guard.throwIfInvalidId("UPP010EE", id, 'id');

																var requestProperties = {
																				userId: id
																};

																var requestUrl = urlHelper.setParameters('User/GeneratePassword', requestProperties);

																var promise = http.post(requestUrl);

																var newPromise = promise.then(resolved, rejected);

																return newPromise;

																function resolved(data) {
																				if (data.success) {
																								return data;
																				} else {
																								return $q.reject(data.failureReason);
																				}
																}

																function rejected(error) {
																				return $q.reject(error);
																}
												}

												/**
             * Saves user notifications             
             */
												function saveUserNotifications(model) {
																guard.throwIfNotAnObject("UPP010BE", model, 'model');

																var promise = http.post('User/SaveUserNotifications', model);

																var newPromise = promise.then(resolved, rejected);

																return newPromise;

																function resolved(data) {
																				return data;
																}

																function rejected(error) {
																				return handleRejectError(error);
																}
												}

												/**
            * Loads allowed actions for user
            */
												function getAllowedActions(id) {
																guard.throwIfInvalidId("UPP010CE", id, 'id');

																var requestUrl = 'User/GetActionsAllowed/' + id;

																var promise = http.get(requestUrl);

																var newPromise = promise.then(resolved, rejected);

																return newPromise;

																function resolved(data) {
																				return data;
																}

																function rejected(error) {
																				return handleRejectError(error);
																}
												}

												/**
             * Removes the user with specified id			 
             */
												function remove(id) {
																guard.throwIfInvalidId("UPP010GE", id, 'id');

																var requestedUrl = urlHelper.setParameters('User/RemoveUser', { id: id });

																var promise = http.doDelete(requestedUrl).then(function (data) {
																				return data;
																}, function (error) {
																				return handleRejectError(error, 'EINVOICING.PORTAL.PROXIES.USER.REMOVE.RESULT_ERROR');
																});

																return promise;
												}

												function handleRejectError(error, failureReason) {
																proxyErrorInterceptor.handleError(error, failureReason, "");
																return $q.reject(error);
												}
								}

								return userProxy;
				};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 555 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(556)], __WEBPACK_AMD_DEFINE_RESULT__ = function (vmFiltersListConfiguratorLoader) {
    'use strict';

    return function (module) {
        vmFiltersListConfiguratorLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 556 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF0C}
// di.einvoicing.ui.portal.components.vmListConfigurator
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;
		var guard = $di.exception.guard;

		module.factory('vmFiltersListConfigurator', vmFiltersListConfigurator);

		vmFiltersListConfigurator.$inject = ['dateFormatter'];

		function vmFiltersListConfigurator(dateFormatter) {
			return {
				configure: configure
			};

			function configure(filters, vm, listConfigurator) {
				guard.throwIfNotAnObject("DEF0C01E", filters, 'filters');
				guard.throwIfNotAnObject("DEF0C02E", vm, 'vm');
				guard.throwIfNotAnObject("DEF0C03E", listConfigurator, 'listConfigurator');

				vm.tableOptions = _.extend({}, listConfigurator.getTableConfiguration());
				if (util.isNumber(filters.pageSize)) {
					vm.tableOptions.paginationPageSize = filters.pageSize;
				}
				if (util.isNumber(filters.pageNumber)) {
					vm.tableOptions.paginationPageNumber = filters.pageNumber;
				}

				vm.buttonsSetOneOptions = listConfigurator.getButtonsSetOneConfiguration();
				vm.buttonsSetTwoOptions = listConfigurator.getButtonsSetTwoConfiguration();
				vm.statusOptions = listConfigurator.getStatusFilters();
				vm.sortOptions = listConfigurator.getSortableColumns();
				vm.dateTypes = listConfigurator.getDateTypesOptions();

				setSelectedFiltersOrDefaultToInitial(vm, filters, listConfigurator);

				if (util.isDefined(listConfigurator.getFreeformSearchDefaultFilter)) {
					var filter = listConfigurator.getFreeformSearchDefaultFilter();

					if (util.isRealObject(filter)) {
						vm.searchDefaultFilter = filter;
					}
				}
			}

			/* 
    Sets the vm selected filters to the passed in values, if defined, and the initial values otherwise
    */
			function setSelectedFiltersOrDefaultToInitial(vm, filters, listConfigurator) {
				if (util.isDefined(filters.statusFilter)) {
					vm.selectedFilters.statusFilter = _.find(vm.statusOptions, function (item) {
						return item.value === filters.statusFilter;
					});
				}
				if (util.isUndefined(vm.selectedFilters.statusFilter)) {
					vm.selectedFilters.statusFilter = listConfigurator.getInitialStatusFilter();
				}

				if (util.isDefined(filters.sortOption)) {
					vm.selectedFilters.sortOption = _.find(vm.sortOptions, function (item) {
						return item.value === filters.sortOption;
					});
				}

				if (util.isUndefined(vm.selectedFilters.sortOption)) {
					vm.selectedFilters.sortOption = listConfigurator.getInitialSortOption();
				}

				if (util.isDefined(filters.dateType)) {
					vm.selectedFilters.dateType = _.find(vm.dateTypes, function (item) {
						return item.value === filters.dateType;
					});
				}
				if (util.isUndefined(vm.selectedFilters.dateType)) {
					vm.selectedFilters.dateType = listConfigurator.getInitialDateType();
				}

				vm.dateOptions = listConfigurator.getDateTimeFilters(vm.selectedFilters.dateType.value);

				if (util.isDefined(filters.dateTimeFilter)) {
					vm.selectedFilters.dateTimeFilter = _.find(vm.dateOptions, function (item) {
						return item.value === filters.dateTimeFilter;
					});
				}
				if (util.isUndefined(vm.selectedFilters.dateTimeFilter)) {
					vm.selectedFilters.dateTimeFilter = listConfigurator.getInitialDateTimeFilter(vm.selectedFilters.dateType.value);
				}

				if (vm.selectedFilters.dateTimeFilter.value === 'Custom' && (util.isDefined(filters.fromDate) || util.isDefined(filters.toDate))) {

					vm.selectedFilters.dateTimeFilter = _.find(vm.dateOptions, function (item) {
						return item.value === 'Custom';
					});

					vm.selectedFilters.customDateTimeFilter = {
						toDate: dateFormatter.toClientDate(filters.toDate) || '',
						fromDate: dateFormatter.toClientDate(filters.fromDate) || ''
					};
				} else {
					vm.selectedFilters.customDateTimeFilter = { toDate: '', fromDate: '' };
				}

				if (util.isDefined(filters.searchText)) {
					vm.selectedFilters.searchText = filters.searchText;
				}
				if (util.isUndefined(vm.selectedFilters.searchText)) {
					vm.selectedFilters.searchText = "";
				}
			}
		}

		return vmFiltersListConfigurator;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 557 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP7T}
// di.einvoicing.ui.portal.portal.summaries.components
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(558), __webpack_require__(575), __webpack_require__(576), __webpack_require__(568), __webpack_require__(577), __webpack_require__(572), __webpack_require__(559)], __WEBPACK_AMD_DEFINE_RESULT__ = function (snippetsLoader, summarySelectorControllerLoader, summaryTypesLoader, rangeSelectorLoader, tabularSummaryLoader, singleValueSummaryLoader, chartSummaryLoader) {
				'use strict';

				return function (module) {
								snippetsLoader(module);
								summarySelectorControllerLoader(module);
								summaryTypesLoader(module);
								rangeSelectorLoader(module);
								tabularSummaryLoader(module);
								singleValueSummaryLoader(module);
								chartSummaryLoader(module);
				};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 558 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP7U}
// di.einvoicing.ui.portal.portal.summaries.components.snippets
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var snippetContext = $di.angular.snippetRegistrar.createContext(module, 'src/app/portal/summaries/_components/_snippets');

		snippetContext.registerSnippet('diSummarySelector', 'summarySelector.html', 'SummarySelectorController', 'summarySelectorCtrl');
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 559 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF0J}
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(565), __webpack_require__(566), __webpack_require__(561), __webpack_require__(562), __webpack_require__(564), __webpack_require__(560), __webpack_require__(563), __webpack_require__(567)], __WEBPACK_AMD_DEFINE_RESULT__ = function (chartSummaryController, chartSummaryDirective, chartConfigurationMapper, chartDataMapper, chartLayoutMapper, chartConfigMapper, chartFontMapper, chartTitleMapper) {
    'use strict';

    return function (module) {
        chartSummaryController(module);
        chartSummaryDirective(module);
        chartConfigurationMapper(module);
        chartDataMapper(module);
        chartLayoutMapper(module);
        chartConfigMapper(module);
        chartFontMapper(module);
        chartTitleMapper(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 560 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF0P}
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.factory('chartConfigMapper', chartConfigMapper);

		function chartConfigMapper() {
			return {
				map: mapConfig
			};

			function mapConfig(chartConfiguration) {
				var result = {};
				if (util.isBoolean(chartConfiguration.displayModeBar) || util.isNonEmptyString(chartConfiguration.displayModeBar)) {
					_.extend(result, { displayModeBar: chartConfiguration.displayModeBar });
				}

				if (util.isBoolean(chartConfiguration.staticPlot)) {
					_.extend(result, { staticPlot: chartConfiguration.staticPlot });
				}

				if (util.isBoolean(chartConfiguration.scrollZoom)) {
					_.extend(result, { scrollZoom: chartConfiguration.scrollZoom });
				}

				if (util.isBoolean(chartConfiguration.doubleClick) && !chartConfiguration.doubleClick || util.isNonEmptyString(chartConfiguration.doubleClick) && _.contains(['reset', 'autosize', 'reset+autosize'], chartConfiguration.doubleClick)) {
					_.extend(result, { doubleClick: chartConfiguration.doubleClick });
				}

				if (util.isBoolean(chartConfiguration.editable)) {
					_.extend(result, { editable: chartConfiguration.editable });
				}
				return result;
			}
		}

		return chartConfigMapper;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 561 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF0K}
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.factory('chartConfigurationMapper', chartConfigurationMapper);

		chartConfigurationMapper.$inject = ['chartDataMapper', 'chartLayoutMapper', 'chartConfigMapper', 'chartFontMapper'];

		function chartConfigurationMapper(chartDataMapper, chartLayoutMapper, chartConfigMapper, chartFontMapper) {
			return {
				getChartConfiguration: getChartConfiguration
			};

			/* config options (with default values)
             *  staticPlot: false,
             *  editable: false,
             *  queueLength: 0,
             *  autosizable: false,
             *  fillFrame: false,
             *  frameMargins: 0,
             *  scrollZoom: false,
             *  doubleClick: 'reset+autosize',
             *  showTips: true,
             *  showLink: false,
             *  sendData: true,
             *  linkText: 'Edit chart',
             *  showSources: false,
             *  displayModeBar: 'hover',
             *  modeBarButtonsToRemove: [],
             *  modeBarButtonsToAdd: [],
             *  modeBarButtons: false,
             *  displaylogo: true,
             *  plotGlPixelRatio: 2,
             */

			/*
             * Chart types
             * scatter
             * bar
             * box
             * heatmap
             * histogram
             * histogram2d
             * area
             * pie
             * contour
             * histogram2dcontour
             * scatter3d
             * surface
             * mesh3d
             * scattergeo
             * choropleth
             * scattergl
             */
			function getChartConfiguration(summaryData, chartConfiguration, documentTypeId) {

				var data = chartDataMapper.map(summaryData, chartConfiguration, documentTypeId);
				var layout = chartLayoutMapper.map(chartConfiguration);
				var config = chartConfigMapper.map(chartConfiguration);

				configureAnnotations(layout, data, chartConfiguration);

				var configuration = {};

				if (util.isRealObject(data)) _.extend(configuration, { data: data });

				if (util.isRealObject(layout)) _.extend(configuration, { layout: layout });

				if (util.isRealObject(config)) _.extend(configuration, { config: config });

				return configuration;
			}

			function configureAnnotations(layout, data, chartConfiguration) {
				var result = [];
				if (util.isRealObject(chartConfiguration.yAxis) && util.isRealObject(chartConfiguration.yAxis.title) && util.isNonEmptyString(chartConfiguration.yAxis.title.orientation) && (!util.isNullOrUndefined(chartConfiguration.yAxis.title.text) || util.isNonEmptyString(chartConfiguration.yAxis.title.languageKey))) {
					if (chartConfiguration.yAxis.title.orientation === 'h') {
						var yAxisAnnotation = {
							xref: 'paper',
							yref: 'paper',
							x: -0.005,
							xanchor: 'right',
							y: 0.5,
							yanchor: 'middle',
							text: layout.yaxis.title,
							showarrow: false
						};
						if (util.isRealObject(chartConfiguration.yAxis.title.font)) {
							yAxisAnnotation.font = layout.yaxis.titlefont;
						}
						result.push(yAxisAnnotation);
						//remove from the layout since we are setting them using annotations
						layout.yaxis.title = undefined;
						layout.yaxis.titlefont = undefined;
					}
				}

				if (chartConfiguration.type === 'bar') {
					if (util.isRealObject(chartConfiguration.barWatermark)) {
						if (util.isNonEmptyString(chartConfiguration.barWatermark.value)) {
							if (chartConfiguration.barWatermark.value === 'currency') {

								var watermarkFont = chartFontMapper.map(chartConfiguration.barWatermark);

								var yValues = _.union(_.flatten(_.pluck(data, 'y'), true));
								var barAnnotations = _.map(yValues, function (yValue) {

									var trace = _.find(data, function (trace) {
										return _.contains(trace.y, yValue);
									});

									var currencySymbol = util.isDefined(trace) ? trace.currencySymbol[trace.y.indexOf(yValue)] : undefined;

									var ann = {
										showarrow: false,
										xanchor: 'left',
										xref: 'paper',
										x: 0.005,
										yref: 'y',
										y: yValue,
										text: currencySymbol
									};
									if (util.isRealObject(watermarkFont)) _.extend(ann, { font: watermarkFont });
									return ann;
								});

								result = result.concat(barAnnotations);
							}
						}
					}
				}

				if (result.length > 0) _.extend(layout, { annotations: result });
			}
		}

		return chartConfigurationMapper;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 562 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF0N}
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.factory('chartDataMapper', chartDataMapper);

		chartDataMapper.$inject = ['enumsKeyResolver', 'CLIENT_ENUMS', 'enumTranslator', 'documentTypeResolver', '$filter', 'invoiceListConfigurator', 'purchaseOrderListConfigurator'];

		function chartDataMapper(enumsKeyResolver, clientEnums, enumTranslator, documentTypeResolver, filter, invoiceListConfigurator, purchaseOrderListConfigurator) {
			return {
				map: mapData
			};

			function mapData(summaryData, chartConfiguration, documentTypeId) {

				var clientStateEnum = getStatesEnum(documentTypeId);
				var hover = mapHoverConfiguration(chartConfiguration);
				var statusesToShow = documentTypeId === clientEnums.documentType.invoice ? invoiceListConfigurator.getStatusFilters() : documentTypeId === clientEnums.documentType.purchaseOrder ? purchaseOrderListConfigurator.getStatusFilters() : null;

				var groupedByClientState = _.groupBy(summaryData, function (tableRow) {
					return tableRow.clientStateId;
				});
				var tracesObj = {};
				var currenciesMapper = {};
				var currencyYValue = 0;

				for (var clientStateId in groupedByClientState) {
					if (groupedByClientState.hasOwnProperty(clientStateId) && (statusesToShow == null || _.some(statusesToShow, function (filter) {
						return filter.value !== clientEnums.documentStateKey.unknown && filter.value === parseInt(clientStateId);
					}))) {

						var stateId = parseInt(clientStateId);
						var groupedByCurrency = _.groupBy(groupedByClientState[clientStateId], function (tableRow) {
							return tableRow.currencyId;
						});

						for (var currencyId in groupedByCurrency) {
							// have a different stacked bar for each currency
							if (groupedByCurrency.hasOwnProperty(currencyId)) {
								//can only be one total for a state with a given currency
								var x = [groupedByCurrency[currencyId][0].totalAmount || groupedByCurrency[currencyId][0].totalIncludingTax];
								var text = [formatCurrency(currencyId, x[0])];
								var currencySymbol = [getCurrencySymbol(currencyId)];
								//do not use the actual currencyId value, to have the different currency bars laid out next to each other
								var y;
								if (currenciesMapper[currencyId] != undefined) y = [currenciesMapper[currencyId]];else {
									currenciesMapper[currencyId] = currencyYValue;
									y = [currencyYValue];
									currencyYValue++;
								}

								if (util.isNullOrUndefined(tracesObj[clientStateId])) {

									var trace = {
										name: toTitleCase(enumTranslator.instantTranslate(clientStateEnum, stateId)),
										y: y,
										x: x,
										text: text,
										currencySymbol: currencySymbol
									};

									var traceOptions = configureTrace(chartConfiguration, hover);
									if (util.isRealObject(traceOptions)) {
										_.extend(trace, traceOptions);
									}

									tracesObj[clientStateId] = trace;
								} else {
									tracesObj[clientStateId].x = tracesObj[clientStateId].x.concat(x);
									tracesObj[clientStateId].y = tracesObj[clientStateId].y.concat(y);
									tracesObj[clientStateId].text = tracesObj[clientStateId].text.concat(text);
									tracesObj[clientStateId].currencySymbol = tracesObj[clientStateId].currencySymbol.concat(currencySymbol);
								}
							}
						}
					}
				}

				var traces = [];
				for (var clientId in tracesObj) {
					if (tracesObj.hasOwnProperty(clientId)) {
						traces.push(tracesObj[clientId]);
					}
				}

				return _.sortBy(traces, function (trace) {
					return trace.name;
				});
			}

			function formatCurrency(currencyId, amount) {
				return filter('diCurrency')(amount, parseInt(currencyId));
			}

			function getCurrencySymbol(currencyId) {
				return formatCurrency(currencyId, 0).replace(/[0-9.,]*/g, '');
			}

			function toTitleCase(input) {
				input = input || '';
				return input.replace(/\w\S*/g, function (txt) {
					return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
				});
			}

			function configureTrace(chartConfiguration, hover) {
				var result = {};
				if (util.isNonEmptyString(chartConfiguration.type)) {
					_.extend(result, { type: chartConfiguration.type });
				}

				if (util.isNonEmptyString(chartConfiguration.orientation)) {
					_.extend(result, { orientation: chartConfiguration.orientation });
				}

				if (util.isRealObject(hover)) {
					_.extend(result, hover);
				}

				return result;
			}

			function mapHoverConfiguration(chartConfigurationParent) {
				var result = {};
				if (util.isRealObject(chartConfigurationParent.hover)) {
					if (util.isNonEmptyString(chartConfigurationParent.hover.info) && (_.contains(["all", "none", "skip", "x", "y", "z", "text", "name"], chartConfigurationParent.hover.info) || chartConfigurationParent.hover.info.match("/^\\b(?:x|y|z|text|name)\\b(\\+\\b(?:x|y|z|text|name)\\b)*$/"))) {
						_.extend(result, { hoverinfo: chartConfigurationParent.hover.info });
					}
				}
				return result;
			}

			function getStatesEnum(documentTypeId) {
				var documentType = documentTypeResolver.getTypeKeyById(documentTypeId);
				return enumsKeyResolver.getEnumsForCurrentRole(clientEnums.documentStateKey, documentType);
			}
		}

		return chartDataMapper;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 563 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF0Q}
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.factory('chartFontMapper', chartFontMapper);

		function chartFontMapper() {
			return {
				map: mapFont
			};

			function mapFont(chartConfiguration) {
				var result = {};
				if (util.isRealObject(chartConfiguration.font)) {
					if (util.isNonEmptyString(chartConfiguration.font.family)) {
						_.extend(result, { family: chartConfiguration.font.family });
					}

					if (util.isNumber(chartConfiguration.font.size)) {
						_.extend(result, { size: chartConfiguration.font.size });
					}

					if (util.isNonEmptyString(chartConfiguration.font.color)) {
						_.extend(result, { color: chartConfiguration.font.color });
					}
				}
				return result;
			}
		}

		return chartFontMapper;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 564 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF0O}
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.factory('chartLayoutMapper', chartLayoutMapper);

		chartLayoutMapper.$inject = ['chartTitleMapper', 'chartFontMapper'];

		function chartLayoutMapper(chartTitleMapper, chartFontMapper) {
			return {
				map: mapLayout
			};

			function mapLayout(chartConfiguration) {
				var layout = {};
				var xAxis = {};
				var yAxis = {};
				var legend = {};

				var title = chartTitleMapper.map(chartConfiguration);

				var size = mapDimensionConfiguration(chartConfiguration);

				var margin = mapMarginConfiguration(chartConfiguration);

				if (chartConfiguration.type === "bar" && util.isNonEmptyString(chartConfiguration.barmode)) {
					_.extend(layout, { barmode: chartConfiguration.barmode });
				}

				if (util.isRealObject(chartConfiguration.hover)) {
					if (util.isNonEmptyString(chartConfiguration.hover.mode) && _.contains(["x", "y", "closest"], chartConfiguration.hover.mode) || util.isBoolean(chartConfiguration.hover.mode) && chartConfiguration.hover.mode === false) {
						_.extend(layout, { hovermode: chartConfiguration.hover.mode });
					}
				}

				if (util.isRealObject(chartConfiguration.legend)) {
					if (util.isBoolean(chartConfiguration.legend.showLegend)) {
						_.extend(layout, { showlegend: chartConfiguration.legend.showLegend });
					}

					legend = mapLegend(chartConfiguration.legend);
				}

				if (util.isRealObject(chartConfiguration.xAxis)) {
					xAxis = mapAxis(chartConfiguration.xAxis);
				}

				if (util.isRealObject(chartConfiguration.yAxis)) {
					yAxis = mapAxis(chartConfiguration.yAxis);
				}

				if (util.isRealObject(title)) _.extend(layout, title);

				if (util.isRealObject(size)) _.extend(layout, size);

				if (util.isRealObject(margin)) _.extend(layout, { margin: margin });

				if (util.isRealObject(xAxis)) _.extend(layout, { xaxis: xAxis });

				if (util.isRealObject(yAxis)) _.extend(layout, { yaxis: yAxis });

				if (util.isRealObject(legend)) _.extend(layout, { legend: legend });

				return layout;
			}

			function mapLegend(chartConfigurationParent) {
				var result = {};
				if (util.isNonEmptyString(chartConfigurationParent.orientation)) {
					_.extend(result, { orientation: chartConfigurationParent.orientation });
				}

				if (util.isNonEmptyString(chartConfigurationParent.traceOrder) && (_.contains(["reversed", "grouped", "normal"], chartConfigurationParent.traceOrder) || chartConfigurationParent.traceOrder.match("/^\\b(?:reversed|grouped)\\b(\\+\\b(?:reversed|grouped)\\b)*$/"))) {
					_.extend(result, { traceorder: chartConfigurationParent.traceOrder });
				}

				var font = chartFontMapper.map(chartConfigurationParent);
				if (util.isRealObject(font)) _.extend(result, { font: font });

				return result;
			}

			function mapDimensionConfiguration(chartConfigurationParent) {
				var result = {};
				if (util.isNumber(chartConfigurationParent.height)) {
					_.extend(result, { height: chartConfigurationParent.height });
				}

				if (util.isNumber(chartConfigurationParent.width)) {
					_.extend(result, { width: chartConfigurationParent.width });
				}
				return result;
			}

			function mapMarginConfiguration(chartConfigurationParent) {
				var result = {};
				if (util.isRealObject(chartConfigurationParent.margin)) {
					if (util.isNumber(chartConfigurationParent.margin.top)) {
						_.extend(result, { t: chartConfigurationParent.margin.top });
					}

					if (util.isNumber(chartConfigurationParent.margin.bottom)) {
						_.extend(result, { b: chartConfigurationParent.margin.bottom });
					}

					if (util.isNumber(chartConfigurationParent.margin.right)) {
						_.extend(result, { r: chartConfigurationParent.margin.right });
					}

					if (util.isNumber(chartConfigurationParent.margin.left)) {
						_.extend(result, { l: chartConfigurationParent.margin.left });
					}
				}

				if (util.isNumber(chartConfigurationParent.padding)) {
					_.extend(result, { pad: chartConfigurationParent.padding });
				}
				return result;
			}

			function mapRangeConfiguration(chartConfigurationParent) {
				var result = {};
				if (util.isBoolean(chartConfigurationParent.autoRange) && chartConfigurationParent.autoRange) {
					_.extend(result, { autorange: chartConfigurationParent.autoRange });
				}

				if (util.isBoolean(chartConfigurationParent.fixedRange)) {
					_.extend(result, { fixedrange: chartConfigurationParent.fixedRange });
				}
				return result;
			}

			function mapTicksConfiguration(chartConfigurationParent) {
				var result = {};
				if (util.isRealObject(chartConfigurationParent.ticks)) {
					if (util.isBoolean(chartConfigurationParent.ticks.showLabels)) {
						_.extend(result, { showticklabels: chartConfigurationParent.ticks.showLabels });
					}

					if (util.isNonEmptyString(chartConfigurationParent.ticks.mode) && _.contains(["auto", "linear", "array"], chartConfigurationParent.ticks.mode)) {
						_.extend(result, { tickmode: chartConfigurationParent.ticks.mode });
					}

					if (util.isNumber(chartConfigurationParent.ticks.numberOfTicks)) {
						_.extend(result, { nticks: chartConfigurationParent.ticks.numberOfTicks });
					}

					if (util.isNumber(chartConfigurationParent.ticks.startPosition)) {
						_.extend(result, { tick0: chartConfigurationParent.ticks.startPosition });
					}

					if (util.isNumber(chartConfigurationParent.ticks.step)) {
						_.extend(result, { dtick: chartConfigurationParent.ticks.step });
					}

					if (util.isArray(chartConfigurationParent.ticks.atValues)) {
						_.extend(result, { tickvals: chartConfigurationParent.ticks.atValues });

						if (util.isArray(chartConfigurationParent.ticks.textAtValues) && chartConfigurationParent.ticks.atValues.length === chartConfigurationParent.ticks.textAtValues.length) {
							_.extend(result, { ticktext: chartConfigurationParent.ticks.textAtValues });
						}
					}

					if (util.isRealObject(chartConfigurationParent.ticks.font)) {
						var font = chartFontMapper.map(chartConfigurationParent.ticks);
						if (util.isRealObject(font)) _.extend(result, { tickfont: font });
					}
				}
				return result;
			}

			function mapAxis(axisConfigurationObject) {
				var result = {};
				var title = chartTitleMapper.map(axisConfigurationObject);
				if (util.isRealObject(title)) _.extend(result, title);

				var range = mapRangeConfiguration(axisConfigurationObject);
				if (util.isRealObject(range)) _.extend(result, range);

				var ticks = mapTicksConfiguration(axisConfigurationObject);
				if (util.isRealObject(ticks)) _.extend(result, ticks);

				return result;
			}
		}

		return chartLayoutMapper;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 565 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF0H}
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;
		var guard = $di.exception.guard;

		module.controller('ChartSummaryController', ChartSummaryController);

		ChartSummaryController.$inject = ['$scope', 'summaryProxy', 'modalSpinner', 'chartConfigurationMapper', 'diState'];

		function ChartSummaryController(scope, summaryProxy, modalSpinner, chartConfigurationMapper, diState) {
			var vm = this;

			var spinner;

			vm.util = util;
			vm.chartConfiguration = {
				data: [],
				layout: {},
				config: {}
			};
			vm.noData = false;
			vm.loadData = loadData;
			vm.buttonValueChanged = buttonValueChanged;
			vm.clickTitle = clickTitle;

			initialise();

			return;

			function initialise() {
				guard.throwIfNotAnObject("DEF0H01E", scope.summaryConfiguration, "summaryConfiguration");
			}

			/**
             * Function which calls the proxy to load the data for the summary, first showing the spinner
             */
			function loadData() {
				vm.dataLoadFailed = undefined;

				var params = _.extend({}, scope.summaryConfiguration.summaryParameters);

				if (util.isString(scope.summaryConfiguration.rangeParameter)) {
					if (util.isDefined(vm[scope.summaryConfiguration.rangeParameter])) {
						params[scope.summaryConfiguration.rangeParameter] = vm[scope.summaryConfiguration.rangeParameter];
					} else {
						//If the range parameter is configured and not yet defined then do not load at this time
						return;
					}
				}

				if (util.isDefined(spinner) === false && util.isFunction(scope.getSpinnerElement)) {
					spinner = modalSpinner.showModalSpinner(scope.getSpinnerElement(), { position: 'absolute' });
				}

				summaryProxy.getSummaryData(scope.summaryConfiguration.summaryType, params).then(summaryDataReceived, summaryDataFailed);
			}

			/**
    * Function which processes the data received from the proxy and fills the summary data array with it
    * @param data - The data received from the proxy
    */
			function summaryDataReceived(data) {
				if (util.isArray(data) && (data.length === 0 || _.every(data, function (tableRow) {
					return (tableRow.totalAmount || tableRow.totalIncludingTax) === 0;
				}))) {
					vm.noData = true;
				} else {
					extendScopeSummaryConfiguration();
					var config = chartConfigurationMapper.getChartConfiguration(data, scope.summaryConfiguration.chart, scope.summaryConfiguration.documentType);
					updateChartConfiguration(config);
					vm.noData = false;
				}
				removeSpinnerIfRequired();
			}

			/**
    * Function which creates a notification message when the summary data fails to load
    */
			function summaryDataFailed() {
				removeSpinnerIfRequired();
				vm.dataLoadFailed = true;
			}

			/**
    * Function which removes the spinner if it is currently shown and sets the variable to undefined
    */
			function removeSpinnerIfRequired() {
				if (util.isObject(spinner) && util.isFunction(spinner.remove)) {
					spinner.remove();
					spinner = undefined;
				}
			}

			/**
    * Function which handles new values being selected in the range selector control
    * 
    * @param buttonValue - The value of the selected option
    */
			function buttonValueChanged(buttonValue) {
				vm[scope.summaryConfiguration.rangeParameter] = buttonValue;
				vm.loadData();
			}

			/**
    * Update the vm.chartConfiguration object with the values from the input param
    * @param {} config 
    * @returns {} 
    */
			function updateChartConfiguration(config) {
				vm.chartConfiguration.data.fill(config.data);
				vm.chartConfiguration.layout = config.layout;
				vm.chartConfiguration.config = config.config;
			}

			/**
    * Sets the yAxis title text to the value of the range param
    * @returns {} 
    */
			function extendScopeSummaryConfiguration() {
				var yAxisWithTitle = { yAxis: { title: { text: vm[scope.summaryConfiguration.rangeParameter] } } };

				if (util.isRealObject(scope.summaryConfiguration.chart)) {
					if (util.isRealObject(scope.summaryConfiguration.chart.yAxis)) {
						if (util.isRealObject(scope.summaryConfiguration.chart.yAxis.title)) {
							_.extend(scope.summaryConfiguration.chart.yAxis.title, yAxisWithTitle.yAxis.title);
						}
					}
				}
			}

			/**
    * Navigate to the target state on title click
    * @returns {} 
    */
			function clickTitle() {
				if (scope.summaryConfiguration.rangeParameter) {
					var range = vm[scope.summaryConfiguration.rangeParameter];
					var result = scope.summaryConfiguration.titleConfiguration.paramsCreator(range);
					diState.go(scope.summaryConfiguration.titleConfiguration.target, result);
				} else {
					diState.go(scope.summaryConfiguration.titleConfiguration.target);
				}
			}
		}

		return ChartSummaryController;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 566 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF0I}
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {

		module.directive('chartSummary', chartSummary);

		function chartSummary() {
			return {
				restrict: 'E',
				templateUrl: 'src/app/portal/summaries/_components/chartSummary/chartSummary.html',
				controller: 'ChartSummaryController',
				controllerAs: 'chartSummaryCtrl',
				scope: {
					summaryConfiguration: '='
				},
				link: link,
				replace: false
			};

			function link(scope, element, attributes, controller) {
				scope.getSpinnerElement = function () {
					return element.find('.spinner');
				};

				controller.loadData();
			}
		}

		return chartSummary;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 567 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF0R}
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.factory('chartTitleMapper', chartTitleMapper);

		chartTitleMapper.$inject = ['translator', 'chartFontMapper'];

		function chartTitleMapper(translator, chartFontMapper) {
			return {
				map: mapTitle
			};

			function mapTitle(chartConfiguration) {
				var result = {};
				if (util.isRealObject(chartConfiguration.title)) {
					if (util.isNonEmptyString(chartConfiguration.title.languageKey)) {
						translator.translate(chartConfiguration.title.languageKey).then(function (translated) {
							_.extend(result, { title: translated });
						});
					} else if (!util.isNullOrUndefined(chartConfiguration.title.text)) {
						_.extend(result, { title: chartConfiguration.title.text });
					}

					var titleFont = chartFontMapper.map(chartConfiguration.title);
					if (util.isRealObject(titleFont)) _.extend(result, { titlefont: titleFont });
				}
				return result;
			}
		}

		return chartTitleMapper;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 568 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP60}
// di.einvoicing.ui.portal.portal.summaries.components.rangeSelector
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(569), __webpack_require__(570), __webpack_require__(571)], __WEBPACK_AMD_DEFINE_RESULT__ = function (rangeSelectorControllerLoader, rangeSelectorDirectiveLoader, summaryOptionsStoreLoader) {
	'use strict';

	return function (module) {
		rangeSelectorControllerLoader(module);
		rangeSelectorDirectiveLoader(module);
		summaryOptionsStoreLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 569 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP64}
// di.einvoicing.ui.portal.portal.summaries.components.rangeSelector
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.controller('RangeSelectorController', RangeSelectorController);

		RangeSelectorController.$inject = ['$scope', 'summaryOptionsStore'];

		function RangeSelectorController(scope, summaryOptionsStore) {
			var vm = this;

			vm.buttonClicked = buttonClicked;

			loadInitialValue();

			return;

			/**
    * Function which attempts to load an inital value for the selected button firstly based
    * on any values stored in the local storage or secondly via the default item option 
    * provided to the directive
    */
			function loadInitialValue() {
				var storageItem = summaryOptionsStore.getSummaryOptions(scope.summaryType);

				if (util.isDefined(storageItem)) {
					buttonClicked(storageItem);
				} else {
					var defaultItem = _.find(scope.buttonConfiguration, function (item) {
						return item.isDefault === true;
					});

					if (util.isObject(defaultItem)) {
						buttonClicked(defaultItem.value);
					}
				}
			}

			/**
    * Function called when a button is clicked, updates the bound object with the new value
    * @param option - The selected option
    */
			function buttonClicked(option) {
				vm.selectedItem = option;
				summaryOptionsStore.setSummaryOptions(scope.summaryType, option);
				scope.onChangeAccessor(option);
			}
		}

		return RangeSelectorController;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 570 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP63}
// di.einvoicing.ui.portal.portal.summaries.components.rangeSelector
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.directive('diRangeSelector', diRangeSelector);

		function diRangeSelector() {
			return {
				restrict: 'E',
				scope: {
					buttonConfiguration: '=',
					summaryType: '=',
					onChangeAccessor: '='
				},
				controller: 'RangeSelectorController',
				controllerAs: 'rangeSelectorCtrl',
				templateUrl: 'src/app/portal/summaries/_components/rangeSelector/rangeSelector.html'
			};
		}

		return diRangeSelector;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 571 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP82}
// di.einvoicing.ui.portal.portal.summaries.components.rangeSelector
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.factory('summaryOptionsStore', summaryOptionsStore);

		summaryOptionsStore.$inject = ['sessionStore'];

		/**
   * Repository for storing options relating to summaries
   */
		function summaryOptionsStore(sessionStore) {
			var storagePrefix = 'summaryOptionsStore';
			var storageKey = 'summaryPreferences';

			var service = {
				setSummaryOptions: setSummaryOptions,
				getSummaryOptions: getSummaryOptions,
				clear: clear
			};

			return service;

			/**
    * Function which sets the summary options for the specific summary in local storage
    * 
    * @param summaryType - The summary type to update the summary configuration for
    * @param summaryOptions - The options for the summary 
    */
			function setSummaryOptions(summaryType, summaryOptions) {
				var summaryPreferences = sessionStore.get(storageKey, storagePrefix);
				var newPreference = {};
				newPreference[summaryType] = summaryOptions;
				var preferences = _.extend({}, summaryPreferences, newPreference);
				sessionStore.set(storageKey, preferences, storagePrefix);
			}

			/**
    * Function which gets the preferences for a specific summary type
    * 
    * @param summaryType - The type of summary to get the options for
    * @returns - The object representing the options for the specified summary type
    * or undefined if preferences for the specific summary cannot be found
    */
			function getSummaryOptions(summaryType) {
				var summaryPreferences = sessionStore.get(storageKey, storagePrefix);

				if (util.isObject(summaryPreferences)) {
					return summaryPreferences[summaryType];
				}

				return undefined;
			}

			/**
    * Function which removes the users preferences from session storage, currently connected to the logout event handler
    */
			function clear() {
				sessionStore.remove(storageKey, storagePrefix);
			}
		}

		return summaryOptionsStore;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 572 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP7Y}
// di.einvoicing.ui.portal.portal.summaries.components.singleValueSummary
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(573), __webpack_require__(574)], __WEBPACK_AMD_DEFINE_RESULT__ = function (singleValueSummaryControllerLoader, singleValueSummaryDirectiveLoader) {
	'use strict';

	return function (module) {
		singleValueSummaryControllerLoader(module);
		singleValueSummaryDirectiveLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 573 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP80}
// di.einvoicing.ui.portal.portal.summaries.components.singleValueSummary
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;
		var guard = $di.exception.guard;

		module.controller('SingleValueSummaryController', SingleValueSummaryController);

		SingleValueSummaryController.$inject = ['$scope', 'diState', 'clickThroughDataMapper', 'summaryProxy', 'translator', 'modalSpinner'];

		function SingleValueSummaryController(scope, diState, clickThroughDataMapper, summaryProxy, translator, modalSpinner) {
			var vm = this;

			var spinner;

			vm.util = util;
			vm.summaryData = [];
			vm.loadData = loadData;
			vm.clickThrough = clickThrough;
			vm.loadValueClasses = loadValueClasses;
			vm.getClickableSummary = getClickableSummary;

			intialise();

			return;

			function intialise() {
				guard.throwIfNotAnObject("EUP6401E", scope.summaryConfiguration, "summaryConfiguration");
			}

			/**
    * Function which calls the proxy to load the data for the summary, first showing the spinner
    */
			function loadData() {
				vm.dataLoadFailed = undefined;

				if (util.isDefined(spinner) === false && util.isFunction(scope.getSpinnerElement)) {
					spinner = modalSpinner.showModalSpinner(scope.getSpinnerElement(), { position: 'absolute' });
				}

				var params = _.extend({}, scope.summaryConfiguration.summaryParameters);

				summaryProxy.getSummaryData(scope.summaryConfiguration.summaryType, params).then(summaryDataReceived, summaryDataFailed);
			}

			/**
    * Function which processes the data received from the proxy and fills the summary data array with it
    * @param data - The data received from the proxy
    */
			function summaryDataReceived(data) {
				if (util.isArray(data) === true) {
					vm.dataItem = data[0];
				} else {
					vm.dataItem = data;
				}

				removeSpinnerIfRequired();
			}

			/**
    * Function which creates a notification message when the summary data fails to load
    */
			function summaryDataFailed() {
				removeSpinnerIfRequired();
				vm.dataLoadFailed = true;
			}

			/**
    * Function which removes the spinner if it is currently shown and sets the variable to undefined
    */
			function removeSpinnerIfRequired() {
				if (util.isObject(spinner) && util.isFunction(spinner.remove)) {
					spinner.remove();
					spinner = undefined;
				}
			}

			/**
    * Function which intiates the transition to the linked state
    */
			function clickThrough() {
				if (util.isObject(vm.dataItem) && util.isNonEmptyString(vm.dataItem.clickThroughState)) {
					diState.go(vm.dataItem.clickThroughState, clickThroughDataMapper.map(vm.dataItem));
				}
			}

			/**
    * Function which determines whether the summary is clickable 
    * based on the information returned with the summary data
    * @returns true/false if it can be determined, undefined otherwise 
    */
			function getClickableSummary() {
				if (util.isObject(vm.dataItem)) {
					return util.isNonEmptyString(vm.dataItem.clickThroughState);
				}
				return undefined;
			}

			/**
    * Function which determines if any additional classes should be added to the summary value
    * based on a function provided as part of the summary configuration
    * 
    * @returns - empty array if no value classes function provided
    * undefined if the value is not yet loaded and therefore the value class function cannot provide a value
    * the return from the valueDisplayClasses function provided when the value is loaded
    */
			function loadValueClasses() {
				if (util.isFunction(scope.summaryConfiguration.valueDisplayClasses)) {
					if (util.isObject(vm.dataItem)) {
						return scope.summaryConfiguration.valueDisplayClasses(vm.dataItem.itemCount);
					}
				} else {
					return [];
				}
				return undefined;
			}
		}

		return SingleValueSummaryController;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 574 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP7Z}
// di.einvoicing.ui.portal.portal.summaries.components.singleValueSummary
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ng) {
	'use strict';

	return function (module) {
		module.directive('diSingleValueSummary', diSingleValueSummary);

		function diSingleValueSummary() {
			return {
				restrict: 'E',
				scope: {
					summaryConfiguration: '='
				},
				controller: 'SingleValueSummaryController',
				controllerAs: 'singleValueSummaryCtrl',
				templateUrl: 'src/app/portal/summaries/_components/singleValueSummary/singleValueSummary.html',
				link: link
			};

			function link(scope, element, attributes, controller) {
				scope.getSpinnerElement = getSpinnerElement;

				controller.loadData();

				function getSpinnerElement() {
					return ng.element(element).find('.spinner');
				}
			}
		}

		return diSingleValueSummary;
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 575 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP7V}
// di.einvoicing.ui.portal.portal.summaries.components
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {

		module.controller('SummarySelectorController', SummarySelectorController);

		SummarySelectorController.$inject = ['userRightsRepository', 'USER_RIGHTS'];

		function SummarySelectorController(rightsRepository, userRights) {
			var vm = this;

			initialise();

			return;

			/**
    * Initialises the controller with the values for which summary to display
    */
			function initialise() {
				vm.displayBuyerSummary = rightsRepository.userHasRight(userRights.Buyer);
				vm.displaySupplierSummary = rightsRepository.userHasRight(userRights.Supplier);
			}
		}

		return SummarySelectorController;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 576 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP7W}
// di.einvoicing.ui.portal.summaries.components
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.constant('SUMMARY_TYPES', summaryTypes());

        function summaryTypes() {
            return {
                unknown: 'Unknown',
                countOrdersRejected: 'CountOrdersRejected',
                countOrdersToAccept: 'CountOrdersSentReceived',
                countOrdersToInvoice: 'CountOrdersToInvoice',
                countInvoicesUnpaid: 'CountInvoicesUnpaid',
                countInvoicesMismatched: 'CountInvoicesMismatched',
                countInvoicesOverdue: 'CountInvoicesOverdue',
                countInvoicesInDispute: 'CountInvoicesInDispute',
                listInvoicesOverdue: 'ListInvoicesOverdue',
                listOrdersLatestReceived: 'ListOrdersLatestReceived',
                listOrdersHighestValue: 'ListOrdersHighestValue',
                listPartiesInvoiceValue: 'ListPartiesInvoiceValue',
                listInvoicesToPayGroupedByStatus: 'ListInvoicesToPayGroupedByStatus',
                listOrdersValueGroupedByStatus: 'ListOrdersValueGroupedByStatus'
            };
        }
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 577 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP7T}
// di.einvoicing.ui.portal.portal.summaries.components.tabularSummary
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(578), __webpack_require__(579)], __WEBPACK_AMD_DEFINE_RESULT__ = function (tabularSummaryControllerLoader, tabularSummaryDirectiveLoader) {
	'use strict';

	return function (module) {
		tabularSummaryControllerLoader(module);
		tabularSummaryDirectiveLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 578 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP64}
// di.einvoicing.ui.portal.portal.summaries.components.tabularSummary
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;
		var guard = $di.exception.guard;

		module.controller('TabularSummaryController', TabularSummaryController);

		TabularSummaryController.$inject = ['$scope', 'diState', 'clickThroughDataMapper', 'summaryProxy', 'translator', 'modalSpinner'];

		function TabularSummaryController(scope, diState, clickThroughDataMapper, summaryProxy, translator, modalSpinner) {
			var vm = this;

			var spinner;

			vm.rowClicked = rowClicked;
			vm.util = util;
			vm.summaryData = [];
			vm.tableConfiguration = {};
			vm.loadData = loadData;
			vm.buttonValueChanged = buttonValueChanged;
			vm.clickTitle = clickTitle;

			intialise();

			return;

			function intialise() {
				guard.throwIfNotAnObject("EUP6401E", scope.summaryConfiguration, "summaryConfiguration");
				vm.tableConfiguration.data = [];
				vm.tableConfiguration.columns = scope.summaryConfiguration.tableColumns;
				vm.tableConfiguration.enablePaging = true;
				vm.tableConfiguration.maxButtonsShown = 2;
				vm.tableConfiguration.paginationPageSize = 10;
			}

			/**
    * Function which calls the proxy to load the data for the summary, first showing the spinner
    */
			function loadData() {
				vm.dataLoadFailed = undefined;

				var params = _.extend({}, scope.summaryConfiguration.summaryParameters);

				if (util.isString(scope.summaryConfiguration.rangeParameter)) {
					if (util.isDefined(vm[scope.summaryConfiguration.rangeParameter])) {
						params[scope.summaryConfiguration.rangeParameter] = vm[scope.summaryConfiguration.rangeParameter];
					} else {
						//If the range parameter is configured and not yet defined then do not load at this time
						return;
					}
				}

				if (util.isDefined(spinner) === false && util.isFunction(scope.getSpinnerElement)) {
					spinner = modalSpinner.showModalSpinner(scope.getSpinnerElement(), { position: 'absolute' });
				}

				summaryProxy.getSummaryData(scope.summaryConfiguration.summaryType, params).then(summaryDataReceived, summaryDataFailed);
			}

			/**
    * Function which changes the state to the clickThroughState provided to the function
    * @param row - The item to process 
    */
			function rowClicked(row) {
				if (util.isNonEmptyString(row.clickThroughState)) {
					diState.go(row.clickThroughState, clickThroughDataMapper.map(row));
				}
			}

			/**
    * Function which processes the data received from the proxy and fills the summary data array with it
    * @param data - The data received from the proxy
    */
			function summaryDataReceived(data) {
				removeSpinnerIfRequired();
				vm.summaryData.fill(data);
			}

			/**
    * Function which creates a notification message when the summary data fails to load
    */
			function summaryDataFailed() {
				removeSpinnerIfRequired();
				vm.dataLoadFailed = true;
			}

			function removeSpinnerIfRequired() {
				if (util.isObject(spinner) && util.isFunction(spinner.remove)) {
					spinner.remove();
					spinner = undefined;
				}
			}

			/**
    * Function which handles new values being selected in the range selector control
    * 
    * @param buttonValue - The value of the selected option
    */
			function buttonValueChanged(buttonValue) {
				vm[scope.summaryConfiguration.rangeParameter] = buttonValue;
				loadData();
			}

			/**
         * Function handle summary title clicks to optionaly set custom date ranges
         */
			function clickTitle() {

				if (scope.summaryConfiguration.rangeParameter) {
					var range = vm[scope.summaryConfiguration.rangeParameter];
					var result = scope.summaryConfiguration.titleConfiguration.paramsCreator(range);

					diState.go(scope.summaryConfiguration.titleConfiguration.target, result);
				} else {
					diState.go(scope.summaryConfiguration.titleConfiguration.target);
				}
			}
		}

		return TabularSummaryController;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 579 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP63}
// di.einvoicing.ui.portal.portal.summaries.components.tabularSummary
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ng) {
	'use strict';

	return function (module) {
		module.directive('diTabularSummary', diTabularSummary);

		function diTabularSummary() {
			return {
				restrict: 'E',
				scope: {
					summaryConfiguration: '='
				},
				controller: 'TabularSummaryController',
				controllerAs: 'tabularSummaryCtrl',
				templateUrl: 'src/app/portal/summaries/_components/tabularSummary/tabularSummary.html',
				link: link
			};

			function link(scope, element, attributes, controller) {
				scope.getSpinnerElement = getSpinnerElement;

				controller.loadData();

				function getSpinnerElement() {
					return ng.element(element).find('.spinner');
				}
			}
		}

		return diTabularSummary;
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 580 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(557), __webpack_require__(581), __webpack_require__(586), __webpack_require__(584), __webpack_require__(585)], __WEBPACK_AMD_DEFINE_RESULT__ = function (componentsLoader, buyerSummaryLoader, supplierSummaryLoader, clickThroughDataMapper, summaryProxyLoader) {
	'use strict';

	return function (module) {
		summaryProxyLoader(module);
		componentsLoader(module);
		buyerSummaryLoader(module);
		supplierSummaryLoader(module);
		clickThroughDataMapper(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 581 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP81}
// di.einvoicing.ui.portal.portal.summaries.buyerSummary
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(583), __webpack_require__(582)], __WEBPACK_AMD_DEFINE_RESULT__ = function (buyerSummaryDirectiveLoader, buyerSummaryControllerLoader) {
	'use strict';

	return function (module) {
		buyerSummaryDirectiveLoader(module);
		buyerSummaryControllerLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 582 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP7V}
// di.einvoicing.ui.portal.portal.summaries.components
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5)], __WEBPACK_AMD_DEFINE_RESULT__ = function (moment) {
	'use strict';

	return function (module) {

		module.controller('BuyerSummaryController', BuyerSummaryController);

		BuyerSummaryController.$inject = ['SUMMARY_TYPES', 'CLIENT_ENUMS'];

		function BuyerSummaryController(summaryTypes, clientEnums) {
			var vm = this;

			vm.countOrdersRejectedConfiguration = {
				titleConfiguration: 'EINVOICING.PORTAL.SUMMARIES.BUYER.COUNT_ORDERS_REJECTED.TITLE',
				summaryType: summaryTypes.countOrdersRejected
			};

			vm.countInvoicesMismatchedConfiguration = {
				titleConfiguration: 'EINVOICING.PORTAL.SUMMARIES.BUYER.COUNT_INVOICES_MISMATCHED.TITLE',
				summaryType: summaryTypes.countInvoicesMismatched,
				valueDisplayClasses: function valueDisplayClasses(itemCount) {
					if (itemCount > 100) {
						return ['red-font'];
					} else if (itemCount > 2) {
						return ['orange-font'];
					} else {
						return [];
					}
				}
			};

			vm.countInvoicesOverdueConfiguration = {
				titleConfiguration: 'EINVOICING.PORTAL.SUMMARIES.BUYER.COUNT_INVOICES_OVERDUE.TITLE',
				summaryType: summaryTypes.countInvoicesOverdue,
				valueDisplayClasses: function valueDisplayClasses(itemCount) {
					if (itemCount > 100) {
						return ['red-font'];
					} else if (itemCount > 2) {
						return ['orange-font'];
					} else {
						return [];
					}
				}
			};

			vm.countInvoicesDisputedConfiguration = {
				titleConfiguration: 'EINVOICING.PORTAL.SUMMARIES.BUYER.COUNT_INVOICES_DISPUTED.TITLE',
				summaryType: summaryTypes.countInvoicesInDispute,
				valueDisplayClasses: function valueDisplayClasses(itemCount) {
					if (itemCount > 100) {
						return ['red-font'];
					} else if (itemCount > 2) {
						return ['orange-font'];
					} else {
						return [];
					}
				}
			};

			vm.listInvoicesOverdueConfiguration = {
				summaryType: summaryTypes.listInvoicesOverdue,
				rangeParameter: 'sortOption',
				titleConfiguration: {
					languageKey: 'EINVOICING.PORTAL.SUMMARIES.BUYER.LIST_OVERDUE_INVOICES.TITLE',
					target: 'portal.invoices.list',
					paramsCreator: function paramsCreator(range) {
						return {
							dateTimeFilter: 'Custom',
							fromDate: moment().utc().subtract(range, 'days').format(),
							toDate: moment().utc().format(),
							statusFilter: 13
						};
					}
				},
				tableColumns: [{
					nameLanguageKey: 'EINVOICING.PORTAL.SUMMARIES.BUYER.LIST_OVERDUE_INVOICES.COLUMNS.SUPPLIER',
					template: '<div class="tooltip-wrap">\
									<span class="text-ellipsis">{{binding.partyName}}</span>\
									<div ng-if="(binding.partyName || \'\').length >= 35"\
										ng-class="((binding.partyName || \'\').length > 70) ? [\'tooltip\', \'tooltip-multiline\'] : \'tooltip\'">\
										<span>\
											{{ ::binding.partyName }}\
										</span>\
									</div>\
								</div>',
					cellClass: 'max-width-300'
				}, {
					nameLanguageKey: 'EINVOICING.PORTAL.SUMMARIES.BUYER.LIST_OVERDUE_INVOICES.COLUMNS.DUE_DATE',
					template: '<span>{{binding.paymentDueDate | diDate}}</span>'
				}, {
					nameLanguageKey: 'EINVOICING.PORTAL.SUMMARIES.BUYER.LIST_OVERDUE_INVOICES.COLUMNS.INVOICE_VALUE',
					cellClass: 'numericcell',
					template: '<span>{{binding.total | diCurrency:binding.currencyId}}</span>'
				}],
				rangeOptions: [{
					languageKey: 'EINVOICING.PORTAL.SUMMARIES.BUYER.LIST_OVERDUE_INVOICES.OPTIONS.DUE',
					isDefault: true,
					value: 2
				}, {
					languageKey: 'EINVOICING.PORTAL.SUMMARIES.BUYER.LIST_OVERDUE_INVOICES.OPTIONS.VALUE',
					value: 1
				}]
			};

			vm.listSuppliersInvoiceValueConfiguration = {
				summaryType: summaryTypes.listPartiesInvoiceValue,
				titleConfiguration: 'EINVOICING.PORTAL.SUMMARIES.BUYER.LIST_PARTIES_VALUE.TITLE',
				tableColumns: [{
					nameLanguageKey: 'EINVOICING.PORTAL.SUMMARIES.BUYER.LIST_PARTIES_VALUE.COLUMNS.SUPPLIER',
					template: '<span>{{binding.supplier}}</span>'
				}, {
					nameLanguageKey: 'EINVOICING.PORTAL.SUMMARIES.BUYER.LIST_PARTIES_VALUE.COLUMNS.INVOICE_TOTAL',
					cellClass: 'numericcell',
					template: '<span>{{binding.value | diCurrency:binding.currencyId}}</span>'
				}]
			};

			vm.chartSummaryConfiguration = {
				summaryType: summaryTypes.listInvoicesToPayGroupedByStatus,
				rangeParameter: 'days',
				titleConfiguration: {
					target: 'portal.invoices.list',
					paramsCreator: function paramsCreator(range) {
						return {
							dateType: 1, //created date
							sortOption: 4, //created date desc
							dateTimeFilter: 'Custom',
							fromDate: moment().utc().subtract(range, 'days').format(),
							toDate: moment().utc().format()
						};
					},
					languageKey: 'EINVOICING.PORTAL.SUMMARIES.BUYER.LIST_INVOICES_CHART.TITLE'
				},
				rangeOptions: [{
					languageKey: 'EINVOICING.PORTAL.SUMMARIES.BUYER.LIST_INVOICES_CHART.RANGE.30_DAYS',
					isDefault: true,
					value: 30
				}, {
					languageKey: 'EINVOICING.PORTAL.SUMMARIES.BUYER.LIST_INVOICES_CHART.RANGE.60_DAYS',
					value: 60
				}, {
					languageKey: 'EINVOICING.PORTAL.SUMMARIES.BUYER.LIST_INVOICES_CHART.RANGE.90_DAYS',
					value: 90
				}],
				documentType: clientEnums.documentType.invoice,
				chart: {
					type: 'bar',
					orientation: 'h',
					barmode: 'stack',
					displayModeBar: false,
					doubleClick: false,
					scrollZoom: false,
					editable: false,
					barWatermark: {
						value: 'none',
						font: {
							family: "'Lato', Arial, sans-serif",
							size: 14,
							color: '#e6e7ea'
						}
					},
					margin: {
						bottom: 0,
						top: 0,
						left: 30,
						right: 0
					},
					hover: {
						info: 'text',
						mode: 'closest'
					},
					legend: {
						showLegend: true,
						orientation: "h",
						font: {
							family: "'Lato', Arial, sans-serif",
							size: 14
						},
						traceOrder: "normal"
					},
					yAxis: {
						autoRange: false,
						fixedRange: true,
						ticks: {
							showLabels: false
						}
					},
					xAxis: {
						fixedRange: true,
						ticks: {
							font: {
								family: "'Lato', Arial, sans-serif",
								size: 14
							}
						}
					}
				}
			};

			return;
		}

		return BuyerSummaryController;
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 583 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP7Z}
// di.einvoicing.ui.portal.portal.summaries.components.singleValueSummary
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.directive('diBuyerSummary', diBuyerSummary);

		function diBuyerSummary() {
			return {
				restrict: 'E',
				controller: 'BuyerSummaryController',
				controllerAs: 'buyerSummaryCtrl',
				templateUrl: 'src/app/portal/summaries/buyerSummary/buyerSummary.html'
			};
		}

		return diBuyerSummary;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 584 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP69}
// di.einvoicing.ui.portal.summaries
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;
		var guard = $di.exception.guard;

		module.factory('clickThroughDataMapper', clickThroughDataMapper);

		function clickThroughDataMapper() {
			return {
				map: map
			};

			/**
    * Function which maps the values of the provided object to a new object
    * based on the settings object provided 
    * 
    * @param item - The item to retrive the values from
    * @param dataSettings - An optional object which provides the mappings
    * as comma separated key value pairs separated by semicolons.  
    * If not provided then a property called clickThroughData of item is used.
    * @returns - The mapped object 
    */
			function map(item, dataSettings) {
				guard.throwIfNotAnObject('EUP6901E', item, 'item');

				if (util.isUndefined(dataSettings)) {
					dataSettings = item.clickThroughData;
				}

				guard.throwIfNullOrUndefined('EUP6901E', dataSettings, 'dataSettings');

				var paramsObject = {};

				var keyValuePairs = dataSettings.split(';');

				_.each(keyValuePairs, function (itemMapping) {
					itemMapping = itemMapping.split(',');

					paramsObject[itemMapping[0]] = item[itemMapping[1]];
				});

				return paramsObject;
			}
		}

		return clickThroughDataMapper;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 585 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP65}
// di.einvoicing.ui.portal.proxies
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var guard = $di.exception.guard;

		module.factory('summaryProxy', summaryProxy);

		summaryProxy.$inject = ['webApiHttp', 'urlHelper'];

		function summaryProxy(http, urlHelper) {
			return {
				getSummaryData: getSummaryData
			};

			/**
    * Method which gets the data for a summary with the specified ID
    * 
    * @param summaryId - the ID of the summary to get the report data for
    * @returns - promise which resolves to the summary data 
    */
			function getSummaryData(summaryType, summaryParameters) {
				guard.throwIfEmptyString("EUP6501E", summaryType, "summaryType");

				var requestParams = {
					summaryType: summaryType
				};

				var requestUrl = urlHelper.setParameters('Summary/GetSummaryData', requestParams);

				var promise = http.post(requestUrl, summaryParameters);

				return promise;
			}
		}

		return summaryProxy;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 586 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP81}
// di.einvoicing.ui.portal.portal.summaries.buyerSummary
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(588), __webpack_require__(587)], __WEBPACK_AMD_DEFINE_RESULT__ = function (supplierSummaryDirectiveLoader, supplierSummaryControllerLoader) {
	'use strict';

	return function (module) {
		supplierSummaryDirectiveLoader(module);
		supplierSummaryControllerLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 587 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP7V}
// di.einvoicing.ui.portal.portal.summaries.components
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5)], __WEBPACK_AMD_DEFINE_RESULT__ = function (moment) {
	'use strict';

	return function (module) {

		module.controller('SupplierSummaryController', SupplierSummaryController);

		SupplierSummaryController.$inject = ['SUMMARY_TYPES', 'CLIENT_ENUMS'];

		function SupplierSummaryController(summaryTypes, clientEnums) {
			var vm = this;

			vm.countOrdersToAcceptConfiguration = {
				titleConfiguration: 'EINVOICING.PORTAL.SUMMARIES.SUPPLIER.COUNT_ORDERS_TO_ACCEPT.TITLE',
				summaryType: summaryTypes.countOrdersToAccept,
				valueDisplayClasses: function valueDisplayClasses(itemCount) {
					if (itemCount > 10) {
						return ['red-font'];
					} else if (itemCount > 2) {
						return ['orange-font'];
					} else {
						return [];
					}
				}
			};

			vm.countOrdersToInvoiceConfiguration = {
				titleConfiguration: 'EINVOICING.PORTAL.SUMMARIES.SUPPLIER.COUNT_ORDERS_TO_INVOICE.TITLE',
				summaryType: summaryTypes.countOrdersToInvoice
			};

			vm.countInvoicesUnpaidConfiguration = {
				titleConfiguration: 'EINVOICING.PORTAL.SUMMARIES.SUPPLIER.COUNT_INVOICES_UNPAID.TITLE',
				summaryType: summaryTypes.countInvoicesUnpaid,
				valueDisplayClasses: function valueDisplayClasses(itemCount) {
					if (itemCount > 100) {
						return ['red-font'];
					} else if (itemCount > 2) {
						return ['orange-font'];
					} else {
						return [];
					}
				}
			};

			vm.countInvoicesDisputedConfiguration = {
				titleConfiguration: 'EINVOICING.PORTAL.SUMMARIES.SUPPLIER.COUNT_INVOICES_DISPUTED.TITLE',
				summaryType: summaryTypes.countInvoicesInDispute,
				valueDisplayClasses: function valueDisplayClasses(itemCount) {
					if (itemCount > 100) {
						return ['red-font'];
					} else if (itemCount > 2) {
						return ['orange-font'];
					} else {
						return [];
					}
				}
			};

			vm.countInvoicesOverdueConfiguration = {
				titleConfiguration: 'EINVOICING.PORTAL.SUMMARIES.SUPPLIER.COUNT_INVOICES_OVERDUE.TITLE',
				summaryType: summaryTypes.countInvoicesOverdue,
				valueDisplayClasses: function valueDisplayClasses(itemCount) {
					if (itemCount > 100) {
						return ['red-font'];
					} else if (itemCount > 2) {
						return ['orange-font'];
					} else {
						return [];
					}
				}
			};

			vm.listOrdersLatestConfiguration = {
				summaryType: summaryTypes.listOrdersLatestReceived,
				titleConfiguration: {
					languageKey: 'EINVOICING.PORTAL.SUMMARIES.SUPPLIER.LIST_ORDERS_LATEST.TITLE',
					target: 'portal.orders.list',
					params: {
						sortOption: 4,
						dateType: 1,
						dateTimeFilter: 'Custom',
						fromDate: '1900-01-01',
						toDate: '9999-12-31'
					}
				},
				tableColumns: [{
					nameLanguageKey: 'EINVOICING.PORTAL.SUMMARIES.SUPPLIER.LIST_ORDERS_LATEST.COLUMNS.NUMBER',
					template: '<span>{{binding.number}}</span>'
				}, {
					nameLanguageKey: 'EINVOICING.PORTAL.SUMMARIES.SUPPLIER.LIST_ORDERS_LATEST.COLUMNS.CUSTOMER',
					template: '<div class="tooltip-wrap">\
									<span class="text-ellipsis">{{binding.partyName}}</span>\
									<div ng-if="(binding.partyName || \'\').length >= 35"\
										ng-class="((binding.partyName || \'\').length > 70) ? [\'tooltip\', \'tooltip-multiline\'] : \'tooltip\'">\
										<span>\
											{{ ::binding.partyName }}\
										</span>\
									</div>\
								</div>',
					cellClass: 'max-width-300'
				}, {
					nameLanguageKey: 'EINVOICING.PORTAL.SUMMARIES.SUPPLIER.LIST_ORDERS_LATEST.COLUMNS.VALUE',
					cellClass: 'numericcell',
					template: '<span>{{binding.totalIncludingTax | diCurrency:binding.currencyId}}</span>'
				}]
			};

			vm.listOrdersHighestValueConfiguration = {
				summaryType: summaryTypes.listOrdersHighestValue,
				rangeParameter: 'days',
				titleConfiguration: {
					target: 'portal.orders.list',
					paramsCreator: function paramsCreator(range) {
						return {
							sortOption: 10,
							dateType: 1,
							dateTimeFilter: 'Custom',
							fromDate: moment().utc().subtract(range, 'days').format(),
							toDate: moment().utc().format(),
							loadCount: 1
						};
					},
					languageKey: 'EINVOICING.PORTAL.SUMMARIES.SUPPLIER.LIST_ORDERS_HIGHEST_VALUE.TITLE'
				},
				tableColumns: [{
					nameLanguageKey: 'EINVOICING.PORTAL.SUMMARIES.SUPPLIER.LIST_ORDERS_HIGHEST_VALUE.COLUMNS.NUMBER',
					template: '<span>{{binding.number}}</span>'
				}, {
					nameLanguageKey: 'EINVOICING.PORTAL.SUMMARIES.SUPPLIER.LIST_ORDERS_HIGHEST_VALUE.COLUMNS.CUSTOMER',
					template: '<div class="tooltip-wrap">\
									<span class="text-ellipsis">{{binding.partyName}}</span>\
									<div ng-if="(binding.partyName || \'\').length >= 35"\
										ng-class="((binding.partyName || \'\').length > 70) ? [\'tooltip\', \'tooltip-multiline\'] : \'tooltip\'">\
										<span>\
											{{ ::binding.partyName }}\
										</span>\
									</div>\
								</div>',
					cellClass: 'max-width-300'
				}, {
					nameLanguageKey: 'EINVOICING.PORTAL.SUMMARIES.SUPPLIER.LIST_ORDERS_HIGHEST_VALUE.COLUMNS.VALUE',
					cellClass: 'numericcell',
					template: '<span>{{binding.totalIncludingTax | diCurrency:binding.currencyId}}</span>'
				}],
				rangeOptions: [{
					languageKey: 'EINVOICING.PORTAL.SUMMARIES.SUPPLIER.LIST_ORDERS_HIGHEST_VALUE.RANGE.30_DAYS',
					isDefault: true,
					value: 30
				}, {
					languageKey: 'EINVOICING.PORTAL.SUMMARIES.SUPPLIER.LIST_ORDERS_HIGHEST_VALUE.RANGE.60_DAYS',
					value: 60
				}, {
					languageKey: 'EINVOICING.PORTAL.SUMMARIES.SUPPLIER.LIST_ORDERS_HIGHEST_VALUE.RANGE.90_DAYS',
					value: 90
				}]
			};

			vm.chartSummaryConfiguration = {
				summaryType: summaryTypes.listOrdersValueGroupedByStatus,
				rangeParameter: 'days',
				titleConfiguration: {
					target: 'portal.orders.list',
					paramsCreator: function paramsCreator(range) {
						return {
							dateType: 1, //created date
							sortOption: 4, //created date desc
							dateTimeFilter: 'Custom',
							fromDate: moment().utc().subtract(range, 'days').format(),
							toDate: moment().utc().format()
						};
					},
					languageKey: 'EINVOICING.PORTAL.SUMMARIES.SUPPLIER.LIST_ORDERS_CHART.TITLE'
				},
				rangeOptions: [{
					languageKey: 'EINVOICING.PORTAL.SUMMARIES.SUPPLIER.LIST_ORDERS_HIGHEST_VALUE.RANGE.30_DAYS',
					isDefault: true,
					value: 30
				}, {
					languageKey: 'EINVOICING.PORTAL.SUMMARIES.SUPPLIER.LIST_ORDERS_HIGHEST_VALUE.RANGE.60_DAYS',
					value: 60
				}, {
					languageKey: 'EINVOICING.PORTAL.SUMMARIES.SUPPLIER.LIST_ORDERS_HIGHEST_VALUE.RANGE.90_DAYS',
					value: 90
				}],
				documentType: clientEnums.documentType.purchaseOrder,
				chart: {
					type: 'bar',
					orientation: 'h',
					barmode: 'stack',
					displayModeBar: false,
					doubleClick: false,
					scrollZoom: false,
					editable: false,
					margin: {
						bottom: 0,
						top: 0,
						left: 30,
						right: 0
					},
					hover: {
						info: 'text',
						mode: 'closest'
					},
					legend: {
						showLegend: true,
						orientation: "h",
						font: {
							family: "'Lato', Arial, sans-serif",
							size: 14
						},
						traceOrder: "normal"
					},
					yAxis: {
						autoRange: false,
						fixedRange: true,
						ticks: {
							showLabels: false
						}
					},
					xAxis: {
						fixedRange: true,
						ticks: {
							font: {
								family: "'Lato', Arial, sans-serif",
								size: 14
							}
						}
					}
				}
			};
			return;
		}

		return SupplierSummaryController;
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 588 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP7Z}
// di.einvoicing.ui.portal.portal.summaries.components.singleValueSummary
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.directive('diSupplierSummary', diSupplierSummary);

		function diSupplierSummary() {
			return {
				restrict: 'E',
				controller: 'SupplierSummaryController',
				controllerAs: 'supplierSummaryCtrl',
				templateUrl: 'src/app/portal/summaries/supplierSummary/supplierSummary.html'
			};
		}

		return diSupplierSummary;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 589 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(590), __webpack_require__(600), __webpack_require__(595), __webpack_require__(591), __webpack_require__(603), __webpack_require__(593), __webpack_require__(605), __webpack_require__(598)], __WEBPACK_AMD_DEFINE_RESULT__ = function (statesLoader, listsLoader, userDetailsLoader, usersBottomButtonsLoader, usersMainButtonsLoader, userDetailsHeaderLoader, usersActionsButtonsLoader, userEditRestrictionsLoader) {
    'use strict';

    return function (module) {
        statesLoader(module);
        listsLoader(module);
        userDetailsLoader(module);
        usersBottomButtonsLoader(module);
        usersMainButtonsLoader(module);
        userDetailsHeaderLoader(module);
        usersActionsButtonsLoader(module);
        userEditRestrictionsLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 590 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP2C}
// di.einvoicing.ui.portal.portal.purchaseorders
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
				'use strict';

				return function (module) {
								module.config(configurePurchaseOrdersStates);

								configurePurchaseOrdersStates.$inject = ['stateHelperProvider'];
								function configurePurchaseOrdersStates(stateHelperProvider) {
												stateHelperProvider.addStates({
																templateBaseUrl: "src/app/portal/users/_states",
																parentStateName: 'portal.users',
																states: [{
																				stateName: "list"
																}, {
																				stateName: "editor",
																				rights: ["PurchaseOrderWriter"],
																				onlyCreateStateCollection: true,
																				stateCollection: [{
																								stateName: "new"
																				}, {
																								stateName: "editById",
																								url: 'id/{id:int}',
																								params: {
																												id: 0
																								}
																				}]
																}]
												});
								}
				};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 591 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(592)], __WEBPACK_AMD_DEFINE_RESULT__ = function (userBottomButtons) {
    'use strict';

    return function (module) {
        module.component(userBottomButtons.UserBottomButtonsComponent.selector, userBottomButtons.UserBottomButtonsComponent);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 592 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var UserBottomButtonsComponent = exports.UserBottomButtonsComponent = {
    selector: 'diUserBottomButtons',
    bindings: {
        mode: '<',
        selectedStates: '<',
        selectedActions: '<',
        bottomButtonsOptions: '<',
        createButtonsOptions: '<',
        enable: '&',
        disable: '&',
        lock: '&',
        unlock: '&',
        save: '&',
        create: '&',
        validate: '&',
        delete: '&'
    },
    controller: function () {
        function controller() {
            _classCallCheck(this, controller);
        }

        _createClass(controller, [{
            key: '$onInit',
            value: function $onInit() {}
        }]);

        return controller;
    }(),
    templateUrl: 'src/app/portal/users/user-bottom-buttons/user-bottom-buttons.component.html'
};

UserBottomButtonsComponent.controller.prototype.constructor.$inject = [];

/***/ }),
/* 593 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(594)], __WEBPACK_AMD_DEFINE_RESULT__ = function (userDetailsHeader) {
    'use strict';

    return function (module) {
        module.component(userDetailsHeader.UserDetailsHeaderComponent.selector, userDetailsHeader.UserDetailsHeaderComponent);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 594 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var UserDetailsHeaderComponent = exports.UserDetailsHeaderComponent = {
    selector: 'diUserDetailsHeader',
    bindings: {
        mode: '<',
        user: '<',
        allRoles: '<',
        selectedRoleId: '=',
        allWorkingFor: '<',
        isSupervisor: '<',
        labels: '<',
        allocatedPartyName: '<',
        letterRangeFilter: '<',
        unallocated: '<',
        selectedRestriction: '<',
        allRights: '<',
        onChanged: '&',
        onRoleChanged: '&',
        onWorkingChanged: '&',
        onSearchRangeChanged: '&',
        filterParties: '&',
        subscribeToEvents: '&'
    },
    controller: function () {
        function controller(translator) {
            _classCallCheck(this, controller);

            this._translator = translator;
        }

        _createClass(controller, [{
            key: '$onInit',
            value: function $onInit() {
                if (this.subscribeToEvents) {
                    this.subscribeToEvents({ subscription: this.setRights.bind(this) });
                }
            }
        }, {
            key: 'setRights',
            value: function setRights(rights) {
                var _this = this;

                this.allRights = rights.allRights;

                var roleRights = rights.roleRights;
                var userRights = rights.userRights;

                var selectedRoleRights = roleRights.find(function (x) {
                    return x.role.id === _this.selectedRoleId;
                }).rights;

                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    var _loop = function _loop() {
                        var right = _step.value;

                        right.friendlyName = _this._translator.instantTranslate('EINVOICING.PORTAL.USERS.EDITOR.RIGHTS.NAME.' + right.id);
                        right.description = _this._translator.instantTranslate('EINVOICING.PORTAL.USERS.EDITOR.RIGHTS.DESCRIPTION.' + right.id);

                        var rightFoundInRole = selectedRoleRights.find(function (x) {
                            return x.id === right.id;
                        });
                        var rightFoundInUser = userRights.find(function (x) {
                            return x.id === right.id;
                        });

                        if (rightFoundInRole && rightFoundInUser) {
                            right.selected = true;
                        } else if (rightFoundInUser && !rightFoundInRole) {
                            right.selected = true;
                        } else {
                            right.selected = false;
                        }
                    };

                    for (var _iterator = this.allRights[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        _loop();
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        }]);

        return controller;
    }(),
    templateUrl: 'src/app/portal/users/user-details-header/user-details-header.component.html'
};

UserDetailsHeaderComponent.controller.prototype.constructor.$inject = ['translator'];

/***/ }),
/* 595 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP0A}
// di.einvoicing.ui.portal.portal.users.editor
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(597), __webpack_require__(596)], __WEBPACK_AMD_DEFINE_RESULT__ = function (userDetailsComponentLoader, userDetailsConfigurationServiceLoader) {
    'use strict';

    return function (module) {
        module.component(userDetailsComponentLoader.UserDetailsComponent.selector, userDetailsComponentLoader.UserDetailsComponent);

        module.service('userDetailsConfigurationService', userDetailsConfigurationServiceLoader.UserDetailsConfigurationService);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 596 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var UserDetailsConfigurationService = function () {
    function UserDetailsConfigurationService(authorizedObjectsFilter, clientEnums) {
        _classCallCheck(this, UserDetailsConfigurationService);

        this.authorizedObjectsFilter = authorizedObjectsFilter;
        this.clientEnums = clientEnums;

        this.baseConfiguration = {
            type: "User",
            buttons: [{
                rights: ["Supervisor"],
                name: 'generatePassword',
                action: this.clientEnums.userActions.generatePassword,
                denyStyle: 'hidden'
            }, {
                rights: ["Supervisor"],
                name: 'resetPassword',
                action: this.clientEnums.userActions.resetPassword,
                denyStyle: 'hidden'
            }, {
                rights: ["Supervisor"],
                name: 'unlockUser',
                action: this.clientEnums.userActions.unlock,
                denyStyle: 'hidden'

            }, {
                rights: ["Supervisor"],
                name: 'enableUser',
                action: this.clientEnums.userActions.enable,
                denyStyle: 'hidden'
            }, {
                rights: ["Supervisor"],
                name: 'disableUser',
                action: this.clientEnums.userActions.disable,
                denyStyle: 'hidden'
            }, {
                rights: ["Supervisor"],
                name: 'saveUser',
                action: this.clientEnums.userActions.save
            }, {
                rights: ["Supervisor"],
                name: 'deleteUser',
                action: this.clientEnums.userActions.deleteUser,
                denyStyle: 'hidden'
            }],
            createButtons: [{
                rights: ["Supervisor"],
                name: 'createUser',
                action: this.clientEnums.userActions.createUser
            }],
            roles: [{
                rights: ["Administrator"],
                name: "administrator",
                id: 1
            }, {
                rights: ["Administrator", "Buyer"],
                name: "buyerSupervisor",
                id: 2
            }, {
                rights: ["Administrator", "Buyer"],
                name: "buyerClerk",
                id: 3
            }, {
                rights: ["Administrator", "Supplier"],
                name: "supplierSupervisor",
                id: 4
            }, {
                rights: ["Administrator", "Supplier"],
                name: "supplierClerk",
                id: 5
            }, {
                rights: ["Administrator"],
                name: "buyerAuditor",
                id: 6
            }, {
                rights: ["Administrator", "Supplier"],
                name: "erpClerk",
                id: 7
            }]
        };
    }

    _createClass(UserDetailsConfigurationService, [{
        key: "getCreateButtonsConfiguration",
        value: function getCreateButtonsConfiguration() {
            this.authorizedObjectsFilter.requireRights(true);

            var configuration = {
                type: "User",
                visibleButtons: []
            };
            configuration.visibleButtons.fill(this.authorizedObjectsFilter.getAuthorizedObjects(this.baseConfiguration.createButtons, true));
            return configuration;
        }
    }, {
        key: "getMainButtonsConfiguration",
        value: function getMainButtonsConfiguration() {
            this.authorizedObjectsFilter.requireRights(true);

            var configuration = {
                type: "User",
                visibleButtons: []
            };

            configuration.visibleButtons.fill(this.authorizedObjectsFilter.getAuthorizedObjects(this.baseConfiguration.buttons, true));
            return configuration;
        }
    }, {
        key: "getRolesConfiguration",
        value: function getRolesConfiguration() {
            this.authorizedObjectsFilter.requireRights(true);

            var configuration = {
                type: "Role",
                visibleRoles: []
            };
            configuration.visibleRoles.fill(this.authorizedObjectsFilter.getAuthorizedObjects(this.baseConfiguration.roles, false));
            return configuration;
        }
    }]);

    return UserDetailsConfigurationService;
}();

UserDetailsConfigurationService.prototype.constructor.$inject = ['authorizedObjectsFilter', 'CLIENT_ENUMS'];

exports.UserDetailsConfigurationService = UserDetailsConfigurationService;

/***/ }),
/* 597 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var util = $di.utility.util;

var UserDetailsComponent = exports.UserDetailsComponent = {
    templateUrl: 'src/app/portal/users/user-details/user-details.component.html',
    selector: 'diUserDetails',
    bindings: {},
    controllerAs: 'userDetailsCtrl',
    controller: function () {
        function UserDetailsController(stateParams, userProxy, partyProxy, diState, notificationHandler, translator, enumTranslator, userDetailsConfigurationService, authorizedObjectsFilter, authenticationData, clientEnums, associativeArrayConvertor, userRightsRepository, userSecurityProxy, userActionsResolver, modalWindow, modalSpinner, clipboard, validationRulesSetter) {
            _classCallCheck(this, UserDetailsController);

            this.stateParams = stateParams;
            this.userProxy = userProxy;
            this.partyProxy = partyProxy;
            this.diState = diState;
            this.notificationHandler = notificationHandler;
            this.translator = translator;
            this.enumTranslator = enumTranslator;
            this.userDetailsConfigurationService = userDetailsConfigurationService;
            this.authorizedObjectsFilter = authorizedObjectsFilter;
            this.authenticationData = authenticationData;
            this.clientEnums = clientEnums;
            this.associativeArrayConvertor = associativeArrayConvertor;
            this.userRightsRepository = userRightsRepository;
            this.userSecurityProxy = userSecurityProxy;
            this.userActionsResolver = userActionsResolver;
            this.modalWindow = modalWindow;
            this.modalSpinner = modalSpinner;
            this.clipboard = clipboard;
            this.validationRulesSetter = validationRulesSetter;
        }

        _createClass(UserDetailsController, [{
            key: '$onInit',
            value: function $onInit() {
                this.isDirty = false;
                this.isReadOnly = false;
                this.isSupervisor = true;
                this.mode = 'edit';
                this.allocatedPartyName = { name: '' };
                this.unallocated = { value: false };
                this.user = {};
                this.selectedRoleId = 0;
                this.allRoles = [];
                this.allRights = [];
                this.userRights = [];
                this.roleRights = [];
                this.allWorkingFor = [];
                this.workingIdsArray = [];
                this.allAllocatedTo = [];
                this.labels = {};
                this.selectedStates = [];
                this.selectedAttributes = [];
                this.selectedActions = [];
                this.mainButtonsOptions = {};
                this.createButtonsOptions = {};
                this.letterRangeFilter = {
                    fromLetter: 'A',
                    toLetter: 'Z'
                };

                this.selectedRestriction = { name: 'restricted' };
                this.eventsSubscriptions = [];

                this.loadUserData = this.loadUserData.bind(this);
                this.loadUserResolved = this.loadUserResolved.bind(this);
                this.filterByNameAndAllocation = this.filterByNameAndAllocation.bind(this);

                if (util.isNumber(this.stateParams.id)) {
                    this.mode = 'edit';
                } else {
                    this.mode = 'new';
                }

                this.setLabels();

                this.setOptions();

                this.initialiseRoles();

                this.loadUserData();
            }
        }, {
            key: 'setLabels',
            value: function setLabels() {
                this.authorizedObjectsFilter.requireRights(false);
                var data = [{
                    key: "titleEdit",
                    label: "EINVOICING.PORTAL.USERS.EDITOR.EDIT.HEADER.TITLE"
                }, {
                    key: "titleNew",
                    label: "EINVOICING.PORTAL.USERS.EDITOR.NEW.HEADER.TITLE"
                }, {
                    rights: ["Supplier"],
                    key: "allocatedTitle",
                    label: "EINVOICING.PORTAL.USERS.EDITOR.COMPONENTS.DETAILS.HEADING_ALLOCATED_TO_SUPPLIER"
                }, {
                    rights: ["Buyer"],
                    key: "allocatedTitle",
                    label: "EINVOICING.PORTAL.USERS.EDITOR.COMPONENTS.DETAILS.HEADING_ALLOCATED_TO_BUYER"
                }, {
                    rights: ["Supplier"],
                    key: "allocatedDesc",
                    label: "EINVOICING.PORTAL.USERS.EDITOR.DESCRIPTIONS.ALLOCATED_TO_SUPPLIER"
                }, {
                    rights: ["Buyer"],
                    key: "allocatedDesc",
                    label: "EINVOICING.PORTAL.USERS.EDITOR.DESCRIPTIONS.ALLOCATED_TO_BUYER"
                }, {
                    rights: ["Supplier"],
                    key: "unallocatedTitle",
                    label: "EINVOICING.PORTAL.USERS.EDITOR.COMPONENTS.DETAILS.HEADING_UNALLOCATED_SUPPLIER"
                }, {
                    rights: ["Buyer"],
                    key: "unallocatedTitle",
                    label: "EINVOICING.PORTAL.USERS.EDITOR.COMPONENTS.DETAILS.HEADING_UNALLOCATED_BUYER"
                }, {
                    rights: ["Supplier"],
                    key: "unallocatedDesc",
                    label: "EINVOICING.PORTAL.USERS.EDITOR.DESCRIPTIONS.UNALLOCATED_SUPPLIER"
                }, {
                    rights: ["Buyer"],
                    key: "unallocatedDesc",
                    label: "EINVOICING.PORTAL.USERS.EDITOR.DESCRIPTIONS.UNALLOCATED_BUYER"
                }];
                this.labels = this.authorizedObjectsFilter.getAuthorizedObjectsAsAssociative(data, 'key', 'label');

                if (this.mode === 'edit') {
                    this.labels.title = this.labels.titleEdit;
                } else {
                    this.labels.title = this.labels.titleNew;
                }
            }
        }, {
            key: 'setOptions',
            value: function setOptions() {
                this.mainButtonsOptions = this.userDetailsConfigurationService.getMainButtonsConfiguration();
                this.createButtonsOptions = this.userDetailsConfigurationService.getCreateButtonsConfiguration();
                this.bottomButtonsOptions = this.userDetailsConfigurationService.getMainButtonsConfiguration();

                this.validationRulesSetter.setValidationRules("User");
            }
        }, {
            key: 'initialiseRoles',
            value: function initialiseRoles() {
                var _this = this;

                var roles = this.userDetailsConfigurationService.getRolesConfiguration();

                this.allRoles.fill(roles.visibleRoles);

                this.translator.whenReady().then(function () {
                    _.each(_this.allRoles, function (role) {
                        role.enabled = false;
                        role.description = _this.getRoleDescription(role.id);
                        role.name = _this.getRoleName(role.id);
                    });
                });
            }
        }, {
            key: 'getRoleDescription',
            value: function getRoleDescription(roleId) {
                var roleName = this.getCurrentUserRoleName();

                if (util.isNonEmptyString(roleName)) {
                    roleName = '_' + roleName;
                }

                return this.translator.instantTranslate('EINVOICING.PORTAL.USERS.EDITOR.ROLES.DESCRIPTION' + roleName + '.' + roleId);
            }
        }, {
            key: 'getRoleName',
            value: function getRoleName(roleId) {
                return this.translator.instantTranslate('EINVOICING.PORTAL.USERS.EDITOR.ROLES.NAME.' + roleId);
            }
        }, {
            key: 'getCurrentUserRoleName',
            value: function getCurrentUserRoleName() {
                var isSupplier = this.userRightsRepository.userHasRight("Supplier");
                var isBuyer = this.userRightsRepository.userHasRight("Buyer");

                var role = '';

                if (isSupplier) {
                    role = "SUPPLIER";
                } else if (isBuyer) {
                    role = "BUYER";
                }

                return role;
            }
        }, {
            key: 'loadUserData',
            value: function loadUserData() {
                var _this2 = this;

                if (util.isNumber(this.stateParams.id)) {
                    if (this.stateParams.id > 0) {
                        this.userProxy.getDetailsModelById(this.stateParams.id).then(this.loadUserResolved, function () {
                            _this2.notificationHandler.showError("EINVOICING.PORTAL.USERS.EDITOR.LOAD_ERROR", _this2.stateParams.id);
                            _this2.backToList();
                        });
                    } else {
                        this.notificationHandler.showError("EINVOICING.PORTAL.USERS.EDITOR.LOAD_ERROR", this.stateParams.id);
                        this.backToList();
                    }
                } else {
                    this.user = {
                        actions: [this.clientEnums.userActions.createUser],
                        isEnabled: true
                    };

                    this.partyProxy.getAllPartiesUserCanWorkFor(0).then(function (data) {
                        _.each(data, function (item) {
                            item.isAssigned = false;
                        });

                        _this2.allWorkingFor = data;

                        _this2.resolveActions();
                    });
                }
            }
        }, {
            key: 'loadUserResolved',
            value: function loadUserResolved(data) {
                var _this3 = this;

                this.user = data;
                var promptDeleteUserMessage = this.translator.instantTranslate('EINVOICING.PORTAL.USERS.DELETE.CONFIRMATION_MESSAGE', this.user.name);
                this.mainButtonsOptions.promptMessage = this.bottomButtonsOptions.promptMessage = { deleteUser: promptDeleteUserMessage };

                this.selectedRestriction = {
                    name: data.editRestrictions ? data.editRestrictions.toLowerCase() : ''
                };

                this.getTrueFalseLabel(this.user.enabled).then(function (enabled) {
                    _this3.user.enabledLabel = enabled;
                });
                this.getTrueFalseLabel(this.user.locked).then(function (locked) {
                    _this3.user.lockedLabel = locked;
                });

                this.partyProxy.getAllPartiesUserCanWorkFor(this.user.id).then(function (data) {
                    _this3.allWorkingFor = data;

                    _this3.setAllocated(true);
                }, function () {
                    _this3.notificationHandler.showError("EINVOICING.PORTAL.USERS.EDITOR.LOAD_ERROR", _this3.stateParams.id);

                    _this3.backToList();
                });
            }

            /**
                 * Event handler for filter by fist letter changes
                 */

        }, {
            key: 'onSearchRangeChanged',
            value: function onSearchRangeChanged() {
                if (util.isNonEmptyString(this.letterRangeFilter.fromLetter) && util.isNonEmptyString(this.letterRangeFilter.toLetter)) {
                    this.setLetters(this.letterRangeFilter.fromLetter, this.letterRangeFilter.toLetter);
                } else {
                    this.setLetters('A', 'Z');
                }
            }
        }, {
            key: 'setLetters',
            value: function setLetters(from, to) {
                this.letterRangeFilter.fromLetter = from.toUpperCase();
                this.letterRangeFilter.toLetter = to.toUpperCase();
            }

            /**
             * Searching by assigned count for supervisor
             */

        }, {
            key: 'filterParties',
            value: function filterParties() {
                var items = this.allAllocatedTo;
                if (items.length === 0) {
                    return items;
                }

                var filtered = void 0;
                if (this.isSupervisor) {

                    filtered = _.filter(items, function (item) {
                        return item.assignedCount === 0;
                    });
                } else {
                    filtered = items;
                }

                return this.filterByNameAndAllocation(filtered);
            }
        }, {
            key: 'filterByNameAndAllocation',
            value: function filterByNameAndAllocation(items) {
                var filtered = void 0;
                var unallocated = this.unallocated.value;
                var allocatedPartyName = this.allocatedPartyName;

                if (util.isNonEmptyString(allocatedPartyName.name)) {
                    filtered = _.filter(items, function (item) {
                        var matched = item.name.toLowerCase().indexOf(allocatedPartyName.name.toLowerCase()) > -1;

                        if (unallocated) {
                            return matched && item.isAssigned === false;
                        } else {
                            return matched;
                        }
                    });
                } else {
                    filtered = _.filter(items, function (item) {
                        if (unallocated) {
                            return item.isAssigned === false;
                        } else {
                            return true;
                        }
                    });
                }

                return this.filterByRange(filtered, this.letterRangeFilter.fromLetter, this.letterRangeFilter.toLetter);
            }
        }, {
            key: 'filterByRange',
            value: function filterByRange(items, fromLetter, toLetter) {
                fromLetter = fromLetter.toLowerCase();
                toLetter = toLetter.toLowerCase();
                var filtered = [];
                for (var i = 0; i < items.length; i++) {
                    var item = items[i];

                    var firstLetter = item.name.substring(0, 1).toLowerCase();

                    if ((!fromLetter || firstLetter >= fromLetter) && (!toLetter || firstLetter <= toLetter)) {
                        filtered.push(item);
                    }
                }
                return filtered;
            }

            /**
             * loads allocated parties list and resets those settings
             */

        }, {
            key: 'setAllocated',
            value: function setAllocated(resetActions) {
                var _this4 = this;

                var workingIdsArray = [];
                _.each(this.allWorkingFor, function (company) {

                    if (company.isAssigned) {
                        workingIdsArray.push(company.partyId);
                    }
                });

                this.partyProxy.getAllRelatedPartyCountries(this.stateParams.id, workingIdsArray).then(function (data) {
                    var relatedIds = [];
                    _.each(data, function (company) {
                        relatedIds.push(company.party.id);
                    });

                    _this4.partyProxy.getAllPartiesUserCanBeAllocatedTo(_this4.stateParams.id, relatedIds).then(function (data) {

                        _this4.allAllocatedTo = _.uniq(data, function (item) {
                            return item.partyId;
                        });

                        _this4.setRoles();
                        _this4.setRights();

                        if (resetActions) {
                            _this4.setActions();
                        }
                    });
                });
            }
        }, {
            key: 'setAllocatedResettingActions',
            value: function setAllocatedResettingActions() {
                this.setAllocated(true);
            }
        }, {
            key: 'subscribeToEvents',
            value: function subscribeToEvents(subscription) {
                this.eventsSubscriptions.push(subscription);
            }
        }, {
            key: 'notifyEventsSubscribers',
            value: function notifyEventsSubscribers(notificationObject) {
                for (var i = 0; i < this.eventsSubscriptions.length; i++) {
                    this.eventsSubscriptions[i](notificationObject);
                }
            }
        }, {
            key: 'setRoles',
            value: function setRoles() {
                if (this.user.roles.length > 0) {
                    this.selectedRoleId = this.user.roles[0].id;
                }
            }
        }, {
            key: 'setRights',
            value: function setRights() {
                var _this5 = this;

                this.userProxy.getUserRights(this.user.id).then(function (data) {

                    var found = _.find(data, function (right) {
                        return right.name === 'Supervisor';
                    });

                    _this5.userRights = data;
                    _this5.isSupervisor = util.isDefined(found);

                    if (_this5.isSupervisor) {
                        _.each(_this5.allAllocatedTo, function (related) {
                            related.assigned = false;
                            related.allocated = false;
                        });
                    }

                    _this5.setRoleRights(false);
                });
            }
        }, {
            key: 'setRoleRights',
            value: function setRoleRights(roleChanged) {
                var _this6 = this;

                this.userProxy.getRoleRights().then(function (roleRights) {
                    _this6.roleRights = roleRights;

                    if (roleChanged) {
                        _this6.userRights = _this6.roleRights.find(function (x) {
                            return x.role.id === _this6.selectedRoleId;
                        }).rights;
                    }

                    _this6.userProxy.getAllRights().then(function (rights) {
                        _this6.allRights = rights;

                        _this6.notifyEventsSubscribers({
                            userRights: _this6.userRights,
                            roleRights: _this6.roleRights,
                            allRights: _this6.allRights
                        });
                    });
                });
            }
        }, {
            key: 'setActions',
            value: function setActions() {
                this.removeAction(this.clientEnums.userActions.save);
                this.resolveActions();
            }

            /**
             * Handler for form changed event
             */

        }, {
            key: 'onChanged',
            value: function onChanged() {
                this.isDirty = true;
                this.addAction(this.clientEnums.userActions.save);
            }
        }, {
            key: 'onRoleChanged',
            value: function onRoleChanged() {
                this.onChanged();
                this.userRights = [];
                this.setRoleRights(true);
            }

            /**
             * Handler for workning company selection change event
             */

        }, {
            key: 'onWorkingChanged',
            value: function onWorkingChanged() {
                if (this.mode === 'edit') {
                    this.setAllocated();
                }

                this.onChanged();
            }

            /**
             * Enables user account
             */

        }, {
            key: 'enable',
            value: function enable() {
                var _this7 = this;

                this.user.enabled = true;

                this.getTrueFalseLabel(true).then(function (translated) {
                    _this7.user.enabledLabel = translated;
                });

                this.removeAction(this.clientEnums.userActions.enable);
                this.addAction(this.clientEnums.userActions.disable);

                this.onChanged();
            }

            /**
             * Disables user account
               */

        }, {
            key: 'disable',
            value: function disable() {
                var _this8 = this;

                this.user.enabled = false;
                this.getTrueFalseLabel(false).then(function (translated) {
                    _this8.user.enabledLabel = translated;
                });

                this.removeAction(this.clientEnums.userActions.disable);
                this.addAction(this.clientEnums.userActions.enable);

                this.onChanged();
            }

            /**
             * Unlocks user account
             */

        }, {
            key: 'unlock',
            value: function unlock() {
                var _this9 = this;

                this.user.locked = false;

                this.getTrueFalseLabel(false).then(function (translated) {
                    _this9.user.lockedLabel = translated;

                    _this9.removeAction(_this9.clientEnums.userActions.unlock);
                    _this9.addAction(_this9.clientEnums.userActions.lock);

                    _this9.onChanged();
                });
            }

            /**
            * Validates user before saving
            */

        }, {
            key: 'validate',
            value: function validate() {
                if (this.selectedRoleId === 0) {
                    this.notificationHandler.showWarning('EINVOICING.PORTAL.USERS.EDITOR.SAVED_NO_ROLE_SELECTED');
                    return false;
                }

                var workingForSelected = _.find(this.allWorkingFor, function (model) {
                    return model.isAssigned === true;
                });

                if (!util.isDefined(workingForSelected)) {
                    this.notificationHandler.showWarning('EINVOICING.PORTAL.USERS.EDITOR.SAVED_NO_WORKING_PARTIES');
                    return false;
                }

                return true;
            }

            /**
             * Creates new user              
             */

        }, {
            key: 'create',
            value: function create() {
                var _this10 = this;

                var selectedRoles = _.filter(this.allRoles, function (role) {
                    return role.id === _this10.selectedRoleId;
                });

                var selectedWorkingFor = [];

                _.each(this.allWorkingFor, function (model) {
                    if (model.isAssigned === true) {
                        selectedWorkingFor.push(model.party);
                    }
                });

                this.user.roles = selectedRoles;
                this.user.workingParties = selectedWorkingFor;
                this.user.allocatedParties = [];
                this.user.enabled = true;

                if (this.creatingUser !== true) {
                    this.showSpinner();
                    this.creatingUser = true;
                    this.userProxy.createUser(this.user).then(function (data) {
                        if (data.success) {
                            _this10.showPassword(data.generatedPassword, true);
                            _this10.diState.go('portal.users.editById', { id: data.userId });
                        } else {
                            _this10.notificationHandler.showError("EINVOICING.PORTAL.USERS.EDITOR.ERRORS." + data.failureReason.toUpperCase());
                        }
                    }, function () {
                        _this10.notificationHandler.showError("EINVOICING.PORTAL.USERS.EDITOR.CREATE_ERROR");
                    }).finally(function () {
                        _this10.creatingUser = false;
                        _this10.removeSpinner();
                    });
                }
            }
        }, {
            key: 'generatePassword',
            value: function generatePassword() {
                var _this11 = this;

                if (this.generatingPassword !== true) {
                    this.showSpinner();
                    this.generatingPassword = true;
                    this.userProxy.generatePassword(this.user.id).then(function (data) {
                        _this11.showPassword(data.generatedPassword, false);
                    }, function () {
                        _this11.notificationHandler.showError("EINVOICING.PORTAL.USERS.EDITOR.GENERATE_ERROR");
                    }).finally(function () {
                        _this11.generatingPassword = false;
                        _this11.removeSpinner();
                    });
                }
            }
        }, {
            key: 'showPassword',
            value: function showPassword(password, created) {
                var _this12 = this;

                var options = {
                    dataModel: {
                        generatedPassword: password,
                        copyToClipboard: function copyToClipboard() {
                            _this12.clipboard.copyText(password);
                        }
                    },
                    controller: "ResourceController",
                    templateUrl: 'src/app/portal/users/user-details/generated-password.html',
                    preventClose: true,
                    title: "New password",
                    promptOnCancel: true
                };

                if (created) {
                    options.dataModel.title = "EINVOICING.PORTAL.USERS.EDITOR.USER_CREATED_TITLE";
                    options.dataModel.createdUser = true;
                    options.dataModel.message = this.translator.instantTranslate("EINVOICING.PORTAL.USERS.EDITOR.USER_CREATED_MESSAGE", password);
                } else {
                    options.dataModel.title = "EINVOICING.PORTAL.USERS.EDITOR.PASSWORD_GENERATED_TITLE";
                    options.dataModel.message = this.translator.instantTranslate("EINVOICING.PORTAL.USERS.EDITOR.PASSWORD_GENERATED", password);
                }

                this.modalWindow.show(options);
            }

            /**
             * Saves form changes
             */

        }, {
            key: 'save',
            value: function save() {
                var _this13 = this;

                if (!this.validate()) {
                    return;
                }

                var selectedRoles = _.filter(this.allRoles, function (role) {
                    return role.id === _this13.selectedRoleId;
                });

                var selectedWorkingFor = [];

                _.each(this.allWorkingFor, function (model) {
                    if (model.isAssigned === true) {
                        selectedWorkingFor.push(model.party);
                    }
                });

                var selectedAllocatedFor = [];

                _.each(this.allAllocatedTo, function (model) {
                    if (model.isAssigned === true && !_this13.isSupervisor) {
                        selectedAllocatedFor.push(model.party);
                    }
                });

                this.user.roles = selectedRoles;
                this.user.workingParties = selectedWorkingFor;
                this.user.allocatedParties = selectedAllocatedFor;
                this.user.editRestrictions = this.selectedRestriction.name.toLowerCase();
                this.user.rights = this.allRights;

                this.userProxy.saveUser(this.user).then(function (data) {
                    _this13.notificationHandler.showSuccess('EINVOICING.PORTAL.USERS.EDITOR.SAVED_SUCCESS');
                    _this13.user.id = data;
                    _this13.isDirty = false;
                    _this13.loadUserData();
                    _this13.removeAction(_this13.clientEnums.userActions.save);
                }, function (error) {
                    _this13.isDirty = true;
                    _this13.notificationHandler.showError(error.failureReason);
                });
            }

            /**
             * calls dependency to send reset password email to edited user
             */

        }, {
            key: 'resetPassword',
            value: function resetPassword() {
                var _this14 = this;

                this.userSecurityProxy.requestPasswordResetOnUserBehalf(this.user.id, this.user.name).then(function (data) {
                    if (data.success) {
                        _this14.notificationHandler.showSuccess('EINVOICING.PORTAL.USERS.EDITOR.RESET_SUCCESS', _this14.user.name);
                    } else {

                        var message = 'CORE.USER_SECURITY.ERRORS.' + data.failureReason.toUpperCase();

                        _this14.notificationHandler.showError(message);
                    }
                }, function (error) {
                    _this14.notificationHandler.showError(error.failureReason);
                });
            }

            /**
             * Confirms the user wishes to cancel their changes and then cancels the changes if required
             */

        }, {
            key: 'cancelChanges',
            value: function cancelChanges() {
                this.loadUserData();
                this.isDirty = false;
            }
        }, {
            key: 'delete',
            value: function _delete() {
                var _this15 = this;

                this.userProxy.remove(this.user.id).then(function (result) {
                    _this15.notificationHandler.showSuccess('EINVOICING.PORTAL.USERS.DELETE.SUCCESS', _this15.user.name);
                    _this15.backToList();
                }, function (error) {
                    _this15.notificationHandler.showError(error.failureReason);
                });
            }
            /**
             * navigates back to user list
             */

        }, {
            key: 'backToList',
            value: function backToList() {
                this.diState.go('portal.users.list');
            }

            /**
             * Returns translated label for true or false state
             */

        }, {
            key: 'getTrueFalseLabel',
            value: function getTrueFalseLabel(value) {
                if (util.isDefined(value) && value === true) {
                    return this.translator.translate("EINVOICING.PORTAL.BODY.TRUE");
                } else {
                    return this.translator.translate("EINVOICING.PORTAL.BODY.FALSE");
                }
            }

            /**
             * adds action to allowed actions        
             */

        }, {
            key: 'addAction',
            value: function addAction(actionId) {
                var found = _.find(this.user.actions, function (id) {
                    return id === actionId;
                });

                if (util.isUndefined(found)) {
                    this.user.actions.push(actionId);
                    this.resolveActions();
                }
            }

            /**
             * removes action from allowed actions
             */

        }, {
            key: 'removeAction',
            value: function removeAction(actionId) {
                var flitered = _.filter(this.user.actions, function (id) {
                    return id !== actionId;
                });

                this.user.actions.fill(flitered);

                this.resolveActions();
            }

            /**
            *  resolves allowed actions
            */

        }, {
            key: 'resolveActions',
            value: function resolveActions() {
                var resolvedActions = this.userActionsResolver.resolveActions(this.user.actions, false);
                this.selectedActions.fill(resolvedActions);
            }

            /**
             * Adds spinner to the page
             */

        }, {
            key: 'showSpinner',
            value: function showSpinner() {
                this.spinner = this.modalSpinner.showModalSpinner("#spinnerHolder");
            }

            /**
             * Removes spinner from the page
            */

        }, {
            key: 'removeSpinner',
            value: function removeSpinner() {
                if (this.spinner) {
                    this.spinner.remove();
                }
            }
        }]);

        return UserDetailsController;
    }()
};

UserDetailsComponent.controller.prototype.constructor.$inject = ['$stateParams', 'userProxy', 'partyProxy', 'diState', 'notificationHandler', 'translator', 'enumTranslator', 'userDetailsConfigurationService', 'authorizedObjectsFilter', 'authenticationData', 'CLIENT_ENUMS', 'associativeArrayConvertor', 'userRightsRepository', 'userSecurityProxy', 'userActionsResolver', 'modalWindow', 'modalSpinner', 'clipboard', 'validationRulesSetter'];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 598 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(599)], __WEBPACK_AMD_DEFINE_RESULT__ = function (userEditRestrictions) {
    'use strict';

    return function (module) {
        module.component(userEditRestrictions.UserEditRestrictionsComponent.selector, userEditRestrictions.UserEditRestrictionsComponent);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 599 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var UserEditRestrictionsComponent = exports.UserEditRestrictionsComponent = {
    selector: 'diUserEditRestrictions',
    bindings: {
        selectedRestriction: '<',
        onChanged: '&',
        isSupervisor: '<'
    },
    controller: function () {
        function controller() {
            _classCallCheck(this, controller);

            this.restrictions = new Map();
            this.restrictions.set("none", "none");
            this.restrictions.set("restricted", "restricted");
            this.restrictions.set("all", "all");
        }

        _createClass(controller, [{
            key: '$onInit',
            value: function $onInit() {}
        }]);

        return controller;
    }(),
    templateUrl: 'src/app/portal/users/user-edit-restrictions/user-edit-restrictions.component.html'
};

UserEditRestrictionsComponent.controller.prototype.constructor.$inject = [];

/***/ }),
/* 600 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP5D}
//di.einvoicing.ui.portal.portal.users
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(602), __webpack_require__(601)], __WEBPACK_AMD_DEFINE_RESULT__ = function (userListComponentModule, userListConfigurationServiceLoader) {
				'use strict';

				return function (module) {
								module.component(userListComponentModule.UserListComponent.selector, userListComponentModule.UserListComponent);
								module.service('userListConfigurationService', userListConfigurationServiceLoader.UserListConfigurationService);
				};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 601 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _columns = Symbol('columns');
var _tableOptions = Symbol('tableOptions');
var _actionColumns = Symbol('actionColumns');

var UserListConfigurationService = function () {
	function UserListConfigurationService() {
		_classCallCheck(this, UserListConfigurationService);

		this[_columns] = [{
			field: 'name',
			nameLanguageKey: 'EINVOICING.PORTAL.USERS.LISTS.COLUMN_HEADERS.NAME',
			template: '<span>{{ binding.name }}</span>'
		}, {
			field: 'friendlyName',
			nameLanguageKey: 'EINVOICING.PORTAL.USERS.LISTS.COLUMN_HEADERS.FRIENDLY_NAME',
			template: '<span>{{ binding.friendlyName }}</span>'
		}, {
			field: 'dateCreated',
			nameLanguageKey: 'EINVOICING.PORTAL.USERS.LISTS.COLUMN_HEADERS.DATE_CREATED',
			template: '<span>{{ binding.dateCreated | diDate }}</span>',
			cellClass: 'centeredcell'
		}, {
			field: 'dateLastLogin',
			nameLanguageKey: 'EINVOICING.PORTAL.USERS.LISTS.COLUMN_HEADERS.DATE_LAST_LOGIN',
			template: '<span>{{ binding.dateLastLogin | diDate }}</span>',
			cellClass: 'centeredcell'
		}, {
			field: 'enabled',
			nameLanguageKey: 'EINVOICING.PORTAL.USERS.LISTS.COLUMN_HEADERS.ENABLED',
			template: '<span>{{ binding.enabled | diYesNo }}</span>',
			cellClass: 'centeredcell'
		}, {
			field: 'locked',
			nameLanguageKey: 'EINVOICING.PORTAL.USERS.LISTS.COLUMN_HEADERS.LOCKED',
			template: '<span>{{ binding.locked | diYesNo }}</span>',
			cellClass: 'centeredcell'
		}];

		this[_tableOptions] = {
			data: [],
			enableSelect: true,
			multiSelect: false,
			enablePaging: true,
			fixedHeight: true,
			maxItemsToShow: 500,
			paginationPageSizes: [5, 10, 15, 20, 25, 50],
			paginationPageSize: 10,
			paginationPageNumber: 1,
			maxButtonsShown: 3,
			pagination: {
				seek: function seek() {}
			}
		};

		this[_actionColumns] = [{
			field: 'editButton',
			template: '<di-button image="edit" image-colour="button" action="controller.editUser(binding)"></di-button>',
			cellClass: 'cell-right'
		}, {
			field: 'deleteButton',
			template: '<di-button image="delete" image-colour="button" action="controller.deleteUser(binding)" di-enabled="controller.canDeleteUser(binding)"></di-button>',
			cellClass: 'centeredCell'
		}];
	}

	_createClass(UserListConfigurationService, [{
		key: 'getTableOptions',
		value: function getTableOptions() {
			this[_tableOptions].columns = this[_columns];
			this[_tableOptions].actionColumns = this[_actionColumns];
			return Promise.resolve(this[_tableOptions]);
		}
	}]);

	return UserListConfigurationService;
}();

UserListConfigurationService.prototype.constructor.$inject = [];

exports.UserListConfigurationService = UserListConfigurationService;

/***/ }),
/* 602 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var util = $di.utility.util;

var UserListComponent = exports.UserListComponent = {
	templateUrl: 'src/app/portal/users/user-list/user-list.component.html',
	selector: 'diUserList',
	controllerAs: 'userListCtrl',
	controller: function () {
		function UserListController(diState, notificationHandler, userProxy, modalSpinner, userListConfigurationService, clientEnums, promptWindow) {
			_classCallCheck(this, UserListController);

			this.diState = diState;
			this.notificationHandler = notificationHandler;
			this.userProxy = userProxy; //TODO:- remove this and pass in the data instead
			this.modalSpinner = modalSpinner;
			this.userListConfigurationService = userListConfigurationService;
			this.clientEnums = clientEnums;
			this.promptWindow = promptWindow;

			this.editUser = this.editUser.bind(this);
			this.deleteUser = this.deleteUser.bind(this);
			this.canDeleteUser = this.canDeleteUser.bind(this);
			this.removeSpinner = this.removeSpinner.bind(this);
			this.showSpinner = this.showSpinner.bind(this);
		}

		_createClass(UserListController, [{
			key: '$onInit',
			value: function $onInit() {
				var _this = this;

				this.spinner = {};
				this.users = [];
				this.tableOptions = {};

				this.userListConfigurationService.getTableOptions().then(function (tableOptions) {
					_this.tableOptions = tableOptions;
					_this.getUsers();
				});
			}
		}, {
			key: 'getUsers',
			value: function getUsers() {
				var _this2 = this;

				this.showSpinner();

				var maxItemsToShow = this.tableOptions.maxItemsToShow;
				this.userProxy.getUsers('', maxItemsToShow).then(function (data) {
					//resolved
					if (util.isUndefined(data)) {
						data = [];
					}

					_this2.tableOptions.data.fill(data);
					_this2.users.fill(data);
				}, function () {
					//rejected
					_this2.notificationHandler.showError('EINVOICING.PORTAL.USERS.LISTS.ERROR_GETTING_USERS');
				}).finally(function () {
					_this2.removeSpinner();
				});

				return;
			}
		}, {
			key: 'editUser',
			value: function editUser(user) {
				if (util.isUndefined(user)) {
					return;
				}

				var selectedId = user.id;

				this.diState.go('portal.users.editById', { id: selectedId });
			}
		}, {
			key: 'deleteUser',
			value: function deleteUser(user) {
				var _this3 = this;

				if (util.isNullOrUndefined(user)) {
					return;
				}

				this.promptWindow.confirm({
					title: 'EINVOICING.PORTAL.USERS.DELETE.CONFIRMATION_MESSAGE_TITLE',
					message: { stringToTranslate: 'EINVOICING.PORTAL.USERS.DELETE.CONFIRMATION_MESSAGE', translationArguments: user.name },
					okBtnText: 'CORE.PROMPT.YES',
					cancelBtnText: 'CORE.PROMPT.NO',
					callback: function callback(result) {
						if (result) {
							_this3.userProxy.remove(user.id).then(function (data) {
								_this3.notificationHandler.showSuccess('EINVOICING.PORTAL.USERS.DELETE.SUCCESS', user.name);
								_this3.getUsers();
							}).catch(function (error) {
								_this3.notificationHandler.showError(error.failureReason);
							});
						}
					}
				});
			}
		}, {
			key: 'canDeleteUser',
			value: function canDeleteUser(user) {
				if (util.isNullOrUndefined(user)) {
					return false;
				}
				return _.contains(user.actions, this.clientEnums.userActions.deleteUser);
			}
		}, {
			key: 'showSpinner',
			value: function showSpinner() {
				this.spinner = this.modalSpinner.showModalSpinner("#spinnerHolder");
			}
		}, {
			key: 'removeSpinner',
			value: function removeSpinner() {
				if (this.spinner) {
					this.spinner.remove();
				}
			}
		}]);

		return UserListController;
	}()
};

UserListComponent.controller.prototype.constructor.$inject = ['diState', 'notificationHandler', 'userProxy', 'modalSpinner', 'userListConfigurationService', 'CLIENT_ENUMS', 'promptWindow'];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 603 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(604)], __WEBPACK_AMD_DEFINE_RESULT__ = function (userMainButtons) {
    'use strict';

    return function (module) {
        module.component(userMainButtons.UserMainButtonsComponent.selector, userMainButtons.UserMainButtonsComponent);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 604 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var UserMainButtonsComponent = exports.UserMainButtonsComponent = {
    selector: 'diUserMainButtons',
    bindings: {
        mode: '<',
        selectedActions: '<',
        mainButtonsOptions: '<',
        createButtonsOptions: '<',
        enable: '&',
        disable: '&',
        lock: '&',
        unlock: '&',
        save: '&',
        create: '&',
        resetPassword: '&',
        generatePassword: '&',
        validate: '&',
        delete: '&'
    },
    controller: function () {
        function controller() {
            _classCallCheck(this, controller);
        }

        _createClass(controller, [{
            key: '$onInit',
            value: function $onInit() {}
        }]);

        return controller;
    }(),
    templateUrl: 'src/app/portal/users/user-main-buttons/user-main-buttons.component.html'
};

UserMainButtonsComponent.controller.prototype.constructor.$inject = [];

/***/ }),
/* 605 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(606)], __WEBPACK_AMD_DEFINE_RESULT__ = function (userActionButtons) {
    'use strict';

    return function (module) {
        module.component(userActionButtons.UsersActionButtonsComponent.selector, userActionButtons.UsersActionButtonsComponent);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 606 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var UsersActionButtonsComponent = exports.UsersActionButtonsComponent = {
    selector: 'diUsersActionButtons',
    bindings: {
        selectedActions: '<',
        selectedStates: '<',
        selectedItemsCount: '<',
        buttonsSetOneOptions: '<',
        buttonsSetTwoOptions: '<',
        editUser: '&',
        getUsers: '&'
    },
    controller: function () {
        function controller() {
            _classCallCheck(this, controller);
        }

        _createClass(controller, [{
            key: '$onInit',
            value: function $onInit() {}
        }]);

        return controller;
    }(),
    templateUrl: 'src/app/portal/users/users-action-buttons/users-action-buttons.component.html'
};

UsersActionButtonsComponent.controller.prototype.constructor.$inject = [];

/***/ }),
/* 607 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

// di.einvoicing.ui.portal.portal.utilities
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(608), __webpack_require__(609)], __WEBPACK_AMD_DEFINE_RESULT__ = function (statesLoader, integratorLoader) {
	'use strict';

	return function (module) {
		statesLoader(module);
		integratorLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 608 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

// di.einvoicing.ui.portal.portal.utilities
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.config(configureAttachmentStates);

        configureAttachmentStates.$inject = ['stateHelperProvider'];

        function configureAttachmentStates(stateHelperProvider) {
            stateHelperProvider.addStates({
                templateBaseUrl: "src/app/portal/utilities/_states",
                parentStateName: 'portal.utilities',
                states: [{
                    stateName: 'integrator'
                }]
            });
        }
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 609 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

// di.einvoicing.ui.portal.portal.utilities.integrator
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(610), __webpack_require__(611)], __WEBPACK_AMD_DEFINE_RESULT__ = function (integratorDetailsProxyServiceModule, integratorDetailsComponentModule) {
	'use strict';

	return function (module) {
		module.service('integratorDetailsProxy', integratorDetailsProxyServiceModule.IntegratorDetailsProxyService);

		module.component(integratorDetailsComponentModule.integratorDetailsComponent.selector, integratorDetailsComponentModule.integratorDetailsComponent);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 610 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//{CODE:EUP9F}
//di.einvoicing.ui.portal.portal.utilities.integrator

var IntegratorDetailsProxyService = function () {
    function IntegratorDetailsProxyService(dHttp, config) {
        _classCallCheck(this, IntegratorDetailsProxyService);

        this._dHttp = dHttp;
        this._config = config.utilities.integrator;
    }

    _createClass(IntegratorDetailsProxyService, [{
        key: 'getClickonceConfig',
        value: function getClickonceConfig() {
            return this._dHttp.get(this._config.configFilePath, this._config.endpointName);
        }
    }]);

    return IntegratorDetailsProxyService;
}();

IntegratorDetailsProxyService.prototype.constructor.$inject = ['dHttp', 'PORTAL_CONFIG'];

exports.IntegratorDetailsProxyService = IntegratorDetailsProxyService;

/***/ }),
/* 611 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//{CODE:EUP9E}
//di.einvoicing.ui.portal.portal.utilities.integrator

var integratorDetailsComponent = exports.integratorDetailsComponent = {
    selector: 'diIntegratorDetails',
    controller: function () {
        function controller(integratorDetailsProxy, urlHelper, $window, config) {
            var _this = this;

            _classCallCheck(this, controller);

            this._integratorDetailsProxy = integratorDetailsProxy;
            this._urlHelper = urlHelper;

            this.clickonceConfig = {};
            this.installUrl = '';
            this.integratorSetupGuideUrl = config.app.integratorSetupGuideUrl;
            this.download = function () {
                $window.open(_this.installUrl);
            };
        }

        _createClass(controller, [{
            key: '$onInit',
            value: function $onInit() {
                var _this2 = this;

                this._integratorDetailsProxy.getClickonceConfig().then(function (clickonceConfig) {
                    _this2.clickonceConfig = clickonceConfig;
                    _this2.installUrl = _this2._urlHelper.combine(clickonceConfig.clickonceInstallUrl, clickonceConfig.clickonceFilename);
                });
            }
        }]);

        return controller;
    }(),
    templateUrl: 'src/app/portal/utilities/integrator/integrator-details.html'
};

integratorDetailsComponent.controller.prototype.constructor.$inject = ['integratorDetailsProxy', 'urlHelper', '$window', 'PORTAL_CONFIG'];

/***/ }),
/* 612 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(617), __webpack_require__(620), __webpack_require__(626), __webpack_require__(628), __webpack_require__(639), __webpack_require__(641), __webpack_require__(643), __webpack_require__(613), __webpack_require__(634), __webpack_require__(624)], __WEBPACK_AMD_DEFINE_RESULT__ = function (dropdownSelectorLoader, headerLoader, imageLoader, navigationLoader, styleConstantsLoader, tooltipLoader, userLoader, clientEnumsLoader, serviceStatusMonitorLoader, identifierLoader) {
	'use strict';

	return function (module) {
		dropdownSelectorLoader(module);
		headerLoader(module);
		imageLoader(module);
		navigationLoader(module);
		styleConstantsLoader(module);
		tooltipLoader(module);
		userLoader(module);
		clientEnumsLoader(module);
		serviceStatusMonitorLoader(module);
		identifierLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 613 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(614), __webpack_require__(615), __webpack_require__(616)], __WEBPACK_AMD_DEFINE_RESULT__ = function (clientEnumsLoader, enumTranslatorLoader, enumsKeyResolverLoader) {
    'use strict';

    return function (module) {
        clientEnumsLoader(module);
        enumTranslatorLoader(module);
        enumsKeyResolverLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 614 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP4K}
// di.einvoicing.ui.portal.components.clientEnums
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.constant('CLIENT_ENUMS', clientEnums());

		function clientEnums() {
			return {
				documentType: {
					languageKey: 'DOCUMENT_TYPE',
					unknown: 1,
					invoice: 2,
					purchaseOrder: 3,
					goodsReceiptNote: 4
				},
				documentSource: {
					languageKey: 'DOCUMENT_SOURCE',
					unknown: 1,
					integration: 2,
					websiteUser: 3,
					websiteFlip: 4
				},
				documentStateKey: {
					languageKey: 'DOCUMENT_STATE',
					unknown: 1,
					invalid: 2,
					pending: 3,
					beingProcessed: 4,
					reconciliationInvalid: 5,
					onHold: 6,
					beingSent: 7,
					sentreceived: 8,
					accepted: 9,
					shipped: 10,
					delivered: 11,
					scheduled: 12,
					overdue: 13,
					paymentSent: 14,
					paymentReceived: 15,
					inDispute: 16,
					rejected: 17,
					closed: 18,
					cancelled: 19,
					exportFailed: 20,
					invalidDraft: 21,
					sendFailed: 22,
					partiallyInvoiced: 23,
					fullyInvoiced: 24
				},
				documentAttribute: {
					languageKey: 'DOCUMENT_ATTRIBUTE',
					unknown: 1,
					schemaInvalid: 2,
					released: 3,
					shipped: 4,
					delivered: 5,
					scheduledForPayment: 6,
					overdue: 7,
					paymentSent: 8,
					paymentReceived: 9,
					inDispute: 10,
					reconciliationFailed: 11,
					businessInvalid: 12,
					documentSourceWebsite: 13,
					partiallyInvoiced: 14,
					fullyInvoiced: 15,
					documentSourceErp: 16,
					xsltInvalid: 17,
					notShipped: 101,
					notDelivered: 102,
					notInvoiced: 103,
					notPaymentSent: 104,
					notPaymentReceived: 105,
					notOverdue: 106,
					notScheduledForPayment: 107,
					notInDispute: 108,
					notSaved: 201,
					saved: 202,
					current: 203,
					hasServerId: 204,
					justFlipped: 205
				},
				eventType: {
					languageKey: 'EVENT_TYPE',
					unknown: 1,
					invoiceChanged: 2,
					purchaseOrderFlipped: 3,
					purchaseOrderImported: 4,
					invoiceImported: 5,
					documentScheduled: 6,
					invoiceExported: 7,
					invoiceCreated: 8,
					legalOriginalCreated: 9,
					goodsReceiptNoteImported: 10,
					eInvoicingStateChanged: 11,
					documentAttributeAdded: 12,
					documentAttributeRemoved: 13,
					documentMismatch: 14,
					documentMatched: 15,
					documentAttachmentAdded: 16,
					documentAttachmentUpdated: 17,
					documentAttachmentRemoved: 18,
					invoiceImportFailed: 19,
					purchaseOrderImportFailed: 20,
					goodsReceiptNoteImportFailed: 21,
					invoicePaid: 22,
					invoiceCancelled: 23,
					purchaseOrderCancelled: 24,
					documentAccepted: 25,
					invoiceDisputed: 26,
					overReceivedGoods: 27,
					invoiceOverdue: 28,
					invoiceDisputeCompleted: 29,
					relationshipVerificationFailed: 30,
					unknownFileFormat: 31,
					invoiceSent: 32,
					purchaseOrderSent: 33,
					invoiceReceived: 34,
					purchaseOrderReceived: 35,
					documentBusinessInvalid: 36,
					invoiceUnPaid: 37,
					documentRejected: 38,
					sendFailed: 39,
					schemaValidationFailed: 40,
					purchaseOrderChanged: 41,
					markAsImported: 42,
					manuallyMarkAsImported: 43,
					buyerPartyAutoProfiled: 44
				},
				productType: {
					languageKey: 'PRODUCT_TYPE',
					product: 1,
					service: 2,
					delivery: 3,
					customs: 4
				},
				orderType: {
					languageKey: 'ORDER_TYPE',
					order: 1,
					blanketOrder: 2,
					spotOrder: 3,
					leaseOrder: 4,
					rushOrder: 5,
					repairOrder: 6,
					callOffOrder: 7,
					consignmentOrder: 8,
					sampleOrder: 9,
					swapOrder: 10,
					purchaseOrderChangeRequest: 11,
					purchaseOrderResponse: 12,
					hireOrder: 13,
					sparePartsOrder: 14
				},
				invoiceType: {
					languageKey: 'INVOICE_TYPE',
					commercialInvoice: 1,
					correctedInvoice: 2,
					factoredInvoice: 3
				},
				notificationFrequency: {
					languageKey: 'NOTIFICATION_FREQUENCY',
					never: 1,
					immediate: 2,
					every10Minutes: 3,
					every30Minutes: 4,
					hourly: 5,
					daily: 6
				},
				documentCreationFailureReason: {
					languageKey: 'DOCUMENT_CREATION_FAILURE_REASON',
					none: 0,
					duplicateDocument: 1,
					documentSchemaInvalid: 2,
					nonExistentParty: 3,
					noTradingRelationship: 4,
					noOriginatorFileFormatLink: 5,
					mappingFailure: 6,
					versionNumberConflict: 7
				},
				roles: {
					administrator: 1,
					buyerSupervisor: 2,
					buyerClerk: 3,
					supplierSupervisor: 4,
					supplierClerk: 5,
					buyerAuditor: 6
				},
				serviceState: {
					languageKey: 'SERVICE_STATE',
					maintenance: 0,
					up: 1,
					down: 2
				},
				userActions: {
					languageKey: 'USER_ACTIONS',
					unknown: 1,
					viewInvoice: 2,
					viewPurchaseOrder: 3,
					viewGoodsReceiptNote: 4,
					editInvoice: 5,
					commit: 6,
					accept: 7,
					cancelInvoice: 8,
					cancelPurchaseOrder: 9,
					close: 10,
					startDispute: 11,
					endDispute: 12,
					reject: 13,
					release: 14,
					submit: 15,
					markAsPaidBuyer: 16,
					markAsNotPaidBuyer: 17,
					markAsPaidSupplier: 18,
					markAsNotPaidSupplier: 19,
					markAsScheduledForPayment: 20,
					markAsNotScheduledForPayment: 21,
					markAsShipped: 22,
					markAsNotShipped: 23,
					markAsDelivered: 24,
					markAsNotDelivered: 25,
					remove: 26,
					save: 27,
					enable: 28,
					disable: 29,
					unlock: 30,
					downloadInvoice: 31,
					downloadPurchaseOrder: 32,
					downloadGoodsReceiptNote: 33,
					viewHistoryInvoice: 34,
					viewHistoryPurchaseOrder: 35,
					viewHistoryGoodsReceiptNote: 36,
					viewAttachements: 37,
					viewRelatedDocumentsInvoice: 38,
					viewRelatedDocumentsPurchaseOrder: 39,
					viewRelatedDocumentsGoodsReceiptNote: 40,
					flip: 41,
					viewUser: 42,
					editUser: 43,
					download: 44,
					viewHistory: 45,
					viewRelatedDocuments: 46,
					resetPassword: 47,
					showIssues: 48,
					downloadAsCsv: 49,
					markAsInvoiced: 50,
					createUser: 51,
					generatePassword: 52,
					deleteUser: 53
				},
				partyCodeType: {
					languageKey: 'PARTYCODE_TYPE',
					unknown: 1,
					default: 2,
					endpoint: 3,
					taxReference: 4
				},
				schemes: {
					languageKey: 'SCHEME',
					5: 'DUNS',
					6: 'GLN',
					38: 'GB:VAT',
					62: 'ZZZ'
				},
				locationType: {
					languageKey: 'LOCATION_TYPE',
					Unknown: 1,
					Business: 2,
					Delivery: 3,
					Accounting: 4
				}
			};
		}

		return clientEnums;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 615 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP4I}
// di.einvoicing.ui.portal.components.clientEnums
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;

        module.factory('enumTranslator', enumTranslator);

        enumTranslator.$inject = ['translator'];

        function enumTranslator(translator) {
            return {
                getLanguageKey: getLanguageKey,
                translate: translate,
                instantTranslate: instantTranslate,
                translateCollection: translateCollection
            };

            /**
             * Gets the language key for the given enum value
             */
            function getLanguageKey(enumObject, enumValue) {
                guard.throwIfNotAnObject("EUP4I01E", enumObject, 'enumObject');
                guard.throwIfInvalidId("EUP4I02E", enumValue, 'enumValue');

                var enumLanguageKey = enumObject.languageKey;
                var languageKey = 'EINVOICING.COMPONENTS.CLIENT_ENUMS.' + enumLanguageKey + '.' + enumValue;

                return languageKey;
            }

            /**
             * Gives the translation of the language key of the given enum value
             */
            function translate(enumObject, enumValue) {
                guard.throwIfNotAnObject("EUP4I07E", enumObject, 'enumObject');
                guard.throwIfInvalidId("EUP4I08E", enumValue, 'enumValue');

                var languageKey = getLanguageKey(enumObject, enumValue);
                return translator.translate(languageKey);
            }

            function instantTranslate(enumObject, enumValue) {
                guard.throwIfNotAnObject("EUP4I07E", enumObject, 'enumObject');
                guard.throwIfInvalidId("EUP4I08E", enumValue, 'enumValue');

                var languageKey = getLanguageKey(enumObject, enumValue);
                return translator.instantTranslate(languageKey);
            }

            /**
             * Maps the language keys for all items in the given collection
             * @param enumName
             * @param items
             * @param idPropertyName
             * @param textPropertyName
             */
            function translateCollection(enumObject, items, idPropertyName, textPropertyName) {
                guard.throwIfNotAnObject("EUP4I03E", enumObject, 'enumObject');
                guard.throwIfNotArray("EUP4I04E", items, 'items');
                guard.throwIfEmptyString("EUP4I05E", idPropertyName, 'idPropertyName');
                guard.throwIfEmptyString("EUP4I06E", textPropertyName, 'textPropertyName');

                translator.whenReady().then(function () {
                    for (var i = 0; i < items.length; i++) {
                        items[i][textPropertyName] = translator.instantTranslate(getLanguageKey(enumObject, items[i][idPropertyName]));
                    }
                });
            }
        }

        return enumTranslator;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 616 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//{CODE:EUP7A}
// di.einvoicing.ui.portal.components.clientEnums
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.factory('enumsKeyResolver', enumsKeyResolver);

		enumsKeyResolver.$inject = ['userRightsRepository'];

		function enumsKeyResolver(userRightsRepository) {
			return {
				getEnumsForCurrentRole: getEnumsForCurrentRole
			};

			/**
    * Creates a copy of enum object with changed values             
    */
			function getEnumsForCurrentRole(obj, docType) {
				if (null == obj || "object" != (typeof obj === 'undefined' ? 'undefined' : _typeof(obj))) {
					return obj;
				}

				var copy = obj.constructor();
				for (var attr in obj) {
					if (obj.hasOwnProperty(attr)) copy[attr] = obj[attr];
				}

				var roleName = getRoleName();

				var newKey = obj.languageKey;

				if (util.isNonEmptyString(docType)) {
					newKey += "_" + docType.toUpperCase();
				}

				if (util.isNonEmptyString(roleName)) {
					newKey += "_" + roleName;
				}

				copy.languageKey = newKey;

				return copy;

				/**
     * Gets role name for language key             
     */
				function getRoleName() {
					var isSupplier = userRightsRepository.userHasRight("Supplier");
					var isBuyer = userRightsRepository.userHasRight("Buyer");

					var role = '';

					if (isSupplier) {
						role = "SUPPLIER";
					} else if (isBuyer) {
						role = "BUYER";
					}

					return role;
				}
			}
		}

		return enumsKeyResolver;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 617 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP5F}
// di.einvoicing.ui.portal.components
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(619), __webpack_require__(618)], __WEBPACK_AMD_DEFINE_RESULT__ = function (dropdownSelectorDirectiveLoader, dropdownSelectorControllerLoader) {
    'use strict';

    return function (module) {
        dropdownSelectorDirectiveLoader(module);
        dropdownSelectorControllerLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 618 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP1V}
// di.einvoicing.ui.portal.components
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var util = $di.utility.util;

        module.controller('DropdownSelectorController', DropdownSelectorController);

        DropdownSelectorController.$inject = ['$scope'];

        function DropdownSelectorController(scope) {
            var vm = this;

            vm.items = [];
            vm.item = {};
            vm.onChangeAccessor = setBoundIdFromSelectedItem;

            setWatches();

            return;

            function setWatches() {
                var unwatch = scope.$watchCollection('items', function () {
                    if (scope.items && scope.items.length > 0) {
                        vm.items.fill(scope.items);
                        setSelectedItemFromBoundId();
                        unwatch();
                    }
                });

                scope.$watch(function () {
                    var obj = scope.bindToObject || {};

                    return obj[scope.bindToProperty];
                }, setSelectedItemFromBoundId);

                return;

                function setSelectedItemFromBoundId() {
                    var bindToObject = scope.bindToObject || {};

                    if (util.isDefined(vm.item) && bindToObject[scope.bindToProperty] === vm.item.id) {
                        return;
                    }

                    var item = _.find(vm.items, function (item) {
                        return item.id === bindToObject[scope.bindToProperty];
                    });

                    if (util.isUndefined(item)) {
                        return;
                    }

                    vm.item = item;
                }
            }

            function setBoundIdFromSelectedItem() {
                var accessor;

                if (util.isFunction(scope.onChangeAccessor)) {
                    accessor = scope.onChangeAccessor();

                    if (util.isFunction(accessor)) {
                        accessor(vm.item);
                    }
                }
            }
        }

        return DropdownSelectorController;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 619 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP5E}
// di.einvoicing.ui.portal.components
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;
		module.directive('diDropdownSelector', diDropdownSelector);

		function diDropdownSelector() {
			return {
				restrict: 'E',
				replace: true,
				scope: {
					items: "=",
					bindToObject: '=',
					bindToProperty: '@',
					validationName: "@",
					isMandatory: "=",
					noSearch: "=",
					validationMessage: '@',
					onChangeAccessor: '&',
					itemCompare: '='
				},
				controller: 'DropdownSelectorController',
				controllerAs: 'dropdownSelectorCtrl',
				template: template,
				compile: compile
			};

			function compile(element, attrs) {
				if (util.isUndefined(attrs.isMandatory) || attrs.isMandatory === "false") {
					var inputs = element.find('input');
					_.each(inputs, function (item) {
						item.setAttribute('di-validate', 'ignored');
						item.setAttribute('validation-name', 'ignored');
						item.removeAttribute('validation-message');
						item.removeAttribute('validation-model-display-name');
						item.removeAttribute('validation-message-position');
					});
				}
			}

			function template(element, attrs) {
				var html = '<div>\
								<di-select';

				if (attrs.noSearch) {
					html += ' mode="dropdown"';
				} else {
					html += ' mode="dropdownSearch"';
				}
				html += ' items="dropdownSelectorCtrl.items"\
				            item-unique-property="id"\
				            bind-to-object="dropdownSelectorCtrl"\
				            bind-to-property="item"\
				            display-property="name"\
				            searchable-properties="name"\
				            on-change-accessor="dropdownSelectorCtrl.onChangeAccessor"\
				            watch-binding="true"\
				            placeholder="EINVOICING.PORTAL.INVOICES.EDITOR.COMPONENTS.DETAILS.SEARCH"';

				if (util.isUndefined(attrs.isMandatory) || attrs.isMandatory === "true") {
					html += getValidationHtml(attrs);
				}

				html += '>{{::filteredItem.item.name}}\
								</di-select>\
							</div>';

				return html;

				function getValidationHtml(attrs) {
					var innerHtml = "";

					if (util.isDefined(attrs.validationName)) {
						var displayName = attrs.validationName;
						if (util.isDefined(attrs.validationModelDisplayName)) {
							displayName = attrs.validationModelDisplayName;
						}

						innerHtml += 'di-validate="{{::validationName}}"\
									  validation-message="{{::validationMessage}}"\
									  validation-model="bindToObject[bindToProperty]"\
									  validation-model-display-name="' + displayName + '"';

						if (attrs.validationModel) {
							innerHtml += 'validation-model="validationModel" ';
						}
					}

					return innerHtml;
				}
			}
		}

		return diDropdownSelector;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 620 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP19}
// di.einvoicing.ui.portal.components
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(621), __webpack_require__(622), __webpack_require__(623)], __WEBPACK_AMD_DEFINE_RESULT__ = function (snippetsLoader, headerDataLoader, headerControllerLoader) {
    'use strict';

    return function (module) {
        headerControllerLoader(module);
        headerDataLoader(module);
        snippetsLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 621 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

// di.einvoicing.ui.portal._components._snippets
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var snippetContext = $di.angular.snippetRegistrar.createContext(module, 'src/app/shared/components/header/_snippets');

		snippetContext.registerSnippet('diHeader', 'header.html', 'HeaderController', 'headerCtrl');
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 622 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP1C}
// di.einvoicing.ui.portal.components
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;

        module.factory('headerData', headerData);

        function headerData() {
            var service = {
                data: {
                    title: ''
                },
                set: set
            };

            return service;

            function set(header) {
                guard.throwIfNotAnObject("EUP1C01E", header, "header");

                service.data.title = header.title;
            }
        }

        return headerData;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 623 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP1B}
// di.einvoicing.ui.portal.components
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.controller('HeaderController', HeaderController);

        HeaderController.$inject = ['headerData', 'authenticationData', 'authenticationClientEventSubscriber', 'LOGGED_OUT_REASON'];

        function HeaderController(headerData, authenticationData, authenticationClientEventSubscriber, LOGGED_OUT_REASON) {
            var vm = this;

            vm.user = {};
            vm.data = headerData.data;
            vm.userData = authenticationData.userData;
            vm.logOut = logOut;

            return;

            function logOut() {
                authenticationClientEventSubscriber.loggedOut();
            }
        }

        return HeaderController;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 624 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP19}
// di.einvoicing.ui.portal.components
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(625)], __WEBPACK_AMD_DEFINE_RESULT__ = function (identifierFactoryLoader) {
    'use strict';

    return function (module) {
        identifierFactoryLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 625 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP5L}
// di.einvoicing.ui.portal.proxies
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
			'use strict';

			return function (module) {
						var util = $di.utility.util;

						module.factory('identifierFactory', identifierFactory);

						identifierFactory.$inject = ['translator', 'modalWindow'];

						function identifierFactory(translator, modalWindow) {
									return {
												create: create,
												edit: edit,
												getDefaultOptions: getDefaultOptions
									};

									function create(scheme, schemeId, code, codeDescription) {
												var description = "";

												if (util.isNonEmptyString(scheme)) {
															description = translator.instantTranslate("EINVOICING.COMPONENTS.CLIENT_ENUMS.SCHEMES." + scheme);
												}

												var codeDesc = undefined;

												if (util.isNonEmptyString(codeDescription)) {
															codeDesc = '(' + codeDescription + ')';
												}

												var display = "";

												if (util.isNonEmptyString(scheme)) {

															display = translator.instantTranslate("EINVOICING.PORTAL.COMPONENTS.IDENTIFIER_SELECTOR.DISPLAY", { scheme: description, code: code, codeDesc: codeDesc });
												} else {
															display = translator.instantTranslate("EINVOICING.PORTAL.COMPONENTS.IDENTIFIER_SELECTOR.DISPLAY_NO_SCHEME", { code: code, codeDesc: codeDesc });
												}

												var displayValue = display;
												var label = display;

												if (util.isNonEmptyString(code) === false || util.isNullOrUndefined(code)) {
															code = "", description = "";
															scheme = "";
															displayValue = "";
															label = translator.instantTranslate("EINVOICING.PORTAL.COMPONENTS.IDENTIFIER_SELECTOR.NONE");
												}

												return {
															identifier: scheme + code,
															code: code,
															codeDescription: codeDesc,
															scheme: scheme,
															schemeId: schemeId,
															schemeDescription: description,
															displayValue: displayValue,
															label: label
												};
									}

									function edit(partyCode, schemes, relatedParties, validationPropertyName, callback, buttonLabels, validate, partyId, partyCodeType) {
												formatSchemesForClient(schemes);

												var options = {
															dataModel: {
																		id: partyCode.id,
																		partyId: partyId,
																		partyCodeType: partyCodeType,
																		code: partyCode.code,
																		identifier: partyCode.code,
																		scheme: {
																					name: partyCode.scheme,
																					id: partyCode.schemeId,
																					value: partyCode.scheme
																		},
																		schemeId: partyCode.schemeId,
																		relatedParty: partyCode.relatedPartyDetails,
																		relatedParties: relatedParties,
																		options: schemes,
																		arrayName: 'edit',
																		action: undefined,
																		validationPropertyName: validationPropertyName,
																		isEditable: true
															},
															validateOnSave: validate,
															dropdownName: 'scheme',
															controller: "ResourceController",
															templateUrl: 'src/app/portal/invoices/editor/_components/invoiceDetails/identifierPopup.html',
															onDataChanged: function onDataChanged() {},
															title: translator.instantTranslate("EINVOICING.PORTAL.COMPONENTS.IDENTIFIER_SELECTOR.ADD_NEW_IDENTIFIER_TITLE")
												};

												var labels = {};

												if (util.isDefined(buttonLabels)) {
															labels = buttonLabels;
												}

												options.save = labels.save || "EINVOICING.PORTAL.COMPONENTS.IDENTIFIER_SELECTOR.ACTIONS.SAVE";
												options.cancel = labels.cancel || "EINVOICING.PORTAL.COMPONENTS.IDENTIFIER_SELECTOR.ACTIONS.CANCEL";

												showPopup(options, callback);
									}

									function getDefaultOptions(schemeOptions, arrayName, validationPropertyname, allowBlank, action, buttonLabels, validate) {
												formatSchemesForClient(schemeOptions);

												if (allowBlank) {
															schemeOptions.unshift({
																		code: "",
																		numericalCode: "",
																		sortOrder: 0,
																		isEnabled: true,
																		id: 0,
																		displayValue: "",
																		showLabel: true,
																		label: translator.instantTranslate("EINVOICING.PORTAL.COMPONENTS.IDENTIFIER_SELECTOR.NONE")
															});
												}

												var none = {
															identifier: "",
															code: "",
															scheme: "",
															schemeDescription: "",
															displayValue: "",
															showLabel: true,
															label: translator.instantTranslate("EINVOICING.PORTAL.COMPONENTS.IDENTIFIER_SELECTOR.NONE")
												};

												var addNew = _.extend(_.clone(none), { addNew: addNewItem });

												addNew.identifier = "NEW";
												addNew.label = translator.instantTranslate("EINVOICING.PORTAL.COMPONENTS.IDENTIFIER_SELECTOR.ADD_NEW");

												var array = [none, addNew];

												return array;

												function addNewItem(callback, partyId, partyCodeType) {
															var options = {
																		dataModel: {
																					partyId: partyId,
																					partyCodeType: partyCodeType,
																					identifier: '',
																					scheme: schemeOptions[0],
																					options: schemeOptions,
																					arrayName: arrayName,
																					action: action,
																					validationPropertyName: validationPropertyname,
																					isEditable: true
																		},
																		validateOnSave: validate,
																		dropdownName: 'scheme',
																		controller: "ResourceController",
																		templateUrl: 'src/app/portal/invoices/editor/_components/invoiceDetails/identifierPopup.html',
																		onDataChanged: function onDataChanged() {},
																		title: translator.instantTranslate("EINVOICING.PORTAL.COMPONENTS.IDENTIFIER_SELECTOR.ADD_NEW_IDENTIFIER_TITLE")
															};

															var labels = {};

															if (util.isDefined(buttonLabels)) {
																		labels = buttonLabels;
															}

															options.save = labels.save || "EINVOICING.PORTAL.COMPONENTS.IDENTIFIER_SELECTOR.ACTIONS.SET";
															options.cancel = labels.cancel || "EINVOICING.PORTAL.COMPONENTS.IDENTIFIER_SELECTOR.ACTIONS.CANCEL";

															showPopup(options, callback);
												}
									}

									function showPopup(options, callback) {
												modalWindow.show(options, function (result) {

															var display;

															if (util.isNonEmptyString(result.scheme.name)) {

																		display = translator.instantTranslate("EINVOICING.PORTAL.COMPONENTS.IDENTIFIER_SELECTOR.DISPLAY", {
																					scheme: result.scheme.name,
																					code: result.code,
																					codeDesc: result.codeDescription
																		});
															} else {
																		display = translator.instantTranslate("EINVOICING.PORTAL.COMPONENTS.IDENTIFIER_SELECTOR.DISPLAY_NO_SCHEME", { code: result.code, codeDesc: result.codeDescription });
															}

															var newItem = {
																		id: result.id,
																		identifier: result.scheme.value + result.code,
																		code: result.code,
																		codeDescription: result.codeDescription,
																		scheme: result.scheme.value,
																		schemeId: result.scheme.id,
																		schemeDescription: result.scheme.name,
																		relatedParty: result.relatedParty,
																		displayValue: display,
																		label: display
															};

															if (util.isFunction(result.action)) {
																		result.action(newItem, result.arrayName);
															}

															callback(newItem);
												}, function () {});
									}

									function formatSchemesForClient(schemes) {
												var schemeTranslationPrefix = "EINVOICING.COMPONENTS.CLIENT_ENUMS.SCHEMES.";

												_.each(schemes, function (scheme) {
															scheme.name = translator.instantTranslate(schemeTranslationPrefix + scheme.code);
															scheme.value = scheme.code;
												});
									}
						}

						return identifierFactory;
			};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 626 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP4P}
// di.einvoicing.ui.portal.components.image
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(627)], __WEBPACK_AMD_DEFINE_RESULT__ = function (imagesLoader) {
    'use strict';

    return function (module) {
        imagesLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 627 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP4R}
// di.einvoicing.ui.portal.components.image
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.constant('IMAGES', images());

		function images() {
			return {
				edit: {
					viewBox: '0 0 1789 1413',
					preserveAspectRatio: 'xMidYMid',
					data: 'M890.5,1058.5l116,-116l-152,-152l-116,116l0,56l96,0l0,96l56,0zm440,-720q-16,-16 -33,1l-350,350q-17,17 -1,33t33,-1l350,-350q17,-17 1,-33zm80,594l0,190q0,119 -84.5,203.5t-203.5,84.5l-832,0q-119,0 -203.5,-84.5t-84.5,-203.5l0,-832q0,-119 84.5,-203.5t203.5,-84.5l832,0q63,0 117,25q15,7 18,23q3,17 -9,29l-49,49q-14,14 -32,8q-23,-6 -45,-6l-832,0q-66,0 -113,47t-47,113l0,832q0,66 47,113t113,47l832,0q66,0 113,-47t47,-113l0,-126q0,-13 9,-22l64,-64q15,-15 35,-7t20,29zm-96,-738l288,288l-672,672l-288,0l0,-288l672,-672zm444,132l-92,92l-288,-288l92,-92q28,-28 68,-28t68,28l152,152q28,28 28,68t-28,68Z'
				},
				view: {
					viewBox: '0 0 1792 1792',
					preserveAspectRatio: 'xMidYMid',
					data: 'M1664 960q-152-236-381-353 61 104 61 225 0 185-131.5 316.5t-316.5 131.5-316.5-131.5-131.5-316.5q0-121 61-225-229 117-381 353 133 205 333.5 326.5t434.5 121.5 434.5-121.5 333.5-326.5zm-720-384q0-20-14-34t-34-14q-125 0-214.5 89.5t-89.5 214.5q0 20 14 34t34 14 34-14 14-34q0-86 61-147t147-61q20 0 34-14t14-34zm848 384q0 34-20 69-140 230-376.5 368.5t-499.5 138.5-499.5-139-376.5-368q-20-35-20-69t20-69q140-229 376.5-368t499.5-139 499.5 139 376.5 368q20 35 20 69z'
				},
				refresh: {
					viewBox: '0 0 1792 1792',
					preserveAspectRatio: 'xMidYMid',
					data: 'M1639 1056q0 5-1 7-64 268-268 434.5t-478 166.5q-146 0-282.5-55t-243.5-157l-129 129q-19 19-45 19t-45-19-19-45v-448q0-26 19-45t45-19h448q26 0 45 19t19 45-19 45l-137 137q71 66 161 102t187 36q134 0 250-65t186-179q11-17 53-117 8-23 30-23h192q13 0 22.5 9.5t9.5 22.5zm25-800v448q0 26-19 45t-45 19h-448q-26 0-45-19t-19-45 19-45l138-138q-148-137-349-137-134 0-250 65t-186 179q-11 17-53 117-8 23-30 23h-199q-13 0-22.5-9.5t-9.5-22.5v-7q65-268 270-434.5t480-166.5q146 0 284 55.5t245 156.5l130-129q19-19 45-19t45 19 19 45z'
				},
				download: {
					viewBox: '0 0 1792 1600',
					preserveAspectRatio: 'xMidYMid',
					data: 'M1344 1344q0-26-19-45t-45-19-45 19-19 45 19 45 45 19 45-19 19-45zm256 0q0-26-19-45t-45-19-45 19-19 45 19 45 45 19 45-19 19-45zm128-224v320q0 40-28 68t-68 28h-1472q-40 0-68-28t-28-68v-320q0-40 28-68t68-28h465l135 136q58 56 136 56t136-56l136-136h464q40 0 68 28t28 68zm-325-569q17 41-14 70l-448 448q-18 19-45 19t-45-19l-448-448q-31-29-14-70 17-39 59-39h256v-448q0-26 19-45t45-19h256q26 0 45 19t19 45v448h256q42 0 59 39z'
				},
				downloadCsv: {
					viewBox: '0 0 14 14.7',
					preserveAspectRatio: 'xMidYMid',
					data: 'M12.2,5.2h-0.4V4h-0.6v1.2H1.7V0.6h9.1V0H1.7C1.4,0,1.2,0.3,1.2,0.6v4.7H0.8C0.4,5.2,0,5.6,0,6.1v4.3c0,0.5,0.4,0.8,0.8,0.8 h0.4v2.9c0,0.3,0.3,0.6,0.6,0.6h9.5c0.3,0,0.6-0.3,0.6-0.6v-2.9h0.4c0.5,0,0.8-0.4,0.8-0.8V6.1C13,5.6,12.6,5.2,12.2,5.2z M6.1,8.4 C5.4,8.1,4.9,7.7,4.9,7.1c0-0.7,0.6-1.3,1.6-1.3C7,5.8,7.4,5.9,7.6,6L7.4,6.8C7.2,6.7,6.9,6.6,6.5,6.6C6.1,6.6,5.9,6.8,5.9,7 c0,0.3,0.2,0.4,0.8,0.6c0.8,0.3,1.1,0.7,1.1,1.3c0,0.7-0.6,1.3-1.7,1.3c-0.5,0-1-0.1-1.2-0.3L5,9.2c0.3,0.1,0.7,0.3,1.1,0.3 c0.4,0,0.7-0.2,0.7-0.5C6.8,8.7,6.6,8.6,6.1,8.4z M1,8.1c0-1.5,1-2.3,2.3-2.3c0.5,0,0.9,0.1,1.1,0.2L4.2,6.8C4,6.7,3.7,6.6,3.4,6.6 C2.6,6.6,2,7.1,2,8c0,0.9,0.5,1.4,1.4,1.4c0.3,0,0.6-0.1,0.8-0.1L4.4,10c-0.2,0.1-0.6,0.2-1.1,0.2C1.8,10.2,1,9.3,1,8.1z M11.2,13.9 H1.7v-2.8h9.5V13.9z M10.6,10.2H9.5L8.1,5.9h1.1l0.5,1.8c0.1,0.5,0.3,1,0.4,1.5h0c0.1-0.5,0.2-1,0.4-1.5L11,5.9h1L10.6,10.2z M11.7,1V0.1L14,2l-2.3,1.9V2.9c-1.6-0.1-2.5,0.6-3.3,1.4C8.4,2.5,10,1,11.7,1z'
				},
				submit: {
					viewBox: '0 0 1792 1792',
					preserveAspectRatio: 'xMidYMid',
					data: 'M1764 11q33 24 27 64l-256 1536q-5 29-32 45-14 8-31 8-11 0-24-5l-453-185-242 295q-18 23-49 23-13 0-22-4-19-7-30.5-23.5t-11.5-36.5v-349l864-1059-1069 925-395-162q-37-14-40-55-2-40 32-59l1664-960q15-9 32-9 20 0 36 11z'
				},
				plus: {
					width: 10,
					height: 10,
					data: 'M10.000,4.000 L6.000,4.000 L6.000,0.000 L4.000,0.000 L4.000,4.000 L0.000,4.000 L0.000,6.000 L4.000,6.000 L4.000,10.000 L6.000,10.000 L6.000,6.000 L10.000,6.000 L10.000,4.000 Z',
					preserveAspectRatio: 'xMidYMid',
					pathStyles: {
						'fill-rule': 'evenodd'
					}
				},
				calendar: getSvgImage(-117, 8, 16, 16, 'M-103,24h-12c-1,0-2-1-2-2V11c0-0.9,0.2-2,1-2h1v3h4V9h4v3h4V9h1c0.8,0,1,1.1,1,2v11 C-101,22.9-102.2,24-103,24z M-103,14h-12v8h12V14z M-105,11c-0.3,0-1-0.7-1-1V9c0-0.3,0.7-1,1-1s1,0.7,1,1v1 C-104,10.3-104.7,11-105,11z M-113,11c-0.3,0-1-0.7-1-1V9c0-0.3,0.7-1,1-1s1,0.7,1,1v1C-112,10.3-112.7,11-113,11z'),
				filter: getSvgImage(-117, 10, 16, 12, 'M-117,10l6,6v6l4-1v-5l6-6H-117z'),
				sort: getSvgImage(-117, 10, 16, 12, 'M-109,21l-6-6h3V8h6v7h3L-109,21z'),
				logo: getSrcImage('logo.svg'),
				info: getSvgImage(-297, 389, 16, 16, 'M-289,405c-4.4,0-8-3.6-8-8s3.6-8,8-8s8,3.6,8,8S-284.6,405-289,405z M-289,390.2c-3.7,0-6.8,3-6.8,6.8s3,6.8,6.8,6.8s6.8-3,6.8-6.8S-285.3,390.2-289,390.2z M-288.2,394c-0.1,0.1-0.5,0.1-0.6,0c-0.1-0.1-0.2-0.2-0.2-0.5c0-0.1,0.1-0.3,0.1-0.4c0.1-0.1,0.4-0.2,0.6-0.2c0.2,0,0.3,0.1,0.3,0.1c0.1,0.1,0.1,0.2,0.1,0.4C-287.9,393.7-288,393.9-288.2,394zM-288.4,396.2c-0.1,0.7-0.6,2.7-0.7,3.4c0,0.2,0,0.3,0.1,0.3c0.2,0,0.4-0.2,0.8-0.6c0,0,0,0,0,0c0,0.1,0,0.3,0,0.4c-0.6,0.8-1.4,1.2-1.7,1.2c-0.3,0-0.4-0.4-0.2-1.3c0.2-1,0.5-2.3,0.6-3.1c0-0.2,0-0.3-0.1-0.3c-0.1,0-0.4,0.1-0.7,0.4c0,0,0,0,0,0c0-0.1,0-0.3,0.1-0.3c0.5-0.5,1.3-1.1,1.7-1.1C-288.3,395.3-288.2,395.6-288.4,396.2z'),
				alert: getSvgImage(-297, 389, 16, 16, 'M-284,398v-4.5c0-2.5-1.8-4.5-5-4.5s-5,2-5,4.5v4.5l-3,5h5c0.3,1.2,1.6,2,3,2s2.7-0.8,3-2h5L-284,398zM-289,404c-0.7,0-1.8-0.4-2-1h4C-287.2,403.6-288.3,404-289,404z M-295,402l2-3.5v-4c0-2.4,1.5-4.5,4-4.5s4,2.1,4,4.5v4l2,3.5H-295z'),
				icoArrowDown: getSvgImage(-120, 12, 10, 7, 'M-110,13.5l-1-1.5l-4,4.5l-4-4.5l-1,1.5l5,5.5L-110,13.5z'),
				invoices: {
					viewBox: '0 0 1792 1792',
					preserveAspectRatio: 'xMidYMid',
					data: 'M256 1312v192q0 13-9.5 22.5t-22.5 9.5h-192q-13 0-22.5-9.5t-9.5-22.5v-192q0-13 9.5-22.5t22.5-9.5h192q13 0 22.5 9.5t9.5 22.5zm0-384v192q0 13-9.5 22.5t-22.5 9.5h-192q-13 0-22.5-9.5t-9.5-22.5v-192q0-13 9.5-22.5t22.5-9.5h192q13 0 22.5 9.5t9.5 22.5zm0-384v192q0 13-9.5 22.5t-22.5 9.5h-192q-13 0-22.5-9.5t-9.5-22.5v-192q0-13 9.5-22.5t22.5-9.5h192q13 0 22.5 9.5t9.5 22.5zm1536 768v192q0 13-9.5 22.5t-22.5 9.5h-1344q-13 0-22.5-9.5t-9.5-22.5v-192q0-13 9.5-22.5t22.5-9.5h1344q13 0 22.5 9.5t9.5 22.5zm-1536-1152v192q0 13-9.5 22.5t-22.5 9.5h-192q-13 0-22.5-9.5t-9.5-22.5v-192q0-13 9.5-22.5t22.5-9.5h192q13 0 22.5 9.5t9.5 22.5zm1536 768v192q0 13-9.5 22.5t-22.5 9.5h-1344q-13 0-22.5-9.5t-9.5-22.5v-192q0-13 9.5-22.5t22.5-9.5h1344q13 0 22.5 9.5t9.5 22.5zm0-384v192q0 13-9.5 22.5t-22.5 9.5h-1344q-13 0-22.5-9.5t-9.5-22.5v-192q0-13 9.5-22.5t22.5-9.5h1344q13 0 22.5 9.5t9.5 22.5zm0-384v192q0 13-9.5 22.5t-22.5 9.5h-1344q-13 0-22.5-9.5t-9.5-22.5v-192q0-13 9.5-22.5t22.5-9.5h1344q13 0 22.5 9.5t9.5 22.5z'
				},
				visibility: getSvgImage(-0, 0, 16, 12, 'M15.9,5.4C15.8,5.3,15.2,3.8,13,2c-1.1-0.9-3.5-2-5-2C6.5,0,4.1,1.1,3,2C0.8,3.8,0.2,5.3,0.1,5.4 C0,5.7,0,6.1,0.1,6.4C0.2,6.5,0.8,8.2,3,10c1.1,0.9,3.5,2,5,2c1.5,0,3.9-1.1,5-2c2.2-1.8,2.8-3.5,2.9-3.6C16,6.1,16,5.7,15.9,5.4z M8,9C6.4,9,5,7.8,5,6c0-1.8,1.5-3,3-3c1.5,0,3,1.2,3,3C11,7.8,9.5,9,8,9z M8,4C7.1,4,6,5,6,6c0,1,1.1,2,2,2c0.9,0,2-1,2-2 C10,5,8.9,4,8,4z'),
				purchaseOrders: {
					viewBox: '0 0 1792 1792',
					preserveAspectRatio: 'xMidYMid',
					data: 'M1344 704q0-26-19-45t-45-19-45 19l-147 146v-293q0-26-19-45t-45-19-45 19-19 45v293l-147-146q-19-19-45-19t-45 19-19 45 19 45l256 256q19 19 45 19t45-19l256-256q19-19 19-45zm-640 832q0 53-37.5 90.5t-90.5 37.5-90.5-37.5-37.5-90.5 37.5-90.5 90.5-37.5 90.5 37.5 37.5 90.5zm896 0q0 53-37.5 90.5t-90.5 37.5-90.5-37.5-37.5-90.5 37.5-90.5 90.5-37.5 90.5 37.5 37.5 90.5zm128-1088v512q0 24-16 42.5t-41 21.5l-1044 122q1 7 4.5 21.5t6 26.5 2.5 22q0 16-24 64h920q26 0 45 19t19 45-19 45-45 19h-1024q-26 0-45-19t-19-45q0-14 11-39.5t29.5-59.5 20.5-38l-177-823h-204q-26 0-45-19t-19-45 19-45 45-19h256q16 0 28.5 6.5t20 15.5 13 24.5 7.5 26.5 5.5 29.5 4.5 25.5h1201q26 0 45 19t19 45z'
				},
				users: {
					viewBox: '0 0 1792 1792',
					preserveAspectRatio: 'xMidYMid',
					data: 'M529 896q-162 5-265 128h-134q-82 0-138-40.5t-56-118.5q0-353 124-353 6 0 43.5 21t97.5 42.5 119 21.5q67 0 133-23-5 37-5 66 0 139 81 256zm1071 637q0 120-73 189.5t-194 69.5h-874q-121 0-194-69.5t-73-189.5q0-53 3.5-103.5t14-109 26.5-108.5 43-97.5 62-81 85.5-53.5 111.5-20q10 0 43 21.5t73 48 107 48 135 21.5 135-21.5 107-48 73-48 43-21.5q61 0 111.5 20t85.5 53.5 62 81 43 97.5 26.5 108.5 14 109 3.5 103.5zm-1024-1277q0 106-75 181t-181 75-181-75-75-181 75-181 181-75 181 75 75 181zm704 384q0 159-112.5 271.5t-271.5 112.5-271.5-112.5-112.5-271.5 112.5-271.5 271.5-112.5 271.5 112.5 112.5 271.5zm576 225q0 78-56 118.5t-138 40.5h-134q-103-123-265-128 81-117 81-256 0-29-5-66 66 23 133 23 59 0 119-21.5t97.5-42.5 43.5-21q124 0 124 353zm-128-609q0 106-75 181t-181 75-181-75-75-181 75-181 181-75 181 75 75 181z'
				},
				companies: getSvgImage(-298, 389, 15, 16, 'M-290.5,389l7.5,6h-15L-290.5,389z M-295,395v8h-1v-8H-295z M-292,395v8h-1v-8H-292z M-288,395v8h-1v-8H-288z M-285,395v8h-1v-8H-285z M-284,403l1,2h-15l1-2'),
				individual: getSvgImage(-298, 389, 15, 16, 'M-285,405h-11c-0.9,0-2-1-2-2v-8.5c0-1,1.1-2,2-2h11c1,0.1,2,1,2,2v8.5C-283,403.9-284,405-285,405z M-288.5,392.5c0-2.4-1.5-2-1.5-2h-1c0,0-1.5-0.2-1.5,2h-1.5c0,0,0-0.9,0-1c0-2,2-2.5,2-2.5h3c0,0,2,0.6,2,2.5c0,0.1,0,1,0,1H-288.5z M-296,393.5h11c0.6,0,1,0.4,1,1v8.4c0,0.6-0.4,1.1-1,1.1h-11c-0.6,0-1-0.5-1-1.1v-8.4C-297,393.9-296.5,393.5-296,393.5z'),
				support: getSvgImage(-297, 389, 16, 16, 'M-283,401h-5l-5,4v-4h-2c-0.9,0-2-1-2-2v-8c0-1.4,1-2,2-2h12c0.9,0,2,1,2,2c0,1,0,8,0,8C-281,400-282,401-283,401z M-282,391c0-0.6-0.4-1-1-1h-12c-0.6,0-1,0.4-1,1v8c0,0.6,0.4,1,1,1h3v3l3-3h6c0.6,0,1-0.4,1-1V391z'),
				faq: getSvgImage(-297, 389, 16, 16, 'M-289,405c-4.4,0-8-3.6-8-8c0-4.4,3.6-8,8-8c4.4,0,8,3.6,8,8C-281,401.4-284.6,405-289,405z M-289,390.2c-3.7,0-6.8,3-6.8,6.8c0,3.7,3,6.8,6.8,6.8c3.7,0,6.8-3,6.8-6.8C-282.2,393.3-285.3,390.2-289,390.2z M-287,396.4c-0.1,0.2-0.3,0.3-0.5,0.5c-0.2,0.2-0.3,0.3-0.5,0.5c-0.2,0.2-0.3,0.3-0.4,0.5c-0.1,0.2-0.1,0.4-0.1,0.7v0.4h-1v-0.8c0-0.3,0.1-0.6,0.3-0.9c0.2-0.2,0.4-0.5,0.6-0.7c0.2-0.2,0.5-0.5,0.7-0.7c0.2-0.2,0.3-0.5,0.3-0.8c0-0.4-0.1-0.7-0.3-0.9c-0.2-0.2-0.6-0.3-1-0.3c-0.5,0-0.8,0.1-1.1,0.5c-0.3,0.3-0.4,0.7-0.4,1.2h-1c0-0.5,0.1-0.7,0.2-1c0.1-0.3,0.3-0.5,0.5-0.8c0.2-0.2,0.5-0.4,0.8-0.5c0.3-0.1,0.7-0.2,1-0.2c0.4,0,0.8,0.1,1.1,0.2c0.3,0.1,0.6,0.3,0.8,0.5c0.2,0.2,0.3,0.4,0.4,0.7c0.1,0.3,0.1,0.5,0.1,0.8c0,0.3-0.1,0.5-0.2,0.7C-286.7,396.1-286.9,396.3-287,396.4z M-288.5,401h-1v-1h1V401z'),
				search: {
					viewBox: '0 0 1792 1792',
					preserveAspectRatio: 'xMidYMid',
					data: 'M1216 832q0-185-131.5-316.5t-316.5-131.5-316.5 131.5-131.5 316.5 131.5 316.5 316.5 131.5 316.5-131.5 131.5-316.5zm512 832q0 52-38 90t-90 38q-54 0-90-38l-343-342q-179 124-399 124-143 0-273.5-55.5t-225-150-150-225-55.5-273.5 55.5-273.5 150-225 225-150 273.5-55.5 273.5 55.5 225 150 150 225 55.5 273.5q0 220-124 399l343 343q37 37 37 90z'
				},
				verticalOptions: getSvgImage(0, 0, 3, 15, 'M1.5,3C2.3,3,3,2.3,3,1.5C3,0.7,2.3,0,1.5,0C0.7,0,0,0.7,0,1.5 C0,2.3,0.7,3,1.5,3z M1.5,6C0.7,6,0,6.7,0,7.5C0,8.3,0.7,9,1.5,9C2.3,9,3,8.3,3,7.5C3,6.7,2.3,6,1.5,6z M1.5,12 C0.7,12,0,12.7,0,13.5C0,14.3,0.7,15,1.5,15C2.3,15,3,14.3,3,13.5C3,12.7,2.3,12,1.5,12z'),
				removeOptionalItem: getSvgImage(0, 0, 16, 16, 'M8,16c-4.4,0-8-3.6-8-8s3.6-8,8-8c4.4,0,8,3.6,8,8S12.4,16,8,16z M8,2C4.3,2,2,4.3,2,8c0,3.7,2.3,6,6,6c3.7,0,6-2.3,6-6C14,4.3,11.7,2,8,2z M10,11L8,9l-2,2l-1-1l2-2L5,6l1-1l2,2l2-2l1,1L9,8l2,2 L10,11z'),
				flip: {
					viewBox: '0 0 1792 1792',
					preserveAspectRatio: 'xMidYMid',
					data: 'M1696 384q40 0 68 28t28 68v1216q0 40-28 68t-68 28h-960q-40 0-68-28t-28-68v-288h-544q-40 0-68-28t-28-68v-672q0-40 20-88t48-76l408-408q28-28 76-48t88-20h416q40 0 68 28t28 68v328q68-40 128-40h416zm-544 213l-299 299h299v-299zm-640-384l-299 299h299v-299zm196 647l316-316v-416h-384v416q0 40-28 68t-68 28h-416v640h512v-256q0-40 20-88t48-76zm956 804v-1152h-384v416q0 40-28 68t-68 28h-416v640h896z'
				},
				paid: {
					viewBox: '0 0 1792 1792',
					preserveAspectRatio: 'xMidYMid',
					data: 'M704 1152h384v-96h-128v-448h-114l-148 137 77 80q42-37 55-57h2v288h-128v96zm512-256q0 70-21 142t-59.5 134-101.5 101-138 39-138-39-101.5-101-59.5-134-21-142 21-142 59.5-134 101.5-101 138-39 138 39 101.5 101 59.5 134 21 142zm512 256v-512q-106 0-181-75t-75-181h-1152q0 106-75 181t-181 75v512q106 0 181 75t75 181h1152q0-106 75-181t181-75zm128-832v1152q0 26-19 45t-45 19h-1792q-26 0-45-19t-19-45v-1152q0-26 19-45t45-19h1792q26 0 45 19t19 45z'
				},
				notPaid: {
					viewBox: '0 0 19.456 13.915',
					preserveAspectRatio: 'xMidYMid',
					data: 'M18.961,8.369c-0.33-0.565-0.777-1.014-1.346-1.343c-0.564-0.331-1.184-0.496-1.852-0.496c-0.669,0-1.288,0.165-1.853,0.496c-0.566,0.329-1.014,0.777-1.344,1.343c-0.331,0.565-0.496,1.184-0.496,1.854s0.165,1.288,0.496,1.854c0.33,0.565,0.778,1.015,1.344,1.343c0.565,0.331,1.184,0.496,1.853,0.496c0.668,0,1.288-0.165,1.852-0.496c0.566-0.328,1.016-0.776,1.346-1.343s0.494-1.184,0.494-1.854S19.292,8.934,18.961,8.369z M18.077,11.423c0.076,0.076,0.115,0.169,0.115,0.277c0,0.109-0.039,0.201-0.115,0.278l-0.555,0.556c-0.078,0.076-0.172,0.114-0.279,0.114s-0.201-0.038-0.277-0.114l-1.203-1.202l-1.202,1.202c-0.076,0.076-0.168,0.114-0.277,0.114c-0.109,0-0.201-0.038-0.278-0.114l-0.556-0.556c-0.077-0.077-0.114-0.169-0.114-0.278c0-0.108,0.038-0.201,0.114-0.277l1.202-1.202L13.45,9.019c-0.077-0.075-0.114-0.169-0.114-0.277c0-0.109,0.038-0.202,0.114-0.278l0.556-0.556c0.077-0.076,0.168-0.114,0.278-0.114c0.11,0,0.202,0.038,0.277,0.114l1.202,1.202l1.203-1.202c0.076-0.076,0.17-0.114,0.277-0.114s0.201,0.038,0.279,0.114l0.555,0.556c0.076,0.077,0.115,0.169,0.115,0.278c0,0.108-0.039,0.202-0.115,0.277l-1.201,1.202L18.077,11.423zM11.032,10.278H3.428c0-0.63-0.223-1.168-0.669-1.615C2.313,8.217,1.773,7.994,1.143,7.994V3.426c0.631,0,1.17-0.223,1.616-0.669c0.446-0.446,0.669-0.984,0.669-1.615h10.285c0,0.631,0.223,1.169,0.67,1.615c0.446,0.446,0.985,0.669,1.616,0.669V5.51c0.397,0.02,0.777,0.092,1.143,0.204V0.571c0-0.155-0.057-0.289-0.17-0.401C16.859,0.057,16.725,0,16.57,0H0.571C0.417,0,0.283,0.057,0.169,0.17C0.057,0.283,0,0.417,0,0.571v10.278c0,0.155,0.057,0.289,0.169,0.401c0.113,0.113,0.247,0.169,0.402,0.169h10.627C11.103,11.053,11.037,10.674,11.032,10.278zM11.24,4.443c-0.125-0.428-0.302-0.827-0.531-1.196c-0.229-0.369-0.531-0.669-0.906-0.901S9.018,1.999,8.571,1.999c-0.446,0-0.857,0.116-1.232,0.348S6.662,2.879,6.433,3.248C6.204,3.617,6.026,4.015,5.901,4.443S5.714,5.294,5.714,5.71c0,0.417,0.063,0.839,0.188,1.267s0.302,0.827,0.531,1.195c0.229,0.369,0.531,0.669,0.906,0.901s0.786,0.348,1.232,0.348c0.447,0,0.857-0.116,1.232-0.348s0.677-0.532,0.906-0.901c0.229-0.369,0.406-0.767,0.531-1.195s0.188-0.851,0.188-1.267C11.428,5.294,11.365,4.872,11.24,4.443z M10.285,7.994H6.857V7.138H8v-2.57H7.981C7.904,4.687,7.741,4.856,7.491,5.077L6.803,4.363l1.321-1.222h1.018v3.997h1.143V7.994z'
				},
				shipped: {
					viewBox: '0 0 1792 1792',
					preserveAspectRatio: 'xMidYMid',
					data: 'M640 1408q0-52-38-90t-90-38-90 38-38 90 38 90 90 38 90-38 38-90zm-384-512h384v-256h-158q-13 0-22 9l-195 195q-9 9-9 22v30zm1280 512q0-52-38-90t-90-38-90 38-38 90 38 90 90 38 90-38 38-90zm256-1088v1024q0 15-4 26.5t-13.5 18.5-16.5 11.5-23.5 6-22.5 2-25.5 0-22.5-.5q0 106-75 181t-181 75-181-75-75-181h-384q0 106-75 181t-181 75-181-75-75-181h-64q-3 0-22.5.5t-25.5 0-22.5-2-23.5-6-16.5-11.5-13.5-18.5-4-26.5q0-26 19-45t45-19v-320q0-8-.5-35t0-38 2.5-34.5 6.5-37 14-30.5 22.5-30l198-198q19-19 50.5-32t58.5-13h160v-192q0-26 19-45t45-19h1024q26 0 45 19t19 45z'
				},
				notShipped: {
					viewBox: '0 0 14.038 14.655',
					preserveAspectRatio: 'xMidYMid',
					data: 'M13.884,0.155C13.779,0.052,13.657,0,13.517,0H5.199c-0.14,0-0.262,0.053-0.365,0.154C4.731,0.258,4.68,0.379,4.68,0.52	V2.08H3.379c-0.146,0-0.305,0.035-0.475,0.104c-0.17,0.071-0.307,0.157-0.41,0.261L0.886,4.053c-0.07,0.069-0.132,0.15-0.183,0.244	C0.652,4.39,0.614,4.471,0.589,4.544C0.564,4.617,0.547,4.718,0.536,4.845C0.525,4.972,0.519,5.066,0.515,5.124	c-0.002,0.061-0.002,0.163,0,0.311C0.519,5.581,0.52,5.676,0.52,5.719V8.32c-0.141,0-0.263,0.051-0.366,0.153	C0.051,8.576,0,8.698,0,8.839c0,0.08,0.011,0.15,0.032,0.214c0.023,0.063,0.058,0.113,0.11,0.149	C0.193,9.24,0.238,9.272,0.276,9.297C0.314,9.32,0.378,9.338,0.467,9.346c0.09,0.009,0.15,0.014,0.183,0.017	c0.033,0.003,0.102,0.003,0.207,0s0.167-0.004,0.184-0.004H1.56c0,0.574,0.204,1.063,0.61,1.471	c0.084,0.085,0.174,0.154,0.266,0.223c-0.013-0.147-0.044-0.289-0.044-0.439c0-0.52,0.103-1.011,0.253-1.479	C2.662,9.06,2.678,8.986,2.712,8.918c0.691-1.861,2.469-3.195,4.572-3.195c2.108,0,3.892,1.343,4.577,3.214	c0.021,0.043,0.027,0.088,0.041,0.133c0.164,0.488,0.273,1.001,0.273,1.545c0,0.148-0.031,0.288-0.045,0.435	c0.09-0.065,0.178-0.134,0.26-0.215c0.404-0.406,0.606-0.896,0.606-1.472c0.019,0,0.076,0.001,0.185,0.004	c0.104,0.003,0.176,0.003,0.207,0c0.033-0.003,0.094-0.008,0.184-0.017c0.088-0.008,0.152-0.024,0.189-0.049	c0.039-0.023,0.084-0.058,0.135-0.093c0.051-0.038,0.088-0.09,0.109-0.151c0.021-0.063,0.032-0.134,0.032-0.214v-8.32	C14.038,0.379,13.985,0.258,13.884,0.155z M4.679,5.2H1.558V4.956c0-0.069,0.025-0.13,0.073-0.178l1.584-1.584	c0.049-0.05,0.109-0.073,0.179-0.073h1.284L4.679,5.2L4.679,5.2z M10.782,8.58c-0.356-0.619-0.85-1.109-1.473-1.473	C8.692,6.745,8.014,6.565,7.282,6.565c-0.733,0-1.413,0.181-2.03,0.543C4.631,7.469,4.141,7.961,3.779,8.58	c-0.362,0.618-0.544,1.298-0.544,2.028c0,0.736,0.183,1.412,0.544,2.031c0.361,0.619,0.852,1.113,1.473,1.473	c0.617,0.361,1.297,0.543,2.03,0.543c0.732,0,1.41-0.182,2.027-0.543c0.623-0.357,1.113-0.854,1.473-1.473	c0.363-0.619,0.545-1.295,0.545-2.031C11.327,9.878,11.145,9.198,10.782,8.58z M9.813,11.928c0.084,0.084,0.127,0.186,0.127,0.305	s-0.043,0.223-0.127,0.307l-0.604,0.605C9.124,13.229,9.02,13.27,8.901,13.27s-0.221-0.041-0.305-0.125L7.28,11.827l-1.316,1.316	c-0.083,0.084-0.185,0.125-0.304,0.125c-0.119,0-0.221-0.041-0.305-0.125l-0.609-0.605c-0.084-0.085-0.124-0.188-0.124-0.307	s0.04-0.221,0.124-0.305l1.317-1.318L4.746,9.296C4.662,9.212,4.622,9.109,4.622,8.99c0-0.117,0.04-0.223,0.124-0.305l0.609-0.607	C5.439,7.993,5.541,7.95,5.66,7.95c0.119,0,0.221,0.043,0.304,0.127L7.28,9.392l1.317-1.314C8.681,7.993,8.783,7.95,8.902,7.95	s0.221,0.043,0.305,0.127l0.607,0.607C9.898,8.767,9.941,8.872,9.941,8.99c0,0.119-0.043,0.223-0.127,0.307l-1.316,1.313	L9.813,11.928z'
				},
				delivered: {
					viewBox: '0 0 1792 1792',
					preserveAspectRatio: 'xMidYMid',
					data: 'M640 1408q0-52-38-90t-90-38-90 38-38 90 38 90 90 38 90-38 38-90zm-384-512h384v-256h-158q-13 0-22 9l-195 195q-9 9-9 22v30zm1280 512q0-52-38-90t-90-38-90 38-38 90 38 90 90 38 90-38 38-90zm256-1088v1024q0 15-4 26.5t-13.5 18.5-16.5 11.5-23.5 6-22.5 2-25.5 0-22.5-.5q0 106-75 181t-181 75-181-75-75-181h-384q0 106-75 181t-181 75-181-75-75-181h-64q-3 0-22.5.5t-25.5 0-22.5-2-23.5-6-16.5-11.5-13.5-18.5-4-26.5q0-26 19-45t45-19v-320q0-8-.5-35t0-38 2.5-34.5 6.5-37 14-30.5 22.5-30l198-198q19-19 50.5-32t58.5-13h160v-192q0-26 19-45t45-19h1024q26 0 45 19t19 45z'
				},
				notDelivered: {
					viewBox: '0 0 14.038 14.655',
					preserveAspectRatio: 'xMidYMid',
					data: 'M13.884,0.155C13.779,0.052,13.657,0,13.517,0H5.199c-0.14,0-0.262,0.053-0.365,0.154C4.731,0.258,4.68,0.379,4.68,0.52	V2.08H3.379c-0.146,0-0.305,0.035-0.475,0.104c-0.17,0.071-0.307,0.157-0.41,0.261L0.886,4.053c-0.07,0.069-0.132,0.15-0.183,0.244	C0.652,4.39,0.614,4.471,0.589,4.544C0.564,4.617,0.547,4.718,0.536,4.845C0.525,4.972,0.519,5.066,0.515,5.124	c-0.002,0.061-0.002,0.163,0,0.311C0.519,5.581,0.52,5.676,0.52,5.719V8.32c-0.141,0-0.263,0.051-0.366,0.153	C0.051,8.576,0,8.698,0,8.839c0,0.08,0.011,0.15,0.032,0.214c0.023,0.063,0.058,0.113,0.11,0.149	C0.193,9.24,0.238,9.272,0.276,9.297C0.314,9.32,0.378,9.338,0.467,9.346c0.09,0.009,0.15,0.014,0.183,0.017	c0.033,0.003,0.102,0.003,0.207,0s0.167-0.004,0.184-0.004H1.56c0,0.574,0.204,1.063,0.61,1.471	c0.084,0.085,0.174,0.154,0.266,0.223c-0.013-0.147-0.044-0.289-0.044-0.439c0-0.52,0.103-1.011,0.253-1.479	C2.662,9.06,2.678,8.986,2.712,8.918c0.691-1.861,2.469-3.195,4.572-3.195c2.108,0,3.892,1.343,4.577,3.214	c0.021,0.043,0.027,0.088,0.041,0.133c0.164,0.488,0.273,1.001,0.273,1.545c0,0.148-0.031,0.288-0.045,0.435	c0.09-0.065,0.178-0.134,0.26-0.215c0.404-0.406,0.606-0.896,0.606-1.472c0.019,0,0.076,0.001,0.185,0.004	c0.104,0.003,0.176,0.003,0.207,0c0.033-0.003,0.094-0.008,0.184-0.017c0.088-0.008,0.152-0.024,0.189-0.049	c0.039-0.023,0.084-0.058,0.135-0.093c0.051-0.038,0.088-0.09,0.109-0.151c0.021-0.063,0.032-0.134,0.032-0.214v-8.32	C14.038,0.379,13.985,0.258,13.884,0.155z M4.679,5.2H1.558V4.956c0-0.069,0.025-0.13,0.073-0.178l1.584-1.584	c0.049-0.05,0.109-0.073,0.179-0.073h1.284L4.679,5.2L4.679,5.2z M10.782,8.58c-0.356-0.619-0.85-1.109-1.473-1.473	C8.692,6.745,8.014,6.565,7.282,6.565c-0.733,0-1.413,0.181-2.03,0.543C4.631,7.469,4.141,7.961,3.779,8.58	c-0.362,0.618-0.544,1.298-0.544,2.028c0,0.736,0.183,1.412,0.544,2.031c0.361,0.619,0.852,1.113,1.473,1.473	c0.617,0.361,1.297,0.543,2.03,0.543c0.732,0,1.41-0.182,2.027-0.543c0.623-0.357,1.113-0.854,1.473-1.473	c0.363-0.619,0.545-1.295,0.545-2.031C11.327,9.878,11.145,9.198,10.782,8.58z M9.813,11.928c0.084,0.084,0.127,0.186,0.127,0.305	s-0.043,0.223-0.127,0.307l-0.604,0.605C9.124,13.229,9.02,13.27,8.901,13.27s-0.221-0.041-0.305-0.125L7.28,11.827l-1.316,1.316	c-0.083,0.084-0.185,0.125-0.304,0.125c-0.119,0-0.221-0.041-0.305-0.125l-0.609-0.605c-0.084-0.085-0.124-0.188-0.124-0.307	s0.04-0.221,0.124-0.305l1.317-1.318L4.746,9.296C4.662,9.212,4.622,9.109,4.622,8.99c0-0.117,0.04-0.223,0.124-0.305l0.609-0.607	C5.439,7.993,5.541,7.95,5.66,7.95c0.119,0,0.221,0.043,0.304,0.127L7.28,9.392l1.317-1.314C8.681,7.993,8.783,7.95,8.902,7.95	s0.221,0.043,0.305,0.127l0.607,0.607C9.898,8.767,9.941,8.872,9.941,8.99c0,0.119-0.043,0.223-0.127,0.307l-1.316,1.313	L9.813,11.928z'
				},
				dispute: {
					viewBox: '0 0 1792 1792',
					preserveAspectRatio: 'xMidYMid',
					data: 'M320 256q0 72-64 110v1266q0 13-9.5 22.5t-22.5 9.5h-64q-13 0-22.5-9.5t-9.5-22.5v-1266q-64-38-64-110 0-53 37.5-90.5t90.5-37.5 90.5 37.5 37.5 90.5zm1472 64v763q0 25-12.5 38.5t-39.5 27.5q-215 116-369 116-61 0-123.5-22t-108.5-48-115.5-48-142.5-22q-192 0-464 146-17 9-33 9-26 0-45-19t-19-45v-742q0-32 31-55 21-14 79-43 236-120 421-120 107 0 200 29t219 88q38 19 88 19 54 0 117.5-21t110-47 88-47 54.5-21q26 0 45 19t19 45z'
				},
				notDispute: {
					viewBox: '0 0 16 16',
					preserveAspectRatio: 'xMidYMid',
					data: 'M11.34899,7.929c-0.36,-0.62 -0.85,-1.11 -1.473,-1.472c-0.616,-0.363 -1.294,-0.543 -2.027,-0.543s-1.413,0.18 -2.03,0.543c-0.62,0.36 -1.11,0.853 -1.473,1.472s-0.544,1.297 -0.544,2.03c0,0.735 0.183,1.41 0.544,2.03s0.852,1.113 1.473,1.473c0.617,0.36 1.297,0.543 2.03,0.543s1.41,-0.182 2.028,-0.543c0.624,-0.36 1.114,-0.854 1.474,-1.473c0.363,-0.62 0.545,-1.295 0.545,-2.03c0,-0.733 -0.183,-1.41 -0.546,-2.03l-0.001,0zm-0.969,3.348c0.085,0.084 0.128,0.186 0.128,0.305s-0.043,0.22 -0.127,0.305l-0.607,0.607c-0.084,0.084 -0.186,0.125 -0.305,0.125s-0.22,-0.04 -0.305,-0.125l-1.319,-1.317l-1.315,1.316c-0.083,0.084 -0.185,0.125 -0.304,0.125s-0.22,-0.04 -0.304,-0.124l-0.61,-0.607c-0.083,-0.085 -0.123,-0.187 -0.123,-0.306s0.04,-0.22 0.124,-0.305l1.317,-1.32l-1.317,-1.313c-0.084,-0.084 -0.124,-0.186 -0.124,-0.305s0.04,-0.223 0.124,-0.305l0.61,-0.608c0.083,-0.085 0.185,-0.128 0.304,-0.128s0.222,0.043 0.305,0.127l1.316,1.314l1.318,-1.315c0.084,-0.085 0.186,-0.128 0.305,-0.128s0.22,0.043 0.305,0.127l0.607,0.607c0.084,0.082 0.127,0.186 0.127,0.305s-0.043,0.22 -0.127,0.305l-1.316,1.314l1.315,1.32l-0.002,0.004zm-8.126,-10.15c0,0.422 -0.188,0.746 -0.564,0.968l0,11.155c0,0.074 -0.027,0.142 -0.083,0.197c-0.054,0.056 -0.12,0.083 -0.197,0.083l-0.564,0c-0.077,0 -0.144,-0.027 -0.2,-0.083c-0.056,-0.056 -0.082,-0.123 -0.082,-0.197l0,-11.155c-0.376,-0.223 -0.564,-0.546 -0.564,-0.968c0,-0.312 0.11,-0.578 0.33,-0.797c0.22,-0.22 0.486,-0.33 0.798,-0.33c0.31,0 0.577,0.11 0.797,0.33c0.22,0.22 0.328,0.485 0.328,0.797l0.001,0zm12.97,0.563l0,6.722c0,0.146 -0.037,0.26 -0.11,0.338c-0.073,0.08 -0.19,0.162 -0.35,0.245c-0.756,0.408 -1.44,0.678 -2.067,0.84l0.002,-0.007c0,-2.678 -2.17,-4.85 -4.85,-4.85c-2.678,0 -4.85,2.172 -4.85,4.85c0,0.092 0.022,0.176 0.027,0.265c-0.07,0.027 -0.14,0.057 -0.208,0.057c-0.153,0 -0.285,-0.057 -0.396,-0.167c-0.112,-0.113 -0.168,-0.244 -0.168,-0.398l0,-6.536c0,-0.187 0.09,-0.348 0.274,-0.484c0.123,-0.083 0.354,-0.208 0.696,-0.38c1.385,-0.704 2.623,-1.056 3.708,-1.056c0.63,0 1.216,0.084 1.763,0.255c0.545,0.17 1.19,0.43 1.93,0.776c0.222,0.112 0.48,0.168 0.773,0.168c0.318,0 0.662,-0.062 1.036,-0.185c0.372,-0.124 0.694,-0.262 0.968,-0.415c0.274,-0.152 0.532,-0.29 0.774,-0.414c0.244,-0.124 0.405,-0.185 0.48,-0.185c0.153,0 0.286,0.055 0.397,0.166c0.11,0.113 0.168,0.245 0.168,0.397l0.003,-0.002z'
				},
				cancel: {
					viewBox: '0 0 1792 1792',
					preserveAspectRatio: 'xMidYMid',
					data: 'M1440 893q0-161-87-295l-754 753q137 89 297 89 111 0 211.5-43.5t173.5-116.5 116-174.5 43-212.5zm-999 299l755-754q-135-91-300-91-148 0-273 73t-198 199-73 274q0 162 89 299zm1223-299q0 157-61 300t-163.5 246-245 164-298.5 61-298.5-61-245-164-163.5-246-61-300 61-299.5 163.5-245.5 245-164 298.5-61 298.5 61 245 164 163.5 245.5 61 299.5z'
				},
				scheduled: {
					viewBox: '0 0 1792 1792',
					preserveAspectRatio: 'xMidYMid',
					data: 'M1024 544v448q0 14-9 23t-23 9h-320q-14 0-23-9t-9-23v-64q0-14 9-23t23-9h224v-352q0-14 9-23t23-9h64q14 0 23 9t9 23zm416 352q0-148-73-273t-198-198-273-73-273 73-198 198-73 273 73 273 198 198 273 73 273-73 198-198 73-273zm224 0q0 209-103 385.5t-279.5 279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5 385.5-103 385.5 103 279.5 279.5 103 385.5z'
				},
				notScheduled: {
					viewBox: '0 0 16.225 16.607',
					preserveAspectRatio: 'xMidYMid',
					data: 'M15.68,10.532c-0.356-0.619-0.85-1.109-1.473-1.473c-0.617-0.362-1.295-0.543-2.026-0.543	c-0.734,0-1.414,0.181-2.031,0.543c-0.621,0.361-1.11,0.854-1.473,1.473c-0.361,0.618-0.544,1.298-0.544,2.028	c0,0.736,0.183,1.412,0.544,2.031s0.852,1.113,1.473,1.473c0.617,0.361,1.297,0.543,2.031,0.543c0.731,0,1.409-0.182,2.026-0.543	c0.623-0.357,1.113-0.854,1.473-1.473c0.363-0.619,0.545-1.295,0.545-2.031C16.225,11.83,16.043,11.151,15.68,10.532z M14.711,13.88	c0.084,0.084,0.127,0.186,0.127,0.305s-0.043,0.223-0.127,0.307l-0.604,0.605c-0.085,0.084-0.188,0.125-0.308,0.125	s-0.221-0.041-0.305-0.125l-1.316-1.317l-1.315,1.316c-0.084,0.084-0.186,0.125-0.305,0.125s-0.221-0.041-0.305-0.125L9.644,14.49	c-0.084-0.085-0.123-0.188-0.123-0.307s0.039-0.221,0.123-0.305l1.317-1.318l-1.317-1.313c-0.084-0.084-0.123-0.188-0.123-0.307	c0-0.117,0.039-0.223,0.123-0.305l0.609-0.607c0.084-0.084,0.186-0.127,0.305-0.127s0.221,0.043,0.305,0.127l1.315,1.314	l1.317-1.314c0.084-0.084,0.186-0.127,0.305-0.127s0.221,0.043,0.305,0.127l0.607,0.607c0.084,0.082,0.127,0.188,0.127,0.305	c0,0.119-0.043,0.223-0.127,0.307l-1.316,1.313L14.711,13.88z M7.269,13.678c-0.138,0.008-0.271,0.025-0.412,0.025	c-1.244,0-2.391-0.305-3.441-0.918s-1.883-1.443-2.496-2.494C0.307,9.242,0,8.096,0,6.852C0,5.61,0.307,4.463,0.919,3.413	c0.613-1.05,1.445-1.882,2.496-2.493C4.466,0.307,5.612,0,6.856,0s2.392,0.307,3.441,0.92c1.051,0.611,1.883,1.443,2.496,2.493	s0.92,2.196,0.92,3.438c0,0.311-0.02,0.615-0.058,0.914c-0.47-0.146-0.96-0.246-1.478-0.246c-0.178,0-0.347,0.034-0.52,0.053	c0.033-0.235,0.055-0.475,0.055-0.721c0-0.879-0.218-1.691-0.652-2.436c-0.434-0.742-1.023-1.332-1.768-1.766	C8.55,2.216,7.737,1.999,6.856,1.999S5.163,2.216,4.419,2.651C3.675,3.084,3.086,3.674,2.651,4.416C2.218,5.16,2,5.973,2,6.852	c0,0.881,0.218,1.693,0.651,2.436c0.435,0.744,1.023,1.333,1.768,1.768c0.744,0.434,1.557,0.65,2.438,0.65	c0.125,0,0.246-0.015,0.368-0.023c-0.051,0.287-0.089,0.579-0.089,0.881C7.136,12.948,7.188,13.318,7.269,13.678z M7.999,7.709	c0,0.083-0.026,0.151-0.08,0.205c-0.053,0.053-0.121,0.08-0.205,0.08H4.856c-0.083,0-0.151-0.027-0.205-0.08	c-0.053-0.054-0.08-0.122-0.08-0.205V7.138c0-0.083,0.027-0.151,0.08-0.205c0.054-0.054,0.122-0.081,0.205-0.081h2v-3.14	c0-0.083,0.027-0.151,0.08-0.206c0.055-0.053,0.123-0.08,0.206-0.08h0.571c0.084,0,0.152,0.027,0.205,0.08	c0.054,0.055,0.08,0.123,0.08,0.206V7.709z'
				},
				reject: {
					viewBox: '0 0 1792 1792',
					preserveAspectRatio: 'xMidYMid',
					data: 'M320 576q0 26-19 45t-45 19q-27 0-45.5-19t-18.5-45q0-27 18.5-45.5t45.5-18.5q26 0 45 18.5t19 45.5zm160 512v-640q0-26-19-45t-45-19h-288q-26 0-45 19t-19 45v640q0 26 19 45t45 19h288q26 0 45-19t19-45zm1129-149q55 61 55 149-1 78-57.5 135t-134.5 57h-277q4 14 8 24t11 22 10 18q18 37 27 57t19 58.5 10 76.5q0 24-.5 39t-5 45-12 50-24 45-40 40.5-60 26-82.5 10.5q-26 0-45-19-20-20-34-50t-19.5-52-12.5-61q-9-42-13.5-60.5t-17.5-48.5-31-48q-33-33-101-120-49-64-101-121t-76-59q-25-2-43-20.5t-18-43.5v-641q0-26 19-44.5t45-19.5q35-1 158-44 77-26 120.5-39.5t121.5-29 144-15.5h129q133 2 197 78 58 69 49 181 39 37 54 94 17 61 0 117 46 61 43 137 0 32-15 76z'
				},
				remove: {
					viewBox: '0 0 26 26',
					preserveAspectRatio: 'xMidYMid',
					data: 'M2.552536,8.060472l5.125316,-4.758566l5.444544,5.05491l5.444544,-5.05491l5.125364,4.758566l-5.444545,5.054951l5.444545,5.054951l-5.125364,4.758611l-5.444544,-5.054953l-5.444544,5.054953l-5.125316,-4.758611l5.444499,-5.054951l-5.444499,-5.054951Z'
				},
				uploadFile: {
					viewBox: '0 0 26 26',
					preserveAspectRatio: 'xMidYMid',
					data: 'm0.75,9.16529l8.41529,0l0,-8.41529l8.63249,0l0,8.41529l8.41529,0l0,8.63249l-8.41529,0l0,8.41529l-8.63249,0l0,-8.41529l-8.41529,0l0,-8.63249z'
				},
				accept: {
					viewBox: '0 0 1792 1792',
					preserveAspectRatio: 'xMidYMid',
					data: 'M1412,734q0-28-18-46l-91-90q-19-19-45-19t-45,19l-408,407-226-226q-19-19-45-19t-45,19l-91,90q-18,18-18,46,0,27,18,45l362,362q19,19,45,19,27,0,46-19l543-543q18-18,18-45zm252,162q0,209-103,385.5t-279.5,279.5-385.5,103-385.5-103-279.5-279.5-103-385.5,103-385.5,279.5-279.5,385.5-103,385.5,103,279.5,279.5,103,385.5z'
				},
				close: {
					viewBox: '0 0 1792 1792',
					preserveAspectRatio: 'xMidYMid',
					data: 'M1490 1322q0 40-28 68l-136 136q-28 28-68 28t-68-28l-294-294-294 294q-28 28-68 28t-68-28l-136-136q-28-28-28-68t28-68l294-294-294-294q-28-28-28-68t28-68l136-136q28-28 68-28t68 28l294 294 294-294q28-28 68-28t68 28l136 136q28 28 28 68t-28 68l-294 294 294 294q28 28 28 68z'

				},
				clearFilter: {
					viewBox: '0 0 1792 1792',
					preserveAspectRatio: 'xMidYMid',
					data: 'M1490 1322q0 40-28 68l-136 136q-28 28-68 28t-68-28l-294-294-294 294q-28 28-68 28t-68-28l-136-136q-28-28-28-68t28-68l294-294-294-294q-28-28-28-68t28-68l136-136q28-28 68-28t68 28l294 294 294-294q28-28 68-28t68 28l136 136q28 28 28 68t-28 68l-294 294 294 294q28 28 28 68z'

				},
				issues: {
					viewBox: '0 0 1792 1792',
					preserveAspectRatio: 'xMidYMid',
					data: 'M896 128q209 0 385.5 103t279.5 279.5 103 385.5-103 385.5-279.5 279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5 385.5-103zm128 1247v-190q0-14-9-23.5t-22-9.5h-192q-13 0-23 10t-10 23v190q0 13 10 23t23 10h192q13 0 22-9.5t9-23.5zm-2-344l18-621q0-12-10-18-10-8-24-8h-220q-14 0-24 8-10 6-10 18l17 621q0 10 10 17.5t24 7.5h185q14 0 23.5-7.5t10.5-17.5z'
				},
				validationIssues: {
					viewBox: '0 0 1792 1792',
					preserveAspectRatio: 'xMidYMid',
					data: 'M896 128q209 0 385.5 103t279.5 279.5 103 385.5-103 385.5-279.5 279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5 385.5-103zm128 1247v-190q0-14-9-23.5t-22-9.5h-192q-13 0-23 10t-10 23v190q0 13 10 23t23 10h192q13 0 22-9.5t9-23.5zm-2-344l18-621q0-12-10-18-10-8-24-8h-220q-14 0-24 8-10 6-10 18l17 621q0 10 10 17.5t24 7.5h185q14 0 23.5-7.5t10.5-17.5z'
				},
				history: {
					viewBox: '0 0 1792 1792',
					preserveAspectRatio: 'xMidYMid',
					data: 'M1664 896q0 156-61 298t-164 245-245 164-298 61q-172 0-327-72.5t-264-204.5q-7-10-6.5-22.5t8.5-20.5l137-138q10-9 25-9 16 2 23 12 73 95 179 147t225 52q104 0 198.5-40.5t163.5-109.5 109.5-163.5 40.5-198.5-40.5-198.5-109.5-163.5-163.5-109.5-198.5-40.5q-98 0-188 35.5t-160 101.5l137 138q31 30 14 69-17 40-59 40h-448q-26 0-45-19t-19-45v-448q0-42 40-59 39-17 69 14l130 129q107-101 244.5-156.5t284.5-55.5q156 0 298 61t245 164 164 245 61 298zm-640-288v448q0 14-9 23t-23 9h-320q-14 0-23-9t-9-23v-64q0-14 9-23t23-9h224v-352q0-14 9-23t23-9h64q14 0 23 9t9 23z'
				},
				related: {
					viewBox: '0 0 1792 1600',
					preserveAspectRatio: 'xMidYMid',
					data: 'M1520 1216q0-40-28-68l-208-208q-28-28-68-28-42 0-72 32 3 3 19 18.5t21.5 21.5 15 19 13 25.5 3.5 27.5q0 40-28 68t-68 28q-15 0-27.5-3.5t-25.5-13-19-15-21.5-21.5-18.5-19q-33 31-33 73 0 40 28 68l206 207q27 27 68 27 40 0 68-26l147-146q28-28 28-67zm-703-705q0-40-28-68l-206-207q-28-28-68-28-39 0-68 27l-147 146q-28 28-28 67 0 40 28 68l208 208q27 27 68 27 42 0 72-31-3-3-19-18.5t-21.5-21.5-15-19-13-25.5-3.5-27.5q0-40 28-68t68-28q15 0 27.5 3.5t25.5 13 19 15 21.5 21.5 18.5 19q33-31 33-73zm895 705q0 120-85 203l-147 146q-83 83-203 83-121 0-204-85l-206-207q-83-83-83-203 0-123 88-209l-88-88q-86 88-208 88-120 0-204-84l-208-208q-84-84-84-204t85-203l147-146q83-83 203-83 121 0 204 85l206 207q83 83 83 203 0 123-88 209l88 88q86-88 208-88 120 0 204 84l208 208q84 84 84 204z'
				},
				markAsInvoiced: {
					viewBox: '0 0 14.6 18.8',
					preserveAspectRatio: 'xMidYMid',
					data: 'M10.41,0H2.1A2.05,2.05,0,0,0,0,2.1V16.71a2.05,2.05,0,0,0,2.1,2.1H12.51a2.05,2.05,0,0,0,2.1-2.1V4.2C13,2.5,12.11,1.6,10.41,0ZM9.9,1.7l3,3h-2.5a.47.47,0,0,1-.5-.5Zm3.1,15a.47.47,0,0,1-.5.5H2.1a.47.47,0,0,1-.5-.5V2.1a.47.47,0,0,1,.5-.5H8.4V4.2a2.05,2.05,0,0,0,2.1,2.1H13ZM2.84,6.59v-1H2.08V5.23A.42.42,0,0,1,2.19,5a.39.39,0,0,1,.31-.12h.34V4A2.27,2.27,0,0,1,3,3.22a1.71,1.71,0,0,1,.36-.61,1.74,1.74,0,0,1,.61-.42A2.16,2.16,0,0,1,4.78,2a2,2,0,0,1,.6.08,1.69,1.69,0,0,1,.48.23,1.77,1.77,0,0,1,.37.35,2.61,2.61,0,0,1,.28.43L6,3.45a.61.61,0,0,1-.29.08.46.46,0,0,1-.34-.15,1.52,1.52,0,0,0-.28-.24.57.57,0,0,0-.3-.08.56.56,0,0,0-.49.23,1.15,1.15,0,0,0-.16.66v.88H5.68v.48a.26.26,0,0,1,0,.12.34.34,0,0,1-.07.1l-.11.07-.14,0H4.13v.63A1,1,0,0,1,4,6.7a1.47,1.47,0,0,1-.25.37L4.16,7l.37,0h2V7.5a.48.48,0,0,1,0,.18.57.57,0,0,1-.11.17A.53.53,0,0,1,6.25,8,.51.51,0,0,1,6,8H2.16V7.26a1.21,1.21,0,0,0,.26-.08.82.82,0,0,0,.22-.13.63.63,0,0,0,.15-.2A.58.58,0,0,0,2.84,6.59Zm.88,5.77A4.53,4.53,0,1,0,8.25,7.83,4.52,4.52,0,0,0,3.72,12.36Zm6.83-2.55a.47.47,0,0,1,.58.07l.33.33a.42.42,0,0,1,.15.29.47.47,0,0,1-.14.36l-3.84,4a.45.45,0,0,1-.34.14.42.42,0,0,1-.35-.16l-1.9-2a.46.46,0,0,1,0-.67l.34-.34a.47.47,0,0,1,.67,0l0,0,1.24,1.33,3.2-3.32Z'
				},
				attachment: {
					viewBox: '0 0 1792 1792',
					preserveAspectRatio: 'xMidYMid',
					data: 'M1596 1385q0 117-79 196t-196 79q-135 0-235-100l-777-776q-113-115-113-271 0-159 110-270t269-111q158 0 273 113l605 606q10 10 10 22 0 16-30.5 46.5t-46.5 30.5q-13 0-23-10l-606-607q-79-77-181-77-106 0-179 75t-73 181q0 105 76 181l776 777q63 63 145 63 64 0 106-42t42-106q0-82-63-145l-581-581q-26-24-60-24-29 0-48 19t-19 48q0 32 25 59l410 410q10 10 10 22 0 16-31 47t-47 31q-12 0-22-10l-410-410q-63-61-63-149 0-82 57-139t139-57q88 0 149 63l581 581q100 98 100 235z'
				},
				updated: {
					viewBox: '0 0 14.6 13.6',
					preserveAspectRatio: 'xMidYMid',
					data: 'M11,10h1.8v0.9c0,1.5-1.2,2.7-2.7,2.7H4.6c-1.5,0-2.7-1.2-2.7-2.7H0l2.7-2.7l2.7,2.7H3.7c0,0.5,0.4,0.9,0.9,0.9h5.5c0.5,0,0.9-0.4,0.9-0.9V10z M3.7,2.7c0-0.5,0.4-0.9,0.9-0.9h5.5c0.5,0,0.9,0.4,0.9,0.9v0H9.1l2.7,2.7l2.7-2.7h-1.8v0c0-1.5-1.2-2.7-2.7-2.7H4.6C3.1,0,1.9,1.2,1.9,2.7v0.9h1.8V2.7z M7.6,4.3c1.4,0,2.6,1.1,2.6,2.6c0,1.4-1.1,2.6-2.6,2.6C6.1,9.5,5,8.3,5,6.9C5,5.5,6.1,4.3,7.6,4.3z M8.8,5.5L7,7.3L6.3,6.6l0,0C6.2,6.5,6,6.5,5.9,6.6L5.7,6.8c0,0-0.1,0.1-0.1,0.2c0,0.1,0,0.1,0.1,0.2l1.1,1.2c0,0.1,0.1,0.1,0.2,0.1c0.1,0,0.1,0,0.2-0.1l2.2-2.3C9.4,6,9.5,5.9,9.5,5.9c0-0.1,0-0.1-0.1-0.2L9.2,5.5C9.1,5.4,9,5.4,8.8,5.5L8.8,5.5z'
				},
				grn: {
					viewBox: '0 0 1792 1792',
					preserveAspectRatio: 'xMidYMid',
					data: 'M1151 960h316q-1-3-2.5-8t-2.5-8l-212-496h-708l-212 496q-1 2-2.5 8t-2.5 8h316l95 192h320zm513 30v482q0 26-19 45t-45 19h-1408q-26 0-45-19t-19-45v-482q0-62 25-123l238-552q10-25 36.5-42t52.5-17h832q26 0 52.5 17t36.5 42l238 552q25 61 25 123z'
				},
				release: {
					viewBox: '0 0 1792 1792',
					preserveAspectRatio: 'xMidYMid',
					data: 'M1728 576v256q0 26-19 45t-45 19h-64q-26 0-45-19t-19-45v-256q0-106-75-181t-181-75-181 75-75 181v192h96q40 0 68 28t28 68v576q0 40-28 68t-68 28h-960q-40 0-68-28t-28-68v-576q0-40 28-68t68-28h672v-192q0-185 131.5-316.5t316.5-131.5 316.5 131.5 131.5 316.5z'
				},
				delete: {
					viewBox: '0 0 1792 1792',
					preserveAspectRatio: 'xMidYMid',
					data: 'M704 1376v-704q0-14-9-23t-23-9h-64q-14 0-23 9t-9 23v704q0 14 9 23t23 9h64q14 0 23-9t9-23zm256 0v-704q0-14-9-23t-23-9h-64q-14 0-23 9t-9 23v704q0 14 9 23t23 9h64q14 0 23-9t9-23zm256 0v-704q0-14-9-23t-23-9h-64q-14 0-23 9t-9 23v704q0 14 9 23t23 9h64q14 0 23-9t9-23zm-544-992h448l-48-117q-7-9-17-11h-317q-10 2-17 11zm928 32v64q0 14-9 23t-23 9h-96v948q0 83-47 143.5t-113 60.5h-832q-66 0-113-58.5t-47-141.5v-952h-96q-14 0-23-9t-9-23v-64q0-14 9-23t23-9h309l70-167q15-37 54-63t79-26h320q40 0 79 26t54 63l70 167h309q14 0 23 9t9 23z'
				},
				void: {
					viewBox: '0 0 14.6 18.8',
					preserveAspectRatio: 'xMidYMid',
					data: 'M10.4,0H2.1C0.9,0,0,0.9,0,2.1v14.6c0,1.2,0.9,2.1,2.1,2.1h10.4c1.2,0,2.1-0.9,2.1-2.1V4.2C13,2.5,12.1,1.6,10.4,0z M9.9,1.7l3,3h-2.5c-0.3,0-0.5-0.2-0.5-0.5V1.7z M13,16.7c0,0.3-0.2,0.5-0.5,0.5H2.1c-0.3,0-0.5-0.2-0.5-0.5V2.1c0-0.3,0.2-0.5,0.5-0.5h6.3v2.6c0,1.2,0.9,2.1,2.1,2.1H13V16.7z M10.6,8.9L8,11.5l2.6,2.6l-0.7,0.7l-2.6-2.6l-2.6,2.6L4,14.1l2.6-2.6L4,8.9l0.7-0.7l2.6,2.6l2.6-2.6L10.6,8.9z'
				},
				dashboard: {
					viewBox: '0 0 1792 1600',
					preserveAspectRatio: 'xMidYMid',
					data: 'M384 1152q0-53-37.5-90.5t-90.5-37.5-90.5 37.5-37.5 90.5 37.5 90.5 90.5 37.5 90.5-37.5 37.5-90.5zm192-448q0-53-37.5-90.5t-90.5-37.5-90.5 37.5-37.5 90.5 37.5 90.5 90.5 37.5 90.5-37.5 37.5-90.5zm428 481l101-382q6-26-7.5-48.5t-38.5-29.5-48 6.5-30 39.5l-101 382q-60 5-107 43.5t-63 98.5q-20 77 20 146t117 89 146-20 89-117q16-60-6-117t-72-91zm660-33q0-53-37.5-90.5t-90.5-37.5-90.5 37.5-37.5 90.5 37.5 90.5 90.5 37.5 90.5-37.5 37.5-90.5zm-640-640q0-53-37.5-90.5t-90.5-37.5-90.5 37.5-37.5 90.5 37.5 90.5 90.5 37.5 90.5-37.5 37.5-90.5zm448 192q0-53-37.5-90.5t-90.5-37.5-90.5 37.5-37.5 90.5 37.5 90.5 90.5 37.5 90.5-37.5 37.5-90.5zm320 448q0 261-141 483-19 29-54 29h-1402q-35 0-54-29-141-221-141-483 0-182 71-348t191-286 286-191 348-71 348 71 286 191 191 286 71 348z'
				},
				hideColumnDetails: {
					viewBox: '0 0 15.2 11.4',
					preserveAspectRatio: 'xMidYMid',
					data: 'M9,8.2l2.4-4.3c0.1,0.2,0.1,0.5,0.1,0.7c0,0.8-0.3,1.6-0.7,2.2C10.3,7.4,9.7,7.9,9,8.2z M8.3,5.7c-1.2,2.1-2.1,3.7-2.7,4.8l-0.4,0.8c0,0.1-0.1,0.1-0.2,0.1c0,0-0.4-0.2-1.1-0.6c-0.1,0-0.1-0.1-0.1-0.2c0,0,0.2-0.3,0.4-0.7C3.4,9.5,2.6,9,2,8.4C1.3,7.8,0.7,7.1,0.2,6.3C0.1,6.1,0,5.9,0,5.7s0.1-0.4,0.2-0.6C1,3.8,2.1,2.7,3.4,2c1.3-0.8,2.7-1.2,4.3-1.1c0.5,0,1,0,1.5,0.1l0.4-0.9C9.7,0,9.8,0,9.9,0c0.1,0,0.2,0,0.3,0.1c0.1,0.1,0.2,0.1,0.3,0.2c0.1,0.1,0.2,0.1,0.3,0.2C10.9,0.6,11,0.6,11,0.6c0.1,0.1,0.1,0.1,0.1,0.3C10.5,2,9.6,3.6,8.3,5.7z M5.4,7.7C4.9,7.3,4.5,6.8,4.2,6.3S3.8,5.2,3.8,4.6c0-0.7,0.2-1.3,0.5-1.9C3,3.4,2,4.4,1.1,5.7C2,7.2,3.2,8.2,4.7,8.9L5.4,7.7z M8,2.5c0-0.2,0-0.3-0.1-0.4C7.8,2,7.7,2,7.6,2C6.9,2,6.3,2.3,5.8,2.8S5,3.9,5,4.6c0,0.1,0.1,0.2,0.2,0.3C5.2,5,5.3,5,5.4,5c0.2,0,0.3,0,0.4-0.1c0.1-0.1,0.1-0.2,0.1-0.3c0-0.5,0.1-0.9,0.5-1.2C6.7,3,7.1,2.9,7.6,2.9c0.1,0,0.2-0.1,0.3-0.2C8,2.7,8,2.6,8,2.5z M15.1,5.1c-0.3-0.5-0.7-1.1-1.2-1.6s-1-0.9-1.6-1.3l-0.5,1c0.9,0.7,1.7,1.5,2.4,2.5c-0.7,1.1-1.5,1.9-2.6,2.6c-1,0.7-2.1,1.1-3.3,1.2l-0.6,1.1c1.3,0,2.4-0.3,3.6-0.8c1.1-0.5,2.1-1.3,3-2.3C14.7,7,15,6.6,15.2,6.3c0.1-0.2,0.2-0.4,0.2-0.6C15.2,5.5,15.2,5.3,15.1,5.1z'
				},
				showAsColumns: {
					viewBox: '0 0 14.4 13.3',
					preserveAspectRatio: 'xMidYMid',
					data: 'M14,0.4C13.8,0.1,13.4,0,13,0H1.4C1,0,0.7,0.1,0.4,0.4S0,1,0,1.4v10.5c0,0.4,0.1,0.7,0.4,1s0.6,0.4,1,0.4H13c0.4,0,0.7-0.1,1-0.4c0.3-0.3,0.4-0.6,0.4-1V1.4C14.4,1,14.3,0.7,14,0.4L14,0.4z M4.7,12.2H1.4c-0.1,0-0.1,0-0.2-0.1S1.1,12,1.1,11.9V2.2h3.6V12.2z M13.3,11.9c0,0.1,0,0.1-0.1,0.2c-0.1,0.1-0.1,0.1-0.2,0.1H5.8v-10h7.6L13.3,11.9L13.3,11.9z'
				},
				showAsColumnsDetails: {
					viewBox: '0 -5 15.2 19.8',
					preserveAspectRatio: 'xMidYMid',
					data: 'M15.1,4.3C14.3,3,13.2,2,11.9,1.2C10.5,0.4,9.1,0,7.6,0S4.7,0.4,3.4,1.2C2,2,1,3,0.2,4.3C0.1,4.5,0,4.7,0,4.9s0.1,0.4,0.2,0.6C1,6.8,2,7.8,3.4,8.6c1.3,0.8,2.8,1.2,4.2,1.2c1.5,0,2.9-0.4,4.2-1.2s2.4-1.8,3.2-3.1c0.1-0.2,0.2-0.4,0.2-0.6S15.2,4.5,15.1,4.3z M5.8,2c0.5-0.5,1.1-0.8,1.8-0.8c0.1,0,0.2,0,0.3,0.1C8,1.4,8,1.5,8,1.6s0,0.2-0.1,0.3C7.8,2,7.7,2,7.6,2C7.1,2,6.7,2.2,6.4,2.6C6,2.9,5.8,3.3,5.8,3.8c0,0.1,0,0.2-0.1,0.3C5.6,4.2,5.6,4.2,5.4,4.2c-0.1,0-0.2,0-0.3-0.1C5.1,4,5,3.9,5,3.8C5,3.1,5.3,2.5,5.8,2z M11.3,7.7c-1.1,0.7-2.4,1-3.7,1c-1.3,0-2.6-0.3-3.7-1C2.8,7,1.8,6.1,1.1,4.9C2,3.6,3,2.6,4.3,1.9C4,2.5,3.8,3.1,3.8,3.8c0,1,0.4,1.9,1.1,2.7c0.7,0.7,1.6,1.1,2.7,1.1c1,0,1.9-0.4,2.7-1.1c0.8-0.7,1.1-1.6,1.1-2.7c0-0.7-0.2-1.3-0.5-1.9c1.3,0.7,2.4,1.7,3.2,3C13.4,6.1,12.4,7,11.3,7.7z'
				},
				partyManagement: {
					viewBox: '0 0 34.6 33.4',
					preserveAspectRatio: 'xMidYMid',
					data: 'M13.5,3.8c0-2.1,1.7-3.8,3.8-3.8S21,1.7,21,3.8s-1.7,3.8-3.8,3.8S13.5,5.8,13.5,3.8zM19.8,7.6h-5 c-1.6,0-2.9,1.3-2.9,2.9v4.2c0,0.7,0.5,1.2,1.2,1.2h8.4c0.7,0,1.2-0.5,1.2-1.2v-4.2C22.7,8.9,21.4,7.6,19.8,7.6z M5.4,25 c2.1,0,3.8-1.7,3.8-3.8s-1.7-3.8-3.8-3.8s-3.8,1.7-3.8,3.8S3.3,25,5.4,25z M7.9,25.1h-5C1.3,25.1,0,26.4,0,28v4.2 c0,0.7,0.5,1.2,1.2,1.2h8.4c0.7,0,1.2-0.5,1.2-1.2V28C10.8,26.4,9.5,25.1,7.9,25.1z M29.2,25c2.1,0,3.8-1.7,3.8-3.8 s-1.7-3.8-3.8-3.8s-3.8,1.7-3.8,3.8S27.1,25,29.2,25z M31.7,25.1h-5c-1.6,0-2.9,1.3-2.9,2.9v4.2c0,0.7,0.5,1.2,1.2,1.2h8.4 c0.7,0,1.2-0.5,1.2-1.2V28C34.6,26.4,33.3,25.1,31.7,25.1z M24.6,24.5c0,0.2-0.2,0.4-0.4,0.4l-0.1,0c-0.7,0-1.3,0.4-1.5,1 c-0.3,0.6-0.1,1.4,0.4,1.8c0.2,0.1,0.2,0.4,0,0.6c-0.3,0.4-0.8,0.8-1.2,1.2c-0.2,0.1-0.4,0.1-0.6,0c-0.4-0.5-1.2-0.7-1.8-0.4 c-0.6,0.3-1,0.9-1,1.6c0,0.2-0.2,0.4-0.4,0.4c-0.3,0-0.5,0-0.8,0c-0.3,0-0.6,0-0.8,0c-0.2,0-0.4-0.2-0.4-0.4c0-0.7-0.4-1.3-1-1.6 c-0.6-0.3-1.4-0.1-1.8,0.4c-0.1,0.2-0.4,0.2-0.6,0c-0.4-0.3-0.8-0.7-1.2-1.2c-0.1-0.2-0.1-0.4,0-0.6c0.5-0.5,0.7-1.2,0.4-1.8 c-0.3-0.6-0.9-1-1.5-1c-0.2,0-0.5-0.2-0.5-0.4c-0.1-0.6-0.1-1.1,0-1.7c0-0.2,0.2-0.4,0.4-0.4c0.7,0,1.3-0.4,1.6-1 c0.3-0.6,0.1-1.4-0.4-1.8c-0.2-0.1-0.2-0.4,0-0.6c0.3-0.4,0.7-0.8,1.2-1.2c0.2-0.1,0.4-0.1,0.6,0c0.4,0.5,1.2,0.7,1.8,0.4 c0.6-0.3,1-0.9,1-1.6c0-0.2,0.2-0.4,0.4-0.4c0.6-0.1,1.1-0.1,1.7,0c0.2,0,0.4,0.2,0.4,0.4c0,0.7,0.4,1.3,1,1.6 c0.6,0.3,1.4,0.1,1.8-0.4c0.1-0.2,0.4-0.2,0.6,0c0.4,0.3,0.8,0.7,1.2,1.2c0.1,0.2,0.1,0.4,0,0.6c-0.5,0.5-0.7,1.2-0.4,1.8 c0.3,0.6,0.8,1,1.5,1c0.2,0,0.4,0.2,0.5,0.4C24.7,23.4,24.7,24,24.6,24.5z M19.8,23.7c0-1.4-1.1-2.5-2.5-2.5c-1.4,0-2.5,1.1-2.5,2.5 s1.1,2.5,2.5,2.5C18.6,26.1,19.8,25,19.8,23.7z'
				},
				myPartyManagement: {
					viewBox: '0 0 49.64 49.02',
					preserveAspectRatio: 'xMidYMid',
					data: 'M20.46,35.67a15.57,15.57,0,0,0,2.32,8,42.53,42.53,0,0,1-4.27.21C7.19,43.87.44,39.48.44,39.48.23,38.29,0,35.61,0,35.61c-.15-2,0-6,3.48-6.85a28.82,28.82,0,0,0,8.41-3.84l2.95,9.3L15.44,36v0l.48,1.49L17.48,33c-3.82-5.32.77-5.27,1-5.26s4.84-.06,1,5.26ZM10.72,18.61a9.27,9.27,0,0,0,5.7,7.06,6.19,6.19,0,0,0,4.18,0,9.4,9.4,0,0,0,5.71-7.05c.44,0,1-.65,1.63-2.84.84-3,0-3.43-.81-3.36a8.24,8.24,0,0,0,.33-1.23c1.29-7.74-2.52-8-2.52-8A5.9,5.9,0,0,0,22.65,1a7.72,7.72,0,0,0-4.72-1A6.54,6.54,0,0,0,16.05.4,8.41,8.41,0,0,0,14,1.45a11,11,0,0,0-2.12,1.76,8.58,8.58,0,0,0-2.3,4,8.75,8.75,0,0,0,0,3.93,8.25,8.25,0,0,0,.33,1.23c-.78-.07-1.67.37-.83,3.36C9.7,18,10.28,18.57,10.72,18.61ZM49.55,37a.75.75,0,0,1-.79.66h-.17a3,3,0,0,0-2.77,1.84,3,3,0,0,0,.76,3.38.75.75,0,0,1,.08,1,13.5,13.5,0,0,1-2.19,2.17.76.76,0,0,1-1-.09,3.13,3.13,0,0,0-3.36-.76,3,3,0,0,0-1.85,2.89.75.75,0,0,1-.67.78,13.5,13.5,0,0,1-3,0,.75.75,0,0,1-.66-.79A3,3,0,0,0,32,45.2a3.12,3.12,0,0,0-3.38.76.75.75,0,0,1-1,.08,13.45,13.45,0,0,1-2.14-2.17.75.75,0,0,1,.08-1,3,3,0,0,0,.76-3.35,3,3,0,0,0-2.79-1.86.9.9,0,0,1-.89-.67,13.57,13.57,0,0,1,0-3.08.74.74,0,0,1,.78-.67,3.13,3.13,0,0,0,2.95-1.83A3,3,0,0,0,25.61,28a.75.75,0,0,1-.08-1,13.47,13.47,0,0,1,2.19-2.17.76.76,0,0,1,1,.09,3.13,3.13,0,0,0,3.35.76A3,3,0,0,0,34,22.78a.75.75,0,0,1,.67-.78,13.52,13.52,0,0,1,3,0,.75.75,0,0,1,.66.79,3,3,0,0,0,1.83,2.94A3.12,3.12,0,0,0,43.55,25a.75.75,0,0,1,1-.08,13.41,13.41,0,0,1,2.15,2.17.75.75,0,0,1-.08,1,3,3,0,0,0,2,5.21.88.88,0,0,1,.87.67A13.52,13.52,0,0,1,49.55,37ZM44.47,35.5a8.35,8.35,0,1,0-8.35,8.35A8.36,8.36,0,0,0,44.47,35.5Z'
				}
			};
		}

		return images;

		function getSrcImage(name) {
			return {
				src: 'src/images/svg/' + name
			};
		}

		function getSvgImage(minX, minY, width, height, data) {
			return {
				minX: minX,
				minY: minY,
				width: width,
				height: height,
				data: data
			};
		}
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 628 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(632), __webpack_require__(633), __webpack_require__(631), __webpack_require__(630), __webpack_require__(629)], __WEBPACK_AMD_DEFINE_RESULT__ = function (navigationControllerLoader, diNavigationDirectiveLoader, navigationWarningLoader, navigationWarningControllerLoader, goBackLoader) {
	'use strict';

	return function (module) {
		navigationControllerLoader(module);
		diNavigationDirectiveLoader(module);
		navigationWarningLoader(module);
		navigationWarningControllerLoader(module);
		goBackLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 629 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP18}
// di.einvoicing.ui.portal.components.navigation
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.directive('goBack', goBack);

		goBack.$inject = ['translator', 'diState'];

		return goBack;

		function goBack(translator, diState) {
			return {
				restrict: 'E',
				template: template,
				link: function link(scope, element, attrs, controllers) {
					element.on('click', function () {
						diState.goBack().catch(function (reason) {
							window.history.back();
						});
					});
				}
			};

			function template(element, attrs) {
				translator.translate(attrs.text).then(function (translated) {
					var html = '<a href="#">' + translated + '</a>';
					return html;
				});
			}
		};
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 630 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF0S}
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.controller('NavigationWarningController', NavigationWarningController);

		NavigationWarningController.$inject = ['$scope'];

		function NavigationWarningController(scope) {
			scope.noWarnStates = [{
				state: 'welcome',
				reason: 'SessionTimeout'
			}];

			return;
		}

		return NavigationWarningController;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 631 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP18}
// di.einvoicing.ui.portal.components.navigation
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.directive('diNavigationWarning', diNavigationWarning);

		diNavigationWarning.$inject = ['translator', '$window', 'promptWindow', 'diState', 'authenticationData', 'formAnalyser'];

		return diNavigationWarning;

		function diNavigationWarning(translator, window, promptWindow, state, authenticationData, formAnalyser) {
			return {
				restrict: 'A',
				required: '^^ngForm',
				controller: 'NavigationWarningController',
				link: function link(scope, element, attrs, controllers) {
					var form = formAnalyser.getFormInstance(scope);
					var removeStateListener = scope.$root.$on("$stateChangeStart", stateChanged);

					window.onbeforeunload = function () {
						return translator.translate(attrs.navigationWarningMessage);
					};

					scope.$on('$destroy', function () {
						removeStateListener();
						removeLeavingPageWarningBox();
					});

					return;

					function stateChanged(event, toState, toParams, fromState, fromParams, options) {
						if (!attrs.navigationWarningUnauthenticated && !authenticationData.userData.isAuthenticated || fromParams.navigationWarningAccepted || util.isNull(form) || form.$pristine || form.$submitted && !form.$dirty || util.isArray(scope.noWarnStates) && _.some(scope.noWarnStates, function (prevent) {
							return util.isDefined(prevent.state) && prevent.state === toState.name && prevent.reason === toParams.reason;
						})) {
							return;
						}

						if (fromState.name === toState.name) {
							options.reload = true;
						}

						var config = {
							title: attrs.navigationWarningTitle || "EINVOICING.COMPONENTS.NAVIGATION.ABANDON_CHANGES_WARNING.TITLE",
							message: attrs.navigationWarningMessage || "EINVOICING.COMPONENTS.NAVIGATION.ABANDON_CHANGES_WARNING.MESSAGE",
							okBtnText: 'CORE.PROMPT.YES',
							cancelBtnText: 'CORE.PROMPT.NO',
							callback: function callback(result) {
								if (result) {
									fromParams.navigationWarningAccepted = true;
									state.go(toState.name, toParams, options);
								}
							}
						};

						promptWindow.confirm(config);

						event.preventDefault();
					}

					function removeLeavingPageWarningBox() {
						window.onbeforeunload = function () {};
					}
				}
			};
		};
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 632 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP1V}
// di.einvoicing.ui.portal.components
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.controller('NavigationController', NavigationController);

		NavigationController.$inject = ['authorizedObjectsFilter', 'userRightsRepository', 'listsParamsStore', 'partyFeatureEnabledService', 'diState', 'partyProxy'];

		function NavigationController(authorizedObjectsFilter, userRightsRepository, listsParamsStore, partyFeatureEnabledService, diState, partyProxy) {
			var vm = this;
			vm.labels = {};
			vm.showCreateOptions = false;
			vm.toggleCreateOptions = toggleCreateOptions;
			vm.closeCreateOptions = closeCreateOptions;
			vm.canManageUsers = false;
			vm.canAccessIntegrator = false;
			vm.canCreateDocuments = false;
			vm.getStateParamsFromStorage = getStateParamsFromStorage;
			vm.getPartiesStateParams = getPartiesStateParams;
			vm.viewPartyManagement = viewPartyManagement;
			setLabels();

			return;

			/**
    * sets labels values depending on user rights           
    */
			function setLabels() {
				var data = [{
					rights: ["Supplier"],
					key: "orders",
					label: "EINVOICING.COMPONENTS.NAVIGATION.ORDERS_SUPPLIER"
				}, {
					rights: ["Buyer"],
					key: "orders",
					label: "EINVOICING.COMPONENTS.NAVIGATION.ORDERS_BUYER"
				}, {
					rights: ["Supplier"],
					key: "newOrder",
					label: "EINVOICING.COMPONENTS.NAVIGATION.ORDER_SUPPLIER"
				}, {
					rights: ["Buyer"],
					key: "newOrder",
					label: "EINVOICING.COMPONENTS.NAVIGATION.ORDER_BUYER"
				}, {
					rights: ["Supplier"],
					key: "invoices",
					label: "EINVOICING.COMPONENTS.NAVIGATION.INVOICES_SUPPLIER"
				}, {
					rights: ["Buyer"],
					key: "invoices",
					label: "EINVOICING.COMPONENTS.NAVIGATION.INVOICES_BUYER"
				}, {
					rights: ["Supplier"],
					key: "newInvoice",
					label: "EINVOICING.COMPONENTS.NAVIGATION.INVOICE_SUPPLIER"
				}, {
					rights: ["Buyer"],
					key: "newInvoice",
					label: "EINVOICING.COMPONENTS.NAVIGATION.INVOICE_BUYER"
				}, {
					rights: ["Supervisor"],
					key: "users",
					label: "EINVOICING.COMPONENTS.NAVIGATION.USERS"
				}, {
					rights: ["Supplier"],
					key: "partyManagement",
					label: "EINVOICING.COMPONENTS.NAVIGATION.BUYERS"
				}, {
					rights: ["Buyer"],
					key: "partyManagement",
					label: "EINVOICING.COMPONENTS.NAVIGATION.SUPPLIERS"
				}, {
					rights: ["Supplier", "Buyer"],
					key: "myPartyManagement",
					label: "EINVOICING.COMPONENTS.NAVIGATION.PARTY_MANAGEMENT"
				}];

				vm.labels = authorizedObjectsFilter.getAuthorizedObjectsAsAssociative(data, 'key', 'label');
				vm.canManageUsers = util.isDefined(vm.labels.users);
				vm.canCreateDocuments = userRightsRepository.userHasRight('Supplier') && userRightsRepository.userHasRight('InvoiceWriter') && userRightsRepository.userHasRight('InvoiceCreator');

				partyFeatureEnabledService.getPartyFeatureEnabled(1).then(function (result) {
					vm.canAccessIntegrator = result;
				});
			}

			function toggleCreateOptions() {
				vm.showCreateOptions = !vm.showCreateOptions;
			}

			function closeCreateOptions() {
				vm.showCreateOptions = false;
			}

			/*
    * Retrieves the state parameters that should be used in the navigation for the requested list view
    */
			function getStateParamsFromStorage(listView) {
				var filters = listsParamsStore.get(listView) || {};
				return filters;
			}

			function getPartiesStateParams() {
				var stateParams = getStateParamsFromStorage('parties');
				return _.extend(stateParams || {}, { pageTitle: vm.labels.partyManagement });
			}

			function getMyPartiesStateParams() {
				var stateParams = getStateParamsFromStorage('myParties');
				return _.extend(stateParams || {}, { pageTitle: vm.labels.myPartyManagement });
			}

			function viewPartyManagement() {
				partyProxy.getWorkingForPartyManagementSearchResults('').then(function (data) {
					if (data.length === 1) {
						var selectedParty = data[0];
						var pageParams = {
							id: selectedParty.partyId,
							forPartyId: selectedParty.partyId,
							partyName: selectedParty.partyName,
							forPartyName: selectedParty.partyName,
							singleDetails: 'true'
						};
						diState.go('portal.parties.viewById', pageParams);
					} else {
						diState.go('portal.parties.mylist', { pageTitle: 'EINVOICING.COMPONENTS.NAVIGATION.PARTY_MANAGEMENT' });
					}
				});
			}
		}

		return NavigationController;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 633 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP18}
// di.einvoicing.ui.portal.components.navigation
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ng) {
    'use strict';

    return function (module) {
        var compat = $di.utility.compatability;

        module.directive('diNavigation', diNavigation);

        function diNavigation() {
            return {
                restrict: 'E',
                replace: true,
                templateUrl: '/src/app/shared/components/navigation/navigation.html',
                controller: 'NavigationController',
                controllerAs: 'navigationCtrl',
                compile: compile
            };

            function compile(element, attrs) {
                activateMenuExpand();

                function activateMenuExpand() {
                    var trigger = ng.element('.js-expand-sidebar');
                    var main = ng.element('.main');
                    var sidebar = ng.element('.sidebar');

                    var elements = ng.element('.sidebar-header').add('.sidebar-content');

                    trigger.on('click', function () {
                        if (main.hasClass('sidebar-is-animating')) {
                            main.removeClass('sidebar-is-animating');
                            ng.element(this).removeClass('is-active');
                        } else {
                            main.addClass('sidebar-is-animating');
                            ng.element(this).addClass('is-active');
                        }

                        elements.addClass('is-hidden');
                    });

                    sidebar.on(compat.transitionEndEvent, function () {
                        if (main.hasClass('sidebar-is-animating')) {
                            main.addClass('sidebar-is-expanded');
                        } else {
                            main.removeClass('sidebar-is-expanded');
                        }

                        elements.removeClass('is-hidden');
                    })

                    // prevent children from bubbling 'transitionend' event to parent
                    .children().on(compat.transitionEndEvent, function (e) {
                        e.stopPropagation();
                    });
                }
            }
        }

        return diNavigation;
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 634 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(636), __webpack_require__(637), __webpack_require__(638), __webpack_require__(635)], __WEBPACK_AMD_DEFINE_RESULT__ = function (serviceStatusMonitorControllerLoader, serviceStatusMonitorDirectiveLoader, serviceStatusMonitorLoader, serverProxyLoader) {
	'use strict';

	return function (module) {
		serverProxyLoader(module);
		serviceStatusMonitorControllerLoader(module);
		serviceStatusMonitorDirectiveLoader(module);
		serviceStatusMonitorLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 635 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP83}
//di.einvoicing.ui.portal.proxies
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {

		module.factory('serverProxy', serverProxy);

		serverProxy.$inject = ['webApiHttp', '$q', 'urlHelper'];

		function serverProxy(http, $q, urlHelper) {
			return {
				getCurrentServerState: getCurrentServerState
			};

			function getCurrentServerState() {
				var requestUrl = urlHelper.setParameters('Status/GetCurrentServerState', {});

				var httpPromise = http.get(requestUrl);
				var newPromise = httpPromise.then(resolved, rejected);

				return newPromise;

				function resolved(data) {
					return data;
				}

				function rejected(error) {
					return $q.reject(error);
				}
			}
		}

		return serverProxy;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 636 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP85}
// di.einvoicing.ui.portal.components.serviceStatusMonitor
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.controller('ServiceStatusMonitorController', ServiceStatusMonitorController);

		ServiceStatusMonitorController.$inject = ['$interval', 'serverProxy', 'CLIENT_ENUMS', 'serviceStatusMonitor', 'authenticationData'];

		function ServiceStatusMonitorController($interval, serverProxy, clientEnums, serviceStatusMonitor, authenticationData) {

			var vm = this;
			vm.serviceState = 'down';
			var guard = $di.exception.guard;
			var util = $di.utility.util;
			var pollingInterval = serviceStatusMonitor.getPollingInterval();
			guard.throwIfUndefined("EUP8501E", pollingInterval, "pollingInterval");

			//first call for monitor service as $interval will place a delay
			monitorService();

			$interval(monitorService, pollingInterval);
			return;

			function monitorService() {
				if (!authenticationData.userData.isAuthenticated) {
					return;
				}

				serverProxy.getCurrentServerState().then(success, failure);
			}

			function success(data) {

				if (data === clientEnums.serviceState.up) {
					vm.serviceState = 'up';
				} else if (data === clientEnums.serviceState.maintenance) {
					vm.serviceState = 'maintenance';
				} else if (data === clientEnums.serviceState.down) {
					vm.serviceState = 'down';
				} else {
					vm.serviceState = 'unknown';
				}
			}

			function failure() {
				vm.serviceState = 'down';
			}
		};
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 637 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP86}
// di.einvoicing.ui.portal.components.serviceStatusMonitor
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {

		module.directive('diServiceStatusMonitor', serviceStatusMonitor);

		function serviceStatusMonitor() {
			return {
				restrict: 'E',
				relace: true,
				templateUrl: 'src/app/shared/components/service-status-monitor/service-status.html',
				controller: 'ServiceStatusMonitorController',
				controllerAs: 'serviceStatusMonitorCtrl'
			};
		}
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 638 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP87}
// di.einvoicing.ui.portal.components.serviceStatusMonitor
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var guard = $di.exception.guard;

		module.provider('serviceStatusMonitor', ServiceStatusMonitorProvider);

		function ServiceStatusMonitorProvider() {
			var config = {};

			var provider = {
				configure: configure,
				$get: $get
			};

			return provider;

			function configure(cfg) {
				guard.throwIfNotAnObject("EUP8701E", cfg, 'cfg');

				config = cfg;
			}

			function $get() {
				return {
					getPollingInterval: getPollingInterval
				};

				function getPollingInterval() {
					return config.pollingInterval;
				}
			}
		}

		return ServiceStatusMonitorProvider;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 639 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP4S}
// di.einvoicing.ui.portal.components.styleConstants
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(640)], __WEBPACK_AMD_DEFINE_RESULT__ = function (colourClassesLoader) {
    'use strict';

    return function (module) {
        colourClassesLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 640 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP4T}
// di.einvoicing.ui.portal.components.styleConstants
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.constant('COLOUR_CLASSES', colourClasses());

        function colourClasses() {
            return {
                offWhite: "#E6E7EA",
                button: "#4F87E6",
                icon: "#ABB0B8",
                negativeButton: "#A31515"
            };
        }
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 641 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(642)], __WEBPACK_AMD_DEFINE_RESULT__ = function (tooltipDirectiveLoader) {
    'use strict';

    return function (module) {
        tooltipDirectiveLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 642 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP1P}
// di.einvoicing.ui.portal.components
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        module.directive('diTooltip', diTooltip);

        function diTooltip() {
            return {
                restrict: 'A',
                link: function link(scope, element, attrs) {
                    element.hover(function () {
                        element.tooltip('show');
                    }, function () {
                        element.tooltip('hide');
                    });
                }
            };
        }

        return diTooltip;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 643 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP38}
// di.einvoicing.ui.portal.components
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(644), __webpack_require__(646), __webpack_require__(645)], __WEBPACK_AMD_DEFINE_RESULT__ = function (authenticationClientEventHandlerLoader, userSetingsStorageLoader, userRightsLoader) {
	'use strict';

	return function (module) {
		authenticationClientEventHandlerLoader(module);
		userSetingsStorageLoader(module);
		userRightsLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 644 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP3Y}
// di.einvoicing.ui.portal.components.user
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.factory('authenticationClientEventHandler', authenticationClientEventHandler);

		authenticationClientEventHandler.$inject = ['authenticationClientEventSubscriber', 'authenticationData', 'currencyCache', 'promptWindow', 'summaryOptionsStore', 'listsParamsStore', 'activityMonitor'];

		/**
   * Service responsible for performing application-specific actions on user
   * login and logout
   */
		function authenticationClientEventHandler(authenticationClientEventSubscriber, authenticationData, currencyCache, promptWindow, summaryOptionsStore, listsParamsStore, activityMonitor) {
			var service = {
				init: init
			};

			return service;

			/**
    * Subscribe to login/logout events
    */
			function init() {
				authenticationClientEventSubscriber.addLoggedInEventHandler(loggedIn);
				authenticationClientEventSubscriber.addLoggedOutEventHandler(loggedOut);
				authenticationClientEventSubscriber.addRightsChangedEventHandler(rightsChanged);
			}

			function loggedIn() {
				getCurrency();
			}

			function loggedOut(loggedOutReason) {
				removeSessionDataFromStorage();

				activityMonitor.stop();

				if (loggedOutReason) {
					var languageKey = 'EINVOICING.COMPONENTS.USERS.LOGGED_OUT_REASON.' + loggedOutReason.toUpperCase() + '.';

					var promptConfig = {
						title: languageKey + 'TITLE',
						message: languageKey + 'MESSAGE'
					};

					promptWindow.alert(promptConfig);
				}
			}

			function rightsChanged() {
				promptWindow.alert({
					title: 'EINVOICING.COMPONENTS.USERS.RIGHTS_CHANGED.TITLE',
					message: 'EINVOICING.COMPONENTS.USERS.RIGHTS_CHANGED.MESSAGE'
				});
			}

			function getCurrency() {
				return currencyCache.getCurrencies();
			}

			function removeSessionDataFromStorage() {
				summaryOptionsStore.clear();

				var listsParamsToRemove = ["searchText", "pageNumber"];
				listsParamsStore.remove("invoices", listsParamsToRemove);
				listsParamsStore.remove("orders", listsParamsToRemove);
				listsParamsStore.remove("grns", listsParamsToRemove);
			}
		}

		return authenticationClientEventHandler;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 645 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP4T}
// di.einvoicing.ui.portal.components.styleConstants
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		module.constant('USER_RIGHTS', userRights());

		function userRights() {
			return {
				Buyer: 'Buyer',
				Supplier: 'Supplier'
			};
		}
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 646 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:EUP39}
// di.einvoicing.ui.portal.components.user
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    return function (module) {
        var guard = $di.exception.guard;

        module.factory('userSettingsStore', userSettingsStore);

        userSettingsStore.$inject = ['sessionStore'];

        function userSettingsStore(sessionStore) {
            var storageKeys = {
                settings: {
                    language: 'settings.language'
                }
            };

            return {
                language: {
                    get: getLanguage,
                    set: setLanguage
                }
            };

            /**
             * Returns the currently stored language settings, if any.
             */
            function getLanguage() {
                return sessionStore.get(storageKeys.settings.language, 'userSettingsStore');
            }

            /**
             * Sets the stored language to the given value.
             * @param language
             */
            function setLanguage(language) {
                guard.throwIfNotAString("EUP3903E", language, "language");

                sessionStore.set(storageKeys.settings.language, language, 'userSettingsStore');
            }
        }

        return userSettingsStore;
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 647 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(648), __webpack_require__(650)], __WEBPACK_AMD_DEFINE_RESULT__ = function (partyFeatureEnabledLoader, sessionPreferencesLoader) {
    'use strict';

    return function (module) {
        partyFeatureEnabledLoader(module);
        sessionPreferencesLoader(module);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 648 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(649)], __WEBPACK_AMD_DEFINE_RESULT__ = function (partyFeatureEnabledService) {
	'use strict';

	return function (module) {
		module.service('partyFeatureEnabledService', partyFeatureEnabledService.PartyFeatureEnabledProxyService);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 649 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PartyFeatureEnabledProxyService = function () {
	function PartyFeatureEnabledProxyService(webApiHttp, urlHelper) {
		_classCallCheck(this, PartyFeatureEnabledProxyService);

		this._webApiHttp = webApiHttp;
		this._urlHelper = urlHelper;
	}

	_createClass(PartyFeatureEnabledProxyService, [{
		key: 'getPartyFeatureEnabled',
		value: function getPartyFeatureEnabled(featureId) {
			var requestedUrl = 'EInvoicingFeature/GetPartyHasEInvoicingFeature?einvoicingFeature=' + featureId;

			return this._webApiHttp.get(requestedUrl);
		}
	}]);

	return PartyFeatureEnabledProxyService;
}();

PartyFeatureEnabledProxyService.prototype.constructor.$inject = ['webApiHttp', 'urlHelper'];

exports.PartyFeatureEnabledProxyService = PartyFeatureEnabledProxyService;

/***/ }),
/* 650 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(651)], __WEBPACK_AMD_DEFINE_RESULT__ = function (listsParamsStoreLoader) {
	'use strict';

	return function (module) {
		listsParamsStoreLoader(module);
	};
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 651 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:DEF1C}
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	'use strict';

	return function (module) {
		var util = $di.utility.util;

		module.factory('listsParamsStore', listsParamsStore);

		listsParamsStore.$inject = ['sessionStore', 'authenticationData'];

		/**
   * Repository for storing filters for list views
   */
		function listsParamsStore(sessionStore, authenticationData) {
			var storagePrefix = 'listsParamsStore';
			var storageKey = 'latestParams';

			var service = {
				set: set,
				get: get,
				update: update,
				remove: remove,
				clear: clear
			};

			return service;

			/**
    * Function which sets the list options for the specified list view in local storage
    * 
    * @param listView - The list view for which the params are stored
    * @param listViewParams - The options to store
    */
			function set(listView, listViewParams) {
				var composite = composeStoragePrefix(storagePrefix);
				var currentPreferences = sessionStore.get(storageKey, composite);
				var newPreference = {};
				newPreference[listView] = listViewParams;
				var preferences = _.extend({}, currentPreferences, newPreference);
				sessionStore.set(storageKey, preferences, composite);
			}

			/**
    * Function which gets the filter options for the specified list view
    *  
    * @param listView - The list view to get the params for
    * @returns - The object representing the options for the specified list view
    * or undefined if preferences for the specified list view cannot be found
    */
			function get(listView) {
				var storedPreferences = sessionStore.get(storageKey, composeStoragePrefix(storagePrefix));

				if (util.isObject(storedPreferences)) {
					return storedPreferences[listView];
				}

				return undefined;
			}

			/**
    * Function which updates the list options for the specified list view in local storage
    * 
    * @param listView - The list view for which the params are updated
    * @param listViewParams - The options to update
    */
			function update(listView, listViewParams) {
				var composite = composeStoragePrefix(storagePrefix);
				var currentPreferences = sessionStore.get(storageKey, composite) || {};
				var newPreference = {};
				newPreference[listView] = _.extend({}, currentPreferences[listView], listViewParams);
				var preferences = _.extend({}, currentPreferences, newPreference);
				sessionStore.set(storageKey, preferences, composite);
			}

			/*
    * Removes the params with given names from the stored options of the given list view
    */
			function remove(listView, paramsNamesToRemove) {
				var composite = composeStoragePrefix(storagePrefix);
				var currentPreferences = sessionStore.get(storageKey, composite) || {};
				var newPreference = {};
				newPreference[listView] = _.omit(currentPreferences[listView] || {}, paramsNamesToRemove);
				var preferences = _.extend({}, currentPreferences, newPreference);
				sessionStore.set(storageKey, preferences, composite);
			}

			/**
    * Function which removes the params from storage
    */
			function clear() {
				sessionStore.remove(storageKey, composeStoragePrefix(storagePrefix));
			}

			/* Returns the storage prefix taking into account the user id */
			function composeStoragePrefix(initial) {
				var userId = authenticationData.userData.userId;
				return initial + '_' + userId;
			}
		}

		return listsParamsStore;
	};
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 652 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(653)], __WEBPACK_AMD_DEFINE_RESULT__ = function (welcomeComponentModule) {
    'use strict';

    return function (module) {
        module.component(welcomeComponentModule.welcomeComponent.selector, welcomeComponentModule.welcomeComponent);
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 653 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var welcomeComponent = exports.welcomeComponent = {
    templateUrl: 'src/app/welcome/welcome.html',
    selector: 'diWelcome',
    controllerAs: 'welcomeCtrl',
    controller: function () {
        function WelcomeController($stateParams, diState, validationInitialiser, validationRulesStore, userAuthenticationProxy, authenticationClientEventSubscriber) {
            _classCallCheck(this, WelcomeController);

            this.stateParams = $stateParams;
            this.diState = diState;
            this.validationInitialiser = validationInitialiser;
            this.validationRulesStore = validationRulesStore;
            this.userAuthenticationProxy = userAuthenticationProxy;
            this.authenticationClientEventSubscriber = authenticationClientEventSubscriber;

            this.onForgotPasswordClick = this.onForgotPasswordClick.bind(this);
            this.onPasswordReset = this.onPasswordReset.bind(this);
            this.onPasswordSet = this.onPasswordSet.bind(this);
            this.onBackToLoginClick = this.onBackToLoginClick.bind(this);
            this.subscribeToResetTokenChange = this.subscribeToResetTokenChange.bind(this);
            this.subscribeToFirstLogin = this.subscribeToFirstLogin.bind(this);
            this.subscribeToPasswordExpired = this.subscribeToPasswordExpired.bind(this);
            this.subscribeToUsernameChange = this.subscribeToUsernameChange.bind(this);
        }

        _createClass(WelcomeController, [{
            key: '$onInit',
            value: function $onInit() {
                this.init();
            }
        }, {
            key: 'init',
            value: function init() {
                this.firstTimeLogin = false;
                this.userName = '';
                this.setUpToken = '';
                this.passwordExpired = false;

                if (this.stateParams.resetToken) {
                    this.showForgotPassword = true;
                    this.resetToken = decodeURIComponent(this.stateParams.resetToken);
                } else {
                    this.showForgotPassword = false;
                    this.resetToken = '';
                }

                if (this.stateParams.reason) {
                    this.removeAllPopups(this.stateParams.reason);
                }

                this.diState.subscribeToStateChange('welcome', this.setAuthenticationValidationRules);

                this.setAuthenticationValidationRules();
            }
        }, {
            key: 'onForgotPasswordClick',
            value: function onForgotPasswordClick() {
                this.showForgotPassword = true;
            }
        }, {
            key: 'onPasswordReset',
            value: function onPasswordReset() {
                this.reloadWelcomePage();
            }
        }, {
            key: 'onPasswordSet',
            value: function onPasswordSet(userName, password) {
                var _this = this;

                this.userAuthenticationProxy.login(userName, password).then(function (data) {
                    var authenticationResult = data.result;

                    if (authenticationResult.success) {
                        _this.authenticationClientEventSubscriber.loggedIn(data);
                    }
                });
            }
        }, {
            key: 'onBackToLoginClick',
            value: function onBackToLoginClick() {
                this.reloadWelcomePage();
            }
        }, {
            key: 'reloadWelcomePage',
            value: function reloadWelcomePage() {
                this.firstTimeLogin = false;
                this.showForgotPassword = false;
                this.passwordExpired = false;
                this.diState.go('welcome');
            }
        }, {
            key: 'subscribeToResetTokenChange',
            value: function subscribeToResetTokenChange(subscription) {
                subscription(this.resetToken);
            }
        }, {
            key: 'subscribeToFirstLogin',
            value: function subscribeToFirstLogin(data) {
                this.firstTimeLogin = true;
                this.userName = data.username;
                this.setUpToken = data.setUpToken;
                this.passwordExpired = false;
            }
        }, {
            key: 'subscribeToPasswordExpired',
            value: function subscribeToPasswordExpired(data) {
                this.firstTimeLogin = true;
                this.userName = data.userName;
                this.setUpToken = data.result.token;
                this.passwordExpired = true;
            }
        }, {
            key: 'subscribeToUsernameChange',
            value: function subscribeToUsernameChange(subscription) {
                subscription(this.userName, this.setUpToken, this.passwordExpired);
            }
        }, {
            key: 'removeAllPopups',
            value: function removeAllPopups(allowModals) {
                if (!allowModals) {
                    $(".bootbox").remove(); //remove any modal bootbox popups
                    $(".modal-backdrop").remove(); //remove any modal backdrops
                }

                $(".pika-single").remove(); //remove any date pickers
            }
        }, {
            key: 'setAuthenticationValidationRules',
            value: function setAuthenticationValidationRules() {
                var authenticationRules = {
                    'authentication': {
                        "username": {
                            "required": {},
                            "email": {},
                            "size": {
                                "min": 1
                            }
                        },
                        "password": {
                            "required": {},
                            "size": {
                                "min": 1
                            }
                        }
                    },
                    'forgotPasswordEmail': {
                        "emailAddress": {
                            "required": {},
                            "email": {}
                        }
                    },
                    'forgotPasswordSecurity': {
                        "securityAnswer": {
                            "required": {}
                        }
                    },
                    'changePassword': {
                        "oldPassword": {
                            "required": {}
                        },
                        "newPassword": {
                            "required": {}

                        },
                        "confirmPassword": {
                            "required": {},
                            "equalIfSelfSet": {
                                "requireModels": ['newPassword'],
                                "clientComparerName": "default"
                            }
                        }
                    },
                    'resetPassword': {
                        "resetToken": {
                            "required": {}
                        },
                        "newPassword": {
                            "required": {}
                        },
                        "confirmPassword": {
                            "required": {},
                            "equalIfSelfSet": {
                                "requireModels": ['newPassword'],
                                "clientComparerName": "default"
                            }
                        }
                    },
                    'passwordExpired': {
                        "userName": {
                            "required": {}
                        },
                        "token": {
                            "required": {}
                        },
                        "newPassword": {
                            "required": {}
                        },
                        "confirmPassword": {
                            "required": {},
                            "equalIfSelfSet": {
                                "requireModels": ['newPassword'],
                                "clientComparerName": "default"
                            }
                        }
                    },
                    'setPassword': {
                        "userName": {
                            "required": {}
                        },
                        "token": {
                            "required": {}
                        },
                        "newPassword": {
                            "required": {}
                        },
                        "confirmPassword": {
                            "required": {},
                            "equalIfSelfSet": {
                                "requireModels": ['newPassword'],
                                "clientComparerName": "default"
                            }
                        },
                        "securityQuestion": {
                            "required": {}
                        },
                        "securityAnswer": {
                            "required": {}
                        }
                    },
                    'editSecurityQuestion': {
                        "securityQuestion": {
                            "required": {}
                        },
                        "securityAnswer": {
                            "required": {}
                        }
                    }
                };

                if (this.validationInitialiser) {
                    this.validationInitialiser.applyValidationRules(authenticationRules);
                }

                if (this.validationRulesStore) {
                    this.validationRulesStore.setValidationRules(authenticationRules);
                }
            }
        }], [{
            key: '$inject',
            get: function get() {
                return ['$stateParams', 'diState', 'validationInitialiser', 'validationRulesStore', 'userAuthenticationProxy', 'authenticationClientEventSubscriber'];
            }
        }]);

        return WelcomeController;
    }()
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ }),
/* 654 */
/***/ (function(module, exports) {

/**
 * @license AngularJS v1.6.5
 * (c) 2010-2017 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function(window, angular) {'use strict';

var ELEMENT_NODE = 1;
var COMMENT_NODE = 8;

var ADD_CLASS_SUFFIX = '-add';
var REMOVE_CLASS_SUFFIX = '-remove';
var EVENT_CLASS_PREFIX = 'ng-';
var ACTIVE_CLASS_SUFFIX = '-active';
var PREPARE_CLASS_SUFFIX = '-prepare';

var NG_ANIMATE_CLASSNAME = 'ng-animate';
var NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';

// Detect proper transitionend/animationend event names.
var CSS_PREFIX = '', TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;

// If unprefixed events are not supported but webkit-prefixed are, use the latter.
// Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.
// Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`
// but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.
// Register both events in case `window.onanimationend` is not supported because of that,
// do the same for `transitionend` as Safari is likely to exhibit similar behavior.
// Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit
// therefore there is no reason to test anymore for other vendor prefixes:
// http://caniuse.com/#search=transition
if ((window.ontransitionend === undefined) && (window.onwebkittransitionend !== undefined)) {
  CSS_PREFIX = '-webkit-';
  TRANSITION_PROP = 'WebkitTransition';
  TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';
} else {
  TRANSITION_PROP = 'transition';
  TRANSITIONEND_EVENT = 'transitionend';
}

if ((window.onanimationend === undefined) && (window.onwebkitanimationend !== undefined)) {
  CSS_PREFIX = '-webkit-';
  ANIMATION_PROP = 'WebkitAnimation';
  ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';
} else {
  ANIMATION_PROP = 'animation';
  ANIMATIONEND_EVENT = 'animationend';
}

var DURATION_KEY = 'Duration';
var PROPERTY_KEY = 'Property';
var DELAY_KEY = 'Delay';
var TIMING_KEY = 'TimingFunction';
var ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';
var ANIMATION_PLAYSTATE_KEY = 'PlayState';
var SAFE_FAST_FORWARD_DURATION_VALUE = 9999;

var ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;
var ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;
var TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;
var TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;

var ngMinErr = angular.$$minErr('ng');
function assertArg(arg, name, reason) {
  if (!arg) {
    throw ngMinErr('areq', 'Argument \'{0}\' is {1}', (name || '?'), (reason || 'required'));
  }
  return arg;
}

function mergeClasses(a,b) {
  if (!a && !b) return '';
  if (!a) return b;
  if (!b) return a;
  if (isArray(a)) a = a.join(' ');
  if (isArray(b)) b = b.join(' ');
  return a + ' ' + b;
}

function packageStyles(options) {
  var styles = {};
  if (options && (options.to || options.from)) {
    styles.to = options.to;
    styles.from = options.from;
  }
  return styles;
}

function pendClasses(classes, fix, isPrefix) {
  var className = '';
  classes = isArray(classes)
      ? classes
      : classes && isString(classes) && classes.length
          ? classes.split(/\s+/)
          : [];
  forEach(classes, function(klass, i) {
    if (klass && klass.length > 0) {
      className += (i > 0) ? ' ' : '';
      className += isPrefix ? fix + klass
                            : klass + fix;
    }
  });
  return className;
}

function removeFromArray(arr, val) {
  var index = arr.indexOf(val);
  if (val >= 0) {
    arr.splice(index, 1);
  }
}

function stripCommentsFromElement(element) {
  if (element instanceof jqLite) {
    switch (element.length) {
      case 0:
        return element;

      case 1:
        // there is no point of stripping anything if the element
        // is the only element within the jqLite wrapper.
        // (it's important that we retain the element instance.)
        if (element[0].nodeType === ELEMENT_NODE) {
          return element;
        }
        break;

      default:
        return jqLite(extractElementNode(element));
    }
  }

  if (element.nodeType === ELEMENT_NODE) {
    return jqLite(element);
  }
}

function extractElementNode(element) {
  if (!element[0]) return element;
  for (var i = 0; i < element.length; i++) {
    var elm = element[i];
    if (elm.nodeType === ELEMENT_NODE) {
      return elm;
    }
  }
}

function $$addClass($$jqLite, element, className) {
  forEach(element, function(elm) {
    $$jqLite.addClass(elm, className);
  });
}

function $$removeClass($$jqLite, element, className) {
  forEach(element, function(elm) {
    $$jqLite.removeClass(elm, className);
  });
}

function applyAnimationClassesFactory($$jqLite) {
  return function(element, options) {
    if (options.addClass) {
      $$addClass($$jqLite, element, options.addClass);
      options.addClass = null;
    }
    if (options.removeClass) {
      $$removeClass($$jqLite, element, options.removeClass);
      options.removeClass = null;
    }
  };
}

function prepareAnimationOptions(options) {
  options = options || {};
  if (!options.$$prepared) {
    var domOperation = options.domOperation || noop;
    options.domOperation = function() {
      options.$$domOperationFired = true;
      domOperation();
      domOperation = noop;
    };
    options.$$prepared = true;
  }
  return options;
}

function applyAnimationStyles(element, options) {
  applyAnimationFromStyles(element, options);
  applyAnimationToStyles(element, options);
}

function applyAnimationFromStyles(element, options) {
  if (options.from) {
    element.css(options.from);
    options.from = null;
  }
}

function applyAnimationToStyles(element, options) {
  if (options.to) {
    element.css(options.to);
    options.to = null;
  }
}

function mergeAnimationDetails(element, oldAnimation, newAnimation) {
  var target = oldAnimation.options || {};
  var newOptions = newAnimation.options || {};

  var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');
  var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');
  var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);

  if (newOptions.preparationClasses) {
    target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);
    delete newOptions.preparationClasses;
  }

  // noop is basically when there is no callback; otherwise something has been set
  var realDomOperation = target.domOperation !== noop ? target.domOperation : null;

  extend(target, newOptions);

  // TODO(matsko or sreeramu): proper fix is to maintain all animation callback in array and call at last,but now only leave has the callback so no issue with this.
  if (realDomOperation) {
    target.domOperation = realDomOperation;
  }

  if (classes.addClass) {
    target.addClass = classes.addClass;
  } else {
    target.addClass = null;
  }

  if (classes.removeClass) {
    target.removeClass = classes.removeClass;
  } else {
    target.removeClass = null;
  }

  oldAnimation.addClass = target.addClass;
  oldAnimation.removeClass = target.removeClass;

  return target;
}

function resolveElementClasses(existing, toAdd, toRemove) {
  var ADD_CLASS = 1;
  var REMOVE_CLASS = -1;

  var flags = {};
  existing = splitClassesToLookup(existing);

  toAdd = splitClassesToLookup(toAdd);
  forEach(toAdd, function(value, key) {
    flags[key] = ADD_CLASS;
  });

  toRemove = splitClassesToLookup(toRemove);
  forEach(toRemove, function(value, key) {
    flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;
  });

  var classes = {
    addClass: '',
    removeClass: ''
  };

  forEach(flags, function(val, klass) {
    var prop, allow;
    if (val === ADD_CLASS) {
      prop = 'addClass';
      allow = !existing[klass] || existing[klass + REMOVE_CLASS_SUFFIX];
    } else if (val === REMOVE_CLASS) {
      prop = 'removeClass';
      allow = existing[klass] || existing[klass + ADD_CLASS_SUFFIX];
    }
    if (allow) {
      if (classes[prop].length) {
        classes[prop] += ' ';
      }
      classes[prop] += klass;
    }
  });

  function splitClassesToLookup(classes) {
    if (isString(classes)) {
      classes = classes.split(' ');
    }

    var obj = {};
    forEach(classes, function(klass) {
      // sometimes the split leaves empty string values
      // incase extra spaces were applied to the options
      if (klass.length) {
        obj[klass] = true;
      }
    });
    return obj;
  }

  return classes;
}

function getDomNode(element) {
  return (element instanceof jqLite) ? element[0] : element;
}

function applyGeneratedPreparationClasses(element, event, options) {
  var classes = '';
  if (event) {
    classes = pendClasses(event, EVENT_CLASS_PREFIX, true);
  }
  if (options.addClass) {
    classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));
  }
  if (options.removeClass) {
    classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));
  }
  if (classes.length) {
    options.preparationClasses = classes;
    element.addClass(classes);
  }
}

function clearGeneratedClasses(element, options) {
  if (options.preparationClasses) {
    element.removeClass(options.preparationClasses);
    options.preparationClasses = null;
  }
  if (options.activeClasses) {
    element.removeClass(options.activeClasses);
    options.activeClasses = null;
  }
}

function blockTransitions(node, duration) {
  // we use a negative delay value since it performs blocking
  // yet it doesn't kill any existing transitions running on the
  // same element which makes this safe for class-based animations
  var value = duration ? '-' + duration + 's' : '';
  applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);
  return [TRANSITION_DELAY_PROP, value];
}

function blockKeyframeAnimations(node, applyBlock) {
  var value = applyBlock ? 'paused' : '';
  var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
  applyInlineStyle(node, [key, value]);
  return [key, value];
}

function applyInlineStyle(node, styleTuple) {
  var prop = styleTuple[0];
  var value = styleTuple[1];
  node.style[prop] = value;
}

function concatWithSpace(a,b) {
  if (!a) return b;
  if (!b) return a;
  return a + ' ' + b;
}

var $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {
  var queue, cancelFn;

  function scheduler(tasks) {
    // we make a copy since RAFScheduler mutates the state
    // of the passed in array variable and this would be difficult
    // to track down on the outside code
    queue = queue.concat(tasks);
    nextTick();
  }

  queue = scheduler.queue = [];

  /* waitUntilQuiet does two things:
   * 1. It will run the FINAL `fn` value only when an uncanceled RAF has passed through
   * 2. It will delay the next wave of tasks from running until the quiet `fn` has run.
   *
   * The motivation here is that animation code can request more time from the scheduler
   * before the next wave runs. This allows for certain DOM properties such as classes to
   * be resolved in time for the next animation to run.
   */
  scheduler.waitUntilQuiet = function(fn) {
    if (cancelFn) cancelFn();

    cancelFn = $$rAF(function() {
      cancelFn = null;
      fn();
      nextTick();
    });
  };

  return scheduler;

  function nextTick() {
    if (!queue.length) return;

    var items = queue.shift();
    for (var i = 0; i < items.length; i++) {
      items[i]();
    }

    if (!cancelFn) {
      $$rAF(function() {
        if (!cancelFn) nextTick();
      });
    }
  }
}];

/**
 * @ngdoc directive
 * @name ngAnimateChildren
 * @restrict AE
 * @element ANY
 *
 * @description
 *
 * ngAnimateChildren allows you to specify that children of this element should animate even if any
 * of the children's parents are currently animating. By default, when an element has an active `enter`, `leave`, or `move`
 * (structural) animation, child elements that also have an active structural animation are not animated.
 *
 * Note that even if `ngAnimateChildren` is set, no child animations will run when the parent element is removed from the DOM (`leave` animation).
 *
 *
 * @param {string} ngAnimateChildren If the value is empty, `true` or `on`,
 *     then child animations are allowed. If the value is `false`, child animations are not allowed.
 *
 * @example
 * <example module="ngAnimateChildren" name="ngAnimateChildren" deps="angular-animate.js" animations="true">
     <file name="index.html">
       <div ng-controller="MainController as main">
         <label>Show container? <input type="checkbox" ng-model="main.enterElement" /></label>
         <label>Animate children? <input type="checkbox" ng-model="main.animateChildren" /></label>
         <hr>
         <div ng-animate-children="{{main.animateChildren}}">
           <div ng-if="main.enterElement" class="container">
             List of items:
             <div ng-repeat="item in [0, 1, 2, 3]" class="item">Item {{item}}</div>
           </div>
         </div>
       </div>
     </file>
     <file name="animations.css">

      .container.ng-enter,
      .container.ng-leave {
        transition: all ease 1.5s;
      }

      .container.ng-enter,
      .container.ng-leave-active {
        opacity: 0;
      }

      .container.ng-leave,
      .container.ng-enter-active {
        opacity: 1;
      }

      .item {
        background: firebrick;
        color: #FFF;
        margin-bottom: 10px;
      }

      .item.ng-enter,
      .item.ng-leave {
        transition: transform 1.5s ease;
      }

      .item.ng-enter {
        transform: translateX(50px);
      }

      .item.ng-enter-active {
        transform: translateX(0);
      }
    </file>
    <file name="script.js">
      angular.module('ngAnimateChildren', ['ngAnimate'])
        .controller('MainController', function MainController() {
          this.animateChildren = false;
          this.enterElement = false;
        });
    </file>
  </example>
 */
var $$AnimateChildrenDirective = ['$interpolate', function($interpolate) {
  return {
    link: function(scope, element, attrs) {
      var val = attrs.ngAnimateChildren;
      if (isString(val) && val.length === 0) { //empty attribute
        element.data(NG_ANIMATE_CHILDREN_DATA, true);
      } else {
        // Interpolate and set the value, so that it is available to
        // animations that run right after compilation
        setData($interpolate(val)(scope));
        attrs.$observe('ngAnimateChildren', setData);
      }

      function setData(value) {
        value = value === 'on' || value === 'true';
        element.data(NG_ANIMATE_CHILDREN_DATA, value);
      }
    }
  };
}];

/* exported $AnimateCssProvider */

var ANIMATE_TIMER_KEY = '$$animateCss';

/**
 * @ngdoc service
 * @name $animateCss
 * @kind object
 *
 * @description
 * The `$animateCss` service is a useful utility to trigger customized CSS-based transitions/keyframes
 * from a JavaScript-based animation or directly from a directive. The purpose of `$animateCss` is NOT
 * to side-step how `$animate` and ngAnimate work, but the goal is to allow pre-existing animations or
 * directives to create more complex animations that can be purely driven using CSS code.
 *
 * Note that only browsers that support CSS transitions and/or keyframe animations are capable of
 * rendering animations triggered via `$animateCss` (bad news for IE9 and lower).
 *
 * ## Usage
 * Once again, `$animateCss` is designed to be used inside of a registered JavaScript animation that
 * is powered by ngAnimate. It is possible to use `$animateCss` directly inside of a directive, however,
 * any automatic control over cancelling animations and/or preventing animations from being run on
 * child elements will not be handled by Angular. For this to work as expected, please use `$animate` to
 * trigger the animation and then setup a JavaScript animation that injects `$animateCss` to trigger
 * the CSS animation.
 *
 * The example below shows how we can create a folding animation on an element using `ng-if`:
 *
 * ```html
 * <!-- notice the `fold-animation` CSS class -->
 * <div ng-if="onOff" class="fold-animation">
 *   This element will go BOOM
 * </div>
 * <button ng-click="onOff=true">Fold In</button>
 * ```
 *
 * Now we create the **JavaScript animation** that will trigger the CSS transition:
 *
 * ```js
 * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {
 *   return {
 *     enter: function(element, doneFn) {
 *       var height = element[0].offsetHeight;
 *       return $animateCss(element, {
 *         from: { height:'0px' },
 *         to: { height:height + 'px' },
 *         duration: 1 // one second
 *       });
 *     }
 *   }
 * }]);
 * ```
 *
 * ## More Advanced Uses
 *
 * `$animateCss` is the underlying code that ngAnimate uses to power **CSS-based animations** behind the scenes. Therefore CSS hooks
 * like `.ng-EVENT`, `.ng-EVENT-active`, `.ng-EVENT-stagger` are all features that can be triggered using `$animateCss` via JavaScript code.
 *
 * This also means that just about any combination of adding classes, removing classes, setting styles, dynamically setting a keyframe animation,
 * applying a hardcoded duration or delay value, changing the animation easing or applying a stagger animation are all options that work with
 * `$animateCss`. The service itself is smart enough to figure out the combination of options and examine the element styling properties in order
 * to provide a working animation that will run in CSS.
 *
 * The example below showcases a more advanced version of the `.fold-animation` from the example above:
 *
 * ```js
 * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {
 *   return {
 *     enter: function(element, doneFn) {
 *       var height = element[0].offsetHeight;
 *       return $animateCss(element, {
 *         addClass: 'red large-text pulse-twice',
 *         easing: 'ease-out',
 *         from: { height:'0px' },
 *         to: { height:height + 'px' },
 *         duration: 1 // one second
 *       });
 *     }
 *   }
 * }]);
 * ```
 *
 * Since we're adding/removing CSS classes then the CSS transition will also pick those up:
 *
 * ```css
 * /&#42; since a hardcoded duration value of 1 was provided in the JavaScript animation code,
 * the CSS classes below will be transitioned despite them being defined as regular CSS classes &#42;/
 * .red { background:red; }
 * .large-text { font-size:20px; }
 *
 * /&#42; we can also use a keyframe animation and $animateCss will make it work alongside the transition &#42;/
 * .pulse-twice {
 *   animation: 0.5s pulse linear 2;
 *   -webkit-animation: 0.5s pulse linear 2;
 * }
 *
 * @keyframes pulse {
 *   from { transform: scale(0.5); }
 *   to { transform: scale(1.5); }
 * }
 *
 * @-webkit-keyframes pulse {
 *   from { -webkit-transform: scale(0.5); }
 *   to { -webkit-transform: scale(1.5); }
 * }
 * ```
 *
 * Given this complex combination of CSS classes, styles and options, `$animateCss` will figure everything out and make the animation happen.
 *
 * ## How the Options are handled
 *
 * `$animateCss` is very versatile and intelligent when it comes to figuring out what configurations to apply to the element to ensure the animation
 * works with the options provided. Say for example we were adding a class that contained a keyframe value and we wanted to also animate some inline
 * styles using the `from` and `to` properties.
 *
 * ```js
 * var animator = $animateCss(element, {
 *   from: { background:'red' },
 *   to: { background:'blue' }
 * });
 * animator.start();
 * ```
 *
 * ```css
 * .rotating-animation {
 *   animation:0.5s rotate linear;
 *   -webkit-animation:0.5s rotate linear;
 * }
 *
 * @keyframes rotate {
 *   from { transform: rotate(0deg); }
 *   to { transform: rotate(360deg); }
 * }
 *
 * @-webkit-keyframes rotate {
 *   from { -webkit-transform: rotate(0deg); }
 *   to { -webkit-transform: rotate(360deg); }
 * }
 * ```
 *
 * The missing pieces here are that we do not have a transition set (within the CSS code nor within the `$animateCss` options) and the duration of the animation is
 * going to be detected from what the keyframe styles on the CSS class are. In this event, `$animateCss` will automatically create an inline transition
 * style matching the duration detected from the keyframe style (which is present in the CSS class that is being added) and then prepare both the transition
 * and keyframe animations to run in parallel on the element. Then when the animation is underway the provided `from` and `to` CSS styles will be applied
 * and spread across the transition and keyframe animation.
 *
 * ## What is returned
 *
 * `$animateCss` works in two stages: a preparation phase and an animation phase. Therefore when `$animateCss` is first called it will NOT actually
 * start the animation. All that is going on here is that the element is being prepared for the animation (which means that the generated CSS classes are
 * added and removed on the element). Once `$animateCss` is called it will return an object with the following properties:
 *
 * ```js
 * var animator = $animateCss(element, { ... });
 * ```
 *
 * Now what do the contents of our `animator` variable look like:
 *
 * ```js
 * {
 *   // starts the animation
 *   start: Function,
 *
 *   // ends (aborts) the animation
 *   end: Function
 * }
 * ```
 *
 * To actually start the animation we need to run `animation.start()` which will then return a promise that we can hook into to detect when the animation ends.
 * If we choose not to run the animation then we MUST run `animation.end()` to perform a cleanup on the element (since some CSS classes and styles may have been
 * applied to the element during the preparation phase). Note that all other properties such as duration, delay, transitions and keyframes are just properties
 * and that changing them will not reconfigure the parameters of the animation.
 *
 * ### runner.done() vs runner.then()
 * It is documented that `animation.start()` will return a promise object and this is true, however, there is also an additional method available on the
 * runner called `.done(callbackFn)`. The done method works the same as `.finally(callbackFn)`, however, it does **not trigger a digest to occur**.
 * Therefore, for performance reasons, it's always best to use `runner.done(callback)` instead of `runner.then()`, `runner.catch()` or `runner.finally()`
 * unless you really need a digest to kick off afterwards.
 *
 * Keep in mind that, to make this easier, ngAnimate has tweaked the JS animations API to recognize when a runner instance is returned from $animateCss
 * (so there is no need to call `runner.done(doneFn)` inside of your JavaScript animation code).
 * Check the {@link ngAnimate.$animateCss#usage animation code above} to see how this works.
 *
 * @param {DOMElement} element the element that will be animated
 * @param {object} options the animation-related options that will be applied during the animation
 *
 * * `event` - The DOM event (e.g. enter, leave, move). When used, a generated CSS class of `ng-EVENT` and `ng-EVENT-active` will be applied
 * to the element during the animation. Multiple events can be provided when spaces are used as a separator. (Note that this will not perform any DOM operation.)
 * * `structural` - Indicates that the `ng-` prefix will be added to the event class. Setting to `false` or omitting will turn `ng-EVENT` and
 * `ng-EVENT-active` in `EVENT` and `EVENT-active`. Unused if `event` is omitted.
 * * `easing` - The CSS easing value that will be applied to the transition or keyframe animation (or both).
 * * `transitionStyle` - The raw CSS transition style that will be used (e.g. `1s linear all`).
 * * `keyframeStyle` - The raw CSS keyframe animation style that will be used (e.g. `1s my_animation linear`).
 * * `from` - The starting CSS styles (a key/value object) that will be applied at the start of the animation.
 * * `to` - The ending CSS styles (a key/value object) that will be applied across the animation via a CSS transition.
 * * `addClass` - A space separated list of CSS classes that will be added to the element and spread across the animation.
 * * `removeClass` - A space separated list of CSS classes that will be removed from the element and spread across the animation.
 * * `duration` - A number value representing the total duration of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `0`
 * is provided then the animation will be skipped entirely.
 * * `delay` - A number value representing the total delay of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `true` is
 * used then whatever delay value is detected from the CSS classes will be mirrored on the elements styles (e.g. by setting delay true then the style value
 * of the element will be `transition-delay: DETECTED_VALUE`). Using `true` is useful when you want the CSS classes and inline styles to all share the same
 * CSS delay value.
 * * `stagger` - A numeric time value representing the delay between successively animated elements
 * ({@link ngAnimate#css-staggering-animations Click here to learn how CSS-based staggering works in ngAnimate.})
 * * `staggerIndex` - The numeric index representing the stagger item (e.g. a value of 5 is equal to the sixth item in the stagger; therefore when a
 *   `stagger` option value of `0.1` is used then there will be a stagger delay of `600ms`)
 * * `applyClassesEarly` - Whether or not the classes being added or removed will be used when detecting the animation. This is set by `$animate` when enter/leave/move animations are fired to ensure that the CSS classes are resolved in time. (Note that this will prevent any transitions from occurring on the classes being added and removed.)
 * * `cleanupStyles` - Whether or not the provided `from` and `to` styles will be removed once
 *    the animation is closed. This is useful for when the styles are used purely for the sake of
 *    the animation and do not have a lasting visual effect on the element (e.g. a collapse and open animation).
 *    By default this value is set to `false`.
 *
 * @return {object} an object with start and end methods and details about the animation.
 *
 * * `start` - The method to start the animation. This will return a `Promise` when called.
 * * `end` - This method will cancel the animation and remove all applied CSS classes and styles.
 */
var ONE_SECOND = 1000;

var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
var CLOSING_TIME_BUFFER = 1.5;

var DETECT_CSS_PROPERTIES = {
  transitionDuration:      TRANSITION_DURATION_PROP,
  transitionDelay:         TRANSITION_DELAY_PROP,
  transitionProperty:      TRANSITION_PROP + PROPERTY_KEY,
  animationDuration:       ANIMATION_DURATION_PROP,
  animationDelay:          ANIMATION_DELAY_PROP,
  animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY
};

var DETECT_STAGGER_CSS_PROPERTIES = {
  transitionDuration:      TRANSITION_DURATION_PROP,
  transitionDelay:         TRANSITION_DELAY_PROP,
  animationDuration:       ANIMATION_DURATION_PROP,
  animationDelay:          ANIMATION_DELAY_PROP
};

function getCssKeyframeDurationStyle(duration) {
  return [ANIMATION_DURATION_PROP, duration + 's'];
}

function getCssDelayStyle(delay, isKeyframeAnimation) {
  var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;
  return [prop, delay + 's'];
}

function computeCssStyles($window, element, properties) {
  var styles = Object.create(null);
  var detectedStyles = $window.getComputedStyle(element) || {};
  forEach(properties, function(formalStyleName, actualStyleName) {
    var val = detectedStyles[formalStyleName];
    if (val) {
      var c = val.charAt(0);

      // only numerical-based values have a negative sign or digit as the first value
      if (c === '-' || c === '+' || c >= 0) {
        val = parseMaxTime(val);
      }

      // by setting this to null in the event that the delay is not set or is set directly as 0
      // then we can still allow for negative values to be used later on and not mistake this
      // value for being greater than any other negative value.
      if (val === 0) {
        val = null;
      }
      styles[actualStyleName] = val;
    }
  });

  return styles;
}

function parseMaxTime(str) {
  var maxValue = 0;
  var values = str.split(/\s*,\s*/);
  forEach(values, function(value) {
    // it's always safe to consider only second values and omit `ms` values since
    // getComputedStyle will always handle the conversion for us
    if (value.charAt(value.length - 1) === 's') {
      value = value.substring(0, value.length - 1);
    }
    value = parseFloat(value) || 0;
    maxValue = maxValue ? Math.max(value, maxValue) : value;
  });
  return maxValue;
}

function truthyTimingValue(val) {
  return val === 0 || val != null;
}

function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
  var style = TRANSITION_PROP;
  var value = duration + 's';
  if (applyOnlyDuration) {
    style += DURATION_KEY;
  } else {
    value += ' linear all';
  }
  return [style, value];
}

function createLocalCacheLookup() {
  var cache = Object.create(null);
  return {
    flush: function() {
      cache = Object.create(null);
    },

    count: function(key) {
      var entry = cache[key];
      return entry ? entry.total : 0;
    },

    get: function(key) {
      var entry = cache[key];
      return entry && entry.value;
    },

    put: function(key, value) {
      if (!cache[key]) {
        cache[key] = { total: 1, value: value };
      } else {
        cache[key].total++;
      }
    }
  };
}

// we do not reassign an already present style value since
// if we detect the style property value again we may be
// detecting styles that were added via the `from` styles.
// We make use of `isDefined` here since an empty string
// or null value (which is what getPropertyValue will return
// for a non-existing style) will still be marked as a valid
// value for the style (a falsy value implies that the style
// is to be removed at the end of the animation). If we had a simple
// "OR" statement then it would not be enough to catch that.
function registerRestorableStyles(backup, node, properties) {
  forEach(properties, function(prop) {
    backup[prop] = isDefined(backup[prop])
        ? backup[prop]
        : node.style.getPropertyValue(prop);
  });
}

var $AnimateCssProvider = ['$animateProvider', /** @this */ function($animateProvider) {
  var gcsLookup = createLocalCacheLookup();
  var gcsStaggerLookup = createLocalCacheLookup();

  this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout',
               '$$forceReflow', '$sniffer', '$$rAFScheduler', '$$animateQueue',
       function($window,   $$jqLite,   $$AnimateRunner,   $timeout,
                $$forceReflow,   $sniffer,   $$rAFScheduler, $$animateQueue) {

    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);

    var parentCounter = 0;
    function gcsHashFn(node, extraClasses) {
      var KEY = '$$ngAnimateParentKey';
      var parentNode = node.parentNode;
      var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);
      return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;
    }

    function computeCachedCssStyles(node, className, cacheKey, properties) {
      var timings = gcsLookup.get(cacheKey);

      if (!timings) {
        timings = computeCssStyles($window, node, properties);
        if (timings.animationIterationCount === 'infinite') {
          timings.animationIterationCount = 1;
        }
      }

      // we keep putting this in multiple times even though the value and the cacheKey are the same
      // because we're keeping an internal tally of how many duplicate animations are detected.
      gcsLookup.put(cacheKey, timings);
      return timings;
    }

    function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {
      var stagger;

      // if we have one or more existing matches of matching elements
      // containing the same parent + CSS styles (which is how cacheKey works)
      // then staggering is possible
      if (gcsLookup.count(cacheKey) > 0) {
        stagger = gcsStaggerLookup.get(cacheKey);

        if (!stagger) {
          var staggerClassName = pendClasses(className, '-stagger');

          $$jqLite.addClass(node, staggerClassName);

          stagger = computeCssStyles($window, node, properties);

          // force the conversion of a null value to zero incase not set
          stagger.animationDuration = Math.max(stagger.animationDuration, 0);
          stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);

          $$jqLite.removeClass(node, staggerClassName);

          gcsStaggerLookup.put(cacheKey, stagger);
        }
      }

      return stagger || {};
    }

    var rafWaitQueue = [];
    function waitUntilQuiet(callback) {
      rafWaitQueue.push(callback);
      $$rAFScheduler.waitUntilQuiet(function() {
        gcsLookup.flush();
        gcsStaggerLookup.flush();

        // DO NOT REMOVE THIS LINE OR REFACTOR OUT THE `pageWidth` variable.
        // PLEASE EXAMINE THE `$$forceReflow` service to understand why.
        var pageWidth = $$forceReflow();

        // we use a for loop to ensure that if the queue is changed
        // during this looping then it will consider new requests
        for (var i = 0; i < rafWaitQueue.length; i++) {
          rafWaitQueue[i](pageWidth);
        }
        rafWaitQueue.length = 0;
      });
    }

    function computeTimings(node, className, cacheKey) {
      var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);
      var aD = timings.animationDelay;
      var tD = timings.transitionDelay;
      timings.maxDelay = aD && tD
          ? Math.max(aD, tD)
          : (aD || tD);
      timings.maxDuration = Math.max(
          timings.animationDuration * timings.animationIterationCount,
          timings.transitionDuration);

      return timings;
    }

    return function init(element, initialOptions) {
      // all of the animation functions should create
      // a copy of the options data, however, if a
      // parent service has already created a copy then
      // we should stick to using that
      var options = initialOptions || {};
      if (!options.$$prepared) {
        options = prepareAnimationOptions(copy(options));
      }

      var restoreStyles = {};
      var node = getDomNode(element);
      if (!node
          || !node.parentNode
          || !$$animateQueue.enabled()) {
        return closeAndReturnNoopAnimator();
      }

      var temporaryStyles = [];
      var classes = element.attr('class');
      var styles = packageStyles(options);
      var animationClosed;
      var animationPaused;
      var animationCompleted;
      var runner;
      var runnerHost;
      var maxDelay;
      var maxDelayTime;
      var maxDuration;
      var maxDurationTime;
      var startTime;
      var events = [];

      if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {
        return closeAndReturnNoopAnimator();
      }

      var method = options.event && isArray(options.event)
            ? options.event.join(' ')
            : options.event;

      var isStructural = method && options.structural;
      var structuralClassName = '';
      var addRemoveClassName = '';

      if (isStructural) {
        structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);
      } else if (method) {
        structuralClassName = method;
      }

      if (options.addClass) {
        addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);
      }

      if (options.removeClass) {
        if (addRemoveClassName.length) {
          addRemoveClassName += ' ';
        }
        addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);
      }

      // there may be a situation where a structural animation is combined together
      // with CSS classes that need to resolve before the animation is computed.
      // However this means that there is no explicit CSS code to block the animation
      // from happening (by setting 0s none in the class name). If this is the case
      // we need to apply the classes before the first rAF so we know to continue if
      // there actually is a detected transition or keyframe animation
      if (options.applyClassesEarly && addRemoveClassName.length) {
        applyAnimationClasses(element, options);
      }

      var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();
      var fullClassName = classes + ' ' + preparationClasses;
      var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);
      var hasToStyles = styles.to && Object.keys(styles.to).length > 0;
      var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;

      // there is no way we can trigger an animation if no styles and
      // no classes are being applied which would then trigger a transition,
      // unless there a is raw keyframe value that is applied to the element.
      if (!containsKeyframeAnimation
           && !hasToStyles
           && !preparationClasses) {
        return closeAndReturnNoopAnimator();
      }

      var cacheKey, stagger;
      if (options.stagger > 0) {
        var staggerVal = parseFloat(options.stagger);
        stagger = {
          transitionDelay: staggerVal,
          animationDelay: staggerVal,
          transitionDuration: 0,
          animationDuration: 0
        };
      } else {
        cacheKey = gcsHashFn(node, fullClassName);
        stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);
      }

      if (!options.$$skipPreparationClasses) {
        $$jqLite.addClass(element, preparationClasses);
      }

      var applyOnlyDuration;

      if (options.transitionStyle) {
        var transitionStyle = [TRANSITION_PROP, options.transitionStyle];
        applyInlineStyle(node, transitionStyle);
        temporaryStyles.push(transitionStyle);
      }

      if (options.duration >= 0) {
        applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;
        var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);

        // we set the duration so that it will be picked up by getComputedStyle later
        applyInlineStyle(node, durationStyle);
        temporaryStyles.push(durationStyle);
      }

      if (options.keyframeStyle) {
        var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];
        applyInlineStyle(node, keyframeStyle);
        temporaryStyles.push(keyframeStyle);
      }

      var itemIndex = stagger
          ? options.staggerIndex >= 0
              ? options.staggerIndex
              : gcsLookup.count(cacheKey)
          : 0;

      var isFirst = itemIndex === 0;

      // this is a pre-emptive way of forcing the setup classes to be added and applied INSTANTLY
      // without causing any combination of transitions to kick in. By adding a negative delay value
      // it forces the setup class' transition to end immediately. We later then remove the negative
      // transition delay to allow for the transition to naturally do it's thing. The beauty here is
      // that if there is no transition defined then nothing will happen and this will also allow
      // other transitions to be stacked on top of each other without any chopping them out.
      if (isFirst && !options.skipBlocking) {
        blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
      }

      var timings = computeTimings(node, fullClassName, cacheKey);
      var relativeDelay = timings.maxDelay;
      maxDelay = Math.max(relativeDelay, 0);
      maxDuration = timings.maxDuration;

      var flags = {};
      flags.hasTransitions          = timings.transitionDuration > 0;
      flags.hasAnimations           = timings.animationDuration > 0;
      flags.hasTransitionAll        = flags.hasTransitions && timings.transitionProperty === 'all';
      flags.applyTransitionDuration = hasToStyles && (
                                        (flags.hasTransitions && !flags.hasTransitionAll)
                                         || (flags.hasAnimations && !flags.hasTransitions));
      flags.applyAnimationDuration  = options.duration && flags.hasAnimations;
      flags.applyTransitionDelay    = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);
      flags.applyAnimationDelay     = truthyTimingValue(options.delay) && flags.hasAnimations;
      flags.recalculateTimingStyles = addRemoveClassName.length > 0;

      if (flags.applyTransitionDuration || flags.applyAnimationDuration) {
        maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;

        if (flags.applyTransitionDuration) {
          flags.hasTransitions = true;
          timings.transitionDuration = maxDuration;
          applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;
          temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));
        }

        if (flags.applyAnimationDuration) {
          flags.hasAnimations = true;
          timings.animationDuration = maxDuration;
          temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));
        }
      }

      if (maxDuration === 0 && !flags.recalculateTimingStyles) {
        return closeAndReturnNoopAnimator();
      }

      if (options.delay != null) {
        var delayStyle;
        if (typeof options.delay !== 'boolean') {
          delayStyle = parseFloat(options.delay);
          // number in options.delay means we have to recalculate the delay for the closing timeout
          maxDelay = Math.max(delayStyle, 0);
        }

        if (flags.applyTransitionDelay) {
          temporaryStyles.push(getCssDelayStyle(delayStyle));
        }

        if (flags.applyAnimationDelay) {
          temporaryStyles.push(getCssDelayStyle(delayStyle, true));
        }
      }

      // we need to recalculate the delay value since we used a pre-emptive negative
      // delay value and the delay value is required for the final event checking. This
      // property will ensure that this will happen after the RAF phase has passed.
      if (options.duration == null && timings.transitionDuration > 0) {
        flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;
      }

      maxDelayTime = maxDelay * ONE_SECOND;
      maxDurationTime = maxDuration * ONE_SECOND;
      if (!options.skipBlocking) {
        flags.blockTransition = timings.transitionDuration > 0;
        flags.blockKeyframeAnimation = timings.animationDuration > 0 &&
                                       stagger.animationDelay > 0 &&
                                       stagger.animationDuration === 0;
      }

      if (options.from) {
        if (options.cleanupStyles) {
          registerRestorableStyles(restoreStyles, node, Object.keys(options.from));
        }
        applyAnimationFromStyles(element, options);
      }

      if (flags.blockTransition || flags.blockKeyframeAnimation) {
        applyBlocking(maxDuration);
      } else if (!options.skipBlocking) {
        blockTransitions(node, false);
      }

      // TODO(matsko): for 1.5 change this code to have an animator object for better debugging
      return {
        $$willAnimate: true,
        end: endFn,
        start: function() {
          if (animationClosed) return;

          runnerHost = {
            end: endFn,
            cancel: cancelFn,
            resume: null, //this will be set during the start() phase
            pause: null
          };

          runner = new $$AnimateRunner(runnerHost);

          waitUntilQuiet(start);

          // we don't have access to pause/resume the animation
          // since it hasn't run yet. AnimateRunner will therefore
          // set noop functions for resume and pause and they will
          // later be overridden once the animation is triggered
          return runner;
        }
      };

      function endFn() {
        close();
      }

      function cancelFn() {
        close(true);
      }

      function close(rejected) {
        // if the promise has been called already then we shouldn't close
        // the animation again
        if (animationClosed || (animationCompleted && animationPaused)) return;
        animationClosed = true;
        animationPaused = false;

        if (!options.$$skipPreparationClasses) {
          $$jqLite.removeClass(element, preparationClasses);
        }
        $$jqLite.removeClass(element, activeClasses);

        blockKeyframeAnimations(node, false);
        blockTransitions(node, false);

        forEach(temporaryStyles, function(entry) {
          // There is only one way to remove inline style properties entirely from elements.
          // By using `removeProperty` this works, but we need to convert camel-cased CSS
          // styles down to hyphenated values.
          node.style[entry[0]] = '';
        });

        applyAnimationClasses(element, options);
        applyAnimationStyles(element, options);

        if (Object.keys(restoreStyles).length) {
          forEach(restoreStyles, function(value, prop) {
            if (value) {
              node.style.setProperty(prop, value);
            } else {
              node.style.removeProperty(prop);
            }
          });
        }

        // the reason why we have this option is to allow a synchronous closing callback
        // that is fired as SOON as the animation ends (when the CSS is removed) or if
        // the animation never takes off at all. A good example is a leave animation since
        // the element must be removed just after the animation is over or else the element
        // will appear on screen for one animation frame causing an overbearing flicker.
        if (options.onDone) {
          options.onDone();
        }

        if (events && events.length) {
          // Remove the transitionend / animationend listener(s)
          element.off(events.join(' '), onAnimationProgress);
        }

        //Cancel the fallback closing timeout and remove the timer data
        var animationTimerData = element.data(ANIMATE_TIMER_KEY);
        if (animationTimerData) {
          $timeout.cancel(animationTimerData[0].timer);
          element.removeData(ANIMATE_TIMER_KEY);
        }

        // if the preparation function fails then the promise is not setup
        if (runner) {
          runner.complete(!rejected);
        }
      }

      function applyBlocking(duration) {
        if (flags.blockTransition) {
          blockTransitions(node, duration);
        }

        if (flags.blockKeyframeAnimation) {
          blockKeyframeAnimations(node, !!duration);
        }
      }

      function closeAndReturnNoopAnimator() {
        runner = new $$AnimateRunner({
          end: endFn,
          cancel: cancelFn
        });

        // should flush the cache animation
        waitUntilQuiet(noop);
        close();

        return {
          $$willAnimate: false,
          start: function() {
            return runner;
          },
          end: endFn
        };
      }

      function onAnimationProgress(event) {
        event.stopPropagation();
        var ev = event.originalEvent || event;

        // we now always use `Date.now()` due to the recent changes with
        // event.timeStamp in Firefox, Webkit and Chrome (see #13494 for more info)
        var timeStamp = ev.$manualTimeStamp || Date.now();

        /* Firefox (or possibly just Gecko) likes to not round values up
         * when a ms measurement is used for the animation */
        var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));

        /* $manualTimeStamp is a mocked timeStamp value which is set
         * within browserTrigger(). This is only here so that tests can
         * mock animations properly. Real events fallback to event.timeStamp,
         * or, if they don't, then a timeStamp is automatically created for them.
         * We're checking to see if the timeStamp surpasses the expected delay,
         * but we're using elapsedTime instead of the timeStamp on the 2nd
         * pre-condition since animationPauseds sometimes close off early */
        if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
          // we set this flag to ensure that if the transition is paused then, when resumed,
          // the animation will automatically close itself since transitions cannot be paused.
          animationCompleted = true;
          close();
        }
      }

      function start() {
        if (animationClosed) return;
        if (!node.parentNode) {
          close();
          return;
        }

        // even though we only pause keyframe animations here the pause flag
        // will still happen when transitions are used. Only the transition will
        // not be paused since that is not possible. If the animation ends when
        // paused then it will not complete until unpaused or cancelled.
        var playPause = function(playAnimation) {
          if (!animationCompleted) {
            animationPaused = !playAnimation;
            if (timings.animationDuration) {
              var value = blockKeyframeAnimations(node, animationPaused);
              if (animationPaused) {
                temporaryStyles.push(value);
              } else {
                removeFromArray(temporaryStyles, value);
              }
            }
          } else if (animationPaused && playAnimation) {
            animationPaused = false;
            close();
          }
        };

        // checking the stagger duration prevents an accidentally cascade of the CSS delay style
        // being inherited from the parent. If the transition duration is zero then we can safely
        // rely that the delay value is an intentional stagger delay style.
        var maxStagger = itemIndex > 0
                         && ((timings.transitionDuration && stagger.transitionDuration === 0) ||
                            (timings.animationDuration && stagger.animationDuration === 0))
                         && Math.max(stagger.animationDelay, stagger.transitionDelay);
        if (maxStagger) {
          $timeout(triggerAnimationStart,
                   Math.floor(maxStagger * itemIndex * ONE_SECOND),
                   false);
        } else {
          triggerAnimationStart();
        }

        // this will decorate the existing promise runner with pause/resume methods
        runnerHost.resume = function() {
          playPause(true);
        };

        runnerHost.pause = function() {
          playPause(false);
        };

        function triggerAnimationStart() {
          // just incase a stagger animation kicks in when the animation
          // itself was cancelled entirely
          if (animationClosed) return;

          applyBlocking(false);

          forEach(temporaryStyles, function(entry) {
            var key = entry[0];
            var value = entry[1];
            node.style[key] = value;
          });

          applyAnimationClasses(element, options);
          $$jqLite.addClass(element, activeClasses);

          if (flags.recalculateTimingStyles) {
            fullClassName = node.getAttribute('class') + ' ' + preparationClasses;
            cacheKey = gcsHashFn(node, fullClassName);

            timings = computeTimings(node, fullClassName, cacheKey);
            relativeDelay = timings.maxDelay;
            maxDelay = Math.max(relativeDelay, 0);
            maxDuration = timings.maxDuration;

            if (maxDuration === 0) {
              close();
              return;
            }

            flags.hasTransitions = timings.transitionDuration > 0;
            flags.hasAnimations = timings.animationDuration > 0;
          }

          if (flags.applyAnimationDelay) {
            relativeDelay = typeof options.delay !== 'boolean' && truthyTimingValue(options.delay)
                  ? parseFloat(options.delay)
                  : relativeDelay;

            maxDelay = Math.max(relativeDelay, 0);
            timings.animationDelay = relativeDelay;
            delayStyle = getCssDelayStyle(relativeDelay, true);
            temporaryStyles.push(delayStyle);
            node.style[delayStyle[0]] = delayStyle[1];
          }

          maxDelayTime = maxDelay * ONE_SECOND;
          maxDurationTime = maxDuration * ONE_SECOND;

          if (options.easing) {
            var easeProp, easeVal = options.easing;
            if (flags.hasTransitions) {
              easeProp = TRANSITION_PROP + TIMING_KEY;
              temporaryStyles.push([easeProp, easeVal]);
              node.style[easeProp] = easeVal;
            }
            if (flags.hasAnimations) {
              easeProp = ANIMATION_PROP + TIMING_KEY;
              temporaryStyles.push([easeProp, easeVal]);
              node.style[easeProp] = easeVal;
            }
          }

          if (timings.transitionDuration) {
            events.push(TRANSITIONEND_EVENT);
          }

          if (timings.animationDuration) {
            events.push(ANIMATIONEND_EVENT);
          }

          startTime = Date.now();
          var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;
          var endTime = startTime + timerTime;

          var animationsData = element.data(ANIMATE_TIMER_KEY) || [];
          var setupFallbackTimer = true;
          if (animationsData.length) {
            var currentTimerData = animationsData[0];
            setupFallbackTimer = endTime > currentTimerData.expectedEndTime;
            if (setupFallbackTimer) {
              $timeout.cancel(currentTimerData.timer);
            } else {
              animationsData.push(close);
            }
          }

          if (setupFallbackTimer) {
            var timer = $timeout(onAnimationExpired, timerTime, false);
            animationsData[0] = {
              timer: timer,
              expectedEndTime: endTime
            };
            animationsData.push(close);
            element.data(ANIMATE_TIMER_KEY, animationsData);
          }

          if (events.length) {
            element.on(events.join(' '), onAnimationProgress);
          }

          if (options.to) {
            if (options.cleanupStyles) {
              registerRestorableStyles(restoreStyles, node, Object.keys(options.to));
            }
            applyAnimationToStyles(element, options);
          }
        }

        function onAnimationExpired() {
          var animationsData = element.data(ANIMATE_TIMER_KEY);

          // this will be false in the event that the element was
          // removed from the DOM (via a leave animation or something
          // similar)
          if (animationsData) {
            for (var i = 1; i < animationsData.length; i++) {
              animationsData[i]();
            }
            element.removeData(ANIMATE_TIMER_KEY);
          }
        }
      }
    };
  }];
}];

var $$AnimateCssDriverProvider = ['$$animationProvider', /** @this */ function($$animationProvider) {
  $$animationProvider.drivers.push('$$animateCssDriver');

  var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';
  var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';

  var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';
  var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';

  function isDocumentFragment(node) {
    return node.parentNode && node.parentNode.nodeType === 11;
  }

  this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document',
       function($animateCss,   $rootScope,   $$AnimateRunner,   $rootElement,   $sniffer,   $$jqLite,   $document) {

    // only browsers that support these properties can render animations
    if (!$sniffer.animations && !$sniffer.transitions) return noop;

    var bodyNode = $document[0].body;
    var rootNode = getDomNode($rootElement);

    var rootBodyElement = jqLite(
      // this is to avoid using something that exists outside of the body
      // we also special case the doc fragment case because our unit test code
      // appends the $rootElement to the body after the app has been bootstrapped
      isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode
    );

    return function initDriverFn(animationDetails) {
      return animationDetails.from && animationDetails.to
          ? prepareFromToAnchorAnimation(animationDetails.from,
                                         animationDetails.to,
                                         animationDetails.classes,
                                         animationDetails.anchors)
          : prepareRegularAnimation(animationDetails);
    };

    function filterCssClasses(classes) {
      //remove all the `ng-` stuff
      return classes.replace(/\bng-\S+\b/g, '');
    }

    function getUniqueValues(a, b) {
      if (isString(a)) a = a.split(' ');
      if (isString(b)) b = b.split(' ');
      return a.filter(function(val) {
        return b.indexOf(val) === -1;
      }).join(' ');
    }

    function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {
      var clone = jqLite(getDomNode(outAnchor).cloneNode(true));
      var startingClasses = filterCssClasses(getClassVal(clone));

      outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
      inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);

      clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);

      rootBodyElement.append(clone);

      var animatorIn, animatorOut = prepareOutAnimation();

      // the user may not end up using the `out` animation and
      // only making use of the `in` animation or vice-versa.
      // In either case we should allow this and not assume the
      // animation is over unless both animations are not used.
      if (!animatorOut) {
        animatorIn = prepareInAnimation();
        if (!animatorIn) {
          return end();
        }
      }

      var startingAnimator = animatorOut || animatorIn;

      return {
        start: function() {
          var runner;

          var currentAnimation = startingAnimator.start();
          currentAnimation.done(function() {
            currentAnimation = null;
            if (!animatorIn) {
              animatorIn = prepareInAnimation();
              if (animatorIn) {
                currentAnimation = animatorIn.start();
                currentAnimation.done(function() {
                  currentAnimation = null;
                  end();
                  runner.complete();
                });
                return currentAnimation;
              }
            }
            // in the event that there is no `in` animation
            end();
            runner.complete();
          });

          runner = new $$AnimateRunner({
            end: endFn,
            cancel: endFn
          });

          return runner;

          function endFn() {
            if (currentAnimation) {
              currentAnimation.end();
            }
          }
        }
      };

      function calculateAnchorStyles(anchor) {
        var styles = {};

        var coords = getDomNode(anchor).getBoundingClientRect();

        // we iterate directly since safari messes up and doesn't return
        // all the keys for the coords object when iterated
        forEach(['width','height','top','left'], function(key) {
          var value = coords[key];
          switch (key) {
            case 'top':
              value += bodyNode.scrollTop;
              break;
            case 'left':
              value += bodyNode.scrollLeft;
              break;
          }
          styles[key] = Math.floor(value) + 'px';
        });
        return styles;
      }

      function prepareOutAnimation() {
        var animator = $animateCss(clone, {
          addClass: NG_OUT_ANCHOR_CLASS_NAME,
          delay: true,
          from: calculateAnchorStyles(outAnchor)
        });

        // read the comment within `prepareRegularAnimation` to understand
        // why this check is necessary
        return animator.$$willAnimate ? animator : null;
      }

      function getClassVal(element) {
        return element.attr('class') || '';
      }

      function prepareInAnimation() {
        var endingClasses = filterCssClasses(getClassVal(inAnchor));
        var toAdd = getUniqueValues(endingClasses, startingClasses);
        var toRemove = getUniqueValues(startingClasses, endingClasses);

        var animator = $animateCss(clone, {
          to: calculateAnchorStyles(inAnchor),
          addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,
          removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,
          delay: true
        });

        // read the comment within `prepareRegularAnimation` to understand
        // why this check is necessary
        return animator.$$willAnimate ? animator : null;
      }

      function end() {
        clone.remove();
        outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
        inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
      }
    }

    function prepareFromToAnchorAnimation(from, to, classes, anchors) {
      var fromAnimation = prepareRegularAnimation(from, noop);
      var toAnimation = prepareRegularAnimation(to, noop);

      var anchorAnimations = [];
      forEach(anchors, function(anchor) {
        var outElement = anchor['out'];
        var inElement = anchor['in'];
        var animator = prepareAnchoredAnimation(classes, outElement, inElement);
        if (animator) {
          anchorAnimations.push(animator);
        }
      });

      // no point in doing anything when there are no elements to animate
      if (!fromAnimation && !toAnimation && anchorAnimations.length === 0) return;

      return {
        start: function() {
          var animationRunners = [];

          if (fromAnimation) {
            animationRunners.push(fromAnimation.start());
          }

          if (toAnimation) {
            animationRunners.push(toAnimation.start());
          }

          forEach(anchorAnimations, function(animation) {
            animationRunners.push(animation.start());
          });

          var runner = new $$AnimateRunner({
            end: endFn,
            cancel: endFn // CSS-driven animations cannot be cancelled, only ended
          });

          $$AnimateRunner.all(animationRunners, function(status) {
            runner.complete(status);
          });

          return runner;

          function endFn() {
            forEach(animationRunners, function(runner) {
              runner.end();
            });
          }
        }
      };
    }

    function prepareRegularAnimation(animationDetails) {
      var element = animationDetails.element;
      var options = animationDetails.options || {};

      if (animationDetails.structural) {
        options.event = animationDetails.event;
        options.structural = true;
        options.applyClassesEarly = true;

        // we special case the leave animation since we want to ensure that
        // the element is removed as soon as the animation is over. Otherwise
        // a flicker might appear or the element may not be removed at all
        if (animationDetails.event === 'leave') {
          options.onDone = options.domOperation;
        }
      }

      // We assign the preparationClasses as the actual animation event since
      // the internals of $animateCss will just suffix the event token values
      // with `-active` to trigger the animation.
      if (options.preparationClasses) {
        options.event = concatWithSpace(options.event, options.preparationClasses);
      }

      var animator = $animateCss(element, options);

      // the driver lookup code inside of $$animation attempts to spawn a
      // driver one by one until a driver returns a.$$willAnimate animator object.
      // $animateCss will always return an object, however, it will pass in
      // a flag as a hint as to whether an animation was detected or not
      return animator.$$willAnimate ? animator : null;
    }
  }];
}];

// TODO(matsko): use caching here to speed things up for detection
// TODO(matsko): add documentation
//  by the time...

var $$AnimateJsProvider = ['$animateProvider', /** @this */ function($animateProvider) {
  this.$get = ['$injector', '$$AnimateRunner', '$$jqLite',
       function($injector,   $$AnimateRunner,   $$jqLite) {

    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
         // $animateJs(element, 'enter');
    return function(element, event, classes, options) {
      var animationClosed = false;

      // the `classes` argument is optional and if it is not used
      // then the classes will be resolved from the element's className
      // property as well as options.addClass/options.removeClass.
      if (arguments.length === 3 && isObject(classes)) {
        options = classes;
        classes = null;
      }

      options = prepareAnimationOptions(options);
      if (!classes) {
        classes = element.attr('class') || '';
        if (options.addClass) {
          classes += ' ' + options.addClass;
        }
        if (options.removeClass) {
          classes += ' ' + options.removeClass;
        }
      }

      var classesToAdd = options.addClass;
      var classesToRemove = options.removeClass;

      // the lookupAnimations function returns a series of animation objects that are
      // matched up with one or more of the CSS classes. These animation objects are
      // defined via the module.animation factory function. If nothing is detected then
      // we don't return anything which then makes $animation query the next driver.
      var animations = lookupAnimations(classes);
      var before, after;
      if (animations.length) {
        var afterFn, beforeFn;
        if (event === 'leave') {
          beforeFn = 'leave';
          afterFn = 'afterLeave'; // TODO(matsko): get rid of this
        } else {
          beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);
          afterFn = event;
        }

        if (event !== 'enter' && event !== 'move') {
          before = packageAnimations(element, event, options, animations, beforeFn);
        }
        after  = packageAnimations(element, event, options, animations, afterFn);
      }

      // no matching animations
      if (!before && !after) return;

      function applyOptions() {
        options.domOperation();
        applyAnimationClasses(element, options);
      }

      function close() {
        animationClosed = true;
        applyOptions();
        applyAnimationStyles(element, options);
      }

      var runner;

      return {
        $$willAnimate: true,
        end: function() {
          if (runner) {
            runner.end();
          } else {
            close();
            runner = new $$AnimateRunner();
            runner.complete(true);
          }
          return runner;
        },
        start: function() {
          if (runner) {
            return runner;
          }

          runner = new $$AnimateRunner();
          var closeActiveAnimations;
          var chain = [];

          if (before) {
            chain.push(function(fn) {
              closeActiveAnimations = before(fn);
            });
          }

          if (chain.length) {
            chain.push(function(fn) {
              applyOptions();
              fn(true);
            });
          } else {
            applyOptions();
          }

          if (after) {
            chain.push(function(fn) {
              closeActiveAnimations = after(fn);
            });
          }

          runner.setHost({
            end: function() {
              endAnimations();
            },
            cancel: function() {
              endAnimations(true);
            }
          });

          $$AnimateRunner.chain(chain, onComplete);
          return runner;

          function onComplete(success) {
            close(success);
            runner.complete(success);
          }

          function endAnimations(cancelled) {
            if (!animationClosed) {
              (closeActiveAnimations || noop)(cancelled);
              onComplete(cancelled);
            }
          }
        }
      };

      function executeAnimationFn(fn, element, event, options, onDone) {
        var args;
        switch (event) {
          case 'animate':
            args = [element, options.from, options.to, onDone];
            break;

          case 'setClass':
            args = [element, classesToAdd, classesToRemove, onDone];
            break;

          case 'addClass':
            args = [element, classesToAdd, onDone];
            break;

          case 'removeClass':
            args = [element, classesToRemove, onDone];
            break;

          default:
            args = [element, onDone];
            break;
        }

        args.push(options);

        var value = fn.apply(fn, args);
        if (value) {
          if (isFunction(value.start)) {
            value = value.start();
          }

          if (value instanceof $$AnimateRunner) {
            value.done(onDone);
          } else if (isFunction(value)) {
            // optional onEnd / onCancel callback
            return value;
          }
        }

        return noop;
      }

      function groupEventedAnimations(element, event, options, animations, fnName) {
        var operations = [];
        forEach(animations, function(ani) {
          var animation = ani[fnName];
          if (!animation) return;

          // note that all of these animations will run in parallel
          operations.push(function() {
            var runner;
            var endProgressCb;

            var resolved = false;
            var onAnimationComplete = function(rejected) {
              if (!resolved) {
                resolved = true;
                (endProgressCb || noop)(rejected);
                runner.complete(!rejected);
              }
            };

            runner = new $$AnimateRunner({
              end: function() {
                onAnimationComplete();
              },
              cancel: function() {
                onAnimationComplete(true);
              }
            });

            endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {
              var cancelled = result === false;
              onAnimationComplete(cancelled);
            });

            return runner;
          });
        });

        return operations;
      }

      function packageAnimations(element, event, options, animations, fnName) {
        var operations = groupEventedAnimations(element, event, options, animations, fnName);
        if (operations.length === 0) {
          var a, b;
          if (fnName === 'beforeSetClass') {
            a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');
            b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');
          } else if (fnName === 'setClass') {
            a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');
            b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');
          }

          if (a) {
            operations = operations.concat(a);
          }
          if (b) {
            operations = operations.concat(b);
          }
        }

        if (operations.length === 0) return;

        // TODO(matsko): add documentation
        return function startAnimation(callback) {
          var runners = [];
          if (operations.length) {
            forEach(operations, function(animateFn) {
              runners.push(animateFn());
            });
          }

          if (runners.length) {
            $$AnimateRunner.all(runners, callback);
          }  else {
            callback();
          }

          return function endFn(reject) {
            forEach(runners, function(runner) {
              if (reject) {
                runner.cancel();
              } else {
                runner.end();
              }
            });
          };
        };
      }
    };

    function lookupAnimations(classes) {
      classes = isArray(classes) ? classes : classes.split(' ');
      var matches = [], flagMap = {};
      for (var i = 0; i < classes.length; i++) {
        var klass = classes[i],
            animationFactory = $animateProvider.$$registeredAnimations[klass];
        if (animationFactory && !flagMap[klass]) {
          matches.push($injector.get(animationFactory));
          flagMap[klass] = true;
        }
      }
      return matches;
    }
  }];
}];

var $$AnimateJsDriverProvider = ['$$animationProvider', /** @this */ function($$animationProvider) {
  $$animationProvider.drivers.push('$$animateJsDriver');
  this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {
    return function initDriverFn(animationDetails) {
      if (animationDetails.from && animationDetails.to) {
        var fromAnimation = prepareAnimation(animationDetails.from);
        var toAnimation = prepareAnimation(animationDetails.to);
        if (!fromAnimation && !toAnimation) return;

        return {
          start: function() {
            var animationRunners = [];

            if (fromAnimation) {
              animationRunners.push(fromAnimation.start());
            }

            if (toAnimation) {
              animationRunners.push(toAnimation.start());
            }

            $$AnimateRunner.all(animationRunners, done);

            var runner = new $$AnimateRunner({
              end: endFnFactory(),
              cancel: endFnFactory()
            });

            return runner;

            function endFnFactory() {
              return function() {
                forEach(animationRunners, function(runner) {
                  // at this point we cannot cancel animations for groups just yet. 1.5+
                  runner.end();
                });
              };
            }

            function done(status) {
              runner.complete(status);
            }
          }
        };
      } else {
        return prepareAnimation(animationDetails);
      }
    };

    function prepareAnimation(animationDetails) {
      // TODO(matsko): make sure to check for grouped animations and delegate down to normal animations
      var element = animationDetails.element;
      var event = animationDetails.event;
      var options = animationDetails.options;
      var classes = animationDetails.classes;
      return $$animateJs(element, event, classes, options);
    }
  }];
}];

var NG_ANIMATE_ATTR_NAME = 'data-ng-animate';
var NG_ANIMATE_PIN_DATA = '$ngAnimatePin';
var $$AnimateQueueProvider = ['$animateProvider', /** @this */ function($animateProvider) {
  var PRE_DIGEST_STATE = 1;
  var RUNNING_STATE = 2;
  var ONE_SPACE = ' ';

  var rules = this.rules = {
    skip: [],
    cancel: [],
    join: []
  };

  function makeTruthyCssClassMap(classString) {
    if (!classString) {
      return null;
    }

    var keys = classString.split(ONE_SPACE);
    var map = Object.create(null);

    forEach(keys, function(key) {
      map[key] = true;
    });
    return map;
  }

  function hasMatchingClasses(newClassString, currentClassString) {
    if (newClassString && currentClassString) {
      var currentClassMap = makeTruthyCssClassMap(currentClassString);
      return newClassString.split(ONE_SPACE).some(function(className) {
        return currentClassMap[className];
      });
    }
  }

  function isAllowed(ruleType, currentAnimation, previousAnimation) {
    return rules[ruleType].some(function(fn) {
      return fn(currentAnimation, previousAnimation);
    });
  }

  function hasAnimationClasses(animation, and) {
    var a = (animation.addClass || '').length > 0;
    var b = (animation.removeClass || '').length > 0;
    return and ? a && b : a || b;
  }

  rules.join.push(function(newAnimation, currentAnimation) {
    // if the new animation is class-based then we can just tack that on
    return !newAnimation.structural && hasAnimationClasses(newAnimation);
  });

  rules.skip.push(function(newAnimation, currentAnimation) {
    // there is no need to animate anything if no classes are being added and
    // there is no structural animation that will be triggered
    return !newAnimation.structural && !hasAnimationClasses(newAnimation);
  });

  rules.skip.push(function(newAnimation, currentAnimation) {
    // why should we trigger a new structural animation if the element will
    // be removed from the DOM anyway?
    return currentAnimation.event === 'leave' && newAnimation.structural;
  });

  rules.skip.push(function(newAnimation, currentAnimation) {
    // if there is an ongoing current animation then don't even bother running the class-based animation
    return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;
  });

  rules.cancel.push(function(newAnimation, currentAnimation) {
    // there can never be two structural animations running at the same time
    return currentAnimation.structural && newAnimation.structural;
  });

  rules.cancel.push(function(newAnimation, currentAnimation) {
    // if the previous animation is already running, but the new animation will
    // be triggered, but the new animation is structural
    return currentAnimation.state === RUNNING_STATE && newAnimation.structural;
  });

  rules.cancel.push(function(newAnimation, currentAnimation) {
    // cancel the animation if classes added / removed in both animation cancel each other out,
    // but only if the current animation isn't structural

    if (currentAnimation.structural) return false;

    var nA = newAnimation.addClass;
    var nR = newAnimation.removeClass;
    var cA = currentAnimation.addClass;
    var cR = currentAnimation.removeClass;

    // early detection to save the global CPU shortage :)
    if ((isUndefined(nA) && isUndefined(nR)) || (isUndefined(cA) && isUndefined(cR))) {
      return false;
    }

    return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);
  });

  this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$Map',
               '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow',
               '$$isDocumentHidden',
       function($$rAF,   $rootScope,   $rootElement,   $document,   $$Map,
                $$animation,   $$AnimateRunner,   $templateRequest,   $$jqLite,   $$forceReflow,
                $$isDocumentHidden) {

    var activeAnimationsLookup = new $$Map();
    var disabledElementsLookup = new $$Map();
    var animationsEnabled = null;

    function postDigestTaskFactory() {
      var postDigestCalled = false;
      return function(fn) {
        // we only issue a call to postDigest before
        // it has first passed. This prevents any callbacks
        // from not firing once the animation has completed
        // since it will be out of the digest cycle.
        if (postDigestCalled) {
          fn();
        } else {
          $rootScope.$$postDigest(function() {
            postDigestCalled = true;
            fn();
          });
        }
      };
    }

    // Wait until all directive and route-related templates are downloaded and
    // compiled. The $templateRequest.totalPendingRequests variable keeps track of
    // all of the remote templates being currently downloaded. If there are no
    // templates currently downloading then the watcher will still fire anyway.
    var deregisterWatch = $rootScope.$watch(
      function() { return $templateRequest.totalPendingRequests === 0; },
      function(isEmpty) {
        if (!isEmpty) return;
        deregisterWatch();

        // Now that all templates have been downloaded, $animate will wait until
        // the post digest queue is empty before enabling animations. By having two
        // calls to $postDigest calls we can ensure that the flag is enabled at the
        // very end of the post digest queue. Since all of the animations in $animate
        // use $postDigest, it's important that the code below executes at the end.
        // This basically means that the page is fully downloaded and compiled before
        // any animations are triggered.
        $rootScope.$$postDigest(function() {
          $rootScope.$$postDigest(function() {
            // we check for null directly in the event that the application already called
            // .enabled() with whatever arguments that it provided it with
            if (animationsEnabled === null) {
              animationsEnabled = true;
            }
          });
        });
      }
    );

    var callbackRegistry = Object.create(null);

    // remember that the `customFilter`/`classNameFilter` are set during the
    // provider/config stage therefore we can optimize here and setup helper functions
    var customFilter = $animateProvider.customFilter();
    var classNameFilter = $animateProvider.classNameFilter();
    var returnTrue = function() { return true; };

    var isAnimatableByFilter = customFilter || returnTrue;
    var isAnimatableClassName = !classNameFilter ? returnTrue : function(node, options) {
      var className = [node.getAttribute('class'), options.addClass, options.removeClass].join(' ');
      return classNameFilter.test(className);
    };

    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);

    function normalizeAnimationDetails(element, animation) {
      return mergeAnimationDetails(element, animation, {});
    }

    // IE9-11 has no method "contains" in SVG element and in Node.prototype. Bug #10259.
    var contains = window.Node.prototype.contains || /** @this */ function(arg) {
      // eslint-disable-next-line no-bitwise
      return this === arg || !!(this.compareDocumentPosition(arg) & 16);
    };

    function findCallbacks(targetParentNode, targetNode, event) {
      var matches = [];
      var entries = callbackRegistry[event];
      if (entries) {
        forEach(entries, function(entry) {
          if (contains.call(entry.node, targetNode)) {
            matches.push(entry.callback);
          } else if (event === 'leave' && contains.call(entry.node, targetParentNode)) {
            matches.push(entry.callback);
          }
        });
      }

      return matches;
    }

    function filterFromRegistry(list, matchContainer, matchCallback) {
      var containerNode = extractElementNode(matchContainer);
      return list.filter(function(entry) {
        var isMatch = entry.node === containerNode &&
                        (!matchCallback || entry.callback === matchCallback);
        return !isMatch;
      });
    }

    function cleanupEventListeners(phase, node) {
      if (phase === 'close' && !node.parentNode) {
        // If the element is not attached to a parentNode, it has been removed by
        // the domOperation, and we can safely remove the event callbacks
        $animate.off(node);
      }
    }

    var $animate = {
      on: function(event, container, callback) {
        var node = extractElementNode(container);
        callbackRegistry[event] = callbackRegistry[event] || [];
        callbackRegistry[event].push({
          node: node,
          callback: callback
        });

        // Remove the callback when the element is removed from the DOM
        jqLite(container).on('$destroy', function() {
          var animationDetails = activeAnimationsLookup.get(node);

          if (!animationDetails) {
            // If there's an animation ongoing, the callback calling code will remove
            // the event listeners. If we'd remove here, the callbacks would be removed
            // before the animation ends
            $animate.off(event, container, callback);
          }
        });
      },

      off: function(event, container, callback) {
        if (arguments.length === 1 && !isString(arguments[0])) {
          container = arguments[0];
          for (var eventType in callbackRegistry) {
            callbackRegistry[eventType] = filterFromRegistry(callbackRegistry[eventType], container);
          }

          return;
        }

        var entries = callbackRegistry[event];
        if (!entries) return;

        callbackRegistry[event] = arguments.length === 1
            ? null
            : filterFromRegistry(entries, container, callback);
      },

      pin: function(element, parentElement) {
        assertArg(isElement(element), 'element', 'not an element');
        assertArg(isElement(parentElement), 'parentElement', 'not an element');
        element.data(NG_ANIMATE_PIN_DATA, parentElement);
      },

      push: function(element, event, options, domOperation) {
        options = options || {};
        options.domOperation = domOperation;
        return queueAnimation(element, event, options);
      },

      // this method has four signatures:
      //  () - global getter
      //  (bool) - global setter
      //  (element) - element getter
      //  (element, bool) - element setter<F37>
      enabled: function(element, bool) {
        var argCount = arguments.length;

        if (argCount === 0) {
          // () - Global getter
          bool = !!animationsEnabled;
        } else {
          var hasElement = isElement(element);

          if (!hasElement) {
            // (bool) - Global setter
            bool = animationsEnabled = !!element;
          } else {
            var node = getDomNode(element);

            if (argCount === 1) {
              // (element) - Element getter
              bool = !disabledElementsLookup.get(node);
            } else {
              // (element, bool) - Element setter
              disabledElementsLookup.set(node, !bool);
            }
          }
        }

        return bool;
      }
    };

    return $animate;

    function queueAnimation(originalElement, event, initialOptions) {
      // we always make a copy of the options since
      // there should never be any side effects on
      // the input data when running `$animateCss`.
      var options = copy(initialOptions);

      var element = stripCommentsFromElement(originalElement);
      var node = getDomNode(element);
      var parentNode = node && node.parentNode;

      options = prepareAnimationOptions(options);

      // we create a fake runner with a working promise.
      // These methods will become available after the digest has passed
      var runner = new $$AnimateRunner();

      // this is used to trigger callbacks in postDigest mode
      var runInNextPostDigestOrNow = postDigestTaskFactory();

      if (isArray(options.addClass)) {
        options.addClass = options.addClass.join(' ');
      }

      if (options.addClass && !isString(options.addClass)) {
        options.addClass = null;
      }

      if (isArray(options.removeClass)) {
        options.removeClass = options.removeClass.join(' ');
      }

      if (options.removeClass && !isString(options.removeClass)) {
        options.removeClass = null;
      }

      if (options.from && !isObject(options.from)) {
        options.from = null;
      }

      if (options.to && !isObject(options.to)) {
        options.to = null;
      }

      // If animations are hard-disabled for the whole application there is no need to continue.
      // There are also situations where a directive issues an animation for a jqLite wrapper that
      // contains only comment nodes. In this case, there is no way we can perform an animation.
      if (!animationsEnabled ||
          !node ||
          !isAnimatableByFilter(node, event, initialOptions) ||
          !isAnimatableClassName(node, options)) {
        close();
        return runner;
      }

      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;

      var documentHidden = $$isDocumentHidden();

      // This is a hard disable of all animations the element itself, therefore  there is no need to
      // continue further past this point if not enabled
      // Animations are also disabled if the document is currently hidden (page is not visible
      // to the user), because browsers slow down or do not flush calls to requestAnimationFrame
      var skipAnimations = documentHidden || disabledElementsLookup.get(node);
      var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};
      var hasExistingAnimation = !!existingAnimation.state;

      // there is no point in traversing the same collection of parent ancestors if a followup
      // animation will be run on the same element that already did all that checking work
      if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state !== PRE_DIGEST_STATE)) {
        skipAnimations = !areAnimationsAllowed(node, parentNode, event);
      }

      if (skipAnimations) {
        // Callbacks should fire even if the document is hidden (regression fix for issue #14120)
        if (documentHidden) notifyProgress(runner, event, 'start');
        close();
        if (documentHidden) notifyProgress(runner, event, 'close');
        return runner;
      }

      if (isStructural) {
        closeChildAnimations(node);
      }

      var newAnimation = {
        structural: isStructural,
        element: element,
        event: event,
        addClass: options.addClass,
        removeClass: options.removeClass,
        close: close,
        options: options,
        runner: runner
      };

      if (hasExistingAnimation) {
        var skipAnimationFlag = isAllowed('skip', newAnimation, existingAnimation);
        if (skipAnimationFlag) {
          if (existingAnimation.state === RUNNING_STATE) {
            close();
            return runner;
          } else {
            mergeAnimationDetails(element, existingAnimation, newAnimation);
            return existingAnimation.runner;
          }
        }
        var cancelAnimationFlag = isAllowed('cancel', newAnimation, existingAnimation);
        if (cancelAnimationFlag) {
          if (existingAnimation.state === RUNNING_STATE) {
            // this will end the animation right away and it is safe
            // to do so since the animation is already running and the
            // runner callback code will run in async
            existingAnimation.runner.end();
          } else if (existingAnimation.structural) {
            // this means that the animation is queued into a digest, but
            // hasn't started yet. Therefore it is safe to run the close
            // method which will call the runner methods in async.
            existingAnimation.close();
          } else {
            // this will merge the new animation options into existing animation options
            mergeAnimationDetails(element, existingAnimation, newAnimation);

            return existingAnimation.runner;
          }
        } else {
          // a joined animation means that this animation will take over the existing one
          // so an example would involve a leave animation taking over an enter. Then when
          // the postDigest kicks in the enter will be ignored.
          var joinAnimationFlag = isAllowed('join', newAnimation, existingAnimation);
          if (joinAnimationFlag) {
            if (existingAnimation.state === RUNNING_STATE) {
              normalizeAnimationDetails(element, newAnimation);
            } else {
              applyGeneratedPreparationClasses(element, isStructural ? event : null, options);

              event = newAnimation.event = existingAnimation.event;
              options = mergeAnimationDetails(element, existingAnimation, newAnimation);

              //we return the same runner since only the option values of this animation will
              //be fed into the `existingAnimation`.
              return existingAnimation.runner;
            }
          }
        }
      } else {
        // normalization in this case means that it removes redundant CSS classes that
        // already exist (addClass) or do not exist (removeClass) on the element
        normalizeAnimationDetails(element, newAnimation);
      }

      // when the options are merged and cleaned up we may end up not having to do
      // an animation at all, therefore we should check this before issuing a post
      // digest callback. Structural animations will always run no matter what.
      var isValidAnimation = newAnimation.structural;
      if (!isValidAnimation) {
        // animate (from/to) can be quickly checked first, otherwise we check if any classes are present
        isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0)
                            || hasAnimationClasses(newAnimation);
      }

      if (!isValidAnimation) {
        close();
        clearElementAnimationState(node);
        return runner;
      }

      // the counter keeps track of cancelled animations
      var counter = (existingAnimation.counter || 0) + 1;
      newAnimation.counter = counter;

      markElementAnimationState(node, PRE_DIGEST_STATE, newAnimation);

      $rootScope.$$postDigest(function() {
        // It is possible that the DOM nodes inside `originalElement` have been replaced. This can
        // happen if the animated element is a transcluded clone and also has a `templateUrl`
        // directive on it. Therefore, we must recreate `element` in order to interact with the
        // actual DOM nodes.
        // Note: We still need to use the old `node` for certain things, such as looking up in
        //       HashMaps where it was used as the key.

        element = stripCommentsFromElement(originalElement);

        var animationDetails = activeAnimationsLookup.get(node);
        var animationCancelled = !animationDetails;
        animationDetails = animationDetails || {};

        // if addClass/removeClass is called before something like enter then the
        // registered parent element may not be present. The code below will ensure
        // that a final value for parent element is obtained
        var parentElement = element.parent() || [];

        // animate/structural/class-based animations all have requirements. Otherwise there
        // is no point in performing an animation. The parent node must also be set.
        var isValidAnimation = parentElement.length > 0
                                && (animationDetails.event === 'animate'
                                    || animationDetails.structural
                                    || hasAnimationClasses(animationDetails));

        // this means that the previous animation was cancelled
        // even if the follow-up animation is the same event
        if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {
          // if another animation did not take over then we need
          // to make sure that the domOperation and options are
          // handled accordingly
          if (animationCancelled) {
            applyAnimationClasses(element, options);
            applyAnimationStyles(element, options);
          }

          // if the event changed from something like enter to leave then we do
          // it, otherwise if it's the same then the end result will be the same too
          if (animationCancelled || (isStructural && animationDetails.event !== event)) {
            options.domOperation();
            runner.end();
          }

          // in the event that the element animation was not cancelled or a follow-up animation
          // isn't allowed to animate from here then we need to clear the state of the element
          // so that any future animations won't read the expired animation data.
          if (!isValidAnimation) {
            clearElementAnimationState(node);
          }

          return;
        }

        // this combined multiple class to addClass / removeClass into a setClass event
        // so long as a structural event did not take over the animation
        event = !animationDetails.structural && hasAnimationClasses(animationDetails, true)
            ? 'setClass'
            : animationDetails.event;

        markElementAnimationState(node, RUNNING_STATE);
        var realRunner = $$animation(element, event, animationDetails.options);

        // this will update the runner's flow-control events based on
        // the `realRunner` object.
        runner.setHost(realRunner);
        notifyProgress(runner, event, 'start', {});

        realRunner.done(function(status) {
          close(!status);
          var animationDetails = activeAnimationsLookup.get(node);
          if (animationDetails && animationDetails.counter === counter) {
            clearElementAnimationState(node);
          }
          notifyProgress(runner, event, 'close', {});
        });
      });

      return runner;

      function notifyProgress(runner, event, phase, data) {
        runInNextPostDigestOrNow(function() {
          var callbacks = findCallbacks(parentNode, node, event);
          if (callbacks.length) {
            // do not optimize this call here to RAF because
            // we don't know how heavy the callback code here will
            // be and if this code is buffered then this can
            // lead to a performance regression.
            $$rAF(function() {
              forEach(callbacks, function(callback) {
                callback(element, phase, data);
              });
              cleanupEventListeners(phase, node);
            });
          } else {
            cleanupEventListeners(phase, node);
          }
        });
        runner.progress(event, phase, data);
      }

      function close(reject) {
        clearGeneratedClasses(element, options);
        applyAnimationClasses(element, options);
        applyAnimationStyles(element, options);
        options.domOperation();
        runner.complete(!reject);
      }
    }

    function closeChildAnimations(node) {
      var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');
      forEach(children, function(child) {
        var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME), 10);
        var animationDetails = activeAnimationsLookup.get(child);
        if (animationDetails) {
          switch (state) {
            case RUNNING_STATE:
              animationDetails.runner.end();
              /* falls through */
            case PRE_DIGEST_STATE:
              activeAnimationsLookup.delete(child);
              break;
          }
        }
      });
    }

    function clearElementAnimationState(node) {
      node.removeAttribute(NG_ANIMATE_ATTR_NAME);
      activeAnimationsLookup.delete(node);
    }

    /**
     * This fn returns false if any of the following is true:
     * a) animations on any parent element are disabled, and animations on the element aren't explicitly allowed
     * b) a parent element has an ongoing structural animation, and animateChildren is false
     * c) the element is not a child of the body
     * d) the element is not a child of the $rootElement
     */
    function areAnimationsAllowed(node, parentNode, event) {
      var bodyNode = $document[0].body;
      var rootNode = getDomNode($rootElement);

      var bodyNodeDetected = (node === bodyNode) || node.nodeName === 'HTML';
      var rootNodeDetected = (node === rootNode);
      var parentAnimationDetected = false;
      var elementDisabled = disabledElementsLookup.get(node);
      var animateChildren;

      var parentHost = jqLite.data(node, NG_ANIMATE_PIN_DATA);
      if (parentHost) {
        parentNode = getDomNode(parentHost);
      }

      while (parentNode) {
        if (!rootNodeDetected) {
          // angular doesn't want to attempt to animate elements outside of the application
          // therefore we need to ensure that the rootElement is an ancestor of the current element
          rootNodeDetected = (parentNode === rootNode);
        }

        if (parentNode.nodeType !== ELEMENT_NODE) {
          // no point in inspecting the #document element
          break;
        }

        var details = activeAnimationsLookup.get(parentNode) || {};
        // either an enter, leave or move animation will commence
        // therefore we can't allow any animations to take place
        // but if a parent animation is class-based then that's ok
        if (!parentAnimationDetected) {
          var parentNodeDisabled = disabledElementsLookup.get(parentNode);

          if (parentNodeDisabled === true && elementDisabled !== false) {
            // disable animations if the user hasn't explicitly enabled animations on the
            // current element
            elementDisabled = true;
            // element is disabled via parent element, no need to check anything else
            break;
          } else if (parentNodeDisabled === false) {
            elementDisabled = false;
          }
          parentAnimationDetected = details.structural;
        }

        if (isUndefined(animateChildren) || animateChildren === true) {
          var value = jqLite.data(parentNode, NG_ANIMATE_CHILDREN_DATA);
          if (isDefined(value)) {
            animateChildren = value;
          }
        }

        // there is no need to continue traversing at this point
        if (parentAnimationDetected && animateChildren === false) break;

        if (!bodyNodeDetected) {
          // we also need to ensure that the element is or will be a part of the body element
          // otherwise it is pointless to even issue an animation to be rendered
          bodyNodeDetected = (parentNode === bodyNode);
        }

        if (bodyNodeDetected && rootNodeDetected) {
          // If both body and root have been found, any other checks are pointless,
          // as no animation data should live outside the application
          break;
        }

        if (!rootNodeDetected) {
          // If `rootNode` is not detected, check if `parentNode` is pinned to another element
          parentHost = jqLite.data(parentNode, NG_ANIMATE_PIN_DATA);
          if (parentHost) {
            // The pin target element becomes the next parent element
            parentNode = getDomNode(parentHost);
            continue;
          }
        }

        parentNode = parentNode.parentNode;
      }

      var allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== true;
      return allowAnimation && rootNodeDetected && bodyNodeDetected;
    }

    function markElementAnimationState(node, state, details) {
      details = details || {};
      details.state = state;

      node.setAttribute(NG_ANIMATE_ATTR_NAME, state);

      var oldValue = activeAnimationsLookup.get(node);
      var newValue = oldValue
          ? extend(oldValue, details)
          : details;
      activeAnimationsLookup.set(node, newValue);
    }
  }];
}];

/* exported $$AnimationProvider */

var $$AnimationProvider = ['$animateProvider', /** @this */ function($animateProvider) {
  var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';

  var drivers = this.drivers = [];

  var RUNNER_STORAGE_KEY = '$$animationRunner';

  function setRunner(element, runner) {
    element.data(RUNNER_STORAGE_KEY, runner);
  }

  function removeRunner(element) {
    element.removeData(RUNNER_STORAGE_KEY);
  }

  function getRunner(element) {
    return element.data(RUNNER_STORAGE_KEY);
  }

  this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$Map', '$$rAFScheduler',
       function($$jqLite,   $rootScope,   $injector,   $$AnimateRunner,   $$Map,   $$rAFScheduler) {

    var animationQueue = [];
    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);

    function sortAnimations(animations) {
      var tree = { children: [] };
      var i, lookup = new $$Map();

      // this is done first beforehand so that the map
      // is filled with a list of the elements that will be animated
      for (i = 0; i < animations.length; i++) {
        var animation = animations[i];
        lookup.set(animation.domNode, animations[i] = {
          domNode: animation.domNode,
          fn: animation.fn,
          children: []
        });
      }

      for (i = 0; i < animations.length; i++) {
        processNode(animations[i]);
      }

      return flatten(tree);

      function processNode(entry) {
        if (entry.processed) return entry;
        entry.processed = true;

        var elementNode = entry.domNode;
        var parentNode = elementNode.parentNode;
        lookup.set(elementNode, entry);

        var parentEntry;
        while (parentNode) {
          parentEntry = lookup.get(parentNode);
          if (parentEntry) {
            if (!parentEntry.processed) {
              parentEntry = processNode(parentEntry);
            }
            break;
          }
          parentNode = parentNode.parentNode;
        }

        (parentEntry || tree).children.push(entry);
        return entry;
      }

      function flatten(tree) {
        var result = [];
        var queue = [];
        var i;

        for (i = 0; i < tree.children.length; i++) {
          queue.push(tree.children[i]);
        }

        var remainingLevelEntries = queue.length;
        var nextLevelEntries = 0;
        var row = [];

        for (i = 0; i < queue.length; i++) {
          var entry = queue[i];
          if (remainingLevelEntries <= 0) {
            remainingLevelEntries = nextLevelEntries;
            nextLevelEntries = 0;
            result.push(row);
            row = [];
          }
          row.push(entry.fn);
          entry.children.forEach(function(childEntry) {
            nextLevelEntries++;
            queue.push(childEntry);
          });
          remainingLevelEntries--;
        }

        if (row.length) {
          result.push(row);
        }

        return result;
      }
    }

    // TODO(matsko): document the signature in a better way
    return function(element, event, options) {
      options = prepareAnimationOptions(options);
      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;

      // there is no animation at the current moment, however
      // these runner methods will get later updated with the
      // methods leading into the driver's end/cancel methods
      // for now they just stop the animation from starting
      var runner = new $$AnimateRunner({
        end: function() { close(); },
        cancel: function() { close(true); }
      });

      if (!drivers.length) {
        close();
        return runner;
      }

      setRunner(element, runner);

      var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));
      var tempClasses = options.tempClasses;
      if (tempClasses) {
        classes += ' ' + tempClasses;
        options.tempClasses = null;
      }

      var prepareClassName;
      if (isStructural) {
        prepareClassName = 'ng-' + event + PREPARE_CLASS_SUFFIX;
        $$jqLite.addClass(element, prepareClassName);
      }

      animationQueue.push({
        // this data is used by the postDigest code and passed into
        // the driver step function
        element: element,
        classes: classes,
        event: event,
        structural: isStructural,
        options: options,
        beforeStart: beforeStart,
        close: close
      });

      element.on('$destroy', handleDestroyedElement);

      // we only want there to be one function called within the post digest
      // block. This way we can group animations for all the animations that
      // were apart of the same postDigest flush call.
      if (animationQueue.length > 1) return runner;

      $rootScope.$$postDigest(function() {
        var animations = [];
        forEach(animationQueue, function(entry) {
          // the element was destroyed early on which removed the runner
          // form its storage. This means we can't animate this element
          // at all and it already has been closed due to destruction.
          if (getRunner(entry.element)) {
            animations.push(entry);
          } else {
            entry.close();
          }
        });

        // now any future animations will be in another postDigest
        animationQueue.length = 0;

        var groupedAnimations = groupAnimations(animations);
        var toBeSortedAnimations = [];

        forEach(groupedAnimations, function(animationEntry) {
          toBeSortedAnimations.push({
            domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),
            fn: function triggerAnimationStart() {
              // it's important that we apply the `ng-animate` CSS class and the
              // temporary classes before we do any driver invoking since these
              // CSS classes may be required for proper CSS detection.
              animationEntry.beforeStart();

              var startAnimationFn, closeFn = animationEntry.close;

              // in the event that the element was removed before the digest runs or
              // during the RAF sequencing then we should not trigger the animation.
              var targetElement = animationEntry.anchors
                  ? (animationEntry.from.element || animationEntry.to.element)
                  : animationEntry.element;

              if (getRunner(targetElement)) {
                var operation = invokeFirstDriver(animationEntry);
                if (operation) {
                  startAnimationFn = operation.start;
                }
              }

              if (!startAnimationFn) {
                closeFn();
              } else {
                var animationRunner = startAnimationFn();
                animationRunner.done(function(status) {
                  closeFn(!status);
                });
                updateAnimationRunners(animationEntry, animationRunner);
              }
            }
          });
        });

        // we need to sort each of the animations in order of parent to child
        // relationships. This ensures that the child classes are applied at the
        // right time.
        $$rAFScheduler(sortAnimations(toBeSortedAnimations));
      });

      return runner;

      // TODO(matsko): change to reference nodes
      function getAnchorNodes(node) {
        var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';
        var items = node.hasAttribute(NG_ANIMATE_REF_ATTR)
              ? [node]
              : node.querySelectorAll(SELECTOR);
        var anchors = [];
        forEach(items, function(node) {
          var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);
          if (attr && attr.length) {
            anchors.push(node);
          }
        });
        return anchors;
      }

      function groupAnimations(animations) {
        var preparedAnimations = [];
        var refLookup = {};
        forEach(animations, function(animation, index) {
          var element = animation.element;
          var node = getDomNode(element);
          var event = animation.event;
          var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;
          var anchorNodes = animation.structural ? getAnchorNodes(node) : [];

          if (anchorNodes.length) {
            var direction = enterOrMove ? 'to' : 'from';

            forEach(anchorNodes, function(anchor) {
              var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
              refLookup[key] = refLookup[key] || {};
              refLookup[key][direction] = {
                animationID: index,
                element: jqLite(anchor)
              };
            });
          } else {
            preparedAnimations.push(animation);
          }
        });

        var usedIndicesLookup = {};
        var anchorGroups = {};
        forEach(refLookup, function(operations, key) {
          var from = operations.from;
          var to = operations.to;

          if (!from || !to) {
            // only one of these is set therefore we can't have an
            // anchor animation since all three pieces are required
            var index = from ? from.animationID : to.animationID;
            var indexKey = index.toString();
            if (!usedIndicesLookup[indexKey]) {
              usedIndicesLookup[indexKey] = true;
              preparedAnimations.push(animations[index]);
            }
            return;
          }

          var fromAnimation = animations[from.animationID];
          var toAnimation = animations[to.animationID];
          var lookupKey = from.animationID.toString();
          if (!anchorGroups[lookupKey]) {
            var group = anchorGroups[lookupKey] = {
              structural: true,
              beforeStart: function() {
                fromAnimation.beforeStart();
                toAnimation.beforeStart();
              },
              close: function() {
                fromAnimation.close();
                toAnimation.close();
              },
              classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),
              from: fromAnimation,
              to: toAnimation,
              anchors: [] // TODO(matsko): change to reference nodes
            };

            // the anchor animations require that the from and to elements both have at least
            // one shared CSS class which effectively marries the two elements together to use
            // the same animation driver and to properly sequence the anchor animation.
            if (group.classes.length) {
              preparedAnimations.push(group);
            } else {
              preparedAnimations.push(fromAnimation);
              preparedAnimations.push(toAnimation);
            }
          }

          anchorGroups[lookupKey].anchors.push({
            'out': from.element, 'in': to.element
          });
        });

        return preparedAnimations;
      }

      function cssClassesIntersection(a,b) {
        a = a.split(' ');
        b = b.split(' ');
        var matches = [];

        for (var i = 0; i < a.length; i++) {
          var aa = a[i];
          if (aa.substring(0,3) === 'ng-') continue;

          for (var j = 0; j < b.length; j++) {
            if (aa === b[j]) {
              matches.push(aa);
              break;
            }
          }
        }

        return matches.join(' ');
      }

      function invokeFirstDriver(animationDetails) {
        // we loop in reverse order since the more general drivers (like CSS and JS)
        // may attempt more elements, but custom drivers are more particular
        for (var i = drivers.length - 1; i >= 0; i--) {
          var driverName = drivers[i];
          var factory = $injector.get(driverName);
          var driver = factory(animationDetails);
          if (driver) {
            return driver;
          }
        }
      }

      function beforeStart() {
        element.addClass(NG_ANIMATE_CLASSNAME);
        if (tempClasses) {
          $$jqLite.addClass(element, tempClasses);
        }
        if (prepareClassName) {
          $$jqLite.removeClass(element, prepareClassName);
          prepareClassName = null;
        }
      }

      function updateAnimationRunners(animation, newRunner) {
        if (animation.from && animation.to) {
          update(animation.from.element);
          update(animation.to.element);
        } else {
          update(animation.element);
        }

        function update(element) {
          var runner = getRunner(element);
          if (runner) runner.setHost(newRunner);
        }
      }

      function handleDestroyedElement() {
        var runner = getRunner(element);
        if (runner && (event !== 'leave' || !options.$$domOperationFired)) {
          runner.end();
        }
      }

      function close(rejected) {
        element.off('$destroy', handleDestroyedElement);
        removeRunner(element);

        applyAnimationClasses(element, options);
        applyAnimationStyles(element, options);
        options.domOperation();

        if (tempClasses) {
          $$jqLite.removeClass(element, tempClasses);
        }

        element.removeClass(NG_ANIMATE_CLASSNAME);
        runner.complete(!rejected);
      }
    };
  }];
}];

/**
 * @ngdoc directive
 * @name ngAnimateSwap
 * @restrict A
 * @scope
 *
 * @description
 *
 * ngAnimateSwap is a animation-oriented directive that allows for the container to
 * be removed and entered in whenever the associated expression changes. A
 * common usecase for this directive is a rotating banner or slider component which
 * contains one image being present at a time. When the active image changes
 * then the old image will perform a `leave` animation and the new element
 * will be inserted via an `enter` animation.
 *
 * @animations
 * | Animation                        | Occurs                               |
 * |----------------------------------|--------------------------------------|
 * | {@link ng.$animate#enter enter}  | when the new element is inserted to the DOM  |
 * | {@link ng.$animate#leave leave}  | when the old element is removed from the DOM |
 *
 * @example
 * <example name="ngAnimateSwap-directive" module="ngAnimateSwapExample"
 *          deps="angular-animate.js"
 *          animations="true" fixBase="true">
 *   <file name="index.html">
 *     <div class="container" ng-controller="AppCtrl">
 *       <div ng-animate-swap="number" class="cell swap-animation" ng-class="colorClass(number)">
 *         {{ number }}
 *       </div>
 *     </div>
 *   </file>
 *   <file name="script.js">
 *     angular.module('ngAnimateSwapExample', ['ngAnimate'])
 *       .controller('AppCtrl', ['$scope', '$interval', function($scope, $interval) {
 *         $scope.number = 0;
 *         $interval(function() {
 *           $scope.number++;
 *         }, 1000);
 *
 *         var colors = ['red','blue','green','yellow','orange'];
 *         $scope.colorClass = function(number) {
 *           return colors[number % colors.length];
 *         };
 *       }]);
 *   </file>
 *  <file name="animations.css">
 *  .container {
 *    height:250px;
 *    width:250px;
 *    position:relative;
 *    overflow:hidden;
 *    border:2px solid black;
 *  }
 *  .container .cell {
 *    font-size:150px;
 *    text-align:center;
 *    line-height:250px;
 *    position:absolute;
 *    top:0;
 *    left:0;
 *    right:0;
 *    border-bottom:2px solid black;
 *  }
 *  .swap-animation.ng-enter, .swap-animation.ng-leave {
 *    transition:0.5s linear all;
 *  }
 *  .swap-animation.ng-enter {
 *    top:-250px;
 *  }
 *  .swap-animation.ng-enter-active {
 *    top:0px;
 *  }
 *  .swap-animation.ng-leave {
 *    top:0px;
 *  }
 *  .swap-animation.ng-leave-active {
 *    top:250px;
 *  }
 *  .red { background:red; }
 *  .green { background:green; }
 *  .blue { background:blue; }
 *  .yellow { background:yellow; }
 *  .orange { background:orange; }
 *  </file>
 * </example>
 */
var ngAnimateSwapDirective = ['$animate', '$rootScope', function($animate, $rootScope) {
  return {
    restrict: 'A',
    transclude: 'element',
    terminal: true,
    priority: 600, // we use 600 here to ensure that the directive is caught before others
    link: function(scope, $element, attrs, ctrl, $transclude) {
      var previousElement, previousScope;
      scope.$watchCollection(attrs.ngAnimateSwap || attrs['for'], function(value) {
        if (previousElement) {
          $animate.leave(previousElement);
        }
        if (previousScope) {
          previousScope.$destroy();
          previousScope = null;
        }
        if (value || value === 0) {
          previousScope = scope.$new();
          $transclude(previousScope, function(element) {
            previousElement = element;
            $animate.enter(element, null, $element);
          });
        }
      });
    }
  };
}];

/**
 * @ngdoc module
 * @name ngAnimate
 * @description
 *
 * The `ngAnimate` module provides support for CSS-based animations (keyframes and transitions) as well as JavaScript-based animations via
 * callback hooks. Animations are not enabled by default, however, by including `ngAnimate` the animation hooks are enabled for an Angular app.
 *
 * <div doc-module-components="ngAnimate"></div>
 *
 * # Usage
 * Simply put, there are two ways to make use of animations when ngAnimate is used: by using **CSS** and **JavaScript**. The former works purely based
 * using CSS (by using matching CSS selectors/styles) and the latter triggers animations that are registered via `module.animation()`. For
 * both CSS and JS animations the sole requirement is to have a matching `CSS class` that exists both in the registered animation and within
 * the HTML element that the animation will be triggered on.
 *
 * ## Directive Support
 * The following directives are "animation aware":
 *
 * | Directive                                                                                                | Supported Animations                                                     |
 * |----------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|
 * | {@link ng.directive:ngRepeat#animations ngRepeat}                                                        | enter, leave and move                                                    |
 * | {@link ngRoute.directive:ngView#animations ngView}                                                       | enter and leave                                                          |
 * | {@link ng.directive:ngInclude#animations ngInclude}                                                      | enter and leave                                                          |
 * | {@link ng.directive:ngSwitch#animations ngSwitch}                                                        | enter and leave                                                          |
 * | {@link ng.directive:ngIf#animations ngIf}                                                                | enter and leave                                                          |
 * | {@link ng.directive:ngClass#animations ngClass}                                                          | add and remove (the CSS class(es) present)                               |
 * | {@link ng.directive:ngShow#animations ngShow} & {@link ng.directive:ngHide#animations ngHide}            | add and remove (the ng-hide class value)                                 |
 * | {@link ng.directive:form#animation-hooks form} & {@link ng.directive:ngModel#animation-hooks ngModel}    | add and remove (dirty, pristine, valid, invalid & all other validations) |
 * | {@link module:ngMessages#animations ngMessages}                                                          | add and remove (ng-active & ng-inactive)                                 |
 * | {@link module:ngMessages#animations ngMessage}                                                           | enter and leave                                                          |
 *
 * (More information can be found by visiting each the documentation associated with each directive.)
 *
 * ## CSS-based Animations
 *
 * CSS-based animations with ngAnimate are unique since they require no JavaScript code at all. By using a CSS class that we reference between our HTML
 * and CSS code we can create an animation that will be picked up by Angular when an underlying directive performs an operation.
 *
 * The example below shows how an `enter` animation can be made possible on an element using `ng-if`:
 *
 * ```html
 * <div ng-if="bool" class="fade">
 *    Fade me in out
 * </div>
 * <button ng-click="bool=true">Fade In!</button>
 * <button ng-click="bool=false">Fade Out!</button>
 * ```
 *
 * Notice the CSS class **fade**? We can now create the CSS transition code that references this class:
 *
 * ```css
 * /&#42; The starting CSS styles for the enter animation &#42;/
 * .fade.ng-enter {
 *   transition:0.5s linear all;
 *   opacity:0;
 * }
 *
 * /&#42; The finishing CSS styles for the enter animation &#42;/
 * .fade.ng-enter.ng-enter-active {
 *   opacity:1;
 * }
 * ```
 *
 * The key thing to remember here is that, depending on the animation event (which each of the directives above trigger depending on what's going on) two
 * generated CSS classes will be applied to the element; in the example above we have `.ng-enter` and `.ng-enter-active`. For CSS transitions, the transition
 * code **must** be defined within the starting CSS class (in this case `.ng-enter`). The destination class is what the transition will animate towards.
 *
 * If for example we wanted to create animations for `leave` and `move` (ngRepeat triggers move) then we can do so using the same CSS naming conventions:
 *
 * ```css
 * /&#42; now the element will fade out before it is removed from the DOM &#42;/
 * .fade.ng-leave {
 *   transition:0.5s linear all;
 *   opacity:1;
 * }
 * .fade.ng-leave.ng-leave-active {
 *   opacity:0;
 * }
 * ```
 *
 * We can also make use of **CSS Keyframes** by referencing the keyframe animation within the starting CSS class:
 *
 * ```css
 * /&#42; there is no need to define anything inside of the destination
 * CSS class since the keyframe will take charge of the animation &#42;/
 * .fade.ng-leave {
 *   animation: my_fade_animation 0.5s linear;
 *   -webkit-animation: my_fade_animation 0.5s linear;
 * }
 *
 * @keyframes my_fade_animation {
 *   from { opacity:1; }
 *   to { opacity:0; }
 * }
 *
 * @-webkit-keyframes my_fade_animation {
 *   from { opacity:1; }
 *   to { opacity:0; }
 * }
 * ```
 *
 * Feel free also mix transitions and keyframes together as well as any other CSS classes on the same element.
 *
 * ### CSS Class-based Animations
 *
 * Class-based animations (animations that are triggered via `ngClass`, `ngShow`, `ngHide` and some other directives) have a slightly different
 * naming convention. Class-based animations are basic enough that a standard transition or keyframe can be referenced on the class being added
 * and removed.
 *
 * For example if we wanted to do a CSS animation for `ngHide` then we place an animation on the `.ng-hide` CSS class:
 *
 * ```html
 * <div ng-show="bool" class="fade">
 *   Show and hide me
 * </div>
 * <button ng-click="bool=!bool">Toggle</button>
 *
 * <style>
 * .fade.ng-hide {
 *   transition:0.5s linear all;
 *   opacity:0;
 * }
 * </style>
 * ```
 *
 * All that is going on here with ngShow/ngHide behind the scenes is the `.ng-hide` class is added/removed (when the hidden state is valid). Since
 * ngShow and ngHide are animation aware then we can match up a transition and ngAnimate handles the rest.
 *
 * In addition the addition and removal of the CSS class, ngAnimate also provides two helper methods that we can use to further decorate the animation
 * with CSS styles.
 *
 * ```html
 * <div ng-class="{on:onOff}" class="highlight">
 *   Highlight this box
 * </div>
 * <button ng-click="onOff=!onOff">Toggle</button>
 *
 * <style>
 * .highlight {
 *   transition:0.5s linear all;
 * }
 * .highlight.on-add {
 *   background:white;
 * }
 * .highlight.on {
 *   background:yellow;
 * }
 * .highlight.on-remove {
 *   background:black;
 * }
 * </style>
 * ```
 *
 * We can also make use of CSS keyframes by placing them within the CSS classes.
 *
 *
 * ### CSS Staggering Animations
 * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a
 * curtain-like effect. The ngAnimate module (versions >=1.2) supports staggering animations and the stagger effect can be
 * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for
 * the animation. The style property expected within the stagger class can either be a **transition-delay** or an
 * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).
 *
 * ```css
 * .my-animation.ng-enter {
 *   /&#42; standard transition code &#42;/
 *   transition: 1s linear all;
 *   opacity:0;
 * }
 * .my-animation.ng-enter-stagger {
 *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/
 *   transition-delay: 0.1s;
 *
 *   /&#42; As of 1.4.4, this must always be set: it signals ngAnimate
 *     to not accidentally inherit a delay property from another CSS class &#42;/
 *   transition-duration: 0s;
 *
 *   /&#42; if you are using animations instead of transitions you should configure as follows:
 *     animation-delay: 0.1s;
 *     animation-duration: 0s; &#42;/
 * }
 * .my-animation.ng-enter.ng-enter-active {
 *   /&#42; standard transition styles &#42;/
 *   opacity:1;
 * }
 * ```
 *
 * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations
 * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this
 * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation
 * will also be reset if one or more animation frames have passed since the multiple calls to `$animate` were fired.
 *
 * The following code will issue the **ng-leave-stagger** event on the element provided:
 *
 * ```js
 * var kids = parent.children();
 *
 * $animate.leave(kids[0]); //stagger index=0
 * $animate.leave(kids[1]); //stagger index=1
 * $animate.leave(kids[2]); //stagger index=2
 * $animate.leave(kids[3]); //stagger index=3
 * $animate.leave(kids[4]); //stagger index=4
 *
 * window.requestAnimationFrame(function() {
 *   //stagger has reset itself
 *   $animate.leave(kids[5]); //stagger index=0
 *   $animate.leave(kids[6]); //stagger index=1
 *
 *   $scope.$digest();
 * });
 * ```
 *
 * Stagger animations are currently only supported within CSS-defined animations.
 *
 * ### The `ng-animate` CSS class
 *
 * When ngAnimate is animating an element it will apply the `ng-animate` CSS class to the element for the duration of the animation.
 * This is a temporary CSS class and it will be removed once the animation is over (for both JavaScript and CSS-based animations).
 *
 * Therefore, animations can be applied to an element using this temporary class directly via CSS.
 *
 * ```css
 * .zipper.ng-animate {
 *   transition:0.5s linear all;
 * }
 * .zipper.ng-enter {
 *   opacity:0;
 * }
 * .zipper.ng-enter.ng-enter-active {
 *   opacity:1;
 * }
 * .zipper.ng-leave {
 *   opacity:1;
 * }
 * .zipper.ng-leave.ng-leave-active {
 *   opacity:0;
 * }
 * ```
 *
 * (Note that the `ng-animate` CSS class is reserved and it cannot be applied on an element directly since ngAnimate will always remove
 * the CSS class once an animation has completed.)
 *
 *
 * ### The `ng-[event]-prepare` class
 *
 * This is a special class that can be used to prevent unwanted flickering / flash of content before
 * the actual animation starts. The class is added as soon as an animation is initialized, but removed
 * before the actual animation starts (after waiting for a $digest).
 * It is also only added for *structural* animations (`enter`, `move`, and `leave`).
 *
 * In practice, flickering can appear when nesting elements with structural animations such as `ngIf`
 * into elements that have class-based animations such as `ngClass`.
 *
 * ```html
 * <div ng-class="{red: myProp}">
 *   <div ng-class="{blue: myProp}">
 *     <div class="message" ng-if="myProp"></div>
 *   </div>
 * </div>
 * ```
 *
 * It is possible that during the `enter` animation, the `.message` div will be briefly visible before it starts animating.
 * In that case, you can add styles to the CSS that make sure the element stays hidden before the animation starts:
 *
 * ```css
 * .message.ng-enter-prepare {
 *   opacity: 0;
 * }
 *
 * ```
 *
 * ## JavaScript-based Animations
 *
 * ngAnimate also allows for animations to be consumed by JavaScript code. The approach is similar to CSS-based animations (where there is a shared
 * CSS class that is referenced in our HTML code) but in addition we need to register the JavaScript animation on the module. By making use of the
 * `module.animation()` module function we can register the animation.
 *
 * Let's see an example of a enter/leave animation using `ngRepeat`:
 *
 * ```html
 * <div ng-repeat="item in items" class="slide">
 *   {{ item }}
 * </div>
 * ```
 *
 * See the **slide** CSS class? Let's use that class to define an animation that we'll structure in our module code by using `module.animation`:
 *
 * ```js
 * myModule.animation('.slide', [function() {
 *   return {
 *     // make note that other events (like addClass/removeClass)
 *     // have different function input parameters
 *     enter: function(element, doneFn) {
 *       jQuery(element).fadeIn(1000, doneFn);
 *
 *       // remember to call doneFn so that angular
 *       // knows that the animation has concluded
 *     },
 *
 *     move: function(element, doneFn) {
 *       jQuery(element).fadeIn(1000, doneFn);
 *     },
 *
 *     leave: function(element, doneFn) {
 *       jQuery(element).fadeOut(1000, doneFn);
 *     }
 *   }
 * }]);
 * ```
 *
 * The nice thing about JS-based animations is that we can inject other services and make use of advanced animation libraries such as
 * greensock.js and velocity.js.
 *
 * If our animation code class-based (meaning that something like `ngClass`, `ngHide` and `ngShow` triggers it) then we can still define
 * our animations inside of the same registered animation, however, the function input arguments are a bit different:
 *
 * ```html
 * <div ng-class="color" class="colorful">
 *   this box is moody
 * </div>
 * <button ng-click="color='red'">Change to red</button>
 * <button ng-click="color='blue'">Change to blue</button>
 * <button ng-click="color='green'">Change to green</button>
 * ```
 *
 * ```js
 * myModule.animation('.colorful', [function() {
 *   return {
 *     addClass: function(element, className, doneFn) {
 *       // do some cool animation and call the doneFn
 *     },
 *     removeClass: function(element, className, doneFn) {
 *       // do some cool animation and call the doneFn
 *     },
 *     setClass: function(element, addedClass, removedClass, doneFn) {
 *       // do some cool animation and call the doneFn
 *     }
 *   }
 * }]);
 * ```
 *
 * ## CSS + JS Animations Together
 *
 * AngularJS 1.4 and higher has taken steps to make the amalgamation of CSS and JS animations more flexible. However, unlike earlier versions of Angular,
 * defining CSS and JS animations to work off of the same CSS class will not work anymore. Therefore the example below will only result in **JS animations taking
 * charge of the animation**:
 *
 * ```html
 * <div ng-if="bool" class="slide">
 *   Slide in and out
 * </div>
 * ```
 *
 * ```js
 * myModule.animation('.slide', [function() {
 *   return {
 *     enter: function(element, doneFn) {
 *       jQuery(element).slideIn(1000, doneFn);
 *     }
 *   }
 * }]);
 * ```
 *
 * ```css
 * .slide.ng-enter {
 *   transition:0.5s linear all;
 *   transform:translateY(-100px);
 * }
 * .slide.ng-enter.ng-enter-active {
 *   transform:translateY(0);
 * }
 * ```
 *
 * Does this mean that CSS and JS animations cannot be used together? Do JS-based animations always have higher priority? We can make up for the
 * lack of CSS animations by using the `$animateCss` service to trigger our own tweaked-out, CSS-based animations directly from
 * our own JS-based animation code:
 *
 * ```js
 * myModule.animation('.slide', ['$animateCss', function($animateCss) {
 *   return {
 *     enter: function(element) {
*        // this will trigger `.slide.ng-enter` and `.slide.ng-enter-active`.
 *       return $animateCss(element, {
 *         event: 'enter',
 *         structural: true
 *       });
 *     }
 *   }
 * }]);
 * ```
 *
 * The nice thing here is that we can save bandwidth by sticking to our CSS-based animation code and we don't need to rely on a 3rd-party animation framework.
 *
 * The `$animateCss` service is very powerful since we can feed in all kinds of extra properties that will be evaluated and fed into a CSS transition or
 * keyframe animation. For example if we wanted to animate the height of an element while adding and removing classes then we can do so by providing that
 * data into `$animateCss` directly:
 *
 * ```js
 * myModule.animation('.slide', ['$animateCss', function($animateCss) {
 *   return {
 *     enter: function(element) {
 *       return $animateCss(element, {
 *         event: 'enter',
 *         structural: true,
 *         addClass: 'maroon-setting',
 *         from: { height:0 },
 *         to: { height: 200 }
 *       });
 *     }
 *   }
 * }]);
 * ```
 *
 * Now we can fill in the rest via our transition CSS code:
 *
 * ```css
 * /&#42; the transition tells ngAnimate to make the animation happen &#42;/
 * .slide.ng-enter { transition:0.5s linear all; }
 *
 * /&#42; this extra CSS class will be absorbed into the transition
 * since the $animateCss code is adding the class &#42;/
 * .maroon-setting { background:red; }
 * ```
 *
 * And `$animateCss` will figure out the rest. Just make sure to have the `done()` callback fire the `doneFn` function to signal when the animation is over.
 *
 * To learn more about what's possible be sure to visit the {@link ngAnimate.$animateCss $animateCss service}.
 *
 * ## Animation Anchoring (via `ng-animate-ref`)
 *
 * ngAnimate in AngularJS 1.4 comes packed with the ability to cross-animate elements between
 * structural areas of an application (like views) by pairing up elements using an attribute
 * called `ng-animate-ref`.
 *
 * Let's say for example we have two views that are managed by `ng-view` and we want to show
 * that there is a relationship between two components situated in within these views. By using the
 * `ng-animate-ref` attribute we can identify that the two components are paired together and we
 * can then attach an animation, which is triggered when the view changes.
 *
 * Say for example we have the following template code:
 *
 * ```html
 * <!-- index.html -->
 * <div ng-view class="view-animation">
 * </div>
 *
 * <!-- home.html -->
 * <a href="#/banner-page">
 *   <img src="./banner.jpg" class="banner" ng-animate-ref="banner">
 * </a>
 *
 * <!-- banner-page.html -->
 * <img src="./banner.jpg" class="banner" ng-animate-ref="banner">
 * ```
 *
 * Now, when the view changes (once the link is clicked), ngAnimate will examine the
 * HTML contents to see if there is a match reference between any components in the view
 * that is leaving and the view that is entering. It will scan both the view which is being
 * removed (leave) and inserted (enter) to see if there are any paired DOM elements that
 * contain a matching ref value.
 *
 * The two images match since they share the same ref value. ngAnimate will now create a
 * transport element (which is a clone of the first image element) and it will then attempt
 * to animate to the position of the second image element in the next view. For the animation to
 * work a special CSS class called `ng-anchor` will be added to the transported element.
 *
 * We can now attach a transition onto the `.banner.ng-anchor` CSS class and then
 * ngAnimate will handle the entire transition for us as well as the addition and removal of
 * any changes of CSS classes between the elements:
 *
 * ```css
 * .banner.ng-anchor {
 *   /&#42; this animation will last for 1 second since there are
 *          two phases to the animation (an `in` and an `out` phase) &#42;/
 *   transition:0.5s linear all;
 * }
 * ```
 *
 * We also **must** include animations for the views that are being entered and removed
 * (otherwise anchoring wouldn't be possible since the new view would be inserted right away).
 *
 * ```css
 * .view-animation.ng-enter, .view-animation.ng-leave {
 *   transition:0.5s linear all;
 *   position:fixed;
 *   left:0;
 *   top:0;
 *   width:100%;
 * }
 * .view-animation.ng-enter {
 *   transform:translateX(100%);
 * }
 * .view-animation.ng-leave,
 * .view-animation.ng-enter.ng-enter-active {
 *   transform:translateX(0%);
 * }
 * .view-animation.ng-leave.ng-leave-active {
 *   transform:translateX(-100%);
 * }
 * ```
 *
 * Now we can jump back to the anchor animation. When the animation happens, there are two stages that occur:
 * an `out` and an `in` stage. The `out` stage happens first and that is when the element is animated away
 * from its origin. Once that animation is over then the `in` stage occurs which animates the
 * element to its destination. The reason why there are two animations is to give enough time
 * for the enter animation on the new element to be ready.
 *
 * The example above sets up a transition for both the in and out phases, but we can also target the out or
 * in phases directly via `ng-anchor-out` and `ng-anchor-in`.
 *
 * ```css
 * .banner.ng-anchor-out {
 *   transition: 0.5s linear all;
 *
 *   /&#42; the scale will be applied during the out animation,
 *          but will be animated away when the in animation runs &#42;/
 *   transform: scale(1.2);
 * }
 *
 * .banner.ng-anchor-in {
 *   transition: 1s linear all;
 * }
 * ```
 *
 *
 *
 *
 * ### Anchoring Demo
 *
  <example module="anchoringExample"
           name="anchoringExample"
           id="anchoringExample"
           deps="angular-animate.js;angular-route.js"
           animations="true">
    <file name="index.html">
      <a href="#!/">Home</a>
      <hr />
      <div class="view-container">
        <div ng-view class="view"></div>
      </div>
    </file>
    <file name="script.js">
      angular.module('anchoringExample', ['ngAnimate', 'ngRoute'])
        .config(['$routeProvider', function($routeProvider) {
          $routeProvider.when('/', {
            templateUrl: 'home.html',
            controller: 'HomeController as home'
          });
          $routeProvider.when('/profile/:id', {
            templateUrl: 'profile.html',
            controller: 'ProfileController as profile'
          });
        }])
        .run(['$rootScope', function($rootScope) {
          $rootScope.records = [
            { id: 1, title: 'Miss Beulah Roob' },
            { id: 2, title: 'Trent Morissette' },
            { id: 3, title: 'Miss Ava Pouros' },
            { id: 4, title: 'Rod Pouros' },
            { id: 5, title: 'Abdul Rice' },
            { id: 6, title: 'Laurie Rutherford Sr.' },
            { id: 7, title: 'Nakia McLaughlin' },
            { id: 8, title: 'Jordon Blanda DVM' },
            { id: 9, title: 'Rhoda Hand' },
            { id: 10, title: 'Alexandrea Sauer' }
          ];
        }])
        .controller('HomeController', [function() {
          //empty
        }])
        .controller('ProfileController', ['$rootScope', '$routeParams',
            function ProfileController($rootScope, $routeParams) {
          var index = parseInt($routeParams.id, 10);
          var record = $rootScope.records[index - 1];

          this.title = record.title;
          this.id = record.id;
        }]);
    </file>
    <file name="home.html">
      <h2>Welcome to the home page</h1>
      <p>Please click on an element</p>
      <a class="record"
         ng-href="#!/profile/{{ record.id }}"
         ng-animate-ref="{{ record.id }}"
         ng-repeat="record in records">
        {{ record.title }}
      </a>
    </file>
    <file name="profile.html">
      <div class="profile record" ng-animate-ref="{{ profile.id }}">
        {{ profile.title }}
      </div>
    </file>
    <file name="animations.css">
      .record {
        display:block;
        font-size:20px;
      }
      .profile {
        background:black;
        color:white;
        font-size:100px;
      }
      .view-container {
        position:relative;
      }
      .view-container > .view.ng-animate {
        position:absolute;
        top:0;
        left:0;
        width:100%;
        min-height:500px;
      }
      .view.ng-enter, .view.ng-leave,
      .record.ng-anchor {
        transition:0.5s linear all;
      }
      .view.ng-enter {
        transform:translateX(100%);
      }
      .view.ng-enter.ng-enter-active, .view.ng-leave {
        transform:translateX(0%);
      }
      .view.ng-leave.ng-leave-active {
        transform:translateX(-100%);
      }
      .record.ng-anchor-out {
        background:red;
      }
    </file>
  </example>
 *
 * ### How is the element transported?
 *
 * When an anchor animation occurs, ngAnimate will clone the starting element and position it exactly where the starting
 * element is located on screen via absolute positioning. The cloned element will be placed inside of the root element
 * of the application (where ng-app was defined) and all of the CSS classes of the starting element will be applied. The
 * element will then animate into the `out` and `in` animations and will eventually reach the coordinates and match
 * the dimensions of the destination element. During the entire animation a CSS class of `.ng-animate-shim` will be applied
 * to both the starting and destination elements in order to hide them from being visible (the CSS styling for the class
 * is: `visibility:hidden`). Once the anchor reaches its destination then it will be removed and the destination element
 * will become visible since the shim class will be removed.
 *
 * ### How is the morphing handled?
 *
 * CSS Anchoring relies on transitions and keyframes and the internal code is intelligent enough to figure out
 * what CSS classes differ between the starting element and the destination element. These different CSS classes
 * will be added/removed on the anchor element and a transition will be applied (the transition that is provided
 * in the anchor class). Long story short, ngAnimate will figure out what classes to add and remove which will
 * make the transition of the element as smooth and automatic as possible. Be sure to use simple CSS classes that
 * do not rely on DOM nesting structure so that the anchor element appears the same as the starting element (since
 * the cloned element is placed inside of root element which is likely close to the body element).
 *
 * Note that if the root element is on the `<html>` element then the cloned node will be placed inside of body.
 *
 *
 * ## Using $animate in your directive code
 *
 * So far we've explored how to feed in animations into an Angular application, but how do we trigger animations within our own directives in our application?
 * By injecting the `$animate` service into our directive code, we can trigger structural and class-based hooks which can then be consumed by animations. Let's
 * imagine we have a greeting box that shows and hides itself when the data changes
 *
 * ```html
 * <greeting-box active="onOrOff">Hi there</greeting-box>
 * ```
 *
 * ```js
 * ngModule.directive('greetingBox', ['$animate', function($animate) {
 *   return function(scope, element, attrs) {
 *     attrs.$observe('active', function(value) {
 *       value ? $animate.addClass(element, 'on') : $animate.removeClass(element, 'on');
 *     });
 *   });
 * }]);
 * ```
 *
 * Now the `on` CSS class is added and removed on the greeting box component. Now if we add a CSS class on top of the greeting box element
 * in our HTML code then we can trigger a CSS or JS animation to happen.
 *
 * ```css
 * /&#42; normally we would create a CSS class to reference on the element &#42;/
 * greeting-box.on { transition:0.5s linear all; background:green; color:white; }
 * ```
 *
 * The `$animate` service contains a variety of other methods like `enter`, `leave`, `animate` and `setClass`. To learn more about what's
 * possible be sure to visit the {@link ng.$animate $animate service API page}.
 *
 *
 * ## Callbacks and Promises
 *
 * When `$animate` is called it returns a promise that can be used to capture when the animation has ended. Therefore if we were to trigger
 * an animation (within our directive code) then we can continue performing directive and scope related activities after the animation has
 * ended by chaining onto the returned promise that animation method returns.
 *
 * ```js
 * // somewhere within the depths of the directive
 * $animate.enter(element, parent).then(function() {
 *   //the animation has completed
 * });
 * ```
 *
 * (Note that earlier versions of Angular prior to v1.4 required the promise code to be wrapped using `$scope.$apply(...)`. This is not the case
 * anymore.)
 *
 * In addition to the animation promise, we can also make use of animation-related callbacks within our directives and controller code by registering
 * an event listener using the `$animate` service. Let's say for example that an animation was triggered on our view
 * routing controller to hook into that:
 *
 * ```js
 * ngModule.controller('HomePageController', ['$animate', function($animate) {
 *   $animate.on('enter', ngViewElement, function(element) {
 *     // the animation for this route has completed
 *   }]);
 * }])
 * ```
 *
 * (Note that you will need to trigger a digest within the callback to get angular to notice any scope-related changes.)
 */

var copy;
var extend;
var forEach;
var isArray;
var isDefined;
var isElement;
var isFunction;
var isObject;
var isString;
var isUndefined;
var jqLite;
var noop;

/**
 * @ngdoc service
 * @name $animate
 * @kind object
 *
 * @description
 * The ngAnimate `$animate` service documentation is the same for the core `$animate` service.
 *
 * Click here {@link ng.$animate to learn more about animations with `$animate`}.
 */
angular.module('ngAnimate', [], function initAngularHelpers() {
  // Access helpers from angular core.
  // Do it inside a `config` block to ensure `window.angular` is available.
  noop        = angular.noop;
  copy        = angular.copy;
  extend      = angular.extend;
  jqLite      = angular.element;
  forEach     = angular.forEach;
  isArray     = angular.isArray;
  isString    = angular.isString;
  isObject    = angular.isObject;
  isUndefined = angular.isUndefined;
  isDefined   = angular.isDefined;
  isFunction  = angular.isFunction;
  isElement   = angular.isElement;
})
  .info({ angularVersion: '1.6.5' })
  .directive('ngAnimateSwap', ngAnimateSwapDirective)

  .directive('ngAnimateChildren', $$AnimateChildrenDirective)
  .factory('$$rAFScheduler', $$rAFSchedulerFactory)

  .provider('$$animateQueue', $$AnimateQueueProvider)
  .provider('$$animation', $$AnimationProvider)

  .provider('$animateCss', $AnimateCssProvider)
  .provider('$$animateCssDriver', $$AnimateCssDriverProvider)

  .provider('$$animateJs', $$AnimateJsProvider)
  .provider('$$animateJsDriver', $$AnimateJsDriverProvider);


})(window, window.angular);


/*** EXPORTS FROM exports-loader ***/
module.exports = window.angular;

/***/ }),
/* 655 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(654);
module.exports = 'ngAnimate';


/*** EXPORTS FROM exports-loader ***/
module.exports = window.angular;

/***/ }),
/* 656 */
/***/ (function(module, exports) {

/**
 * @license AngularJS v1.6.5
 * (c) 2010-2017 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function(window, angular) {'use strict';

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *     Any commits to this file should be reviewed with security in mind.  *
 *   Changes to this file can potentially create security vulnerabilities. *
 *          An approval from 2 Core members with history of modifying      *
 *                         this file is required.                          *
 *                                                                         *
 *  Does the change somehow allow for arbitrary javascript to be executed? *
 *    Or allows for someone to change the prototype of built-in objects?   *
 *     Or gives undesired access to variables likes document or window?    *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

var $sanitizeMinErr = angular.$$minErr('$sanitize');
var bind;
var extend;
var forEach;
var isDefined;
var lowercase;
var noop;
var nodeContains;
var htmlParser;
var htmlSanitizeWriter;

/**
 * @ngdoc module
 * @name ngSanitize
 * @description
 *
 * # ngSanitize
 *
 * The `ngSanitize` module provides functionality to sanitize HTML.
 *
 *
 * <div doc-module-components="ngSanitize"></div>
 *
 * See {@link ngSanitize.$sanitize `$sanitize`} for usage.
 */

/**
 * @ngdoc service
 * @name $sanitize
 * @kind function
 *
 * @description
 *   Sanitizes an html string by stripping all potentially dangerous tokens.
 *
 *   The input is sanitized by parsing the HTML into tokens. All safe tokens (from a whitelist) are
 *   then serialized back to properly escaped html string. This means that no unsafe input can make
 *   it into the returned string.
 *
 *   The whitelist for URL sanitization of attribute values is configured using the functions
 *   `aHrefSanitizationWhitelist` and `imgSrcSanitizationWhitelist` of {@link ng.$compileProvider
 *   `$compileProvider`}.
 *
 *   The input may also contain SVG markup if this is enabled via {@link $sanitizeProvider}.
 *
 * @param {string} html HTML input.
 * @returns {string} Sanitized HTML.
 *
 * @example
   <example module="sanitizeExample" deps="angular-sanitize.js" name="sanitize-service">
   <file name="index.html">
     <script>
         angular.module('sanitizeExample', ['ngSanitize'])
           .controller('ExampleController', ['$scope', '$sce', function($scope, $sce) {
             $scope.snippet =
               '<p style="color:blue">an html\n' +
               '<em onmouseover="this.textContent=\'PWN3D!\'">click here</em>\n' +
               'snippet</p>';
             $scope.deliberatelyTrustDangerousSnippet = function() {
               return $sce.trustAsHtml($scope.snippet);
             };
           }]);
     </script>
     <div ng-controller="ExampleController">
        Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
       <table>
         <tr>
           <td>Directive</td>
           <td>How</td>
           <td>Source</td>
           <td>Rendered</td>
         </tr>
         <tr id="bind-html-with-sanitize">
           <td>ng-bind-html</td>
           <td>Automatically uses $sanitize</td>
           <td><pre>&lt;div ng-bind-html="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
           <td><div ng-bind-html="snippet"></div></td>
         </tr>
         <tr id="bind-html-with-trust">
           <td>ng-bind-html</td>
           <td>Bypass $sanitize by explicitly trusting the dangerous value</td>
           <td>
           <pre>&lt;div ng-bind-html="deliberatelyTrustDangerousSnippet()"&gt;
&lt;/div&gt;</pre>
           </td>
           <td><div ng-bind-html="deliberatelyTrustDangerousSnippet()"></div></td>
         </tr>
         <tr id="bind-default">
           <td>ng-bind</td>
           <td>Automatically escapes</td>
           <td><pre>&lt;div ng-bind="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
           <td><div ng-bind="snippet"></div></td>
         </tr>
       </table>
       </div>
   </file>
   <file name="protractor.js" type="protractor">
     it('should sanitize the html snippet by default', function() {
       expect(element(by.css('#bind-html-with-sanitize div')).getAttribute('innerHTML')).
         toBe('<p>an html\n<em>click here</em>\nsnippet</p>');
     });

     it('should inline raw snippet if bound to a trusted value', function() {
       expect(element(by.css('#bind-html-with-trust div')).getAttribute('innerHTML')).
         toBe("<p style=\"color:blue\">an html\n" +
              "<em onmouseover=\"this.textContent='PWN3D!'\">click here</em>\n" +
              "snippet</p>");
     });

     it('should escape snippet without any filter', function() {
       expect(element(by.css('#bind-default div')).getAttribute('innerHTML')).
         toBe("&lt;p style=\"color:blue\"&gt;an html\n" +
              "&lt;em onmouseover=\"this.textContent='PWN3D!'\"&gt;click here&lt;/em&gt;\n" +
              "snippet&lt;/p&gt;");
     });

     it('should update', function() {
       element(by.model('snippet')).clear();
       element(by.model('snippet')).sendKeys('new <b onclick="alert(1)">text</b>');
       expect(element(by.css('#bind-html-with-sanitize div')).getAttribute('innerHTML')).
         toBe('new <b>text</b>');
       expect(element(by.css('#bind-html-with-trust div')).getAttribute('innerHTML')).toBe(
         'new <b onclick="alert(1)">text</b>');
       expect(element(by.css('#bind-default div')).getAttribute('innerHTML')).toBe(
         "new &lt;b onclick=\"alert(1)\"&gt;text&lt;/b&gt;");
     });
   </file>
   </example>
 */


/**
 * @ngdoc provider
 * @name $sanitizeProvider
 * @this
 *
 * @description
 * Creates and configures {@link $sanitize} instance.
 */
function $SanitizeProvider() {
  var svgEnabled = false;

  this.$get = ['$$sanitizeUri', function($$sanitizeUri) {
    if (svgEnabled) {
      extend(validElements, svgElements);
    }
    return function(html) {
      var buf = [];
      htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
        return !/^unsafe:/.test($$sanitizeUri(uri, isImage));
      }));
      return buf.join('');
    };
  }];


  /**
   * @ngdoc method
   * @name $sanitizeProvider#enableSvg
   * @kind function
   *
   * @description
   * Enables a subset of svg to be supported by the sanitizer.
   *
   * <div class="alert alert-warning">
   *   <p>By enabling this setting without taking other precautions, you might expose your
   *   application to click-hijacking attacks. In these attacks, sanitized svg elements could be positioned
   *   outside of the containing element and be rendered over other elements on the page (e.g. a login
   *   link). Such behavior can then result in phishing incidents.</p>
   *
   *   <p>To protect against these, explicitly setup `overflow: hidden` css rule for all potential svg
   *   tags within the sanitized content:</p>
   *
   *   <br>
   *
   *   <pre><code>
   *   .rootOfTheIncludedContent svg {
   *     overflow: hidden !important;
   *   }
   *   </code></pre>
   * </div>
   *
   * @param {boolean=} flag Enable or disable SVG support in the sanitizer.
   * @returns {boolean|ng.$sanitizeProvider} Returns the currently configured value if called
   *    without an argument or self for chaining otherwise.
   */
  this.enableSvg = function(enableSvg) {
    if (isDefined(enableSvg)) {
      svgEnabled = enableSvg;
      return this;
    } else {
      return svgEnabled;
    }
  };

  //////////////////////////////////////////////////////////////////////////////////////////////////
  // Private stuff
  //////////////////////////////////////////////////////////////////////////////////////////////////

  bind = angular.bind;
  extend = angular.extend;
  forEach = angular.forEach;
  isDefined = angular.isDefined;
  lowercase = angular.lowercase;
  noop = angular.noop;

  htmlParser = htmlParserImpl;
  htmlSanitizeWriter = htmlSanitizeWriterImpl;

  nodeContains = window.Node.prototype.contains || /** @this */ function(arg) {
    // eslint-disable-next-line no-bitwise
    return !!(this.compareDocumentPosition(arg) & 16);
  };

  // Regular Expressions for parsing tags and attributes
  var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
    // Match everything outside of normal chars and " (quote character)
    NON_ALPHANUMERIC_REGEXP = /([^#-~ |!])/g;


  // Good source of info about elements and attributes
  // http://dev.w3.org/html5/spec/Overview.html#semantics
  // http://simon.html5.org/html-elements

  // Safe Void Elements - HTML5
  // http://dev.w3.org/html5/spec/Overview.html#void-elements
  var voidElements = toMap('area,br,col,hr,img,wbr');

  // Elements that you can, intentionally, leave open (and which close themselves)
  // http://dev.w3.org/html5/spec/Overview.html#optional-tags
  var optionalEndTagBlockElements = toMap('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr'),
      optionalEndTagInlineElements = toMap('rp,rt'),
      optionalEndTagElements = extend({},
                                              optionalEndTagInlineElements,
                                              optionalEndTagBlockElements);

  // Safe Block Elements - HTML5
  var blockElements = extend({}, optionalEndTagBlockElements, toMap('address,article,' +
          'aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' +
          'h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,section,table,ul'));

  // Inline Elements - HTML5
  var inlineElements = extend({}, optionalEndTagInlineElements, toMap('a,abbr,acronym,b,' +
          'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,' +
          'samp,small,span,strike,strong,sub,sup,time,tt,u,var'));

  // SVG Elements
  // https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Elements
  // Note: the elements animate,animateColor,animateMotion,animateTransform,set are intentionally omitted.
  // They can potentially allow for arbitrary javascript to be executed. See #11290
  var svgElements = toMap('circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,' +
          'hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,' +
          'radialGradient,rect,stop,svg,switch,text,title,tspan');

  // Blocked Elements (will be stripped)
  var blockedElements = toMap('script,style');

  var validElements = extend({},
                                     voidElements,
                                     blockElements,
                                     inlineElements,
                                     optionalEndTagElements);

  //Attributes that have href and hence need to be sanitized
  var uriAttrs = toMap('background,cite,href,longdesc,src,xlink:href');

  var htmlAttrs = toMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' +
      'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' +
      'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' +
      'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' +
      'valign,value,vspace,width');

  // SVG attributes (without "id" and "name" attributes)
  // https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Attributes
  var svgAttrs = toMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' +
      'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' +
      'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' +
      'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' +
      'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' +
      'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' +
      'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' +
      'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' +
      'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' +
      'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' +
      'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' +
      'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' +
      'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' +
      'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' +
      'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);

  var validAttrs = extend({},
                                  uriAttrs,
                                  svgAttrs,
                                  htmlAttrs);

  function toMap(str, lowercaseKeys) {
    var obj = {}, items = str.split(','), i;
    for (i = 0; i < items.length; i++) {
      obj[lowercaseKeys ? lowercase(items[i]) : items[i]] = true;
    }
    return obj;
  }

  /**
   * Create an inert document that contains the dirty HTML that needs sanitizing
   * Depending upon browser support we use one of three strategies for doing this.
   * Support: Safari 10.x -> XHR strategy
   * Support: Firefox -> DomParser strategy
   */
  var getInertBodyElement /* function(html: string): HTMLBodyElement */ = (function(window, document) {
    var inertDocument;
    if (document && document.implementation) {
      inertDocument = document.implementation.createHTMLDocument('inert');
    } else {
      throw $sanitizeMinErr('noinert', 'Can\'t create an inert html document');
    }
    var inertBodyElement = (inertDocument.documentElement || inertDocument.getDocumentElement()).querySelector('body');

    // Check for the Safari 10.1 bug - which allows JS to run inside the SVG G element
    inertBodyElement.innerHTML = '<svg><g onload="this.parentNode.remove()"></g></svg>';
    if (!inertBodyElement.querySelector('svg')) {
      return getInertBodyElement_XHR;
    } else {
      // Check for the Firefox bug - which prevents the inner img JS from being sanitized
      inertBodyElement.innerHTML = '<svg><p><style><img src="</style><img src=x onerror=alert(1)//">';
      if (inertBodyElement.querySelector('svg img')) {
        return getInertBodyElement_DOMParser;
      } else {
        return getInertBodyElement_InertDocument;
      }
    }

    function getInertBodyElement_XHR(html) {
      // We add this dummy element to ensure that the rest of the content is parsed as expected
      // e.g. leading whitespace is maintained and tags like `<meta>` do not get hoisted to the `<head>` tag.
      html = '<remove></remove>' + html;
      try {
        html = encodeURI(html);
      } catch (e) {
        return undefined;
      }
      var xhr = new window.XMLHttpRequest();
      xhr.responseType = 'document';
      xhr.open('GET', 'data:text/html;charset=utf-8,' + html, false);
      xhr.send(null);
      var body = xhr.response.body;
      body.firstChild.remove();
      return body;
    }

    function getInertBodyElement_DOMParser(html) {
      // We add this dummy element to ensure that the rest of the content is parsed as expected
      // e.g. leading whitespace is maintained and tags like `<meta>` do not get hoisted to the `<head>` tag.
      html = '<remove></remove>' + html;
      try {
        var body = new window.DOMParser().parseFromString(html, 'text/html').body;
        body.firstChild.remove();
        return body;
      } catch (e) {
        return undefined;
      }
    }

    function getInertBodyElement_InertDocument(html) {
      inertBodyElement.innerHTML = html;

      // Support: IE 9-11 only
      // strip custom-namespaced attributes on IE<=11
      if (document.documentMode) {
        stripCustomNsAttrs(inertBodyElement);
      }

      return inertBodyElement;
    }
  })(window, window.document);

  /**
   * @example
   * htmlParser(htmlString, {
   *     start: function(tag, attrs) {},
   *     end: function(tag) {},
   *     chars: function(text) {},
   *     comment: function(text) {}
   * });
   *
   * @param {string} html string
   * @param {object} handler
   */
  function htmlParserImpl(html, handler) {
    if (html === null || html === undefined) {
      html = '';
    } else if (typeof html !== 'string') {
      html = '' + html;
    }

    var inertBodyElement = getInertBodyElement(html);
    if (!inertBodyElement) return '';

    //mXSS protection
    var mXSSAttempts = 5;
    do {
      if (mXSSAttempts === 0) {
        throw $sanitizeMinErr('uinput', 'Failed to sanitize html because the input is unstable');
      }
      mXSSAttempts--;

      // trigger mXSS if it is going to happen by reading and writing the innerHTML
      html = inertBodyElement.innerHTML;
      inertBodyElement = getInertBodyElement(html);
    } while (html !== inertBodyElement.innerHTML);

    var node = inertBodyElement.firstChild;
    while (node) {
      switch (node.nodeType) {
        case 1: // ELEMENT_NODE
          handler.start(node.nodeName.toLowerCase(), attrToMap(node.attributes));
          break;
        case 3: // TEXT NODE
          handler.chars(node.textContent);
          break;
      }

      var nextNode;
      if (!(nextNode = node.firstChild)) {
        if (node.nodeType === 1) {
          handler.end(node.nodeName.toLowerCase());
        }
        nextNode = getNonDescendant('nextSibling', node);
        if (!nextNode) {
          while (nextNode == null) {
            node = getNonDescendant('parentNode', node);
            if (node === inertBodyElement) break;
            nextNode = getNonDescendant('nextSibling', node);
            if (node.nodeType === 1) {
              handler.end(node.nodeName.toLowerCase());
            }
          }
        }
      }
      node = nextNode;
    }

    while ((node = inertBodyElement.firstChild)) {
      inertBodyElement.removeChild(node);
    }
  }

  function attrToMap(attrs) {
    var map = {};
    for (var i = 0, ii = attrs.length; i < ii; i++) {
      var attr = attrs[i];
      map[attr.name] = attr.value;
    }
    return map;
  }


  /**
   * Escapes all potentially dangerous characters, so that the
   * resulting string can be safely inserted into attribute or
   * element text.
   * @param value
   * @returns {string} escaped text
   */
  function encodeEntities(value) {
    return value.
      replace(/&/g, '&amp;').
      replace(SURROGATE_PAIR_REGEXP, function(value) {
        var hi = value.charCodeAt(0);
        var low = value.charCodeAt(1);
        return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
      }).
      replace(NON_ALPHANUMERIC_REGEXP, function(value) {
        return '&#' + value.charCodeAt(0) + ';';
      }).
      replace(/</g, '&lt;').
      replace(/>/g, '&gt;');
  }

  /**
   * create an HTML/XML writer which writes to buffer
   * @param {Array} buf use buf.join('') to get out sanitized html string
   * @returns {object} in the form of {
   *     start: function(tag, attrs) {},
   *     end: function(tag) {},
   *     chars: function(text) {},
   *     comment: function(text) {}
   * }
   */
  function htmlSanitizeWriterImpl(buf, uriValidator) {
    var ignoreCurrentElement = false;
    var out = bind(buf, buf.push);
    return {
      start: function(tag, attrs) {
        tag = lowercase(tag);
        if (!ignoreCurrentElement && blockedElements[tag]) {
          ignoreCurrentElement = tag;
        }
        if (!ignoreCurrentElement && validElements[tag] === true) {
          out('<');
          out(tag);
          forEach(attrs, function(value, key) {
            var lkey = lowercase(key);
            var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');
            if (validAttrs[lkey] === true &&
              (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
              out(' ');
              out(key);
              out('="');
              out(encodeEntities(value));
              out('"');
            }
          });
          out('>');
        }
      },
      end: function(tag) {
        tag = lowercase(tag);
        if (!ignoreCurrentElement && validElements[tag] === true && voidElements[tag] !== true) {
          out('</');
          out(tag);
          out('>');
        }
        // eslint-disable-next-line eqeqeq
        if (tag == ignoreCurrentElement) {
          ignoreCurrentElement = false;
        }
      },
      chars: function(chars) {
        if (!ignoreCurrentElement) {
          out(encodeEntities(chars));
        }
      }
    };
  }


  /**
   * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1' attribute to declare
   * ns1 namespace and prefixes the attribute with 'ns1' (e.g. 'ns1:xlink:foo'). This is undesirable since we don't want
   * to allow any of these custom attributes. This method strips them all.
   *
   * @param node Root element to process
   */
  function stripCustomNsAttrs(node) {
    while (node) {
      if (node.nodeType === window.Node.ELEMENT_NODE) {
        var attrs = node.attributes;
        for (var i = 0, l = attrs.length; i < l; i++) {
          var attrNode = attrs[i];
          var attrName = attrNode.name.toLowerCase();
          if (attrName === 'xmlns:ns1' || attrName.lastIndexOf('ns1:', 0) === 0) {
            node.removeAttributeNode(attrNode);
            i--;
            l--;
          }
        }
      }

      var nextNode = node.firstChild;
      if (nextNode) {
        stripCustomNsAttrs(nextNode);
      }

      node = getNonDescendant('nextSibling', node);
    }
  }

  function getNonDescendant(propName, node) {
    // An element is clobbered if its `propName` property points to one of its descendants
    var nextNode = node[propName];
    if (nextNode && nodeContains.call(node, nextNode)) {
      throw $sanitizeMinErr('elclob', 'Failed to sanitize html because the element is clobbered: {0}', node.outerHTML || node.outerText);
    }
    return nextNode;
  }
}

function sanitizeText(chars) {
  var buf = [];
  var writer = htmlSanitizeWriter(buf, noop);
  writer.chars(chars);
  return buf.join('');
}


// define ngSanitize module and register $sanitize service
angular.module('ngSanitize', [])
  .provider('$sanitize', $SanitizeProvider)
  .info({ angularVersion: '1.6.5' });

/**
 * @ngdoc filter
 * @name linky
 * @kind function
 *
 * @description
 * Finds links in text input and turns them into html links. Supports `http/https/ftp/mailto` and
 * plain email address links.
 *
 * Requires the {@link ngSanitize `ngSanitize`} module to be installed.
 *
 * @param {string} text Input text.
 * @param {string} target Window (`_blank|_self|_parent|_top`) or named frame to open links in.
 * @param {object|function(url)} [attributes] Add custom attributes to the link element.
 *
 *    Can be one of:
 *
 *    - `object`: A map of attributes
 *    - `function`: Takes the url as a parameter and returns a map of attributes
 *
 *    If the map of attributes contains a value for `target`, it overrides the value of
 *    the target parameter.
 *
 *
 * @returns {string} Html-linkified and {@link $sanitize sanitized} text.
 *
 * @usage
   <span ng-bind-html="linky_expression | linky"></span>
 *
 * @example
   <example module="linkyExample" deps="angular-sanitize.js" name="linky-filter">
     <file name="index.html">
       <div ng-controller="ExampleController">
       Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
       <table>
         <tr>
           <th>Filter</th>
           <th>Source</th>
           <th>Rendered</th>
         </tr>
         <tr id="linky-filter">
           <td>linky filter</td>
           <td>
             <pre>&lt;div ng-bind-html="snippet | linky"&gt;<br>&lt;/div&gt;</pre>
           </td>
           <td>
             <div ng-bind-html="snippet | linky"></div>
           </td>
         </tr>
         <tr id="linky-target">
          <td>linky target</td>
          <td>
            <pre>&lt;div ng-bind-html="snippetWithSingleURL | linky:'_blank'"&gt;<br>&lt;/div&gt;</pre>
          </td>
          <td>
            <div ng-bind-html="snippetWithSingleURL | linky:'_blank'"></div>
          </td>
         </tr>
         <tr id="linky-custom-attributes">
          <td>linky custom attributes</td>
          <td>
            <pre>&lt;div ng-bind-html="snippetWithSingleURL | linky:'_self':{rel: 'nofollow'}"&gt;<br>&lt;/div&gt;</pre>
          </td>
          <td>
            <div ng-bind-html="snippetWithSingleURL | linky:'_self':{rel: 'nofollow'}"></div>
          </td>
         </tr>
         <tr id="escaped-html">
           <td>no filter</td>
           <td><pre>&lt;div ng-bind="snippet"&gt;<br>&lt;/div&gt;</pre></td>
           <td><div ng-bind="snippet"></div></td>
         </tr>
       </table>
     </file>
     <file name="script.js">
       angular.module('linkyExample', ['ngSanitize'])
         .controller('ExampleController', ['$scope', function($scope) {
           $scope.snippet =
             'Pretty text with some links:\n' +
             'http://angularjs.org/,\n' +
             'mailto:us@somewhere.org,\n' +
             'another@somewhere.org,\n' +
             'and one more: ftp://127.0.0.1/.';
           $scope.snippetWithSingleURL = 'http://angularjs.org/';
         }]);
     </file>
     <file name="protractor.js" type="protractor">
       it('should linkify the snippet with urls', function() {
         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).
             toBe('Pretty text with some links: http://angularjs.org/, us@somewhere.org, ' +
                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');
         expect(element.all(by.css('#linky-filter a')).count()).toEqual(4);
       });

       it('should not linkify snippet without the linky filter', function() {
         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText()).
             toBe('Pretty text with some links: http://angularjs.org/, mailto:us@somewhere.org, ' +
                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');
         expect(element.all(by.css('#escaped-html a')).count()).toEqual(0);
       });

       it('should update', function() {
         element(by.model('snippet')).clear();
         element(by.model('snippet')).sendKeys('new http://link.');
         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).
             toBe('new http://link.');
         expect(element.all(by.css('#linky-filter a')).count()).toEqual(1);
         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText())
             .toBe('new http://link.');
       });

       it('should work with the target property', function() {
        expect(element(by.id('linky-target')).
            element(by.binding("snippetWithSingleURL | linky:'_blank'")).getText()).
            toBe('http://angularjs.org/');
        expect(element(by.css('#linky-target a')).getAttribute('target')).toEqual('_blank');
       });

       it('should optionally add custom attributes', function() {
        expect(element(by.id('linky-custom-attributes')).
            element(by.binding("snippetWithSingleURL | linky:'_self':{rel: 'nofollow'}")).getText()).
            toBe('http://angularjs.org/');
        expect(element(by.css('#linky-custom-attributes a')).getAttribute('rel')).toEqual('nofollow');
       });
     </file>
   </example>
 */
angular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {
  var LINKY_URL_REGEXP =
        /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"\u201d\u2019]/i,
      MAILTO_REGEXP = /^mailto:/i;

  var linkyMinErr = angular.$$minErr('linky');
  var isDefined = angular.isDefined;
  var isFunction = angular.isFunction;
  var isObject = angular.isObject;
  var isString = angular.isString;

  return function(text, target, attributes) {
    if (text == null || text === '') return text;
    if (!isString(text)) throw linkyMinErr('notstring', 'Expected string but received: {0}', text);

    var attributesFn =
      isFunction(attributes) ? attributes :
      isObject(attributes) ? function getAttributesObject() {return attributes;} :
      function getEmptyAttributesObject() {return {};};

    var match;
    var raw = text;
    var html = [];
    var url;
    var i;
    while ((match = raw.match(LINKY_URL_REGEXP))) {
      // We can not end in these as they are sometimes found at the end of the sentence
      url = match[0];
      // if we did not match ftp/http/www/mailto then assume mailto
      if (!match[2] && !match[4]) {
        url = (match[3] ? 'http://' : 'mailto:') + url;
      }
      i = match.index;
      addText(raw.substr(0, i));
      addLink(url, match[0].replace(MAILTO_REGEXP, ''));
      raw = raw.substring(i + match[0].length);
    }
    addText(raw);
    return $sanitize(html.join(''));

    function addText(text) {
      if (!text) {
        return;
      }
      html.push(sanitizeText(text));
    }

    function addLink(url, text) {
      var key, linkAttributes = attributesFn(url);
      html.push('<a ');

      for (key in linkAttributes) {
        html.push(key + '="' + linkAttributes[key] + '" ');
      }

      if (isDefined(target) && !('target' in linkAttributes)) {
        html.push('target="',
                  target,
                  '" ');
      }
      html.push('href="',
                url.replace(/"/g, '&quot;'),
                '">');
      addText(text);
      html.push('</a>');
    }
  };
}]);


})(window, window.angular);


/*** EXPORTS FROM exports-loader ***/
module.exports = window.angular;

/***/ }),
/* 657 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(656);
module.exports = 'ngSanitize';


/*** EXPORTS FROM exports-loader ***/
module.exports = window.angular;

/***/ }),
/* 658 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CGA02}
// di.core.global.angular
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(659), __webpack_require__(660)], __WEBPACK_AMD_DEFINE_RESULT__ = function () {}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/*** EXPORTS FROM exports-loader ***/
module.exports = window.angular;

/***/ }),
/* 659 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CGA01}
// di.core.global.angular
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    'use strict';

    /** angular helper */

    window.$di.angular.snippetRegistrar = {
        registerSnippet: registerSnippet,
        createContext: createContext
    };

    return window.$di.angular.snippetRegistrar;

    function registerSnippet(module, directiveName, templateUrl, controller, controllerAs) {
        module.directive(directiveName, directive);

        function directive() {
            return {
                restrict: 'E',
                replace: true,
                templateUrl: templateUrl,
                controller: controller,
                controllerAs: controllerAs
            };
        }
    }

    function createContext(module, templateBaseUrl) {
        return {
            registerSnippet: registerSnippetInContext
        };

        function registerSnippetInContext(directiveName, templateName, controller, controllerAs) {
            var templateUrl = templateBaseUrl + '/' + templateName;

            registerSnippet(module, directiveName, templateUrl, controller, controllerAs);
        }
    }
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/*** EXPORTS FROM exports-loader ***/
module.exports = window.angular;

/***/ }),
/* 660 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//{CODE:CGA04}
// di.core.global.angular
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(10)], __WEBPACK_AMD_DEFINE_RESULT__ = function (util) {
    'use strict';

    window.$di.angular.util = {
        $watch: $watch,
        $watchCollection: $watchCollection
    };

    return window.$di.angular.util;

    /**
     * Watch function that only invokes the callback if the new value is a
     * non-empty object and is not equal to the optional ignore object
     */
    function $watch(scope, objFunction, callback, ignoreObj) {
        return scope.$watch(objFunction, function (newValue) {
            if (util.isRealObject(newValue) && newValue !== (ignoreObj || {})) {
                callback(newValue);
            }
        });
    }

    function $watchCollection(scope, object, listener) {
        return scope.$watchCollection(object, function (newValue) {
            if (util.isArray(newValue) && newValue.length > 0) {
                listener(newValue);
            }
        });
    }
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/*** EXPORTS FROM exports-loader ***/
module.exports = window.angular;

/***/ }),
/* 661 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(angularLocalStorage) {var isDefined = angular.isDefined,
  isUndefined = angular.isUndefined,
  isNumber = angular.isNumber,
  isObject = angular.isObject,
  isArray = angular.isArray,
  extend = angular.extend,
  toJson = angular.toJson;

angular
  .module('LocalStorageModule', [])
  .provider('localStorageService', function() {
    // You should set a prefix to avoid overwriting any local storage variables from the rest of your app
    // e.g. localStorageServiceProvider.setPrefix('yourAppName');
    // With provider you can use config as this:
    // myApp.config(function (localStorageServiceProvider) {
    //    localStorageServiceProvider.prefix = 'yourAppName';
    // });
    this.prefix = 'ls';

    // You could change web storage type localstorage or sessionStorage
    this.storageType = 'localStorage';

    // Cookie options (usually in case of fallback)
    // expiry = Number of days before cookies expire // 0 = Does not expire
    // path = The web path the cookie represents
    this.cookie = {
      expiry: 30,
      path: '/'
    };

    // Send signals for each of the following actions?
    this.notify = {
      setItem: true,
      removeItem: false
    };

    // Setter for the prefix
    this.setPrefix = function(prefix) {
      this.prefix = prefix;
      return this;
    };

    // Setter for the storageType
    this.setStorageType = function(storageType) {
      this.storageType = storageType;
      return this;
    };

    // Setter for cookie config
    this.setStorageCookie = function(exp, path) {
      this.cookie.expiry = exp;
      this.cookie.path = path;
      return this;
    };

    // Setter for cookie domain
    this.setStorageCookieDomain = function(domain) {
      this.cookie.domain = domain;
      return this;
    };

    // Setter for notification config
    // itemSet & itemRemove should be booleans
    this.setNotify = function(itemSet, itemRemove) {
      this.notify = {
        setItem: itemSet,
        removeItem: itemRemove
      };
      return this;
    };

    this.$get = ['$rootScope', '$window', '$document', '$parse', function($rootScope, $window, $document, $parse) {
      var self = this;
      var prefix = self.prefix;
      var cookie = self.cookie;
      var notify = self.notify;
      var storageType = self.storageType;
      var webStorage;

      // When Angular's $document is not available
      if (!$document) {
        $document = document;
      } else if ($document[0]) {
        $document = $document[0];
      }

      // If there is a prefix set in the config lets use that with an appended period for readability
      if (prefix.substr(-1) !== '.') {
        prefix = !!prefix ? prefix + '.' : '';
      }
      var deriveQualifiedKey = function(key) {
        return prefix + key;
      };
      // Checks the browser to see if local storage is supported
      var browserSupportsLocalStorage = (function () {
        try {
          var supported = (storageType in $window && $window[storageType] !== null);

          // When Safari (OS X or iOS) is in private browsing mode, it appears as though localStorage
          // is available, but trying to call .setItem throws an exception.
          //
          // "QUOTA_EXCEEDED_ERR: DOM Exception 22: An attempt was made to add something to storage
          // that exceeded the quota."
          var key = deriveQualifiedKey('__' + Math.round(Math.random() * 1e7));
          if (supported) {
            webStorage = $window[storageType];
            webStorage.setItem(key, '');
            webStorage.removeItem(key);
          }

          return supported;
        } catch (e) {
          storageType = 'cookie';
          $rootScope.$broadcast('LocalStorageModule.notification.error', e.message);
          return false;
        }
      }());

      // Directly adds a value to local storage
      // If local storage is not available in the browser use cookies
      // Example use: localStorageService.add('library','angular');
      var addToLocalStorage = function (key, value) {
        // Let's convert undefined values to null to get the value consistent
        if (isUndefined(value)) {
          value = null;
        } else {
          value = toJson(value);
        }

        // If this browser does not support local storage use cookies
        if (!browserSupportsLocalStorage || self.storageType === 'cookie') {
          if (!browserSupportsLocalStorage) {
            $rootScope.$broadcast('LocalStorageModule.notification.warning', 'LOCAL_STORAGE_NOT_SUPPORTED');
          }

          if (notify.setItem) {
            $rootScope.$broadcast('LocalStorageModule.notification.setitem', {key: key, newvalue: value, storageType: 'cookie'});
          }
          return addToCookies(key, value);
        }

        try {
          if (webStorage) {
            webStorage.setItem(deriveQualifiedKey(key), value);
          }
          if (notify.setItem) {
            $rootScope.$broadcast('LocalStorageModule.notification.setitem', {key: key, newvalue: value, storageType: self.storageType});
          }
        } catch (e) {
          $rootScope.$broadcast('LocalStorageModule.notification.error', e.message);
          return addToCookies(key, value);
        }
        return true;
      };

      // Directly get a value from local storage
      // Example use: localStorageService.get('library'); // returns 'angular'
      var getFromLocalStorage = function (key) {

        if (!browserSupportsLocalStorage || self.storageType === 'cookie') {
          if (!browserSupportsLocalStorage) {
            $rootScope.$broadcast('LocalStorageModule.notification.warning', 'LOCAL_STORAGE_NOT_SUPPORTED');
          }

          return getFromCookies(key);
        }

        var item = webStorage ? webStorage.getItem(deriveQualifiedKey(key)) : null;
        // angular.toJson will convert null to 'null', so a proper conversion is needed
        // FIXME not a perfect solution, since a valid 'null' string can't be stored
        if (!item || item === 'null') {
          return null;
        }

        try {
          return JSON.parse(item);
        } catch (e) {
          return item;
        }
      };

      // Remove an item from local storage
      // Example use: localStorageService.remove('library'); // removes the key/value pair of library='angular'
      var removeFromLocalStorage = function () {
        var i, key;
        for (i=0; i<arguments.length; i++) {
          key = arguments[i];
          if (!browserSupportsLocalStorage || self.storageType === 'cookie') {
            if (!browserSupportsLocalStorage) {
              $rootScope.$broadcast('LocalStorageModule.notification.warning', 'LOCAL_STORAGE_NOT_SUPPORTED');
            }

            if (notify.removeItem) {
              $rootScope.$broadcast('LocalStorageModule.notification.removeitem', {key: key, storageType: 'cookie'});
            }
            removeFromCookies(key);
          }
          else {
            try {
              webStorage.removeItem(deriveQualifiedKey(key));
              if (notify.removeItem) {
                $rootScope.$broadcast('LocalStorageModule.notification.removeitem', {
                  key: key,
                  storageType: self.storageType
                });
              }
            } catch (e) {
              $rootScope.$broadcast('LocalStorageModule.notification.error', e.message);
              removeFromCookies(key);
            }
          }
        }
      };

      // Return array of keys for local storage
      // Example use: var keys = localStorageService.keys()
      var getKeysForLocalStorage = function () {

        if (!browserSupportsLocalStorage) {
          $rootScope.$broadcast('LocalStorageModule.notification.warning', 'LOCAL_STORAGE_NOT_SUPPORTED');
          return [];
        }

        var prefixLength = prefix.length;
        var keys = [];
        for (var key in webStorage) {
          // Only return keys that are for this app
          if (key.substr(0, prefixLength) === prefix) {
            try {
              keys.push(key.substr(prefixLength));
            } catch (e) {
              $rootScope.$broadcast('LocalStorageModule.notification.error', e.Description);
              return [];
            }
          }
        }
        return keys;
      };

      // Remove all data for this app from local storage
      // Also optionally takes a regular expression string and removes the matching key-value pairs
      // Example use: localStorageService.clearAll();
      // Should be used mostly for development purposes
      var clearAllFromLocalStorage = function (regularExpression) {

        // Setting both regular expressions independently
        // Empty strings result in catchall RegExp
        var prefixRegex = !!prefix ? new RegExp('^' + prefix) : new RegExp();
        var testRegex = !!regularExpression ? new RegExp(regularExpression) : new RegExp();

        if (!browserSupportsLocalStorage || self.storageType === 'cookie') {
          if (!browserSupportsLocalStorage) {
            $rootScope.$broadcast('LocalStorageModule.notification.warning', 'LOCAL_STORAGE_NOT_SUPPORTED');
          }
          return clearAllFromCookies();
        }

        var prefixLength = prefix.length;

        for (var key in webStorage) {
          // Only remove items that are for this app and match the regular expression
          if (prefixRegex.test(key) && testRegex.test(key.substr(prefixLength))) {
            try {
              removeFromLocalStorage(key.substr(prefixLength));
            } catch (e) {
              $rootScope.$broadcast('LocalStorageModule.notification.error', e.message);
              return clearAllFromCookies();
            }
          }
        }
        return true;
      };

      // Checks the browser to see if cookies are supported
      var browserSupportsCookies = (function() {
        try {
          return $window.navigator.cookieEnabled ||
          ("cookie" in $document && ($document.cookie.length > 0 ||
            ($document.cookie = "test").indexOf.call($document.cookie, "test") > -1));
          } catch (e) {
            $rootScope.$broadcast('LocalStorageModule.notification.error', e.message);
            return false;
          }
        }());

        // Directly adds a value to cookies
        // Typically used as a fallback is local storage is not available in the browser
        // Example use: localStorageService.cookie.add('library','angular');
        var addToCookies = function (key, value, daysToExpiry) {

          if (isUndefined(value)) {
            return false;
          } else if(isArray(value) || isObject(value)) {
            value = toJson(value);
          }

          if (!browserSupportsCookies) {
            $rootScope.$broadcast('LocalStorageModule.notification.error', 'COOKIES_NOT_SUPPORTED');
            return false;
          }

          try {
            var expiry = '',
            expiryDate = new Date(),
            cookieDomain = '';

            if (value === null) {
              // Mark that the cookie has expired one day ago
              expiryDate.setTime(expiryDate.getTime() + (-1 * 24 * 60 * 60 * 1000));
              expiry = "; expires=" + expiryDate.toGMTString();
              value = '';
            } else if (isNumber(daysToExpiry) && daysToExpiry !== 0) {
              expiryDate.setTime(expiryDate.getTime() + (daysToExpiry * 24 * 60 * 60 * 1000));
              expiry = "; expires=" + expiryDate.toGMTString();
            } else if (cookie.expiry !== 0) {
              expiryDate.setTime(expiryDate.getTime() + (cookie.expiry * 24 * 60 * 60 * 1000));
              expiry = "; expires=" + expiryDate.toGMTString();
            }
            if (!!key) {
              var cookiePath = "; path=" + cookie.path;
              if(cookie.domain){
                cookieDomain = "; domain=" + cookie.domain;
              }
              $document.cookie = deriveQualifiedKey(key) + "=" + encodeURIComponent(value) + expiry + cookiePath + cookieDomain;
            }
          } catch (e) {
            $rootScope.$broadcast('LocalStorageModule.notification.error', e.message);
            return false;
          }
          return true;
        };

        // Directly get a value from a cookie
        // Example use: localStorageService.cookie.get('library'); // returns 'angular'
        var getFromCookies = function (key) {
          if (!browserSupportsCookies) {
            $rootScope.$broadcast('LocalStorageModule.notification.error', 'COOKIES_NOT_SUPPORTED');
            return false;
          }

          var cookies = $document.cookie && $document.cookie.split(';') || [];
          for(var i=0; i < cookies.length; i++) {
            var thisCookie = cookies[i];
            while (thisCookie.charAt(0) === ' ') {
              thisCookie = thisCookie.substring(1,thisCookie.length);
            }
            if (thisCookie.indexOf(deriveQualifiedKey(key) + '=') === 0) {
              var storedValues = decodeURIComponent(thisCookie.substring(prefix.length + key.length + 1, thisCookie.length));
              try {
                return JSON.parse(storedValues);
              } catch(e) {
                return storedValues;
              }
            }
          }
          return null;
        };

        var removeFromCookies = function (key) {
          addToCookies(key,null);
        };

        var clearAllFromCookies = function () {
          var thisCookie = null, thisKey = null;
          var prefixLength = prefix.length;
          var cookies = $document.cookie.split(';');
          for(var i = 0; i < cookies.length; i++) {
            thisCookie = cookies[i];

            while (thisCookie.charAt(0) === ' ') {
              thisCookie = thisCookie.substring(1, thisCookie.length);
            }

            var key = thisCookie.substring(prefixLength, thisCookie.indexOf('='));
            removeFromCookies(key);
          }
        };

        var getStorageType = function() {
          return storageType;
        };

        // Add a listener on scope variable to save its changes to local storage
        // Return a function which when called cancels binding
        var bindToScope = function(scope, key, def, lsKey) {
          lsKey = lsKey || key;
          var value = getFromLocalStorage(lsKey);

          if (value === null && isDefined(def)) {
            value = def;
          } else if (isObject(value) && isObject(def)) {
            value = extend(value, def);
          }

          $parse(key).assign(scope, value);

          return scope.$watch(key, function(newVal) {
            addToLocalStorage(lsKey, newVal);
          }, isObject(scope[key]));
        };

        // Return localStorageService.length
        // ignore keys that not owned
        var lengthOfLocalStorage = function() {
          var count = 0;
          var storage = $window[storageType];
          for(var i = 0; i < storage.length; i++) {
            if(storage.key(i).indexOf(prefix) === 0 ) {
              count++;
            }
          }
          return count;
        };

        return {
          isSupported: browserSupportsLocalStorage,
          getStorageType: getStorageType,
          set: addToLocalStorage,
          add: addToLocalStorage, //DEPRECATED
          get: getFromLocalStorage,
          keys: getKeysForLocalStorage,
          remove: removeFromLocalStorage,
          clearAll: clearAllFromLocalStorage,
          bind: bindToScope,
          deriveKey: deriveQualifiedKey,
          length: lengthOfLocalStorage,
          cookie: {
            isSupported: browserSupportsCookies,
            set: addToCookies,
            add: addToCookies, //DEPRECATED
            get: getFromCookies,
            remove: removeFromCookies,
            clearAll: clearAllFromCookies
          }
        };
      }];
  });


/*** EXPORTS FROM exports-loader ***/
module.exports = angularLocalStorage;

/*** EXPORTS FROM exports-loader ***/
module.exports = window.angular;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(25)))

/***/ }),
/* 662 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var change_detection_util_1 = __webpack_require__(54);
exports.SimpleChange = change_detection_util_1.SimpleChange;
var constants_1 = __webpack_require__(664);
exports.ChangeDetectionStrategy = constants_1.ChangeDetectionStrategy;
var change_detector_ref_1 = __webpack_require__(55);
exports.ChangeDetectorRef = change_detector_ref_1.ChangeDetectorRef;
//# sourceMappingURL=change_detection.js.map

/***/ }),
/* 663 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// @TODO this needs to be in a singleton
var lang_1 = __webpack_require__(2);
var TTL = 10;
var onChangesTtl = TTL;
var ChangesQueue = (function () {
    function ChangesQueue() {
    }
    ChangesQueue.prototype.buildFlushOnChanges = function ($rootScope) {
        var _context = this;
        buildFlushOnChangesCb($rootScope);
        function buildFlushOnChangesCb($rootScope) {
            if (lang_1.isFunction(_context.flushOnChangesQueue)) {
                return _context.flushOnChangesQueue;
            }
            _context.flushOnChangesQueue = getFlushOnChangesQueueCb($rootScope);
            return _context.flushOnChangesQueue;
        }
        function getFlushOnChangesQueueCb($rootScope) {
            // This function is called in a $$postDigest to trigger all the onChanges hooks in a single digest
            return function _flushOnChangesQueue() {
                try {
                    if (!(--onChangesTtl)) {
                        // We have hit the TTL limit so reset everything
                        _context.onChangesQueue = undefined;
                        throw new Error("infchng, " + TTL + " ngOnChanges() iterations reached. Aborting!\n");
                    }
                    // We must run this hook in an apply since the $$postDigest runs outside apply
                    $rootScope.$apply(function () {
                        for (var i = 0, ii = _context.onChangesQueue.length; i < ii; ++i) {
                            _context.onChangesQueue[i]();
                        }
                        // Reset the queue to trigger a new schedule next time there is a change
                        _context.onChangesQueue = undefined;
                    });
                }
                finally {
                    onChangesTtl++;
                }
            };
        }
    };
    return ChangesQueue;
}());
exports.ChangesQueue = ChangesQueue;
exports.changesQueueService = new ChangesQueue();
//# sourceMappingURL=changes_queue.js.map

/***/ }),
/* 664 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var lang_1 = __webpack_require__(2);
/**
 * Describes the current state of the change detector.
 */
var ChangeDetectorState;
(function (ChangeDetectorState) {
    /**
     * `NeverChecked` means that the change detector has not been checked yet, and
     * initialization methods should be called during detection.
     */
    ChangeDetectorState[ChangeDetectorState["NeverChecked"] = 0] = "NeverChecked";
    /**
     * `CheckedBefore` means that the change detector has successfully completed at least
     * one detection previously.
     */
    ChangeDetectorState[ChangeDetectorState["CheckedBefore"] = 1] = "CheckedBefore";
    /**
     * `Errored` means that the change detector encountered an error checking a binding
     * or calling a directive lifecycle method and is now in an inconsistent state. Change
     * detectors in this state will no longer detect changes.
     */
    ChangeDetectorState[ChangeDetectorState["Errored"] = 2] = "Errored";
})(ChangeDetectorState = exports.ChangeDetectorState || (exports.ChangeDetectorState = {}));
/**
 * Describes within the change detector which strategy will be used the next time change
 * detection is triggered.
 */
var ChangeDetectionStrategy;
(function (ChangeDetectionStrategy) {
    /**
     * `CheckedOnce` means that after calling detectChanges the mode of the change detector
     * will become `Checked`.
     */
    // CheckOnce,
    /**
     * `Checked` means that the change detector should be skipped until its mode changes to
     * `CheckOnce`.
     */
    // Checked,
    /**
     * `CheckAlways` means that after calling detectChanges the mode of the change detector
     * will remain `CheckAlways`.
     */
    // CheckAlways,
    /**
     * `Detached` means that the change detector sub tree is not a part of the main tree and
     * should be skipped.
     */
    // Detached,
    /**
     * `OnPush` means that the change detector's mode will be set to `CheckOnce` during hydration.
     */
    ChangeDetectionStrategy[ChangeDetectionStrategy["OnPush"] = 0] = "OnPush";
    /**
     * `Default` means that the change detector's mode will be set to `CheckAlways` during hydration.
     */
    ChangeDetectionStrategy[ChangeDetectionStrategy["Default"] = 1] = "Default";
})(ChangeDetectionStrategy = exports.ChangeDetectionStrategy || (exports.ChangeDetectionStrategy = {}));
/**
 * List of possible {@link ChangeDetectionStrategy} values.
 */
exports.CHANGE_DETECTION_STRATEGY_VALUES = [
    // ChangeDetectionStrategy.CheckOnce,
    // ChangeDetectionStrategy.Checked,
    // ChangeDetectionStrategy.CheckAlways,
    // ChangeDetectionStrategy.Detached,
    0 /* OnPush */,
    1 /* Default */
];
/**
 * List of possible {@link ChangeDetectorState} values.
 */
exports.CHANGE_DETECTOR_STATE_VALUES = [
    0 /* NeverChecked */,
    1 /* CheckedBefore */,
    2 /* Errored */
];
function isDefaultChangeDetectionStrategy(changeDetectionStrategy) {
    return lang_1.isBlank(changeDetectionStrategy) || changeDetectionStrategy === 1 /* Default */;
}
exports.isDefaultChangeDetectionStrategy = isDefaultChangeDetectionStrategy;
//# sourceMappingURL=constants.js.map

/***/ }),
/* 665 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(__webpack_require__(56));
__export(__webpack_require__(7));
var opaque_token_1 = __webpack_require__(57);
exports.OpaqueToken = opaque_token_1.OpaqueToken;
var forward_ref_1 = __webpack_require__(13);
exports.forwardRef = forward_ref_1.forwardRef;
var provider_1 = __webpack_require__(11);
exports.provide = provider_1.provide;
exports.getInjectableName = provider_1.getInjectableName;
//# sourceMappingURL=di.js.map

/***/ }),
/* 666 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var lang_1 = __webpack_require__(2);
var collections_1 = __webpack_require__(6);
var lang_2 = __webpack_require__(2);
var lang_3 = __webpack_require__(2);
/**
 * @TODO
 * this module is not used, we can leverage the Key creation for
 * caching @Inject token to string names for performance
 */
/**
 * A unique object used for retrieving items from the {@link Injector}.
 *
 * Keys have:
 * - a system-wide unique `id`.
 * - a `token`.
 *
 * `Key` is used internally by {@link Injector} because its system-wide unique `id` allows the
 * injector to store created objects in a more efficient way.
 *
 * `Key` should not be created directly. {@link Injector} creates keys automatically when resolving
 * providers.
 */
//export class Key {
//  /**
//   * Private
//   */
//  constructor( public token: Object, public id: number ) {
//    if ( isBlank( token ) ) {
//      throw new Error( 'Token must be defined!' );
//    }
//  }
//
//  /**
//   * Returns a stringified token.
//   */
//  get displayName(): string { return stringify( this.token ); }
//
//  /**
//   * Retrieves a `Key` for a token.
//   */
//  static get( token: Object ): Key { return _globalKeyRegistry.get( resolveForwardRef( token ) ); }
//
//  /**
//   * @returns the number of keys registered in the system.
//   */
//  static get numberOfKeys(): number { return _globalKeyRegistry.numberOfKeys; }
//}
/**
 * @internal
 */
var KeyRegistry = (function () {
    function KeyRegistry() {
        this._allKeys = collections_1.ListWrapper.create();
        this._idCounter = 0;
    }
    //get( token: string | OpaqueToken | Type ): string {
    //  // Return it if it is already a string like `'$http'` or `'$state'`
    //  if(isString(token)) {
    //    return token;
    //  }
    //  if(token instanceof OpaqueToken){
    //    return token.desc;
    //  }
    //
    //  const tokenString = stringify( token );
    //  const hasToken = StringMapWrapper.contains( this._allKeys, tokenString );
    //
    //  if ( hasToken ) {
    //    return tokenString;
    //  }
    //
    //  const newKey = `${ tokenString }${ this._uniqueId() }`;
    //  StringMapWrapper.set( this._allKeys, newKey, token );
    //  return newKey;
    //}
    /**
     *
     * @param token
     * @returns {*}
     */
    KeyRegistry.prototype.get = function (token) {
        if (!lang_2.isType(token)) {
            throw new Error("KeyRegistry#get:\n                        ================\n                        you'v tried to create a key for `" + token + "`\n                        creating and getting key tokens is avaialable only for Type");
        }
        var newKey = "" + lang_3.getTypeName(token) + KeyRegistry._suffix + this._uniqueId();
        this._allKeys.push(newKey);
        return newKey;
    };
    Object.defineProperty(KeyRegistry.prototype, "numberOfKeys", {
        get: function () { return collections_1.ListWrapper.size(this._allKeys); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KeyRegistry.prototype, "allKeys", {
        get: function () { return collections_1.ListWrapper.clone(this._allKeys); },
        enumerable: true,
        configurable: true
    });
    /**
     * just for testing purposes
     * @private
     * @internal
     */
    KeyRegistry.prototype._reset = function () {
        collections_1.ListWrapper.clear(this._allKeys);
        this._idCounter = 0;
    };
    /**
     * Generates a unique ID. If `prefix` is provided the ID is appended to it.
     *
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _uniqueId('contact_');
     * // => 'contact_104'
     *
     * _uniqueId();
     * // => '105'
     */
    KeyRegistry.prototype._uniqueId = function (prefix) {
        var id = ++this._idCounter;
        return "" + lang_1.baseToString(prefix) + id;
    };
    return KeyRegistry;
}());
KeyRegistry._suffix = "#";
exports.KeyRegistry = KeyRegistry;
exports.globalKeyRegistry = new KeyRegistry();
//# sourceMappingURL=key.js.map

/***/ }),
/* 667 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var lang_1 = __webpack_require__(2);
var reflection_1 = __webpack_require__(9);
var provider_1 = __webpack_require__(11);
var provider_util_1 = __webpack_require__(14);
/**
 * process provider literals and return map for angular1Module consumption
 * @param provider
 * @returns {{method: string, name: string, value: any}}
 */
function resolveReflectiveProvider(provider) {
    var token = provider.token;
    if (lang_1.isPresent(provider.useValue)) {
        var _a = provider_1.provide(token, { useValue: provider.useValue }), name_1 = _a[0], value = _a[1];
        var method = 'value';
        return { method: method, name: name_1, value: value };
    }
    if (provider.useFactory) {
        var _b = provider_1.provide(token, { useFactory: provider.useFactory, deps: provider.dependencies }), name_2 = _b[0], value = _b[1];
        var method = 'factory';
        return { method: method, name: name_2, value: value };
    }
    if (provider.useClass) {
        var _c = provider_1.provide(token, { useClass: provider.useClass }), name_3 = _c[0], value = _c[1];
        var method = 'service';
        return { method: method, name: name_3, value: value };
    }
    if (provider.useExisting) {
        var _d = provider_1.provide(provider.useExisting), name_4 = _d[0], value = _d[1];
        var method = 'factory';
        throw new Error('useExisting is unimplemented');
    }
    throw new Error('invalid provider type! please specify one of: [useValue,useFactory,useClass]');
}
exports.resolveReflectiveProvider = resolveReflectiveProvider;
/**
 * returns StringMap of values needed for angular1Module registration and duplicity checks
 * @param injectable
 * @returns {any}
 * @private
 */
function _getAngular1ModuleMetadataByType(injectable) {
    // only the first class annotations is injectable
    var annotation = reflection_1.reflector.annotations(injectable)[0];
    if (lang_1.isBlank(annotation)) {
        // support configPhase ( function or pure class )
        if (lang_1.isType(injectable)) {
            return {
                providerName: '$injector',
                providerMethod: 'invoke',
                moduleMethod: 'config'
            };
        }
        throw new Error("\n        cannot get injectable name token from none decorated class " + lang_1.getFuncName(injectable) + "\n        Only decorated classes by one of [ @Injectable,@Directive,@Component,@Pipe ], can be injected by reference\n      ");
    }
    if (provider_util_1.isPipe(annotation)) {
        return {
            providerName: '$filterProvider',
            providerMethod: 'register',
            moduleMethod: 'filter'
        };
    }
    if (provider_util_1.isDirectiveLike(annotation)) {
        return {
            providerName: '$compileProvider',
            providerMethod: 'directive',
            moduleMethod: 'directive'
        };
    }
    if (provider_util_1.isService(annotation)) {
        return {
            providerName: '$provide',
            providerMethod: 'service',
            moduleMethod: 'service'
        };
    }
}
exports._getAngular1ModuleMetadataByType = _getAngular1ModuleMetadataByType;
/**
 * run through Component tree and register everything that is registered via Metadata
 * - works for nested arrays like angular 2 does ;)
 * @param angular1Module
 * @param providers
 * @returns {ng.IModule}
 * @private
 */
function _normalizeProviders(angular1Module, providers) {
    providers.forEach(function (providerType) {
        // this is for legacy Angular 1 module
        if (lang_1.isString(providerType)) {
            angular1Module.requires.push(providerType);
            return;
        }
        // this works only for value,factory,aliased services
        // you cannot register directive/pipe within provider literal
        if (provider_util_1.isProviderLiteral(providerType)) {
            var provider = provider_util_1.createProvider(providerType);
            var _a = resolveReflectiveProvider(provider), method = _a.method, name_5 = _a.name, value = _a.value;
            if (!_isTypeRegistered(name_5, angular1Module, '$provide', method)) {
                angular1Module[method](name_5, value);
            }
            return;
        }
        // this is for pipes/directives/services
        if (lang_1.isType(providerType)) {
            // const provider = createProvider( {provide:b, useClass:b} );
            // const { method, name, value } = resolveReflectiveProvider( provider );
            var _b = provider_1.provide(providerType), name_6 = _b[0], value = _b[1];
            var _c = _getAngular1ModuleMetadataByType(providerType), providerName = _c.providerName, providerMethod = _c.providerMethod, moduleMethod = _c.moduleMethod;
            // config phase support
            if (lang_1.isType(name_6)) {
                angular1Module.config(name_6);
                return;
            }
            if (!_isTypeRegistered(name_6, angular1Module, providerName, providerMethod)) {
                // @TODO register via this once requires are resolved for 3 types of attr directive from template
                // _registerTypeProvider( angular1Module, providerType, { moduleMethod, name, value } );
                angular1Module[moduleMethod](name_6, value);
            }
            return;
        }
        // un flattened array, unwrap and parse next array level of providers
        if (lang_1.isArray(providerType)) {
            _normalizeProviders(angular1Module, providerType);
        }
        else {
            throw new Error("InvalidProviderError(" + providerType + ")");
        }
    });
    // return res;
    return angular1Module;
}
exports._normalizeProviders = _normalizeProviders;
/**
 * check if `findRegisteredType` is registered within angular1Module, so we don't have duplicates
 * @param findRegisteredType
 * @param angular1Module
 * @param instanceType
 * @param methodName
 * @returns {boolean}
 * @private
 */
function _isTypeRegistered(findRegisteredType, angular1Module, instanceType, methodName) {
    var invokeQueue = angular1Module._invokeQueue;
    var types = invokeQueue
        .filter(function (_a) {
        var type = _a[0], fnName = _a[1];
        return type === instanceType && fnName === methodName;
    })
        .map(function (_a) {
        var type = _a[0], fnName = _a[1], registeredProvider = _a[2];
        return registeredProvider;
    });
    return types.some(function (_a) {
        var typeName = _a[0], typeFn = _a[1];
        return findRegisteredType === typeName;
    });
}
exports._isTypeRegistered = _isTypeRegistered;
/**
 * we need to register 3 types of attribute directives, if we are registering directive,
 * because we need to allow all 3 types of binding on the defined directive [name],(name),name
 * @private
 */
function _registerTypeProvider(angular1Module, provider, _a) {
    var moduleMethod = _a.moduleMethod, name = _a.name, value = _a.value;
    // only the first class annotations is injectable
    var annotation = reflection_1.reflector.annotations(provider)[0];
    if (lang_1.isBlank(annotation)) {
        return;
    }
    // we need to register attr directives for all possible binding types
    if (provider_util_1.isDirective(annotation)) {
        angular1Module[moduleMethod](name, value);
        angular1Module[moduleMethod]("[" + name + "]", value);
        angular1Module[moduleMethod]("(" + name + ")", value);
    }
    else {
        angular1Module[moduleMethod](name, value);
    }
}
exports._registerTypeProvider = _registerTypeProvider;
//# sourceMappingURL=reflective_provider.js.map

/***/ }),
/* 668 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(__webpack_require__(673));
__export(__webpack_require__(18));
__export(__webpack_require__(8));
//# sourceMappingURL=directives.js.map

/***/ }),
/* 669 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var directives_utils_1 = __webpack_require__(27);
var change_detection_util_1 = __webpack_require__(54);
var changes_queue_1 = __webpack_require__(663);
var collections_1 = __webpack_require__(6);
var lang_1 = __webpack_require__(2);
var async_1 = __webpack_require__(59);
var constants_1 = __webpack_require__(58);
var binding_parser_1 = __webpack_require__(670);
/**
 * Create Bindings manually for both Directive/Component
 * @returns {{watchers: Array, observers: Array}}
 * @internal
 * @private
 */
function _createDirectiveBindings(hasIsolateScope, ngScope, ngAttrs, ctrl, metadata, _a) {
    /*  let BOOLEAN_ATTR = {};
     'multiple,selected,checked,disabled,readOnly,required,open'
     .split(',')
     .forEach(function(value) {
     BOOLEAN_ATTR[value.toLocaleLowerCase()] = value;
     });*/
    var $interpolate = _a.$interpolate, $parse = _a.$parse, $rootScope = _a.$rootScope;
    var isBindingImmutable = directives_utils_1.isComponentDirective(metadata) && change_detection_util_1.ChangeDetectionUtil.isOnPushChangeDetectionStrategy(metadata.changeDetection);
    var scope = hasIsolateScope
        ? ngScope.$parent
        : ngScope;
    var _b = metadata.inputs, inputs = _b === void 0 ? [] : _b, _c = metadata.outputs, outputs = _c === void 0 ? [] : _c;
    var parsedBindings = binding_parser_1.setupFields(ngAttrs, inputs, outputs);
    var _internalWatchers = [];
    var _internalObservers = [];
    // onChanges tmp vars
    var initialChanges = {};
    var changes;
    // this will create flush queue internally only once
    // we need to call this here because we need $rootScope service
    changes_queue_1.changesQueueService.buildFlushOnChanges($rootScope);
    // setup @Inputs '<' or '='
    collections_1.StringMapWrapper.forEach(parsedBindings.inputs, function (config, propName) {
        var exp = config.exp, attrName = config.attrName, mode = config.mode;
        // support for TWO_WAY only for components
        var hasTwoWayBinding = hasIsolateScope && mode === constants_1.BINDING_MODE.twoWay;
        var removeWatch = hasTwoWayBinding
            ? _createTwoWayBinding(propName, attrName, exp)
            : _createOneWayBinding(propName, attrName, exp, isBindingImmutable);
        _internalWatchers.push(removeWatch);
    });
    // setup @Input('@')
    collections_1.StringMapWrapper.forEach(parsedBindings.attrs, function (config, propName) {
        var attrName = config.attrName, exp = config.exp, mode = config.mode;
        var removeObserver = _createAttrBinding(propName, attrName, exp);
        _internalObservers.push(removeObserver);
    });
    // setup @Outputs
    collections_1.StringMapWrapper.forEach(parsedBindings.outputs, function (config, propName) {
        var exp = config.exp, attrName = config.attrName, mode = config.mode;
        _createOutputBinding(propName, attrName, exp);
    });
    function _createOneWayBinding(propName, attrName, exp, isImmutable) {
        if (isImmutable === void 0) { isImmutable = false; }
        if (!exp)
            return;
        var parentGet = $parse(exp);
        var initialValue = ctrl[propName] = parentGet(scope);
        initialChanges[propName] = change_detection_util_1.ChangeDetectionUtil.simpleChange(change_detection_util_1.ChangeDetectionUtil.uninitialized, ctrl[propName]);
        return scope.$watch(parentGet, function parentValueWatchAction(newValue, oldValue) {
            // https://github.com/angular/angular.js/commit/d9448dcb9f901ceb04deda1d5f3d5aac8442a718
            // https://github.com/angular/angular.js/commit/304796471292f9805b9cf77e51aacc9cfbb09921
            if (oldValue === newValue) {
                if (oldValue === initialValue)
                    return;
                oldValue = initialValue;
            }
            recordChanges(propName, newValue, oldValue);
            ctrl[propName] = isImmutable ? lang_1.global.angular.copy(newValue) : newValue;
        }, parentGet.literal);
    }
    function _createTwoWayBinding(propName, attrName, exp) {
        if (!exp)
            return;
        var lastValue;
        var parentGet = $parse(exp);
        var parentSet = parentGet.assign || function () {
            // reset the change, or we will throw this exception on every $digest
            lastValue = ctrl[propName] = parentGet(scope);
            throw new Error("nonassign,\n          Expression '" + ngAttrs[attrName] + "' in attribute '" + attrName + "' used with directive '{2}' is non-assignable!");
        };
        var compare = parentGet.literal ? lang_1.global.angular.equals : simpleCompare;
        var parentValueWatch = function parentValueWatch(parentValue) {
            if (!compare(parentValue, ctrl[propName])) {
                // we are out of sync and need to copy
                if (!compare(parentValue, lastValue)) {
                    // parent changed and it has precedence
                    ctrl[propName] = parentValue;
                }
                else {
                    // if the parent can be assigned then do so
                    parentSet(scope, parentValue = ctrl[propName]);
                }
            }
            return lastValue = parentValue;
        };
        parentValueWatch.$stateful = true;
        lastValue = ctrl[propName] = parentGet(scope);
        // NOTE: we don't support collection watch, it's not good for performance
        // if (definition.collection) {
        //   removeWatch = scope.$watchCollection(attributes[attrName], parentValueWatch);
        // } else {
        //   removeWatch = scope.$watch($parse(attributes[attrName], parentValueWatch), null, parentGet.literal);
        // }
        // removeWatchCollection.push(removeWatch);
        return scope.$watch(
        // $parse( ngAttrs[ attrName ], parentValueWatch ),
        $parse(exp, parentValueWatch), null, parentGet.literal);
        function simpleCompare(a, b) { return a === b || (a !== a && b !== b); }
    }
    function _createOutputBinding(propName, attrName, exp) {
        // Don't assign Object.prototype method to scope
        var parentGet = exp
            ? $parse(exp)
            : lang_1.noop;
        // Don't assign noop to ctrl if expression is not valid
        if (parentGet === lang_1.noop)
            return;
        // here we assign property to EventEmitter instance directly
        var emitter = new async_1.EventEmitter();
        emitter.wrapNgExpBindingToEmitter(function _exprBindingCb(locals) {
            return parentGet(scope, locals);
        });
        ctrl[propName] = emitter;
    }
    function _createAttrBinding(propName, attrName, exp) {
        var lastValue = exp;
        // register watchers for further changes
        // The observer function will be invoked once during the next $digest following compilation.
        // The observer is then invoked whenever the interpolated value changes.
        var _disposeObserver = ngAttrs.$observe(attrName, function (value) {
            // https://github.com/angular/angular.js/commit/499e1b2adf27f32d671123f8dceadb3df2ad84a9
            if (lang_1.isString(value) || lang_1.isBoolean(value)) {
                var oldValue = ctrl[propName];
                recordChanges(propName, value, oldValue);
                ctrl[propName] = value;
            }
        });
        ngAttrs.$$observers[attrName].$$scope = scope;
        if (lang_1.isString(lastValue)) {
            // If the attribute has been provided then we trigger an interpolation to ensure
            // the value is there for use in the link fn
            ctrl[propName] = $interpolate(lastValue)(scope);
        }
        else if (lang_1.isBoolean(lastValue)) {
            // If the attributes is one of the BOOLEAN_ATTR then Angular will have converted
            // the value to boolean rather than a string, so we special case this situation
            ctrl[propName] = lastValue;
        }
        initialChanges[propName] = change_detection_util_1.ChangeDetectionUtil.simpleChange(change_detection_util_1.ChangeDetectionUtil.uninitialized, ctrl[propName]);
        return _disposeObserver;
    }
    function recordChanges(key, currentValue, previousValue) {
        if (lang_1.isFunction(ctrl.ngOnChanges) && currentValue !== previousValue) {
            // If we have not already scheduled the top level onChangesQueue handler then do so now
            if (!changes_queue_1.changesQueueService.onChangesQueue) {
                scope.$$postDigest(changes_queue_1.changesQueueService.flushOnChangesQueue);
                changes_queue_1.changesQueueService.onChangesQueue = [];
            }
            // If we have not already queued a trigger of onChanges for this controller then do so now
            if (!changes) {
                changes = {};
                changes_queue_1.changesQueueService.onChangesQueue.push(triggerOnChangesHook);
            }
            // If the has been a change on this property already then we need to reuse the previous value
            if (changes[key]) {
                previousValue = changes[key].previousValue;
            }
            // Store this change
            changes[key] = change_detection_util_1.ChangeDetectionUtil.simpleChange(previousValue, currentValue);
        }
    }
    function triggerOnChangesHook() {
        ctrl.ngOnChanges(changes);
        // Now clear the changes so that we schedule onChanges when more changes arrive
        changes = undefined;
    }
    function removeWatches() {
        var removeWatchCollection = _internalWatchers.concat(_internalObservers);
        for (var i = 0, ii = removeWatchCollection.length; i < ii; ++i) {
            if (removeWatchCollection[i] && lang_1.isFunction(removeWatchCollection[i])) {
                removeWatchCollection[i]();
            }
        }
    }
    return {
        initialChanges: initialChanges,
        removeWatches: removeWatches,
        _watchers: { watchers: _internalWatchers, observers: _internalObservers }
    };
}
exports._createDirectiveBindings = _createDirectiveBindings;
//# sourceMappingURL=binding_factory.js.map

/***/ }),
/* 670 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var collections_1 = __webpack_require__(6);
var constants_1 = __webpack_require__(58);
function setupFields(ngAttrs, rawInputs, rawOutputs) {
    if (rawInputs === void 0) { rawInputs = []; }
    if (rawOutputs === void 0) { rawOutputs = []; }
    var _a = _setupInputs(_parseFields(rawInputs), ngAttrs), inputs = _a.inputs, attrs = _a.attrs;
    var outputs = _setupOutputs(_parseFields(rawOutputs), ngAttrs).outputs;
    return {
        inputs: inputs,
        attrs: attrs,
        outputs: outputs
    };
}
exports.setupFields = setupFields;
function _parseFields(names) {
    var attrProps = [];
    if (!names) {
        return attrProps;
    }
    for (var _i = 0, names_1 = names; _i < names_1.length; _i++) {
        var name_1 = names_1[_i];
        var parts = name_1.split(':');
        var prop = parts[0].trim();
        var attr = (parts[1] || parts[0]).trim();
        var isTypeByDeclaration = _isTypeByDeclaration(attr);
        var attrName = _getNormalizedAttrName(attr, prop, isTypeByDeclaration);
        var type = _getBindingType(attr, isTypeByDeclaration);
        attrProps.push({
            prop: prop,
            attr: attrName,
            bracketAttr: "[" + attrName + "]",
            parenAttr: "(" + attrName + ")",
            bracketParenAttr: "[(" + attrName + ")]",
            type: type,
            typeByTemplate: !isTypeByDeclaration
        });
    }
    return attrProps;
}
exports._parseFields = _parseFields;
function _getBindingType(originalAttr, isTypeByDeclaration) {
    return isTypeByDeclaration
        ? originalAttr.charAt(0)
        : '';
}
function _isTypeByDeclaration(attr) {
    return collections_1.ListWrapper.contains([
        constants_1.BINDING_MODE.attr, constants_1.BINDING_MODE.oneWay, constants_1.BINDING_MODE.twoWay
    ], attr.charAt(0));
}
function _getNormalizedAttrName(originalAttr, propName, isTypeByDeclaration) {
    if (!isTypeByDeclaration) {
        return originalAttr;
    }
    return originalAttr.length > 1
        ? originalAttr.substring(1)
        : propName;
}
function _setupInputs(inputs, ngAttrs) {
    var parsedAttrs = {};
    var parsedInputs = {};
    for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {
        var input = inputs_1[_i];
        if (input.typeByTemplate) {
            if (ngAttrs.hasOwnProperty(input.attr)) {
                // @
                parsedAttrs[input.prop] = {
                    mode: constants_1.BINDING_MODE.attr,
                    exp: ngAttrs[input.attr],
                    attrName: input.attr
                };
            }
            else if (ngAttrs.hasOwnProperty(input.bracketAttr)) {
                // <
                parsedInputs[input.prop] = {
                    mode: constants_1.BINDING_MODE.oneWay,
                    exp: ngAttrs[input.bracketAttr],
                    attrName: input.bracketAttr
                };
            }
            else if (ngAttrs.hasOwnProperty(input.bracketParenAttr)) {
                // =
                parsedInputs[input.prop] = {
                    mode: constants_1.BINDING_MODE.twoWay,
                    exp: ngAttrs[input.bracketParenAttr],
                    attrName: input.bracketParenAttr
                };
            }
        }
        else {
            if (ngAttrs.hasOwnProperty(input.attr)) {
                var attrMetadata = { mode: input.type, exp: ngAttrs[input.attr], attrName: input.attr };
                if (input.type === constants_1.BINDING_MODE.attr) {
                    parsedAttrs[input.prop] = attrMetadata;
                }
                else {
                    parsedInputs[input.prop] = attrMetadata;
                }
            }
        }
    }
    return {
        inputs: parsedInputs,
        attrs: parsedAttrs
    };
}
exports._setupInputs = _setupInputs;
function _setupOutputs(outputs, ngAttrs) {
    var parsedOutputs = {};
    for (var i = 0; i < outputs.length; i = i + 1) {
        var output = outputs[i];
        var baseParsedAttrField = { mode: constants_1.BINDING_MODE.output, exp: undefined, attrName: '' };
        // & via event
        if (ngAttrs.hasOwnProperty(output.attr)) {
            parsedOutputs[output.prop] = collections_1.StringMapWrapper.assign({}, baseParsedAttrField, { exp: ngAttrs[output.attr], attrName: output.attr });
        }
        else if (ngAttrs.hasOwnProperty(output.parenAttr)) {
            parsedOutputs[output.prop] = collections_1.StringMapWrapper.assign({}, baseParsedAttrField, { exp: ngAttrs[output.parenAttr], attrName: output.parenAttr });
        }
    }
    return { outputs: parsedOutputs };
}
exports._setupOutputs = _setupOutputs;
/**
 * parses input/output/attrs string arrays from metadata fro further processing
 * @param inputs
 * @param outputs
 * @param attrs
 * @returns {{inputs: ParsedBindingsMap, outputs: ParsedBindingsMap, attrs: ParsedBindingsMap}}
 * @private
 * @deprecated
 */
function _parseBindings(_a) {
    var _b = _a.inputs, inputs = _b === void 0 ? [] : _b, _c = _a.outputs, outputs = _c === void 0 ? [] : _c, _d = _a.attrs, attrs = _d === void 0 ? [] : _d;
    var SPLIT_BY = ':';
    return {
        inputs: _parseByMode(inputs, constants_1.BINDING_MODE.twoWay, [constants_1.BINDING_MODE.attr]),
        outputs: _parseByMode(outputs, constants_1.BINDING_MODE.output),
        attrs: collections_1.StringMapWrapper.merge(
        // this will be removed in 2.0
        _parseByMode(attrs, constants_1.BINDING_MODE.attr), 
        // attrs build from @Input('@')
        _parseByMode(inputs, constants_1.BINDING_MODE.twoWay, [constants_1.BINDING_MODE.oneWay, constants_1.BINDING_MODE.twoWay]))
    };
    function _parseByMode(bindingArr, defaultMode, excludeMode) {
        if (excludeMode === void 0) { excludeMode = []; }
        return bindingArr.reduce(function (acc, binding) {
            var _a = binding.split(SPLIT_BY).map(function (part) { return part.trim(); }), name = _a[0], _b = _a[1], modeConfigAndAlias = _b === void 0 ? '' : _b;
            var parsedConfigAndAlias = modeConfigAndAlias.match(constants_1.INPUT_MODE_REGEX);
            var _c = parsedConfigAndAlias || [], _d = _c[1], mode = _d === void 0 ? defaultMode : _d, _e = _c[2], optional = _e === void 0 ? '' : _e, _f = _c[3], alias = _f === void 0 ? '' : _f;
            // exit early if processed mode is not allowed
            // for example if we are parsing Input('@') which produces attr binding instead of one or two way
            if (excludeMode.indexOf(mode) !== -1) {
                return acc;
            }
            // @TODO remove this in next version where template parsing will be implemented
            if ((defaultMode !== constants_1.BINDING_MODE.output) && !(parsedConfigAndAlias && parsedConfigAndAlias[1])) {
                console.warn("\n        You need to explicitly provide type of binding(=,<,@) within your <code>'@Input() " + name + ";</code>.\n        Next version 2.0 will create binding by parsing template if you provide '@Input()' without binding type.\n        ");
            }
            acc[name] = {
                mode: mode,
                alias: alias,
                optional: optional === constants_1.BINDING_MODE.optional || true
            };
            return acc;
        }, {});
    }
}
exports._parseBindings = _parseBindings;
//# sourceMappingURL=binding_parser.js.map

/***/ }),
/* 671 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
//# sourceMappingURL=constants.js.map

/***/ }),
/* 672 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var collections_1 = __webpack_require__(6);
var change_detector_ref_1 = __webpack_require__(55);
var binding_factory_1 = __webpack_require__(669);
var directives_utils_1 = __webpack_require__(27);
var lang_1 = __webpack_require__(2);
var primitives_1 = __webpack_require__(61);
var constants_1 = __webpack_require__(671);
function directiveControllerFactory(caller, controller, $injector, locals, requireMap, _ddo, metadata) {
    var $scope = locals.$scope, $element = locals.$element, $attrs = locals.$attrs;
    var _services = {
        $parse: $injector.get('$parse'),
        $interpolate: $injector.get('$interpolate'),
        $rootScope: $injector.get('$rootScope')
    };
    var _localServices = {
        changeDetectorRef: change_detector_ref_1.ChangeDetectorRef.create($scope)
    };
    // Create an instance of the controller without calling its constructor
    var instance = Object.create(controller.prototype);
    // NOTE: this is not needed because we are creating bindings manually because of
    // angular behaviour https://github.com/ngParty/ng-metadata/issues/53
    // ===================================================================
    // Remember, angular has already set those bindings on the `caller`
    // argument. Now we need to extend them onto our `instance`. It is important
    // to extend after defining the properties. That way we fire the setters.
    //
    // StringMapWrapper.assign( instance, caller );
    // setup @Input/@Output/@Attrs for @Component/@Directive
    var _a = binding_factory_1._createDirectiveBindings(!directives_utils_1.isAttrDirective(metadata), $scope, $attrs, instance, metadata, _services), removeWatches = _a.removeWatches, initialChanges = _a.initialChanges;
    cleanUpWatchers(removeWatches);
    // change injectables to proper inject directives
    // we wanna do this only if we inject some locals/directives
    if (collections_1.StringMapWrapper.size(requireMap)) {
        controller.$inject = createNewInjectablesToMatchLocalDi(controller.$inject, requireMap);
    }
    var $requires = getEmptyRequiredControllers(requireMap);
    // $injector.invoke will delete any @Input/@Attr/@Output which were resolved within _createDirectiveBindings
    // and which have set default values in constructor. We need to store them and reassign after this invoke
    var initialInstanceBindingValues = getInitialBindings(instance);
    // Finally, invoke the constructor using the injection array and the captured locals
    $injector.invoke(controller, instance, collections_1.StringMapWrapper.assign(locals, _localServices, $requires));
    // reassign back the initial binding values, just in case if we used default values
    collections_1.StringMapWrapper.assign(instance, initialInstanceBindingValues);
    /*if ( isFunction( instance.ngOnDestroy ) ) {
     $scope.$on( '$destroy', instance.ngOnDestroy.bind( instance ) );
     }*/
    /*if (typeof instance.ngAfterViewInit === 'function') {
     ddo.ngAfterViewInitBound = instance.ngAfterViewInit.bind(instance);
     }*/
    // https://github.com/angular/angular.js/commit/0ad2b70862d49ecc4355a16d767c0ca9358ecc3e
    // onChanges is called before onInit
    if (lang_1.isFunction(instance.ngOnChanges)) {
        instance.ngOnChanges(initialChanges);
    }
    _ddo._ngOnInitBound = function _ngOnInitBound() {
        // invoke again only if there are any directive requires
        // #perf
        if (collections_1.StringMapWrapper.size(requireMap)) {
            var $requires_1 = getRequiredControllers(requireMap, $element, controller);
            // $injector.invoke will delete any @Input/@Attr/@Output which were resolved within _createDirectiveBindings
            // and which have set default values in constructor. We need to store them and reassign after this invoke
            var initialInstanceBindingValues_1 = getInitialBindings(instance);
            $injector.invoke(controller, instance, collections_1.StringMapWrapper.assign(locals, _localServices, $requires_1));
            // reassign back the initial binding values, just in case if we used default values
            collections_1.StringMapWrapper.assign(instance, initialInstanceBindingValues_1);
        }
        if (lang_1.isFunction(instance.ngOnInit)) {
            instance.ngOnInit();
        }
        // DoCheck is called after OnChanges and OnInit
        if (lang_1.isFunction(instance.ngDoCheck)) {
            var removeDoCheckWatcher = $postDigestWatch($scope, function () { return instance.ngDoCheck(); });
            cleanUpWatchers(removeDoCheckWatcher);
        }
    };
    // Return the controller instance
    return instance;
    function cleanUpWatchers(cb) {
        $scope.$on('$destroy', function () { return cb; });
    }
}
exports.directiveControllerFactory = directiveControllerFactory;
/**
 * Note: $$postDigest will not trigger another digest cycle.
 * So any modification to $scope inside $$postDigest will not get reflected in the DOM
 */
function $postDigestWatch(scope, cb) {
    var hasRegistered = false;
    var removeDoCheckWatcher = scope.$watch(function () {
        if (hasRegistered) {
            return;
        }
        hasRegistered = true;
        scope.$$postDigest(function () {
            hasRegistered = false;
            cb();
        });
    });
    return removeDoCheckWatcher;
}
function getInitialBindings(instance) {
    var initialBindingValues = {};
    collections_1.StringMapWrapper.forEach(instance, function (value, propName) {
        if (instance[propName]) {
            initialBindingValues[propName] = value;
        }
    });
    return initialBindingValues;
}
/**
 * Angular 1 copy of how to require other directives
 * @param require
 * @param $element
 * @param directive
 * @returns {any|null}
 */
function getRequiredControllers(require, $element, directive) {
    var value;
    if (lang_1.isString(require)) {
        var match = require.match(constants_1.REQUIRE_PREFIX_REGEXP);
        var name = require.substring(match[0].length);
        var inheritType = match[1] || match[3];
        var optional = match[2] === '?';
        //If only parents then start at the parent element
        if (inheritType === '^^') {
            $element = $element.parent();
        }
        if (!value) {
            var dataName = "$" + name + "Controller";
            value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
        }
        if (!value && !optional) {
            throw new Error("Directive/Controller '" + name + "', required by directive '" + lang_1.getFuncName(directive) + "', can't be found!");
        }
    }
    else if (lang_1.isArray(require)) {
        value = [];
        for (var i = 0, ii = require.length; i < ii; i++) {
            value[i] = getRequiredControllers(require[i], $element, directive);
        }
    }
    else if (lang_1.isJsObject(require)) {
        value = {};
        collections_1.StringMapWrapper.forEach(require, function (controller, property) {
            value[property] = getRequiredControllers(controller, $element, directive);
        });
    }
    return value || null;
}
exports.getRequiredControllers = getRequiredControllers;
function getEmptyRequiredControllers(requireMap) {
    return collections_1.StringMapWrapper.keys(requireMap).reduce(function (acc, keyName) {
        acc[keyName] = undefined;
        return acc;
    }, {});
}
exports.getEmptyRequiredControllers = getEmptyRequiredControllers;
function createNewInjectablesToMatchLocalDi(originalInjectables, requireMap) {
    var requireKeys = collections_1.StringMapWrapper.keys(requireMap);
    return originalInjectables.slice()
        .map(function (injectable) {
        var replaceInjName = requireKeys
            .filter(function (keyName) { return primitives_1.StringWrapper.startsWith(keyName, injectable); })[0];
        // if found remove that key so we won't assign the same
        if (replaceInjName) {
            var idx = requireKeys.indexOf(replaceInjName);
            requireKeys.splice(idx, 1);
        }
        return replaceInjName || injectable;
    });
}
exports.createNewInjectablesToMatchLocalDi = createNewInjectablesToMatchLocalDi;
/**
 * @deprecated
 * @TODO remove?
 */
function injectionArgs(fn, locals, serviceName, injects) {
    var args = [], 
    // $inject = createInjector.$$annotate(fn, strictDi, serviceName);
    $inject = injects;
    for (var i = 0, length = $inject.length; i < length; i++) {
        var key = $inject[i];
        if (typeof key !== 'string') {
            throw new Error("itkn, Incorrect injection token! Expected service name as string, got " + key);
        }
        /*    args.push( locals && locals.hasOwnProperty( key )
         ? locals[ key ]
         : getService( key, serviceName ) );*/
        args.push(locals[key]);
    }
    return args;
}
//# sourceMappingURL=controller_factory.js.map

/***/ }),
/* 673 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var decorators_1 = __webpack_require__(19);
var metadata_di_1 = __webpack_require__(18);
var metadata_directives_1 = __webpack_require__(8);
exports.Component = decorators_1.makeDecorator(metadata_directives_1.ComponentMetadata);
exports.Directive = decorators_1.makeDecorator(metadata_directives_1.DirectiveMetadata);
exports.ContentChildren = decorators_1.makePropDecorator(metadata_di_1.ContentChildrenMetadata);
exports.ContentChild = decorators_1.makePropDecorator(metadata_di_1.ContentChildMetadata);
exports.ViewChildren = decorators_1.makePropDecorator(metadata_di_1.ViewChildrenMetadata);
exports.ViewChild = decorators_1.makePropDecorator(metadata_di_1.ViewChildMetadata);
exports.Input = decorators_1.makePropDecorator(metadata_directives_1.InputMetadata);
/**
 *
 * @type {any}
 * @deprecated use @Input('@') instead. Will be removed in 2.0
 */
exports.Attr = decorators_1.makePropDecorator(metadata_directives_1.AttrMetadata);
exports.Output = decorators_1.makePropDecorator(metadata_directives_1.OutputMetadata);
exports.HostBinding = decorators_1.makePropDecorator(metadata_directives_1.HostBindingMetadata);
exports.HostListener = decorators_1.makePropDecorator(metadata_directives_1.HostListenerMetadata);
/**
 * Declares an ng module.
 * @experimental
 * @Annotation
 */
exports.NgModule = decorators_1.makeDecorator(metadata_directives_1.NgModuleMetadata);
//# sourceMappingURL=decorators.js.map

/***/ }),
/* 674 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var directive_resolver_1 = __webpack_require__(679);
var lang_1 = __webpack_require__(2);
var collections_1 = __webpack_require__(6);
var directive_lifecycles_reflector_1 = __webpack_require__(678);
var directive_lifecycle_interfaces_1 = __webpack_require__(28);
var metadata_directives_1 = __webpack_require__(8);
var controller_factory_1 = __webpack_require__(672);
var children_resolver_1 = __webpack_require__(677);
var host_parser_1 = __webpack_require__(675);
var host_resolver_1 = __webpack_require__(676);
var directives_utils_1 = __webpack_require__(27);
/**
 * @internal
 */
var DirectiveProvider = (function () {
    function DirectiveProvider(directiveResolver) {
        this.directiveResolver = directiveResolver;
    }
    /**
     * creates directiveName and DirectiveFactory for angularJS container
     *
     * it produces directive for classes decorated with @Directive with following DDO:
     * ```
     * {
     * require: ['directiveName'],
     * controller: ClassDirective,
     * link: postLinkFn
     * }
     * ```
     *
     * it produces component for classes decorated with @Component with following DDO:
     * ```
     * {
     * require: ['directiveName'],
     * controller: ClassDirective,
     * controllerAs: '$ctrl',
     * template: 'component template string',
     * scope:{},
     * bindToController:{},
     * transclude: false,
     * link: postLinkFn
     * }
     * ```
     * @param type
     * @returns {string|function(): ng.IDirective[]}
     */
    DirectiveProvider.prototype.createFromType = function (type) {
        var metadata = this.directiveResolver.resolve(type);
        var directiveName = lang_1.resolveDirectiveNameFromSelector(metadata.selector);
        var requireMap = this.directiveResolver.getRequiredDirectivesMap(type);
        var lfHooks = directive_lifecycles_reflector_1.resolveImplementedLifeCycleHooks(type);
        var _ddo = {
            restrict: 'A',
            controller: _controller,
            link: {
                pre: function () { _ddo._ngOnInitBound(); },
                post: this._createLink(type, metadata, lfHooks)
            },
            // @TODO this will be removed after @Query handling is moved to directiveControllerFactory
            require: this._createRequires(requireMap, directiveName),
            _ngOnInitBound: lang_1.noop
        };
        // Component controllers must be created from a factory. Checkout out
        // util/directive-controller.js for more information about what's going on here
        _controller.$inject = ['$scope', '$element', '$attrs', '$transclude', '$injector'];
        function _controller($scope, $element, $attrs, $transclude, $injector) {
            var locals = { $scope: $scope, $element: $element, $attrs: $attrs, $transclude: $transclude };
            return controller_factory_1.directiveControllerFactory(this, type, $injector, locals, requireMap, _ddo, metadata);
        }
        // specific DDO augmentation for @Component
        if (metadata instanceof metadata_directives_1.ComponentMetadata) {
            var assetsPath = this.directiveResolver.parseAssetUrl(metadata);
            var componentSpecificDDO = {
                restrict: 'E',
                scope: {},
                bindToController: {},
                controllerAs: DirectiveProvider._controllerAs,
                transclude: DirectiveProvider._transclude
            };
            if (metadata.template && metadata.templateUrl) {
                throw new Error('cannot have both template and templateUrl');
            }
            if (metadata.template) {
                componentSpecificDDO.template = metadata.template;
            }
            if (metadata.templateUrl) {
                componentSpecificDDO.templateUrl = "" + assetsPath + metadata.templateUrl;
            }
            collections_1.StringMapWrapper.assign(_ddo, componentSpecificDDO);
        }
        // allow compile defined as static method on Type
        if (lang_1.isFunction(type.compile)) {
            _ddo.compile = function compile(tElement, tAttrs) {
                var linkFn = type.compile(tElement, tAttrs);
                // if user custom compile fn returns link use that one instead use generated
                return lang_1.isJsObject(linkFn)
                    ? linkFn
                    : this.link;
            };
        }
        // allow link defined as static method on Type override the created one
        // you should not use this very often
        // Note: if you use this any @Host property decorators or lifeCycle hooks wont work
        if (lang_1.isFunction(type.link)) {
            _ddo.link = type.link;
        }
        // legacy property overrides all generated DDO stuff
        var ddo = this._createDDO(_ddo, metadata.legacy);
        function directiveFactory() { return ddo; }
        // ==========================
        // ngComponentRouter Support:
        // ==========================
        // @TODO(pete) remove the following `forEach` before we release 1.6.0
        // The component-router@0.2.0 looks for the annotations on the controller constructor
        // Nothing in Angular looks for annotations on the factory function but we can't remove
        // it from 1.5.x yet.
        // Copy any annotation properties (starting with $) over to the factory and controller constructor functions
        // These could be used by libraries such as the new component router
        collections_1.StringMapWrapper.forEach(ddo, function (val, key) {
            if (key.charAt(0) === '$') {
                directiveFactory[key] = val;
                // Don't try to copy over annotations to named controller
                if (lang_1.isFunction(ddo.controller)) {
                    ddo.controller[key] = val;
                }
            }
        });
        // support componentRouter $canActivate lc hook as static instead of defined within legacy object
        // componentRouter reads all lc hooks from directiveFactory \_()_/
        // @TODO update this when new component router will be available for Angular 1 ( 1.6 release probably )
        if (lang_1.isFunction(type.$canActivate)) {
            directiveFactory.$canActivate = type.$canActivate;
        }
        return [directiveName, directiveFactory];
    };
    DirectiveProvider.prototype._createDDO = function (ddo, legacyDDO) {
        return lang_1.assign({}, DirectiveProvider._ddoShell, ddo, legacyDDO);
    };
    /**
     *
     * @param requireMap
     * @param directiveName
     * @returns {Array}
     * @private
     * @internal
     */
    DirectiveProvider.prototype._createRequires = function (requireMap, directiveName) {
        return [directiveName].concat(collections_1.StringMapWrapper.values(requireMap));
    };
    /**
     * Directive lifeCycles:
     * - ngOnInit from preLink (all children compiled and DOM ready)
     * - ngAfterContentInit from postLink ( DOM in children ready )
     * - ngOnDestroy from postLink
     *
     * Component lifeCycles:
     * - ngOnInit from preLink (controller require ready)
     * - ngAfterViewInit from postLink ( all children in view+content compiled and DOM ready )
     * - ngAfterContentInit from postLink ( same as ngAfterViewInit )
     * - ngOnDestroy from postLink
     * @param type
     * @param metadata
     * @param lfHooks
     * @private
     * @internal
     */
    DirectiveProvider.prototype._createLink = function (type, metadata, lfHooks) {
        if ((lfHooks.ngAfterContentChecked || lfHooks.ngAfterViewChecked) && collections_1.StringMapWrapper.size(metadata.queries) === 0) {
            throw new Error("\n              Hooks Impl for " + lang_1.stringify(type) + ":\n              ===================================\n              You've implement AfterContentChecked/AfterViewChecked lifecycle, but @ViewChild(ren)/@ContentChild(ren) decorators are not used.\n              we cannot invoke After(Content|View)Checked without provided @Query decorators\n              ");
        }
        if (metadata instanceof metadata_directives_1.ComponentMetadata) {
            if ((lfHooks.ngAfterContentInit || lfHooks.ngAfterContentChecked) && !collections_1.StringMapWrapper.getValueFromPath(metadata, 'legacy.transclude')) {
                throw new Error("\n              Hooks Impl for " + lang_1.stringify(type) + ":\n              ===================================\n              You cannot implement AfterContentInit lifecycle, without allowed transclusion.\n              turn transclusion on within decorator like this: @Component({legacy:{transclude:true}})\n              ");
            }
        }
        // we need to implement this if query are present on class, because during postLink _ngOnChildrenChanged is not yet
        // implemented on controller instance
        if (collections_1.StringMapWrapper.size(metadata.queries)) {
            type.prototype._ngOnChildrenChanged = lang_1.noop;
        }
        var hostProcessed = host_parser_1._parseHost(metadata.host);
        return postLink;
        function postLink(scope, element, attrs, controller, transclude) {
            var _watchers = [];
            var ctrl = controller[0], requiredCtrls = controller.slice(1);
            host_resolver_1._setHostStaticAttributes(element, hostProcessed.hostStatic);
            // setup @HostBindings
            _watchers.push.apply(_watchers, host_resolver_1._setHostBindings(scope, element, ctrl, hostProcessed.hostBindings));
            // setup @HostListeners
            host_resolver_1._setHostListeners(scope, element, ctrl, hostProcessed.hostListeners);
            // @ContentChild/@ContentChildren/@ViewChild/@ViewChildren related logic
            var parentCheckedNotifiers = children_resolver_1._getParentCheckNotifiers(ctrl, requiredCtrls);
            _watchers.push.apply(_watchers, parentCheckedNotifiers);
            children_resolver_1._setupQuery(scope, element, ctrl, metadata.queries);
            // AfterContentInit/AfterViewInit Hooks
            // if there are query defined schedule $evalAsync semaphore
            if (collections_1.StringMapWrapper.size(metadata.queries)) {
                ctrl._ngOnChildrenChanged(directive_lifecycle_interfaces_1.ChildrenChangeHook.FromView, [
                    parentCheckedNotifiers.forEach(function (cb) { return cb(); }),
                    ctrl.ngAfterViewInit && ctrl.ngAfterViewInit.bind(ctrl),
                    ctrl.ngAfterViewChecked && ctrl.ngAfterViewChecked.bind(ctrl),
                ]);
                ctrl._ngOnChildrenChanged(directive_lifecycle_interfaces_1.ChildrenChangeHook.FromContent, [
                    parentCheckedNotifiers.forEach(function (cb) { return cb(); }),
                    ctrl.ngAfterContentInit && ctrl.ngAfterContentInit.bind(ctrl),
                    ctrl.ngAfterContentChecked && ctrl.ngAfterContentChecked.bind(ctrl),
                ]);
            }
            else {
                // no @ContentChild/@ViewChild(ref) decorators exist, call just controller init method
                parentCheckedNotifiers.forEach(function (cb) { return cb(); });
                ctrl.ngAfterViewInit && ctrl.ngAfterViewInit();
                ctrl.ngAfterContentInit && ctrl.ngAfterContentInit();
            }
            directives_utils_1._setupDestroyHandler(scope, element, ctrl, lfHooks.ngOnDestroy, _watchers);
        }
    };
    return DirectiveProvider;
}());
DirectiveProvider._ddoShell = {
    require: [],
    controller: lang_1.noop,
    link: { pre: lang_1.noop, post: lang_1.noop }
};
DirectiveProvider._controllerAs = "$ctrl";
DirectiveProvider._transclude = false;
exports.DirectiveProvider = DirectiveProvider;
exports.directiveProvider = new DirectiveProvider(new directive_resolver_1.DirectiveResolver());
//# sourceMappingURL=directive_provider.js.map

/***/ }),
/* 675 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var lang_1 = __webpack_require__(2);
var collections_1 = __webpack_require__(6);
var HOST_BINDING_KEY_REGEX = /^\[.*\]$/;
var HOST_LISTENER_KEY_REGEX = /^\(.*\)$/;
var HAS_CLASS_REGEX = /^class./;
var HAS_ATTR_REGEX = /^attr./;
function _parseHost(host) {
    if (!lang_1.isPresent(host)) {
        return;
    }
    var hostStatic = {};
    var hostBindingsRaw = [];
    var hostListeners = {};
    collections_1.StringMapWrapper.forEach(host, function (hostValue, hostKey) {
        var hostMap = (_a = {}, _a[stripBindingOrListenerBrackets(hostKey)] = hostValue, _a);
        if (isStaticHost(hostKey)) {
            lang_1.assign(hostStatic, hostMap);
            return;
        }
        if (isHostBinding(hostKey)) {
            hostBindingsRaw.push(hostMap);
            return;
        }
        if (isHostListener(hostKey)) {
            lang_1.assign(hostListeners, processHostListenerCallback(hostMap));
        }
        var _a;
    });
    var hostBindings = hostBindingsRaw
        .reduce(function (acc, hostBindingObj) {
        var hostObjKey = Object.keys(hostBindingObj)[0];
        var hostObjValue = hostBindingObj[hostObjKey];
        if (HAS_CLASS_REGEX.test(hostObjKey)) {
            acc.classes[hostObjKey.replace(HAS_CLASS_REGEX, '')] = hostObjValue;
            return acc;
        }
        if (HAS_ATTR_REGEX.test(hostObjKey)) {
            acc.attributes[hostObjKey.replace(HAS_ATTR_REGEX, '')] = hostObjValue;
            return acc;
        }
        lang_1.assign(acc.properties, hostBindingObj);
        return acc;
    }, {
        classes: {},
        attributes: {},
        properties: {}
    });
    return {
        hostStatic: hostStatic,
        hostBindings: hostBindings,
        hostListeners: hostListeners
    };
    function isHostBinding(hostKey) {
        return HOST_BINDING_KEY_REGEX.test(hostKey);
    }
    function isHostListener(hostKey) {
        return HOST_LISTENER_KEY_REGEX.test(hostKey);
    }
    function isStaticHost(hostKey) {
        return !(isHostBinding(hostKey) || isHostListener(hostKey));
    }
    function stripBindingOrListenerBrackets(hostKey) {
        return hostKey.replace(/\[|\]|\(|\)/g, '');
    }
    function processHostListenerCallback(hostListener) {
        // eventKey is 'click' or 'document: click' etc
        var eventKey = Object.keys(hostListener)[0];
        // cbString is just value 'onMove($event.target)' or 'onMove()'
        var cbString = hostListener[eventKey];
        // here we parse out callback method and its argument to separate strings
        // - for instance we got from 'onMove($event.target)' --> 'onMove','$event.target'
        var _a = /^(\w+)\(([$\w.\s,]*)\)$/.exec(cbString), cbMethodName = _a[1], cbMethodArgs = _a[2];
        var eventValue = [
            cbMethodName
        ].concat(cbMethodArgs.split(',').filter(function (argument) { return Boolean(argument); }).map(function (argument) { return argument.trim(); }));
        return _b = {},
            _b[eventKey.replace(/\s/g, '')] = eventValue,
            _b;
        var _b;
    }
}
exports._parseHost = _parseHost;
//# sourceMappingURL=host_parser.js.map

/***/ }),
/* 676 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var lang_1 = __webpack_require__(2);
var collections_1 = __webpack_require__(6);
var primitives_1 = __webpack_require__(61);
/**
 *
 * @param element
 * @param staticAttributes
 * @private
 */
function _setHostStaticAttributes(element, staticAttributes) {
    element.attr(staticAttributes);
}
exports._setHostStaticAttributes = _setHostStaticAttributes;
/**
 *
 * @param scope
 * @param element
 * @param ctrl
 * @param hostBindings
 * @returns {Array}
 * @internal
 * @private
 */
function _setHostBindings(scope, element, ctrl, hostBindings) {
    // setup @HostBindings
    return _createWatcherByType('classes', hostBindings).concat(_createWatcherByType('attributes', hostBindings), _createWatcherByType('properties', hostBindings));
    /**
     * registers $scope.$watch for appropriate hostBinding
     * the watcher watches property on controller instance
     * @param type
     * @param hostBinding
     * @returns {Array}
     * @private
     */
    function _createWatcherByType(type, hostBinding) {
        var _watchersByType = [];
        collections_1.StringMapWrapper.forEach(hostBinding[type], function (watchPropName, keyToSet) {
            _watchersByType.push(scope.$watch(function () { return ctrl[watchPropName]; }, function (newValue) {
                if (type === 'classes') {
                    element.toggleClass(keyToSet, newValue);
                }
                if (type === 'attributes') {
                    element.attr(keyToSet, newValue);
                }
                if (type === 'properties') {
                    collections_1.StringMapWrapper.setValueInPath(element[0], keyToSet, newValue);
                }
            }));
        });
        return _watchersByType;
    }
}
exports._setHostBindings = _setHostBindings;
/**
 *
 * @param scope
 * @param element
 * @param ctrl
 * @param hostListeners
 * @internal
 * @private
 */
function _setHostListeners(scope, element, ctrl, hostListeners) {
    collections_1.StringMapWrapper.forEach(hostListeners, _registerHostListener);
    function _registerHostListener(cbArray, eventKey) {
        var methodName = cbArray[0], methodParams = cbArray.slice(1);
        var _a = _getTargetAndEvent(eventKey, element), event = _a.event, target = _a.target;
        // console.log( event );
        target.on(event, eventHandler);
        // global event
        if (target !== element) {
            scope.$on('$destroy', function () { return target.off(event, eventHandler); });
        }
        function eventHandler(evt) {
            var cbParams = _getHostListenerCbParams(evt, methodParams);
            scope.$apply(function () {
                var noPreventDefault = ctrl[methodName].apply(ctrl, cbParams);
                // HostListener event.preventDefault if method returns false
                if (noPreventDefault === false) {
                    evt.preventDefault();
                }
            });
        }
    }
}
exports._setHostListeners = _setHostListeners;
/**
 * return $event or it's property if found via path
 * @param event
 * @param eventParams
 * @returns {Array}
 * @private
 */
function _getHostListenerCbParams(event, eventParams) {
    var ALLOWED_EVENT_NAME = '$event';
    return eventParams.reduce(function (acc, eventPath) {
        if (!primitives_1.StringWrapper.startsWith(eventPath, ALLOWED_EVENT_NAME)) {
            throw new Error("\n              only $event.* is supported. Please provide correct listener parameter @example: $event,$event.target\n              ");
        }
        if (eventPath === ALLOWED_EVENT_NAME) {
            return acc.concat([event]);
        }
        return acc.concat([collections_1.StringMapWrapper.getValueFromPath(event, eventPath.replace(ALLOWED_EVENT_NAME, ''))]);
    }, []);
}
exports._getHostListenerCbParams = _getHostListenerCbParams;
function _getGlobalTargetReference($injector, targetName) {
    var globalEventTargets = ['document', 'window', 'body'];
    var $document = $injector.get("$document");
    if (targetName === 'document') {
        return $document;
    }
    if (targetName === 'window') {
        return lang_1.global.angular.element($injector.get("$" + targetName));
    }
    if (targetName === 'body') {
        return lang_1.global.angular.element($document[0][targetName]);
    }
    throw new Error("unsupported global target '" + targetName + "', only '" + globalEventTargets + "' are supported");
}
/**
 *
 * @param definedHostEvent this will be just simple 'event' string name or 'globalTarget:event'
 * @param hostElement
 * @returns {any}
 * @private
 */
function _getTargetAndEvent(definedHostEvent, hostElement) {
    // global target
    var eventWithGlobalTarget = definedHostEvent.split(/\s*:\s*/);
    if (eventWithGlobalTarget.length === 2) {
        var globalTarget = eventWithGlobalTarget[0], eventOnTarget = eventWithGlobalTarget[1];
        return {
            event: eventOnTarget,
            target: _getGlobalTargetReference(hostElement.injector(), globalTarget)
        };
    }
    return {
        event: definedHostEvent,
        target: hostElement
    };
}
//# sourceMappingURL=host_resolver.js.map

/***/ }),
/* 677 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var lang_1 = __webpack_require__(2);
var collections_1 = __webpack_require__(6);
var directive_lifecycle_interfaces_1 = __webpack_require__(28);
var reflection_1 = __webpack_require__(9);
var provider_1 = __webpack_require__(11);
var metadata_directives_1 = __webpack_require__(8);
var metadata_di_1 = __webpack_require__(18);
/**
 * setup watchers for children component/directives provided by @Query decorators
 * - setup @ContentChild/@ContentChildren/@ViewChild/@ViewChildren
 * @param scope
 * @param element
 * @param ctrl
 * @param queries
 * @private
 */
function _setupQuery(scope, element, ctrl, queries) {
    var SEMAPHORE_PROP_NAMES = Object.freeze({
        view: '__readViewChildrenOrderScheduled',
        content: '__readContentChildrenOrderScheduled'
    });
    var DOM_RESOLVER_TYPES = Object.freeze({
        view: 'view',
        content: 'content'
    });
    if (collections_1.StringMapWrapper.size(queries) === 0) {
        return;
    }
    var onChildrenChangedCb = _getOnChildrenResolvers(element, ctrl, queries);
    ctrl.__readContentChildrenOrderScheduled = false;
    ctrl.__readViewChildrenOrderScheduled = false;
    // this is our created _ngOnChildrenChanged which will be called by children directives
    var _ngOnChildrenChanged = function (type, onFirstChangeDoneCb, domResolverCb) {
        if (onFirstChangeDoneCb === void 0) { onFirstChangeDoneCb = []; }
        if (domResolverCb === void 0) { domResolverCb = onChildrenChangedCb; }
        var orderScheduledSemaphorePropName = '';
        var domResolverCbType = '';
        if (type === directive_lifecycle_interfaces_1.ChildrenChangeHook.FromView) {
            orderScheduledSemaphorePropName = SEMAPHORE_PROP_NAMES.view;
            domResolverCbType = DOM_RESOLVER_TYPES.view;
        }
        else if (type === directive_lifecycle_interfaces_1.ChildrenChangeHook.FromContent) {
            domResolverCbType = DOM_RESOLVER_TYPES.content;
            orderScheduledSemaphorePropName = SEMAPHORE_PROP_NAMES.content;
        }
        else {
            throw new Error("_ngOnChildrenChanged: queryType(" + type + ") must be one of FromView|FromContent");
        }
        if (ctrl[orderScheduledSemaphorePropName]) {
            return;
        }
        ctrl[orderScheduledSemaphorePropName] = true;
        // we execute callback within $evalAsync to extend $digest loop count, which will not trigger another
        // $rootScope.$digest === #perfmatters
        scope.$evalAsync(function () {
            // turn semaphore On back again
            ctrl[orderScheduledSemaphorePropName] = false;
            // query DOM and assign instances/jqLite to controller properties
            domResolverCb[domResolverCbType].forEach(function (cb) { return cb(); });
            // when DOM is queried we can execute DirectiveComponent life cycles which have been registered
            // AfterViewInit | AfterContentInit
            onFirstChangeDoneCb.forEach(function (cb) { lang_1.isFunction(cb) && cb(); });
        });
    };
    // this method needs to be called from children which are we querying
    // if they are rendered dynamically/async
    ctrl._ngOnChildrenChanged = _ngOnChildrenChanged.bind(ctrl);
    /**
     * get all callbacks which will be executed withing $scope.$evalAsync,
     * which are querying for DOM elements and gets controller instances from host element children
     * @param element
     * @param ctrl
     * @param queries
     * @returns {view: Function[], content: Function[]}
     * @private
     */
    function _getOnChildrenResolvers(element, ctrl, queries) {
        var _onChildrenChangedCbMap = (_a = {},
            _a[DOM_RESOLVER_TYPES.view] = [],
            _a[DOM_RESOLVER_TYPES.content] = [],
            _a);
        collections_1.StringMapWrapper.forEach(queries, function (meta, key) {
            if (meta instanceof metadata_di_1.ViewChildMetadata) {
                _onChildrenChangedCbMap[DOM_RESOLVER_TYPES.view].push(_resolveViewChild(element, ctrl, key, meta));
            }
            if (meta instanceof metadata_di_1.ViewChildrenMetadata) {
                _onChildrenChangedCbMap[DOM_RESOLVER_TYPES.view].push(_resolveViewChildren(element, ctrl, key, meta));
            }
            if (meta instanceof metadata_di_1.ContentChildMetadata) {
                _onChildrenChangedCbMap[DOM_RESOLVER_TYPES.content].push(_resolveContentChild(element, ctrl, key, meta));
            }
            if (meta instanceof metadata_di_1.ContentChildrenMetadata) {
                _onChildrenChangedCbMap[DOM_RESOLVER_TYPES.content].push(_resolveContentChildren(element, ctrl, key, meta));
            }
        });
        return _onChildrenChangedCbMap;
        function _resolveViewChild(element, ctrl, key, meta) {
            return _resolveChildrenFactory(element, ctrl, key, meta.selector, DOM_RESOLVER_TYPES.view, true);
        }
        function _resolveContentChild(element, ctrl, key, meta) {
            return _resolveChildrenFactory(element, ctrl, key, meta.selector, DOM_RESOLVER_TYPES.content, true);
        }
        function _resolveViewChildren(element, ctrl, key, meta) {
            return _resolveChildrenFactory(element, ctrl, key, meta.selector, DOM_RESOLVER_TYPES.view);
        }
        function _resolveContentChildren(element, ctrl, key, meta) {
            return _resolveChildrenFactory(element, ctrl, key, meta.selector, DOM_RESOLVER_TYPES.content);
        }
        var _a;
    }
}
exports._setupQuery = _setupQuery;
/**
 * resolving DOM instances by provided @ContentChild(ref)/@ViewChild(ref)
 * - if querying for string, we handle it as a selector and return jqLite instances
 * - if querying for Type( directive | component ) we get proper selector and controller from
 * provided Type reference, query the DOM and return that controller instance if exists, otherwise null
 * @param element
 * @param ctrl
 * @param key
 * @param cssSelector
 * @param type
 * @param firstOnly
 * @returns {function(): void}
 * @private
 */
function _resolveChildrenFactory(element, ctrl, key, cssSelector, type, firstOnly) {
    if (firstOnly === void 0) { firstOnly = false; }
    var _a = _getSelectorAndCtrlName(cssSelector), selector = _a.selector, childCtrlName = _a.childCtrlName;
    return _childResolver;
    function _childResolver() {
        if (firstOnly) {
            ctrl[key] = null;
            var child = _getChildElements(element, selector, type, firstOnly);
            var childInstance = lang_1.isString(cssSelector)
                ? child
                : getControllerOnElement(child, childCtrlName);
            ctrl[key] = childInstance;
        }
        else {
            ctrl[key] = [];
            var children = _getChildElements(element, selector, type);
            if (lang_1.isString(cssSelector)) {
                ctrl[key] = children;
                return;
            }
            for (var i = 0; i < children.length; i++) {
                ctrl[key].push(getControllerOnElement(children.eq(i), childCtrlName));
            }
        }
    }
}
exports._resolveChildrenFactory = _resolveChildrenFactory;
/**
 * query View/Content DOM for particular child elements/attributes selector
 * @param $element
 * @param selector
 * @param type
 * @param firstOnly
 * @returns {IAugmentedJQuery}
 * @private
 */
function _getChildElements($element, selector, type, firstOnly) {
    if (firstOnly === void 0) { firstOnly = false; }
    var querySelector = '';
    if (type === 'view') {
        // Note: we are guarding only for first nested child inside ng-transclude
        // this would be to complicated and DOM heavy to select only selectors outside ng-transclude
        // - it should be author responsibility to not include Component view directive within <ng-transclude> and querying for them
        querySelector = ":not(ng-transclude):not([ng-transclude]) > " + selector;
    }
    if (type === 'content') {
        querySelector = "ng-transclude " + selector + ", [ng-transclude] " + selector;
    }
    var queryMethod = firstOnly
        ? 'querySelector'
        : 'querySelectorAll';
    return lang_1.global.angular.element($element[0][queryMethod](querySelector));
}
exports._getChildElements = _getChildElements;
function _getSelectorAndCtrlName(childSelector) {
    var selector = _getSelector(childSelector);
    var childCtrlName = provider_1.getInjectableName(childSelector);
    return { selector: selector, childCtrlName: childCtrlName };
}
exports._getSelectorAndCtrlName = _getSelectorAndCtrlName;
/**
 * get CSS selector from Component/Directive decorated class metadata
 * @param selector
 * @returns {string}
 * @private
 */
function _getSelector(selector) {
    if (lang_1.isString(selector)) {
        return selector;
    }
    if (lang_1.isType(selector)) {
        var annotation = reflection_1.reflector.annotations(selector)[0];
        if (annotation instanceof metadata_directives_1.DirectiveMetadata) {
            return annotation.selector;
        }
    }
    throw new Error("cannot query for non Directive/Component type " + lang_1.getFuncName(selector));
}
exports._getSelector = _getSelector;
/**
 * creates functions which will be called from parent component which is querying this component
 * - component which queries needs to be injected to child,
 * here child creates special callbacks by type of @Query which will be called from postLink and on scope destroy so
 * we clean up GC
 * @param ctrl
 * @param requiredCtrls
 * @returns {Object|Array|T|function()[]}
 * @private
 */
function _getParentCheckNotifiers(ctrl, requiredCtrls) {
    var parentCheckedNotifiers = requiredCtrls.reduce(function (acc, requiredCtrl) {
        if (!lang_1.isJsObject(requiredCtrl)) {
            return acc;
        }
        var Ctor = requiredCtrl.constructor;
        if (!lang_1.isType(Ctor)) {
            return acc;
        }
        var propMeta = reflection_1.reflector.propMetadata(Ctor);
        if (!collections_1.StringMapWrapper.size(propMeta)) {
            return acc;
        }
        var _parentCheckedNotifiers = [];
        collections_1.StringMapWrapper.forEach(propMeta, function (propMetaPropArr) {
            propMetaPropArr
                .filter(function (propMetaInstance) {
                // check if propMeta is one of @Query types and that it queries for Directive/Component ( typeof selector == function )
                if (!((propMetaInstance instanceof metadata_di_1.QueryMetadata) && lang_1.isType(propMetaInstance.selector))) {
                    return false;
                }
                // check if current child is really queried from its parent
                return ctrl instanceof propMetaInstance.selector;
            })
                .forEach(function (propMetaInstance) {
                // parent queried for this child with one from @ContentChild/@ContentChildren
                if (!propMetaInstance.isViewQuery) {
                    _parentCheckedNotifiers.push(function () { return requiredCtrl._ngOnChildrenChanged(directive_lifecycle_interfaces_1.ChildrenChangeHook.FromContent, [requiredCtrl.ngAfterContentChecked.bind(requiredCtrl)]); });
                }
                // parent queried for this child with one from @ViewChild/@ViewChildren
                if (propMetaInstance.isViewQuery) {
                    _parentCheckedNotifiers.push(function () { return requiredCtrl._ngOnChildrenChanged(directive_lifecycle_interfaces_1.ChildrenChangeHook.FromView, [requiredCtrl.ngAfterViewChecked.bind(requiredCtrl)]); });
                }
            });
        });
        return acc.concat(_parentCheckedNotifiers);
    }, []);
    return collections_1.ListWrapper.size(parentCheckedNotifiers)
        ? parentCheckedNotifiers
        : [lang_1.noop];
}
exports._getParentCheckNotifiers = _getParentCheckNotifiers;
function getControllerOnElement($element, ctrlName) {
    if (!$element) {
        return null;
    }
    return $element.controller(ctrlName);
}
exports.getControllerOnElement = getControllerOnElement;
//# sourceMappingURL=children_resolver.js.map

/***/ }),
/* 678 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var type_1 = __webpack_require__(62);
var directive_lifecycle_interfaces_1 = __webpack_require__(28);
function hasLifecycleHook(lcInterface, token) {
    if (!(token instanceof type_1.Type))
        return false;
    var proto = token.prototype;
    switch (lcInterface) {
        case directive_lifecycle_interfaces_1.LifecycleHooks.AfterContentInit:
            return !!proto.ngAfterContentInit;
        case directive_lifecycle_interfaces_1.LifecycleHooks.AfterContentChecked:
            return !!proto.ngAfterContentChecked;
        case directive_lifecycle_interfaces_1.LifecycleHooks.AfterViewInit:
            return !!proto.ngAfterViewInit;
        case directive_lifecycle_interfaces_1.LifecycleHooks.AfterViewChecked:
            return !!proto.ngAfterViewChecked;
        case directive_lifecycle_interfaces_1.LifecycleHooks.OnDestroy:
            return !!proto.ngOnDestroy;
        case directive_lifecycle_interfaces_1.LifecycleHooks.OnInit:
            return !!proto.ngOnInit;
        case directive_lifecycle_interfaces_1.LifecycleHooks.OnChanges:
            return !!proto.ngOnChanges;
        case directive_lifecycle_interfaces_1.LifecycleHooks.DoCheck:
            return !!proto.ngDoCheck;
        case directive_lifecycle_interfaces_1.LifecycleHooks._OnChildrenChanged:
            return !!proto._ngOnChildrenChanged;
        default:
            return false;
    }
}
exports.hasLifecycleHook = hasLifecycleHook;
/**
 * @internal
 */
function resolveImplementedLifeCycleHooks(type) {
    return {
        ngOnInit: hasLifecycleHook(directive_lifecycle_interfaces_1.LifecycleHooks.OnInit, type),
        ngOnChanges: hasLifecycleHook(directive_lifecycle_interfaces_1.LifecycleHooks.OnChanges, type),
        ngDoCheck: hasLifecycleHook(directive_lifecycle_interfaces_1.LifecycleHooks.DoCheck, type),
        ngAfterContentInit: hasLifecycleHook(directive_lifecycle_interfaces_1.LifecycleHooks.AfterContentInit, type),
        ngAfterContentChecked: hasLifecycleHook(directive_lifecycle_interfaces_1.LifecycleHooks.AfterContentChecked, type),
        ngAfterViewInit: hasLifecycleHook(directive_lifecycle_interfaces_1.LifecycleHooks.AfterViewInit, type),
        ngAfterViewChecked: hasLifecycleHook(directive_lifecycle_interfaces_1.LifecycleHooks.AfterViewChecked, type),
        ngOnDestroy: hasLifecycleHook(directive_lifecycle_interfaces_1.LifecycleHooks.OnDestroy, type),
        _ngOnChildrenChanged: hasLifecycleHook(directive_lifecycle_interfaces_1.LifecycleHooks._OnChildrenChanged, type)
    };
}
exports.resolveImplementedLifeCycleHooks = resolveImplementedLifeCycleHooks;
//# sourceMappingURL=directive_lifecycles_reflector.js.map

/***/ }),
/* 679 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var lang_1 = __webpack_require__(2);
var collections_1 = __webpack_require__(6);
var reflection_1 = __webpack_require__(9);
var metadata_directives_1 = __webpack_require__(8);
var metadata_di_1 = __webpack_require__(18);
var metadata_1 = __webpack_require__(7);
var provider_1 = __webpack_require__(11);
var forward_ref_1 = __webpack_require__(13);
var exceptions_1 = __webpack_require__(60);
// asset:<package-name>/<realm>/<path-to-module>
// var _ASSET_URL_RE = /asset:([^\/]+)\/([^\/]+)\/(.+)/g;
// <path-to-module>/filename.js
var ASSET_URL_RE = /^(.+)\/.+\.js$/;
function _isDirectiveMetadata(type) {
    return type instanceof metadata_directives_1.DirectiveMetadata;
}
/**
 * return required string map for provided local DI
 * ```typescript
 * // for
 * constructor(@Inject('ngModel') @Self() @Optional() ngModel){}
 * // it returns:
 * { ngModel: '?ngModel' }
 *
 * // when MyComponent is
 * @Component({ selector: 'myCoolCmp', template:`hello`})
 * class MyComponent{}
 * // for
 * constructor(@Host() @Optional() myCmp: MyComponent){}
 * // it returns:
 * { myCmp: '^myCoolCmp' }
 * ```
 * @param paramsMeta
 * @param idx
 * @param typeOrFunc
 * @returns {{[directiveName]:string}}
 * @private
 */
function _transformInjectedDirectivesMeta(paramsMeta, idx, typeOrFunc) {
    if (!_isInjectableParamsDirective(paramsMeta)) {
        return;
    }
    // @TODO unite this with _extractToken from provider.ts
    var injectInst = collections_1.ListWrapper.find(paramsMeta, function (param) { return param instanceof metadata_1.InjectMetadata; });
    var injectType = collections_1.ListWrapper.find(paramsMeta, lang_1.isType);
    var _a = (injectInst || { token: injectType }).token, token = _a === void 0 ? undefined : _a;
    // we need to decrement param count if user uses both @Inject() and :MyType
    var paramsMetaLength = (injectInst && injectType)
        ? paramsMeta.length - 1
        : paramsMeta.length;
    if (!token) {
        throw new Error(exceptions_1.getErrorMsg(typeOrFunc, "no Directive instance name provided within @Inject() or :DirectiveClass annotation missing"));
    }
    var isHost = collections_1.ListWrapper.findIndex(paramsMeta, function (param) { return param instanceof metadata_1.HostMetadata; }) !== -1;
    var isOptional = collections_1.ListWrapper.findIndex(paramsMeta, function (param) { return param instanceof metadata_1.OptionalMetadata; }) !== -1;
    var isSelf = collections_1.ListWrapper.findIndex(paramsMeta, function (param) { return param instanceof metadata_1.SelfMetadata; }) !== -1;
    var isSkipSelf = collections_1.ListWrapper.findIndex(paramsMeta, function (param) { return param instanceof metadata_1.SkipSelfMetadata; }) !== -1;
    if (isOptional && paramsMetaLength !== 3) {
        throw new Error(exceptions_1.getErrorMsg(typeOrFunc, "you cannot use @Optional() without related decorator for injecting Directives. use one of @Host|@Self()|@SkipSelf() + @Optional()"));
    }
    if (isSelf && isSkipSelf) {
        throw new Error(exceptions_1.getErrorMsg(typeOrFunc, "you cannot provide both @Self() and @SkipSelf() with @Inject(" + lang_1.getFuncName(token) + ") for Directive Injection"));
    }
    if ((isHost && isSelf) || (isHost && isSkipSelf)) {
        throw new Error(exceptions_1.getErrorMsg(typeOrFunc, "you cannot provide both @Host(),@SkipSelf() or @Host(),@Self() with @Inject(" + lang_1.getFuncName(token) + ") for Directive Injections"));
    }
    var locateType = _getLocateTypeSymbol();
    var optionalType = isOptional ? '?' : '';
    var requireExpressionPrefix = "" + optionalType + locateType;
    var directiveName = _getDirectiveName(token);
    // we need to generate unique names because if we require same directive controllers,
    // with different locale decorators it would merge to one which is wrong
    return _b = {},
        _b[directiveName + "#" + idx] = "" + requireExpressionPrefix + directiveName,
        _b;
    function _getDirectiveName(token) {
        return lang_1.isType(forward_ref_1.resolveForwardRef(token))
            ? provider_1.getInjectableName(forward_ref_1.resolveForwardRef(token))
            : token;
    }
    function _getLocateTypeSymbol() {
        if (isSelf) {
            return '';
        }
        if (isHost) {
            return '^';
        }
        if (isSkipSelf) {
            return '^^';
        }
    }
    // exit if user uses both @Inject() and :Type for DI because this is not directive injection
    function _isInjectableParamsDirective(paramsMeta) {
        // if there is just @Inject or Type from design:paramtypes return
        if (paramsMeta.length < 2) {
            return false;
        }
        if (paramsMeta.length === 2) {
            var injectableParamCount = paramsMeta.filter(function (inj) { return inj instanceof metadata_1.InjectMetadata || lang_1.isType(inj); }).length;
            if (injectableParamCount === 2) {
                return false;
            }
        }
        return true;
    }
    var _b;
}
/**
 * Resolve a `Type` for {@link DirectiveMetadata}.
 */
var DirectiveResolver = (function () {
    function DirectiveResolver() {
    }
    /**
     * Return {@link DirectiveMetadata} for a given `Type`.
     */
    DirectiveResolver.prototype.resolve = function (type) {
        var metadata = this._getDirectiveMeta(type);
        var propertyMetadata = reflection_1.reflector.propMetadata(type);
        return this._mergeWithPropertyMetadata(metadata, propertyMetadata);
    };
    /**
     * transform parameter annotations to required directives map so we can use it
     * for DDO creation
     *
     * map consist of :
     *  - key == name of directive
     *  - value == Angular 1 require expression
     *  ```js
     *  {
     *    ngModel: 'ngModel',
     *    form: '^^form',
     *    foo: '^foo',
     *    moo: '?^foo',
     *  }
     *  ```
     *
     * @param {Type} type
     * @returns {StringMap}
     */
    DirectiveResolver.prototype.getRequiredDirectivesMap = function (type) {
        var metadata = this._getDirectiveMeta(type);
        var paramMetadata = reflection_1.reflector.parameters(type);
        if (lang_1.isPresent(paramMetadata)) {
            return paramMetadata
                .reduce(function (acc, paramMetaArr, idx) {
                var requireExp = _transformInjectedDirectivesMeta(paramMetaArr, idx, type);
                if (lang_1.isPresent(requireExp)) {
                    lang_1.assign(acc, requireExp);
                }
                return acc;
            }, {});
        }
        return {};
    };
    DirectiveResolver.prototype.parseAssetUrl = function (cmpMetadata) {
        if (lang_1.isBlank(cmpMetadata.moduleId)) {
            return '';
        }
        var moduleId = cmpMetadata.moduleId;
        var _a = moduleId.match(ASSET_URL_RE) || [], _b = _a[1], urlPathMatch = _b === void 0 ? '' : _b;
        return urlPathMatch + "/";
    };
    /**
     *
     * @param type
     * @returns {DirectiveMetadata}
     * @throws Error
     * @private
     */
    DirectiveResolver.prototype._getDirectiveMeta = function (type) {
        var typeMetadata = reflection_1.reflector.annotations(forward_ref_1.resolveForwardRef(type));
        if (lang_1.isPresent(typeMetadata)) {
            var metadata = collections_1.ListWrapper.find(typeMetadata, _isDirectiveMetadata);
            if (lang_1.isPresent(metadata)) {
                return metadata;
            }
        }
        throw new Error("No Directive annotation found on " + lang_1.stringify(type));
    };
    DirectiveResolver.prototype._mergeWithPropertyMetadata = function (directiveMetadata, propertyMetadata) {
        var inputs = [];
        var attrs = [];
        var outputs = [];
        var host = {};
        var queries = {};
        collections_1.StringMapWrapper.forEach(propertyMetadata, function (metadata, propName) {
            metadata.forEach(function (propMetaInst) {
                if (propMetaInst instanceof metadata_directives_1.InputMetadata) {
                    if (lang_1.isPresent(propMetaInst.bindingPropertyName)) {
                        inputs.push(propName + ": " + propMetaInst.bindingPropertyName);
                    }
                    else {
                        inputs.push(propName);
                    }
                }
                if (propMetaInst instanceof metadata_directives_1.AttrMetadata) {
                    if (lang_1.isPresent(propMetaInst.bindingPropertyName)) {
                        attrs.push(propName + ": " + propMetaInst.bindingPropertyName);
                    }
                    else {
                        attrs.push(propName);
                    }
                }
                if (propMetaInst instanceof metadata_directives_1.OutputMetadata) {
                    if (lang_1.isPresent(propMetaInst.bindingPropertyName)) {
                        outputs.push(propName + ": " + propMetaInst.bindingPropertyName);
                    }
                    else {
                        outputs.push(propName);
                    }
                }
                if (propMetaInst instanceof metadata_directives_1.HostBindingMetadata) {
                    if (lang_1.isPresent(propMetaInst.hostPropertyName)) {
                        host["[" + propMetaInst.hostPropertyName + "]"] = propName;
                    }
                    else {
                        host["[" + propName + "]"] = propName;
                    }
                }
                if (propMetaInst instanceof metadata_directives_1.HostListenerMetadata) {
                    var args = lang_1.isPresent(propMetaInst.args)
                        ? propMetaInst.args.join(', ')
                        : '';
                    host["(" + propMetaInst.eventName + ")"] = propName + "(" + args + ")";
                }
                if (propMetaInst instanceof metadata_di_1.ContentChildrenMetadata) {
                    queries[propName] = propMetaInst;
                }
                if (propMetaInst instanceof metadata_di_1.ViewChildrenMetadata) {
                    queries[propName] = propMetaInst;
                }
                if (propMetaInst instanceof metadata_di_1.ContentChildMetadata) {
                    queries[propName] = propMetaInst;
                }
                if (propMetaInst instanceof metadata_di_1.ViewChildMetadata) {
                    queries[propName] = propMetaInst;
                }
            });
        });
        return this._merge(directiveMetadata, inputs, attrs, outputs, host, queries);
    };
    DirectiveResolver.prototype._merge = function (dm, inputs, attrs, outputs, host, queries) {
        var mergedInputs = lang_1.isPresent(dm.inputs)
            ? collections_1.ListWrapper.concat(dm.inputs, inputs)
            : inputs;
        var mergedAttrs = lang_1.isPresent(dm.attrs)
            ? collections_1.ListWrapper.concat(dm.attrs, attrs)
            : attrs;
        var mergedOutputs = lang_1.isPresent(dm.outputs)
            ? collections_1.ListWrapper.concat(dm.outputs, outputs)
            : outputs;
        var mergedHost = lang_1.isPresent(dm.host)
            ? collections_1.StringMapWrapper.merge(dm.host, host)
            : host;
        var mergedQueries = lang_1.isPresent(dm.queries)
            ? collections_1.StringMapWrapper.merge(dm.queries, queries)
            : queries;
        var directiveSettings = {
            selector: dm.selector,
            inputs: mergedInputs,
            attrs: mergedAttrs,
            outputs: mergedOutputs,
            host: mergedHost,
            queries: mergedQueries,
            legacy: dm.legacy
        };
        if (dm instanceof metadata_directives_1.ComponentMetadata) {
            var componentSettings = collections_1.StringMapWrapper.assign({}, directiveSettings, {
                moduleId: dm.moduleId,
                template: dm.template,
                templateUrl: dm.templateUrl,
                changeDetection: lang_1.isPresent(dm.changeDetection) ? dm.changeDetection : 1 /* Default */
            });
            return new metadata_directives_1.ComponentMetadata(componentSettings);
        }
        else {
            return new metadata_directives_1.DirectiveMetadata(directiveSettings);
        }
    };
    return DirectiveResolver;
}());
exports.DirectiveResolver = DirectiveResolver;
//# sourceMappingURL=directive_resolver.js.map

/***/ }),
/* 680 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var lang_1 = __webpack_require__(2);
var collections_1 = __webpack_require__(6);
var metadata_1 = __webpack_require__(29);
var reflection_1 = __webpack_require__(9);
var forward_ref_1 = __webpack_require__(13);
function _isPipeMetadata(type) {
    return type instanceof metadata_1.PipeMetadata;
}
/**
 * Resolve a `Type` for {@link PipeMetadata}.
 *
 */
var PipeResolver = (function () {
    function PipeResolver() {
    }
    /**
     * Return {@link PipeMetadata} for a given `Type`.
     */
    PipeResolver.prototype.resolve = function (type) {
        var metas = reflection_1.reflector.annotations(forward_ref_1.resolveForwardRef(type));
        if (lang_1.isPresent(metas)) {
            var annotation = collections_1.ListWrapper.find(metas, _isPipeMetadata);
            if (lang_1.isPresent(annotation)) {
                return annotation;
            }
        }
        throw new Error("No Pipe decorator found on " + lang_1.stringify(type));
    };
    return PipeResolver;
}());
exports.PipeResolver = PipeResolver;
//# sourceMappingURL=pipe_resolver.js.map

/***/ }),
/* 681 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var decorators_1 = __webpack_require__(682);
exports.Pipe = decorators_1.Pipe;
//# sourceMappingURL=pipes.js.map

/***/ }),
/* 682 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var decorators_1 = __webpack_require__(19);
var metadata_1 = __webpack_require__(29);
exports.Pipe = decorators_1.makeDecorator(metadata_1.PipeMetadata);
//# sourceMappingURL=decorators.js.map

/***/ }),
/* 683 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var lang_1 = __webpack_require__(2);
var pipe_resolver_1 = __webpack_require__(680);
/**
 * @internal
 */
var PipeProvider = (function () {
    function PipeProvider(pipeResolver) {
        this.pipeResolver = pipeResolver;
    }
    PipeProvider.prototype.createFromType = function (type) {
        var metadata = this.pipeResolver.resolve(type);
        if (!lang_1.isFunction(type.prototype.transform)) {
            throw new Error("@Pipe: must implement '#transform' method");
        }
        filterFactory.$inject = ['$injector'];
        function filterFactory($injector) {
            var pipeInstance = $injector.instantiate(type);
            // return angular 1 filter function
            var filterFn = pipeInstance.transform.bind(pipeInstance);
            if (metadata.pure === false) {
                filterFn.$stateful = true;
            }
            return filterFn;
        }
        return [
            metadata.name,
            filterFactory
        ];
    };
    return PipeProvider;
}());
exports.PipeProvider = PipeProvider;
/** @internal */
exports.pipeProvider = new PipeProvider(new pipe_resolver_1.PipeResolver());
//# sourceMappingURL=pipe_provider.js.map

/***/ }),
/* 684 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var lang_1 = __webpack_require__(2);
var collections_1 = __webpack_require__(6);
// import {BaseException} from 'angular2/src/facade/exceptions';
// This will be needed when we will used Reflect APIs
var Reflect = lang_1.global.Reflect;
if (!isReflectMetadata(Reflect)) {
    throw "\n    Reflect.*metadata shim is required when using class decorators.\n    You can use one of: \n    - \"reflect-metadata\" (https://www.npmjs.com/package/reflect-metadata) \n    - \"core-js/es7/reflect\" (https://github.com/zloirock/core-js)\n  ";
}
/**
 * @internal
 */
exports.CLASS_META_KEY = 'annotations';
/**
 * @internal
 */
exports.PARAM_META_KEY = 'parameters';
/**
 * @internal
 */
exports.PARAM_REFLECT_META_KEY = 'design:paramtypes';
/**
 * @internal
 */
exports.PROP_META_KEY = 'propMetadata';
/**
 * @internal
 */
exports.DOWNGRADED_COMPONENT_NAME_KEY = 'downgradeComponentName';
function isReflectMetadata(reflect) {
    return lang_1.isPresent(reflect) && lang_1.isPresent(reflect.getMetadata);
}
var ReflectionCapabilities = (function () {
    function ReflectionCapabilities(reflect) {
        if (reflect === void 0) { reflect = lang_1.global.Reflect; }
        this._reflect = reflect;
    }
    ReflectionCapabilities.prototype.isReflectionEnabled = function () { return true; };
    ReflectionCapabilities.prototype.factory = function (t) {
        switch (t.length) {
            case 0:
                return function () { return new t(); };
            case 1:
                return function (a1) { return new t(a1); };
            case 2:
                return function (a1, a2) { return new t(a1, a2); };
            case 3:
                return function (a1, a2, a3) { return new t(a1, a2, a3); };
            case 4:
                return function (a1, a2, a3, a4) { return new t(a1, a2, a3, a4); };
            case 5:
                return function (a1, a2, a3, a4, a5) { return new t(a1, a2, a3, a4, a5); };
            case 6:
                return function (a1, a2, a3, a4, a5, a6) {
                    return new t(a1, a2, a3, a4, a5, a6);
                };
            case 7:
                return function (a1, a2, a3, a4, a5, a6, a7) {
                    return new t(a1, a2, a3, a4, a5, a6, a7);
                };
            case 8:
                return function (a1, a2, a3, a4, a5, a6, a7, a8) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8);
                };
            case 9:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9);
                };
            case 10:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) { return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10); };
            case 11:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) { return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11); };
            case 12:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
                };
            case 13:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
                };
            case 14:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
                };
            case 15:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
                };
            case 16:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
                };
            case 17:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
                };
            case 18:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18) { return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18); };
            case 19:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19) { return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19); };
            case 20:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20) { return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20); };
        }
        throw new Error("Cannot create a factory for '" + lang_1.stringify(t) + "' because its constructor has more than 20 arguments");
    };
    /** @internal */
    ReflectionCapabilities.prototype._zipTypesAndAnnotations = function (paramTypes, paramAnnotations) {
        var result;
        if (typeof paramTypes === 'undefined') {
            result = new Array(paramAnnotations.length);
        }
        else {
            result = new Array(paramTypes.length);
        }
        for (var i = 0; i < result.length; i++) {
            // TS outputs Object for parameters without types, while Traceur omits
            // the annotations. For now we preserve the Traceur behavior to aid
            // migration, but this can be revisited.
            if (typeof paramTypes === 'undefined') {
                result[i] = [];
            }
            else if (paramTypes[i] != Object) {
                result[i] = [paramTypes[i]];
            }
            else {
                result[i] = [];
            }
            if (lang_1.isPresent(paramAnnotations) && lang_1.isPresent(paramAnnotations[i])) {
                result[i] = result[i].concat(paramAnnotations[i]);
            }
        }
        return result;
    };
    ReflectionCapabilities.prototype.parameters = function (typeOrFunc) {
        // // Prefer the direct API.
        // if (isPresent((<any>typeOrFunc).parameters)) {
        //   return (<any>typeOrFunc).parameters;
        // }
        if (isReflectMetadata(this._reflect)) {
            // get parameter created with @Inject()
            var paramAnnotations = this._reflect.getMetadata(exports.PARAM_META_KEY, typeOrFunc);
            // get parameter created via TS type annotations
            var paramTypes = this._reflect.getMetadata(exports.PARAM_REFLECT_META_KEY, typeOrFunc);
            if (lang_1.isPresent(paramTypes) || lang_1.isPresent(paramAnnotations)) {
                return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
            }
        }
        // The array has to be filled with `undefined` because holes would be skipped by `some`
        var parameters = new Array(typeOrFunc.length);
        collections_1.ListWrapper.fill(parameters, undefined);
        // parameters.fill(undefined);
        return parameters;
    };
    ReflectionCapabilities.prototype.rawParameters = function (typeOrFunc) {
        return this._reflect.getMetadata(exports.PARAM_META_KEY, typeOrFunc);
    };
    ReflectionCapabilities.prototype.registerParameters = function (parameters, type) {
        this._reflect.defineMetadata(exports.PARAM_META_KEY, parameters, type);
    };
    ReflectionCapabilities.prototype.annotations = function (typeOrFunc) {
        // // Prefer the direct API.
        // if (isPresent((<any>typeOrFunc).annotations)) {
        //   var annotations = (<any>typeOrFunc).annotations;
        //   if (isFunction(annotations) && annotations.annotations) {
        //     annotations = annotations.annotations;
        //   }
        //   return annotations;
        // }
        if (isReflectMetadata(this._reflect)) {
            var annotations = this._reflect.getMetadata(exports.CLASS_META_KEY, typeOrFunc);
            if (lang_1.isPresent(annotations))
                return annotations;
        }
        return [];
    };
    ReflectionCapabilities.prototype.ownAnnotations = function (typeOrFunc) {
        return this._reflect.getOwnMetadata(exports.CLASS_META_KEY, typeOrFunc);
    };
    ReflectionCapabilities.prototype.registerAnnotations = function (annotations, typeOrFunc) {
        this._reflect.defineMetadata(exports.CLASS_META_KEY, annotations, typeOrFunc);
    };
    ReflectionCapabilities.prototype.propMetadata = function (typeOrFunc) {
        // // Prefer the direct API.
        // if (isPresent((<any>typeOrFunc).propMetadata)) {
        //   var propMetadata = (<any>typeOrFunc).propMetadata;
        //   if (isFunction(propMetadata) && propMetadata.propMetadata) {
        //     propMetadata = propMetadata.propMetadata;
        //   }
        //   return propMetadata;
        // }
        if (isReflectMetadata(this._reflect)) {
            var propMetadata = this._reflect.getMetadata(exports.PROP_META_KEY, typeOrFunc);
            if (lang_1.isPresent(propMetadata))
                return propMetadata;
        }
        return {};
    };
    ReflectionCapabilities.prototype.ownPropMetadata = function (typeOrFunc) {
        return this._reflect.getOwnMetadata(exports.PROP_META_KEY, typeOrFunc);
    };
    ReflectionCapabilities.prototype.registerPropMetadata = function (propMetadata, typeOrFunc) {
        this._reflect.defineMetadata(exports.PROP_META_KEY, propMetadata, typeOrFunc);
    };
    ReflectionCapabilities.prototype.registerDowngradedNg2ComponentName = function (componentName, typeOrFunc) {
        this._reflect.defineMetadata(exports.DOWNGRADED_COMPONENT_NAME_KEY, componentName, typeOrFunc);
    };
    ReflectionCapabilities.prototype.downgradedNg2ComponentName = function (typeOrFunc) {
        return this._reflect.getOwnMetadata(exports.DOWNGRADED_COMPONENT_NAME_KEY, typeOrFunc);
    };
    ReflectionCapabilities.prototype.interfaces = function (type) {
        // throw new BaseException("JavaScript does not support interfaces");
        throw new Error('JavaScript does not support interfaces');
    };
    ReflectionCapabilities.prototype.getter = function (name) { return new Function('o', 'return o.' + name + ';'); };
    ReflectionCapabilities.prototype.setter = function (name) {
        return new Function('o', 'v', 'return o.' + name + ' = v;');
    };
    ReflectionCapabilities.prototype.method = function (name) {
        var functionBody = "if (!o." + name + ") throw new Error('\"" + name + "\" is undefined');\n        return o." + name + ".apply(o, args);";
        return new Function('o', 'args', functionBody);
    };
    return ReflectionCapabilities;
}());
exports.ReflectionCapabilities = ReflectionCapabilities;
//# sourceMappingURL=reflection_capabilities.js.map

/***/ }),
/* 685 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var reflector_reader_1 = __webpack_require__(686);
/**
 * Reflective information about a symbol, including annotations, interfaces, and other metadata.
 */
var ReflectionInfo = (function () {
    function ReflectionInfo(annotations, parameters, factory, interfaces, propMetadata) {
        this.annotations = annotations;
        this.parameters = parameters;
        this.factory = factory;
        this.interfaces = interfaces;
        this.propMetadata = propMetadata;
    }
    return ReflectionInfo;
}());
exports.ReflectionInfo = ReflectionInfo;
/**
 * Provides access to reflection data about symbols. Used internally by Angular
 * to power dependency injection and compilation.
 */
var Reflector = (function (_super) {
    __extends(Reflector, _super);
    function Reflector(reflectionCapabilities) {
        var _this = _super.call(this) || this;
        // this._usedKeys = null;
        _this.reflectionCapabilities = reflectionCapabilities;
        return _this;
    }
    Reflector.prototype.isReflectionEnabled = function () { return this.reflectionCapabilities.isReflectionEnabled(); };
    Reflector.prototype.parameters = function (typeOrFunc) {
        // // get cached
        // if (this._injectableInfo.has(typeOrFunc)) {
        //   var res = this._getReflectionInfo(typeOrFunc).parameters;
        //   return isPresent(res) ? res : [];
        // } else {
        return this.reflectionCapabilities.parameters(typeOrFunc);
        // }
    };
    Reflector.prototype.rawParameters = function (typeOrFunc) {
        return this.reflectionCapabilities.rawParameters(typeOrFunc);
    };
    Reflector.prototype.registerParameters = function (parameters, typeOrFunc) {
        this.reflectionCapabilities.registerParameters(parameters, typeOrFunc);
    };
    Reflector.prototype.annotations = function (typeOrFunc) {
        // // get cached
        // if (this._injectableInfo.has(typeOrFunc)) {
        //   var res = this._getReflectionInfo(typeOrFunc).annotations;
        //   return isPresent(res) ? res : [];
        // } else {
        return this.reflectionCapabilities.annotations(typeOrFunc);
        // }
    };
    Reflector.prototype.ownAnnotations = function (typeOrFunc) {
        return this.reflectionCapabilities.ownAnnotations(typeOrFunc);
    };
    Reflector.prototype.registerAnnotations = function (parameters, typeOrFunc) {
        this.reflectionCapabilities.registerAnnotations(parameters, typeOrFunc);
    };
    Reflector.prototype.propMetadata = function (typeOrFunc) {
        // // get cached
        // if (this._injectableInfo.has(typeOrFunc)) {
        //   var res = this._getReflectionInfo(typeOrFunc).propMetadata;
        //   return isPresent(res) ? res : {};
        // } else {
        return this.reflectionCapabilities.propMetadata(typeOrFunc);
        // }
    };
    Reflector.prototype.ownPropMetadata = function (typeOrFunc) {
        return this.reflectionCapabilities.ownPropMetadata(typeOrFunc);
    };
    Reflector.prototype.registerPropMetadata = function (parameters, typeOrFunc) {
        this.reflectionCapabilities.registerPropMetadata(parameters, typeOrFunc);
    };
    Reflector.prototype.registerDowngradedNg2ComponentName = function (componentName, typeOrFunc) {
        this.reflectionCapabilities.registerDowngradedNg2ComponentName(componentName, typeOrFunc);
    };
    Reflector.prototype.downgradedNg2ComponentName = function (typeOrFunc) {
        return this.reflectionCapabilities.downgradedNg2ComponentName(typeOrFunc);
    };
    /** @internal */
    Reflector.prototype._getReflectionInfo = function (typeOrFunc) {
        /*if (isPresent(this._usedKeys)) {
         this._usedKeys.add(typeOrFunc);
         }
         return this._injectableInfo.get(typeOrFunc);*/
    };
    /** @internal */
    Reflector.prototype._containsReflectionInfo = function (typeOrFunc) { };
    return Reflector;
}(reflector_reader_1.ReflectorReader));
exports.Reflector = Reflector;
//# sourceMappingURL=reflector.js.map

/***/ }),
/* 686 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Provides read-only access to reflection data about symbols. Used internally by Angular
 * to power dependency injection and compilation.
 */
var ReflectorReader = (function () {
    function ReflectorReader() {
    }
    return ReflectorReader;
}());
exports.ReflectorReader = ReflectorReader;
//# sourceMappingURL=reflector_reader.js.map

/***/ }),
/* 687 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(__webpack_require__(19));
var bundler_1 = __webpack_require__(688);
exports.bundle = bundler_1.bundle;
//# sourceMappingURL=util.js.map

/***/ }),
/* 688 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var lang_1 = __webpack_require__(2);
var reflection_1 = __webpack_require__(9);
var provider_1 = __webpack_require__(11);
var provider_util_1 = __webpack_require__(14);
var reflective_provider_1 = __webpack_require__(667);
var collections_1 = __webpack_require__(6);
function _bundleComponent(ComponentClass, otherProviders, existingAngular1Module) {
    if (otherProviders === void 0) { otherProviders = []; }
    // Support registering downgraded ng2 components directly
    var downgradedNgComponentName = reflection_1.reflector.downgradedNg2ComponentName(ComponentClass);
    if (downgradedNgComponentName) {
        var angular1Module_1 = existingAngular1Module || lang_1.global.angular.module(downgradedNgComponentName, []);
        angular1Module_1.directive(downgradedNgComponentName, ComponentClass);
        return angular1Module_1;
    }
    var angular1ModuleName = provider_1.getInjectableName(ComponentClass);
    var angular1Module = existingAngular1Module || lang_1.global.angular.module(angular1ModuleName, []);
    var annotations = reflection_1.reflector.annotations(ComponentClass);
    var cmpAnnotation = annotations[0];
    var _a = cmpAnnotation.providers, providers = _a === void 0 ? [] : _a, _b = cmpAnnotation.viewProviders, viewProviders = _b === void 0 ? [] : _b;
    // process component
    var _c = provider_1.provide(ComponentClass), cmpName = _c[0], cmpFactoryFn = _c[1];
    var _d = reflective_provider_1._getAngular1ModuleMetadataByType(ComponentClass), providerName = _d.providerName, providerMethod = _d.providerMethod, moduleMethod = _d.moduleMethod;
    if (reflective_provider_1._isTypeRegistered(cmpName, angular1Module, providerName, providerMethod)) {
        return angular1Module;
    }
    // @TODO register via this once requires are resolved for 3 types of attr directive from template
    // _registerTypeProvider( angular1Module, ComponentClass, { moduleMethod, name: cmpName, value: cmpFactoryFn } );
    angular1Module[moduleMethod](cmpName, cmpFactoryFn);
    // 1. process component/directive decorator providers/viewProviders
    reflective_provider_1._normalizeProviders(angular1Module, providers);
    reflective_provider_1._normalizeProviders(angular1Module, viewProviders);
    // 2. process otherProviders argument
    // - providers can be string(angular1Module reference), Type, StringMap(providerLiteral)
    // - directives can't be registered as via global providers only @Injectable,@Pipe,{provide:any,use*:any}
    // registerProviders(angular1Module, otherProviders);
    reflective_provider_1._normalizeProviders(angular1Module, otherProviders);
    return angular1Module;
}
function bundle(NgModuleClass, otherProviders, existingAngular1Module) {
    if (otherProviders === void 0) { otherProviders = []; }
    var angular1ModuleName = provider_1.getInjectableName(NgModuleClass);
    var angular1Module = existingAngular1Module || lang_1.global.angular.module(angular1ModuleName, []);
    var annotations = reflection_1.reflector.annotations(NgModuleClass);
    var ngModuleAnnotation = annotations[0];
    if (!provider_util_1.isNgModule(ngModuleAnnotation)) {
        throw new Error("bundle() requires a decorated NgModule as its first argument");
    }
    var _a = ngModuleAnnotation.declarations, declarations = _a === void 0 ? [] : _a, _b = ngModuleAnnotation.providers, providers = _b === void 0 ? [] : _b, _c = ngModuleAnnotation.imports, imports = _c === void 0 ? [] : _c;
    /**
     * Process `declarations`
     */
    collections_1.ListWrapper.flattenDeep(declarations).forEach(function (directiveType) {
        _bundleComponent(directiveType, [], angular1Module);
    });
    /**
     * Process `providers`
     */
    reflective_provider_1._normalizeProviders(angular1Module, providers);
    /**
     * Process `imports`
     */
    // 1. imports which are not NgModules
    var nonNgModuleImports = imports.filter(function (imported) {
        if (!lang_1.isFunction(imported)) {
            return true;
        }
        var annotations = reflection_1.reflector.annotations(imported);
        return !provider_util_1.isNgModule(ngModuleAnnotation);
    });
    reflective_provider_1._normalizeProviders(angular1Module, nonNgModuleImports);
    // 2.imports which are NgModules
    var NgModuleImports = imports.filter(function (imported) {
        if (!lang_1.isFunction(imported)) {
            return false;
        }
        var annotations = reflection_1.reflector.annotations(imported);
        return provider_util_1.isNgModule(ngModuleAnnotation);
    });
    NgModuleImports.forEach(function (importedNgModule) {
        bundle(importedNgModule, [], angular1Module);
    });
    /**
     * Process `otherProviders`
     */
    reflective_provider_1._normalizeProviders(angular1Module, otherProviders);
    return angular1Module;
}
exports.bundle = bundle;
//# sourceMappingURL=bundler.js.map

/***/ }),
/* 689 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Public API for Facade
// None :)

var type_1 = __webpack_require__(62);
exports.Type = type_1.Type;
var async_1 = __webpack_require__(59);
exports.EventEmitter = async_1.EventEmitter;
//# sourceMappingURL=facade.js.map

/***/ }),
/* 690 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(32);
var toSubscriber_1 = __webpack_require__(698);
var observable_1 = __webpack_require__(693);
/**
 * A representation of any set of values over any amount of time. This the most basic building block
 * of RxJS.
 *
 * @class Observable<T>
 */
var Observable = (function () {
    /**
     * @constructor
     * @param {Function} subscribe the function that is  called when the Observable is
     * initially subscribed to. This function is given a Subscriber, to which new values
     * can be `next`ed, or an `error` method can be called to raise an error, or
     * `complete` can be called to notify of a successful completion.
     */
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    /**
     * Creates a new Observable, with this Observable as the source, and the passed
     * operator defined as the new observable's operator.
     * @method lift
     * @param {Operator} operator the operator defining the operation to take on the observable
     * @return {Observable} a new observable with the Operator applied
     */
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
            operator.call(sink, this.source);
        }
        else {
            sink.add(this._subscribe(sink));
        }
        if (sink.syncErrorThrowable) {
            sink.syncErrorThrowable = false;
            if (sink.syncErrorThrown) {
                throw sink.syncErrorValue;
            }
        }
        return sink;
    };
    /**
     * @method forEach
     * @param {Function} next a handler for each value emitted by the observable
     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
     * @return {Promise} a promise that either resolves on observable completion or
     *  rejects with the handled error
     */
    Observable.prototype.forEach = function (next, PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
                PromiseCtor = root_1.root.Rx.config.Promise;
            }
            else if (root_1.root.Promise) {
                PromiseCtor = root_1.root.Promise;
            }
        }
        if (!PromiseCtor) {
            throw new Error('no Promise impl found');
        }
        return new PromiseCtor(function (resolve, reject) {
            var subscription = _this.subscribe(function (value) {
                if (subscription) {
                    // if there is a subscription, then we can surmise
                    // the next handling is asynchronous. Any errors thrown
                    // need to be rejected explicitly and unsubscribe must be
                    // called manually
                    try {
                        next(value);
                    }
                    catch (err) {
                        reject(err);
                        subscription.unsubscribe();
                    }
                }
                else {
                    // if there is NO subscription, then we're getting a nexted
                    // value synchronously during subscription. We can just call it.
                    // If it errors, Observable's `subscribe` will ensure the
                    // unsubscription logic is called, then synchronously rethrow the error.
                    // After that, Promise will trap the error and send it
                    // down the rejection path.
                    next(value);
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        return this.source.subscribe(subscriber);
    };
    /**
     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
     * @method Symbol.observable
     * @return {Observable} this instance of the observable
     */
    Observable.prototype[observable_1.$$observable] = function () {
        return this;
    };
    // HACK: Since TypeScript inherits static properties too, we have to
    // fight against TypeScript here so Subject can have a different static create signature
    /**
     * Creates a new cold Observable by calling the Observable constructor
     * @static true
     * @owner Observable
     * @method create
     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
     * @return {Observable} a new cold observable
     */
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());
exports.Observable = Observable;
//# sourceMappingURL=Observable.js.map

/***/ }),
/* 691 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(690);
var Subscriber_1 = __webpack_require__(64);
var Subscription_1 = __webpack_require__(30);
var ObjectUnsubscribedError_1 = __webpack_require__(694);
var SubjectSubscription_1 = __webpack_require__(692);
var rxSubscriber_1 = __webpack_require__(31);
/**
 * @class SubjectSubscriber<T>
 */
var SubjectSubscriber = (function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        _super.call(this, destination);
        this.destination = destination;
    }
    return SubjectSubscriber;
}(Subscriber_1.Subscriber));
exports.SubjectSubscriber = SubjectSubscriber;
/**
 * @class Subject<T>
 */
var Subject = (function (_super) {
    __extends(Subject, _super);
    function Subject() {
        _super.call(this);
        this.observers = [];
        this.closed = false;
        this.isStopped = false;
        this.hasError = false;
        this.thrownError = null;
    }
    Subject.prototype[rxSubscriber_1.$$rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable_1.Observable));
exports.Subject = Subject;
/**
 * @class AnonymousSubject<T>
 */
var AnonymousSubject = (function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        _super.call(this);
        this.destination = destination;
        this.source = source;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        }
        else {
            return Subscription_1.Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject));
exports.AnonymousSubject = AnonymousSubject;
//# sourceMappingURL=Subject.js.map

/***/ }),
/* 692 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = __webpack_require__(30);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubjectSubscription = (function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        _super.call(this);
        this.subject = subject;
        this.subscriber = subscriber;
        this.closed = false;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription_1.Subscription));
exports.SubjectSubscription = SubjectSubscription;
//# sourceMappingURL=SubjectSubscription.js.map

/***/ }),
/* 693 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(32);
function getSymbolObservable(context) {
    var $$observable;
    var Symbol = context.Symbol;
    if (typeof Symbol === 'function') {
        if (Symbol.observable) {
            $$observable = Symbol.observable;
        }
        else {
            $$observable = Symbol('observable');
            Symbol.observable = $$observable;
        }
    }
    else {
        $$observable = '@@observable';
    }
    return $$observable;
}
exports.getSymbolObservable = getSymbolObservable;
exports.$$observable = getSymbolObservable(root_1.root);
//# sourceMappingURL=observable.js.map

/***/ }),
/* 694 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an action is invalid because the object has been
 * unsubscribed.
 *
 * @see {@link Subject}
 * @see {@link BehaviorSubject}
 *
 * @class ObjectUnsubscribedError
 */
var ObjectUnsubscribedError = (function (_super) {
    __extends(ObjectUnsubscribedError, _super);
    function ObjectUnsubscribedError() {
        var err = _super.call(this, 'object unsubscribed');
        this.name = err.name = 'ObjectUnsubscribedError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ObjectUnsubscribedError;
}(Error));
exports.ObjectUnsubscribedError = ObjectUnsubscribedError;
//# sourceMappingURL=ObjectUnsubscribedError.js.map

/***/ }),
/* 695 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when one or more errors have occurred during the
 * `unsubscribe` of a {@link Subscription}.
 */
var UnsubscriptionError = (function (_super) {
    __extends(UnsubscriptionError, _super);
    function UnsubscriptionError(errors) {
        _super.call(this);
        this.errors = errors;
        var err = Error.call(this, errors ?
            errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n  ') : '');
        this.name = err.name = 'UnsubscriptionError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return UnsubscriptionError;
}(Error));
exports.UnsubscriptionError = UnsubscriptionError;
//# sourceMappingURL=UnsubscriptionError.js.map

/***/ }),
/* 696 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });
//# sourceMappingURL=isArray.js.map

/***/ }),
/* 697 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function isObject(x) {
    return x != null && typeof x === 'object';
}
exports.isObject = isObject;
//# sourceMappingURL=isObject.js.map

/***/ }),
/* 698 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Subscriber_1 = __webpack_require__(64);
var rxSubscriber_1 = __webpack_require__(31);
var Observer_1 = __webpack_require__(63);
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber_1.$$rxSubscriber]) {
            return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1.Subscriber(Observer_1.empty);
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
}
exports.toSubscriber = toSubscriber;
//# sourceMappingURL=toSubscriber.js.map

/***/ }),
/* 699 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var errorObject_1 = __webpack_require__(65);
var tryCatchTarget;
function tryCatcher() {
    try {
        return tryCatchTarget.apply(this, arguments);
    }
    catch (e) {
        errorObject_1.errorObject.e = e;
        return errorObject_1.errorObject;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}
exports.tryCatch = tryCatch;
;
//# sourceMappingURL=tryCatch.js.map

/***/ })
],[303]);
//# sourceMappingURL=app.bundle.js.map